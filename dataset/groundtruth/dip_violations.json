[
  {
    "input": "public class MySQLDatabase {\n    public void connect() {\n        System.out.println(\"Connected to MySQL\");\n    }\n    \n    public String getUserEmail(int userId) {\n        return \"user\" + userId + \"@example.com\";\n    }\n}\n\npublic class EmailService {\n    private MySQLDatabase database;\n    \n    public EmailService() {\n        this.database = new MySQLDatabase();\n    }\n    \n    public void sendEmail(int userId, String message) {\n        database.connect();\n        String email = database.getUserEmail(userId);\n        System.out.println(\"Sending email to \" + email + \": \" + message);\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "class MySQLDatabase:\n    def connect(self):\n        print(\"Connected to MySQL\")\n    \n    def get_user_email(self, user_id):\n        return f\"user{user_id}@example.com\"\n\nclass EmailService:\n    def __init__(self):\n        self.database = MySQLDatabase()\n    \n    def send_email(self, user_id, message):\n        self.database.connect()\n        email = self.database.get_user_email(user_id)\n        print(f\"Sending email to {email}: {message}\")",
    "output": "",
    "level": "EASY",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "class MySQLDatabase {\n    fun connect() {\n        println(\"Connected to MySQL\")\n    }\n    \n    fun getUserEmail(userId: Int): String {\n        return \"user$userId@example.com\"\n    }\n}\n\nclass EmailService {\n    private val database = MySQLDatabase()\n    \n    fun sendEmail(userId: Int, message: String) {\n        database.connect()\n        val email = database.getUserEmail(userId)\n        println(\"Sending email to $email: $message\")\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "public class MySQLDatabase\n{\n    public void Connect()\n    {\n        Console.WriteLine(\"Connected to MySQL\");\n    }\n    \n    public string GetUserEmail(int userId)\n    {\n        return $\"user{userId}@example.com\";\n    }\n}\n\npublic class EmailService\n{\n    private MySQLDatabase database;\n    \n    public EmailService()\n    {\n        database = new MySQLDatabase();\n    }\n    \n    public void SendEmail(int userId, string message)\n    {\n        database.Connect();\n        string email = database.GetUserEmail(userId);\n        Console.WriteLine($\"Sending email to {email}: {message}\");\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "public class MySQLDatabase {\n    private String connectionString;\n    private boolean isConnected;\n    \n    public MySQLDatabase(String connectionString) {\n        this.connectionString = connectionString;\n        this.isConnected = false;\n    }\n    \n    public void connect() {\n        if (!isConnected) {\n            System.out.println(\"Connecting to MySQL with: \" + connectionString);\n            isConnected = true;\n        }\n    }\n    \n    public void disconnect() {\n        if (isConnected) {\n            System.out.println(\"Disconnecting from MySQL\");\n            isConnected = false;\n        }\n    }\n    \n    public String getUserEmail(int userId) {\n        if (!isConnected) {\n            throw new RuntimeException(\"Database not connected\");\n        }\n        return \"user\" + userId + \"@company.com\";\n    }\n    \n    public boolean validateUser(int userId) {\n        if (!isConnected) {\n            throw new RuntimeException(\"Database not connected\");\n        }\n        return userId > 0 && userId < 10000;\n    }\n}\n\npublic class EmailService {\n    private MySQLDatabase database;\n    private String smtpServer;\n    \n    public EmailService(String smtpServer) {\n        this.smtpServer = smtpServer;\n        this.database = new MySQLDatabase(\"jdbc:mysql://localhost:3306/users\");\n    }\n    \n    public void sendEmail(int userId, String subject, String message) {\n        database.connect();\n        \n        if (!database.validateUser(userId)) {\n            System.out.println(\"Invalid user ID: \" + userId);\n            return;\n        }\n        \n        String email = database.getUserEmail(userId);\n        System.out.println(\"Using SMTP server: \" + smtpServer);\n        System.out.println(\"Sending email to \" + email);\n        System.out.println(\"Subject: \" + subject);\n        System.out.println(\"Message: \" + message);\n        \n        database.disconnect();\n    }\n    \n    public void sendBulkEmails(int[] userIds, String subject, String message) {\n        database.connect();\n        \n        for (int userId : userIds) {\n            if (database.validateUser(userId)) {\n                String email = database.getUserEmail(userId);\n                System.out.println(\"Bulk email sent to: \" + email);\n            }\n        }\n        \n        database.disconnect();\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "class MySQLDatabase:\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n        self.is_connected = False\n    \n    def connect(self):\n        if not self.is_connected:\n            print(f\"Connecting to MySQL with: {self.connection_string}\")\n            self.is_connected = True\n    \n    def disconnect(self):\n        if self.is_connected:\n            print(\"Disconnecting from MySQL\")\n            self.is_connected = False\n    \n    def get_user_email(self, user_id):\n        if not self.is_connected:\n            raise RuntimeError(\"Database not connected\")\n        return f\"user{user_id}@company.com\"\n    \n    def validate_user(self, user_id):\n        if not self.is_connected:\n            raise RuntimeError(\"Database not connected\")\n        return user_id > 0 and user_id < 10000\n\nclass EmailService:\n    def __init__(self, smtp_server):\n        self.smtp_server = smtp_server\n        self.database = MySQLDatabase(\"mysql://localhost:3306/users\")\n    \n    def send_email(self, user_id, subject, message):\n        self.database.connect()\n        \n        if not self.database.validate_user(user_id):\n            print(f\"Invalid user ID: {user_id}\")\n            return\n        \n        email = self.database.get_user_email(user_id)\n        print(f\"Using SMTP server: {self.smtp_server}\")\n        print(f\"Sending email to {email}\")\n        print(f\"Subject: {subject}\")\n        print(f\"Message: {message}\")\n        \n        self.database.disconnect()\n    \n    def send_bulk_emails(self, user_ids, subject, message):\n        self.database.connect()\n        \n        for user_id in user_ids:\n            if self.database.validate_user(user_id):\n                email = self.database.get_user_email(user_id)\n                print(f\"Bulk email sent to: {email}\")\n        \n        self.database.disconnect()",
    "output": "",
    "level": "MODERATE",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "class MySQLDatabase(private val connectionString: String) {\n    private var isConnected = false\n    \n    fun connect() {\n        if (!isConnected) {\n            println(\"Connecting to MySQL with: $connectionString\")\n            isConnected = true\n        }\n    }\n    \n    fun disconnect() {\n        if (isConnected) {\n            println(\"Disconnecting from MySQL\")\n            isConnected = false\n        }\n    }\n    \n    fun getUserEmail(userId: Int): String {\n        if (!isConnected) {\n            throw RuntimeException(\"Database not connected\")\n        }\n        return \"user$userId@company.com\"\n    }\n    \n    fun validateUser(userId: Int): Boolean {\n        if (!isConnected) {\n            throw RuntimeException(\"Database not connected\")\n        }\n        return userId > 0 && userId < 10000\n    }\n}\n\nclass EmailService(private val smtpServer: String) {\n    private val database = MySQLDatabase(\"jdbc:mysql://localhost:3306/users\")\n    \n    fun sendEmail(userId: Int, subject: String, message: String) {\n        database.connect()\n        \n        if (!database.validateUser(userId)) {\n            println(\"Invalid user ID: $userId\")\n            return\n        }\n        \n        val email = database.getUserEmail(userId)\n        println(\"Using SMTP server: $smtpServer\")\n        println(\"Sending email to $email\")\n        println(\"Subject: $subject\")\n        println(\"Message: $message\")\n        \n        database.disconnect()\n    }\n    \n    fun sendBulkEmails(userIds: IntArray, subject: String, message: String) {\n        database.connect()\n        \n        for (userId in userIds) {\n            if (database.validateUser(userId)) {\n                val email = database.getUserEmail(userId)\n                println(\"Bulk email sent to: $email\")\n            }\n        }\n        \n        database.disconnect()\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "public class MySQLDatabase\n{\n    private string connectionString;\n    private bool isConnected;\n    \n    public MySQLDatabase(string connectionString)\n    {\n        this.connectionString = connectionString;\n        this.isConnected = false;\n    }\n    \n    public void Connect()\n    {\n        if (!isConnected)\n        {\n            Console.WriteLine($\"Connecting to MySQL with: {connectionString}\");\n            isConnected = true;\n        }\n    }\n    \n    public void Disconnect()\n    {\n        if (isConnected)\n        {\n            Console.WriteLine(\"Disconnecting from MySQL\");\n            isConnected = false;\n        }\n    }\n    \n    public string GetUserEmail(int userId)\n    {\n        if (!isConnected)\n        {\n            throw new InvalidOperationException(\"Database not connected\");\n        }\n        return $\"user{userId}@company.com\";\n    }\n    \n    public bool ValidateUser(int userId)\n    {\n        if (!isConnected)\n        {\n            throw new InvalidOperationException(\"Database not connected\");\n        }\n        return userId > 0 && userId < 10000;\n    }\n}\n\npublic class EmailService\n{\n    private MySQLDatabase database;\n    private string smtpServer;\n    \n    public EmailService(string smtpServer)\n    {\n        this.smtpServer = smtpServer;\n        this.database = new MySQLDatabase(\"Server=localhost;Database=users;Uid=root;Pwd=password;\");\n    }\n    \n    public void SendEmail(int userId, string subject, string message)\n    {\n        database.Connect();\n        \n        if (!database.ValidateUser(userId))\n        {\n            Console.WriteLine($\"Invalid user ID: {userId}\");\n            return;\n        }\n        \n        string email = database.GetUserEmail(userId);\n        Console.WriteLine($\"Using SMTP server: {smtpServer}\");\n        Console.WriteLine($\"Sending email to {email}\");\n        Console.WriteLine($\"Subject: {subject}\");\n        Console.WriteLine($\"Message: {message}\");\n        \n        database.Disconnect();\n    }\n    \n    public void SendBulkEmails(int[] userIds, string subject, string message)\n    {\n        database.Connect();\n        \n        foreach (int userId in userIds)\n        {\n            if (database.ValidateUser(userId))\n            {\n                string email = database.GetUserEmail(userId);\n                Console.WriteLine($\"Bulk email sent to: {email}\");\n            }\n        }\n        \n        database.Disconnect();\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class MySQLDatabase {\n    private String connectionString;\n    private Properties connectionProperties;\n    private boolean isConnected;\n    private int connectionTimeout;\n    private ExecutorService connectionPool;\n    \n    public MySQLDatabase(String connectionString, Properties properties) {\n        this.connectionString = connectionString;\n        this.connectionProperties = properties;\n        this.isConnected = false;\n        this.connectionTimeout = 30;\n        this.connectionPool = Executors.newFixedThreadPool(10);\n    }\n    \n    public void connect() throws Exception {\n        if (!isConnected) {\n            System.out.println(\"Establishing MySQL connection with: \" + connectionString);\n            Thread.sleep(connectionTimeout);\n            isConnected = true;\n            System.out.println(\"MySQL connection established successfully\");\n        }\n    }\n    \n    public void disconnect() {\n        if (isConnected) {\n            System.out.println(\"Closing MySQL connection\");\n            isConnected = false;\n            connectionPool.shutdown();\n        }\n    }\n    \n    public String getUserEmail(int userId) throws Exception {\n        if (!isConnected) {\n            throw new RuntimeException(\"Database connection not established\");\n        }\n        \n        Future<String> future = connectionPool.submit(() -> {\n            try {\n                Thread.sleep(10);\n                return \"user\" + userId + \"@enterprise.com\";\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n        \n        return future.get(5, TimeUnit.SECONDS);\n    }\n    \n    public boolean validateUser(int userId) throws Exception {\n        if (!isConnected) {\n            throw new RuntimeException(\"Database connection not established\");\n        }\n        \n        Future<Boolean> future = connectionPool.submit(() -> {\n            try {\n                Thread.sleep(5);\n                return userId > 0 && userId < 100000;\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n        \n        return future.get(3, TimeUnit.SECONDS);\n    }\n    \n    public List<String> getUserGroups(int userId) throws Exception {\n        if (!isConnected) {\n            throw new RuntimeException(\"Database connection not established\");\n        }\n        \n        Future<List<String>> future = connectionPool.submit(() -> {\n            try {\n                Thread.sleep(15);\n                List<String> groups = new ArrayList<>();\n                groups.add(\"general\");\n                groups.add(\"department_\" + (userId % 10));\n                return groups;\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n        \n        return future.get(10, TimeUnit.SECONDS);\n    }\n    \n    public void updateEmailSentStatus(int userId, String messageId) throws Exception {\n        if (!isConnected) {\n            throw new RuntimeException(\"Database connection not established\");\n        }\n        \n        connectionPool.submit(() -> {\n            try {\n                Thread.sleep(20);\n                System.out.println(\"Email status updated for user \" + userId + \", message: \" + messageId);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n}\n\npublic class EmailService {\n    private MySQLDatabase database;\n    private String smtpServer;\n    private int smtpPort;\n    private String smtpUsername;\n    private String smtpPassword;\n    private boolean useSSL;\n    \n    public EmailService(String smtpServer, int smtpPort, String username, String password, boolean useSSL) {\n        this.smtpServer = smtpServer;\n        this.smtpPort = smtpPort;\n        this.smtpUsername = username;\n        this.smtpPassword = password;\n        this.useSSL = useSSL;\n        \n        Properties dbProperties = new Properties();\n        dbProperties.setProperty(\"useSSL\", \"true\");\n        dbProperties.setProperty(\"serverTimezone\", \"UTC\");\n        \n        this.database = new MySQLDatabase(\"jdbc:mysql://localhost:3306/enterprise_users?useSSL=true&serverTimezone=UTC\", dbProperties);\n    }\n    \n    public void sendEmail(int userId, String subject, String message, String priority) throws Exception {\n        database.connect();\n        \n        try {\n            if (!database.validateUser(userId)) {\n                System.out.println(\"User validation failed for ID: \" + userId);\n                return;\n            }\n            \n            String email = database.getUserEmail(userId);\n            List<String> groups = database.getUserGroups(userId);\n            \n            System.out.println(\"Configuring SMTP connection:\");\n            System.out.println(\"Server: \" + smtpServer + \":\" + smtpPort);\n            System.out.println(\"SSL: \" + useSSL);\n            System.out.println(\"Authentication: \" + smtpUsername);\n            \n            String messageId = UUID.randomUUID().toString();\n            \n            System.out.println(\"Sending email:\");\n            System.out.println(\"To: \" + email);\n            System.out.println(\"Subject: \" + subject);\n            System.out.println(\"Message: \" + message);\n            System.out.println(\"Priority: \" + priority);\n            System.out.println(\"User Groups: \" + groups);\n            System.out.println(\"Message ID: \" + messageId);\n            \n            database.updateEmailSentStatus(userId, messageId);\n            \n        } finally {\n            database.disconnect();\n        }\n    }\n    \n    public void sendBulkEmails(int[] userIds, String subject, String message, String priority) throws Exception {\n        database.connect();\n        \n        try {\n            List<Future<Void>> futures = new ArrayList<>();\n            ExecutorService executor = Executors.newFixedThreadPool(5);\n            \n            for (int userId : userIds) {\n                futures.add(executor.submit(() -> {\n                    try {\n                        if (database.validateUser(userId)) {\n                            String email = database.getUserEmail(userId);\n                            List<String> groups = database.getUserGroups(userId);\n                            String messageId = UUID.randomUUID().toString();\n                            \n                            System.out.println(\"Bulk email sent to: \" + email + \" (Groups: \" + groups + \")\");\n                            database.updateEmailSentStatus(userId, messageId);\n                        }\n                    } catch (Exception e) {\n                        System.err.println(\"Failed to send email to user \" + userId + \": \" + e.getMessage());\n                    }\n                    return null;\n                }));\n            }\n            \n            for (Future<Void> future : futures) {\n                future.get();\n            }\n            \n            executor.shutdown();\n            \n        } finally {\n            database.disconnect();\n        }\n    }\n    \n    public void sendScheduledEmails(Map<Integer, String> userMessages, String subject, long delaySeconds) throws Exception {\n        database.connect();\n        \n        try {\n            ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3);\n            \n            for (Map.Entry<Integer, String> entry : userMessages.entrySet()) {\n                int userId = entry.getKey();\n                String personalizedMessage = entry.getValue();\n                \n                scheduler.schedule(() -> {\n                    try {\n                        if (database.validateUser(userId)) {\n                            String email = database.getUserEmail(userId);\n                            List<String> groups = database.getUserGroups(userId);\n                            String messageId = UUID.randomUUID().toString();\n                            \n                            System.out.println(\"Scheduled email sent to: \" + email);\n                            System.out.println(\"Personalized message: \" + personalizedMessage);\n                            database.updateEmailSentStatus(userId, messageId);\n                        }\n                    } catch (Exception e) {\n                        System.err.println(\"Failed to send scheduled email to user \" + userId + \": \" + e.getMessage());\n                    }\n                }, delaySeconds, TimeUnit.SECONDS);\n            }\n            \n        } finally {\n            database.disconnect();\n        }\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import asyncio\nimport concurrent.futures\nimport time\nfrom typing import List, Dict, Optional\nfrom uuid import uuid4\n\nclass MySQLDatabase:\n    def __init__(self, connection_string: str, connection_properties: Dict[str, str]):\n        self.connection_string = connection_string\n        self.connection_properties = connection_properties\n        self.is_connected = False\n        self.connection_timeout = 30\n        self.connection_pool = concurrent.futures.ThreadPoolExecutor(max_workers=10)\n    \n    async def connect(self):\n        if not self.is_connected:\n            print(f\"Establishing MySQL connection with: {self.connection_string}\")\n            await asyncio.sleep(self.connection_timeout / 1000)\n            self.is_connected = True\n            print(\"MySQL connection established successfully\")\n    \n    def disconnect(self):\n        if self.is_connected:\n            print(\"Closing MySQL connection\")\n            self.is_connected = False\n            self.connection_pool.shutdown()\n    \n    async def get_user_email(self, user_id: int) -> str:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._fetch_user_email, user_id)\n        return await loop.run_in_executor(None, future.result, 5)\n    \n    def _fetch_user_email(self, user_id: int) -> str:\n        time.sleep(0.01)\n        return f\"user{user_id}@enterprise.com\"\n    \n    async def validate_user(self, user_id: int) -> bool:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._validate_user_internal, user_id)\n        return await loop.run_in_executor(None, future.result, 3)\n    \n    def _validate_user_internal(self, user_id: int) -> bool:\n        time.sleep(0.005)\n        return user_id > 0 and user_id < 100000\n    \n    async def get_user_groups(self, user_id: int) -> List[str]:\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._fetch_user_groups, user_id)\n        return await loop.run_in_executor(None, future.result, 10)\n    \n    def _fetch_user_groups(self, user_id: int) -> List[str]:\n        time.sleep(0.015)\n        return [\"general\", f\"department_{user_id % 10}\"]\n    \n    async def update_email_sent_status(self, user_id: int, message_id: str):\n        if not self.is_connected:\n            raise RuntimeError(\"Database connection not established\")\n        \n        loop = asyncio.get_event_loop()\n        future = self.connection_pool.submit(self._update_status, user_id, message_id)\n        await loop.run_in_executor(None, future.result)\n    \n    def _update_status(self, user_id: int, message_id: str):\n        time.sleep(0.02)\n        print(f\"Email status updated for user {user_id}, message: {message_id}\")\n\nclass EmailService:\n    def __init__(self, smtp_server: str, smtp_port: int, username: str, password: str, use_ssl: bool):\n        self.smtp_server = smtp_server\n        self.smtp_port = smtp_port\n        self.smtp_username = username\n        self.smtp_password = password\n        self.use_ssl = use_ssl\n        \n        db_properties = {\n            \"useSSL\": \"true\",\n            \"serverTimezone\": \"UTC\"\n        }\n        \n        self.database = MySQLDatabase(\"mysql://localhost:3306/enterprise_users?useSSL=true&serverTimezone=UTC\", db_properties)\n    \n    async def send_email(self, user_id: int, subject: str, message: str, priority: str):\n        await self.database.connect()\n        \n        try:\n            if not await self.database.validate_user(user_id):\n                print(f\"User validation failed for ID: {user_id}\")\n                return\n            \n            email = await self.database.get_user_email(user_id)\n            groups = await self.database.get_user_groups(user_id)\n            \n            print(\"Configuring SMTP connection:\")\n            print(f\"Server: {self.smtp_server}:{self.smtp_port}\")\n            print(f\"SSL: {self.use_ssl}\")\n            print(f\"Authentication: {self.smtp_username}\")\n            \n            message_id = str(uuid4())\n            \n            print(\"Sending email:\")\n            print(f\"To: {email}\")\n            print(f\"Subject: {subject}\")\n            print(f\"Message: {message}\")\n            print(f\"Priority: {priority}\")\n            print(f\"User Groups: {groups}\")\n            print(f\"Message ID: {message_id}\")\n            \n            await self.database.update_email_sent_status(user_id, message_id)\n            \n        finally:\n            self.database.disconnect()\n    \n    async def send_bulk_emails(self, user_ids: List[int], subject: str, message: str, priority: str):\n        await self.database.connect()\n        \n        try:\n            tasks = []\n            for user_id in user_ids:\n                tasks.append(self._send_single_bulk_email(user_id, subject, message, priority))\n            \n            await asyncio.gather(*tasks)\n            \n        finally:\n            self.database.disconnect()\n    \n    async def _send_single_bulk_email(self, user_id: int, subject: str, message: str, priority: str):\n        try:\n            if await self.database.validate_user(user_id):\n                email = await self.database.get_user_email(user_id)\n                groups = await self.database.get_user_groups(user_id)\n                message_id = str(uuid4())\n                \n                print(f\"Bulk email sent to: {email} (Groups: {groups})\")\n                await self.database.update_email_sent_status(user_id, message_id)\n        except Exception as e:\n            print(f\"Failed to send email to user {user_id}: {e}\")\n    \n    async def send_scheduled_emails(self, user_messages: Dict[int, str], subject: str, delay_seconds: int):\n        await self.database.connect()\n        \n        try:\n            for user_id, personalized_message in user_messages.items():\n                await asyncio.sleep(delay_seconds)\n                \n                try:\n                    if await self.database.validate_user(user_id):\n                        email = await self.database.get_user_email(user_id)\n                        groups = await self.database.get_user_groups(user_id)\n                        message_id = str(uuid4())\n                        \n                        print(f\"Scheduled email sent to: {email}\")\n                        print(f\"Personalized message: {personalized_message}\")\n                        await self.database.update_email_sent_status(user_id, message_id)\n                except Exception as e:\n                    print(f\"Failed to send scheduled email to user {user_id}: {e}\")\n                    \n        finally:\n            self.database.disconnect()",
    "output": "",
    "level": "HARD",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "import kotlinx.coroutines.*\nimport java.util.concurrent.Executors\nimport java.util.concurrent.TimeUnit\nimport java.util.UUID\n\nclass MySQLDatabase(\n    private val connectionString: String,\n    private val connectionProperties: Map<String, String>\n) {\n    private var isConnected = false\n    private val connectionTimeout = 30\n    private val executor = Executors.newFixedThreadPool(10)\n    \n    suspend fun connect() {\n        if (!isConnected) {\n            println(\"Establishing MySQL connection with: $connectionString\")\n            delay(connectionTimeout.toLong())\n            isConnected = true\n            println(\"MySQL connection established successfully\")\n        }\n    }\n    \n    fun disconnect() {\n        if (isConnected) {\n            println(\"Closing MySQL connection\")\n            isConnected = false\n            executor.shutdown()\n        }\n    }\n    \n    suspend fun getUserEmail(userId: Int): String = withContext(Dispatchers.IO) {\n        if (!isConnected) {\n            throw RuntimeException(\"Database connection not established\")\n        }\n        \n        val future = executor.submit {\n            Thread.sleep(10)\n            \"user$userId@enterprise.com\"\n        }\n        \n        future.get(5, TimeUnit.SECONDS)\n    }\n    \n    suspend fun validateUser(userId: Int): Boolean = withContext(Dispatchers.IO) {\n        if (!isConnected) {\n            throw RuntimeException(\"Database connection not established\")\n        }\n        \n        val future = executor.submit {\n            Thread.sleep(5)\n            userId > 0 && userId < 100000\n        }\n        \n        future.get(3, TimeUnit.SECONDS)\n    }\n    \n    suspend fun getUserGroups(userId: Int): List<String> = withContext(Dispatchers.IO) {\n        if (!isConnected) {\n            throw RuntimeException(\"Database connection not established\")\n        }\n        \n        val future = executor.submit {\n            Thread.sleep(15)\n            listOf(\"general\", \"department_${userId % 10}\")\n        }\n        \n        future.get(10, TimeUnit.SECONDS)\n    }\n    \n    suspend fun updateEmailSentStatus(userId: Int, messageId: String) = withContext(Dispatchers.IO) {\n        if (!isConnected) {\n            throw RuntimeException(\"Database connection not established\")\n        }\n        \n        val future = executor.submit {\n            Thread.sleep(20)\n            println(\"Email status updated for user $userId, message: $messageId\")\n        }\n        \n        future.get()\n    }\n}\n\nclass EmailService(\n    private val smtpServer: String,\n    private val smtpPort: Int,\n    private val username: String,\n    private val password: String,\n    private val useSSL: Boolean\n) {\n    private val database = MySQLDatabase(\n        \"mysql://localhost:3306/enterprise_users?useSSL=true&serverTimezone=UTC\",\n        mapOf(\n            \"useSSL\" to \"true\",\n            \"serverTimezone\" to \"UTC\"\n        )\n    )\n    \n    suspend fun sendEmail(userId: Int, subject: String, message: String, priority: String) {\n        database.connect()\n        \n        try {\n            if (!database.validateUser(userId)) {\n                println(\"User validation failed for ID: $userId\")\n                return\n            }\n            \n            val email = database.getUserEmail(userId)\n            val groups = database.getUserGroups(userId)\n            \n            println(\"Configuring SMTP connection:\")\n            println(\"Server: $smtpServer:$smtpPort\")\n            println(\"SSL: $useSSL\")\n            println(\"Authentication: $username\")\n            \n            val messageId = UUID.randomUUID().toString()\n            \n            println(\"Sending email:\")\n            println(\"To: $email\")\n            println(\"Subject: $subject\")\n            println(\"Message: $message\")\n            println(\"Priority: $priority\")\n            println(\"User Groups: $groups\")\n            println(\"Message ID: $messageId\")\n            \n            database.updateEmailSentStatus(userId, messageId)\n            \n        } finally {\n            database.disconnect()\n        }\n    }\n    \n    suspend fun sendBulkEmails(userIds: List<Int>, subject: String, message: String, priority: String) {\n        database.connect()\n        \n        try {\n            val jobs = userIds.map { userId ->\n                async {\n                    sendSingleBulkEmail(userId, subject, message, priority)\n                }\n            }\n            \n            jobs.awaitAll()\n            \n        } finally {\n            database.disconnect()\n        }\n    }\n    \n    private suspend fun sendSingleBulkEmail(userId: Int, subject: String, message: String, priority: String) {\n        try {\n            if (database.validateUser(userId)) {\n                val email = database.getUserEmail(userId)\n                val groups = database.getUserGroups(userId)\n                val messageId = UUID.randomUUID().toString()\n                \n                println(\"Bulk email sent to: $email (Groups: $groups)\")\n                database.updateEmailSentStatus(userId, messageId)\n            }\n        } catch (e: Exception) {\n            println(\"Failed to send email to user $userId: ${e.message}\")\n        }\n    }\n    \n    suspend fun sendScheduledEmails(userMessages: Map<Int, String>, subject: String, delaySeconds: Int) {\n        database.connect()\n        \n        try {\n            for ((userId, personalizedMessage) in userMessages) {\n                delay(delaySeconds * 1000L)\n                \n                try {\n                    if (database.validateUser(userId)) {\n                        val email = database.getUserEmail(userId)\n                        val groups = database.getUserGroups(userId)\n                        val messageId = UUID.randomUUID().toString()\n                        \n                        println(\"Scheduled email sent to: $email\")\n                        println(\"Personalized message: $personalizedMessage\")\n                        database.updateEmailSentStatus(userId, messageId)\n                    }\n                } catch (e: Exception) {\n                    println(\"Failed to send scheduled email to user $userId: ${e.message}\")\n                }\n            }\n            \n        } finally {\n            database.disconnect()\n        }\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing System.Threading;\nusing System.Collections.Concurrent;\nusing System.Data.SqlClient;\n\npublic class MySQLDatabase\n{\n    private readonly string connectionString;\n    private readonly Dictionary<string, string> connectionProperties;\n    private bool isConnected = false;\n    private readonly int connectionTimeout = 30;\n    private readonly SemaphoreSlim connectionSemaphore = new SemaphoreSlim(10, 10);\n    \n    public MySQLDatabase(string connectionString, Dictionary<string, string> connectionProperties)\n    {\n        this.connectionString = connectionString;\n        this.connectionProperties = connectionProperties;\n    }\n    \n    public async Task ConnectAsync()\n    {\n        if (!isConnected)\n        {\n            Console.WriteLine($\"Establishing MySQL connection with: {connectionString}\");\n            await Task.Delay(connectionTimeout);\n            isConnected = true;\n            Console.WriteLine(\"MySQL connection established successfully\");\n        }\n    }\n    \n    public void Disconnect()\n    {\n        if (isConnected)\n        {\n            Console.WriteLine(\"Closing MySQL connection\");\n            isConnected = false;\n            connectionSemaphore.Dispose();\n        }\n    }\n    \n    public async Task<string> GetUserEmailAsync(int userId)\n    {\n        if (!isConnected)\n        {\n            throw new InvalidOperationException(\"Database connection not established\");\n        }\n        \n        await connectionSemaphore.WaitAsync();\n        try\n        {\n            await Task.Run(() => Thread.Sleep(10));\n            return $\"user{userId}@enterprise.com\";\n        }\n        finally\n        {\n            connectionSemaphore.Release();\n        }\n    }\n    \n    public async Task<bool> ValidateUserAsync(int userId)\n    {\n        if (!isConnected)\n        {\n            throw new InvalidOperationException(\"Database connection not established\");\n        }\n        \n        await connectionSemaphore.WaitAsync();\n        try\n        {\n            await Task.Run(() => Thread.Sleep(5));\n            return userId > 0 && userId < 100000;\n        }\n        finally\n        {\n            connectionSemaphore.Release();\n        }\n    }\n    \n    public async Task<List<string>> GetUserGroupsAsync(int userId)\n    {\n        if (!isConnected)\n        {\n            throw new InvalidOperationException(\"Database connection not established\");\n        }\n        \n        await connectionSemaphore.WaitAsync();\n        try\n        {\n            await Task.Run(() => Thread.Sleep(15));\n            return new List<string> { \"general\", $\"department_{userId % 10}\" };\n        }\n        finally\n        {\n            connectionSemaphore.Release();\n        }\n    }\n    \n    public async Task UpdateEmailSentStatusAsync(int userId, string messageId)\n    {\n        if (!isConnected)\n        {\n            throw new InvalidOperationException(\"Database connection not established\");\n        }\n        \n        await connectionSemaphore.WaitAsync();\n        try\n        {\n            await Task.Run(() => \n            {\n                Thread.Sleep(20);\n                Console.WriteLine($\"Email status updated for user {userId}, message: {messageId}\");\n            });\n        }\n        finally\n        {\n            connectionSemaphore.Release();\n        }\n    }\n}\n\npublic class EmailService\n{\n    private readonly string smtpServer;\n    private readonly int smtpPort;\n    private readonly string username;\n    private readonly string password;\n    private readonly bool useSSL;\n    private readonly MySQLDatabase database;\n    \n    public EmailService(string smtpServer, int smtpPort, string username, string password, bool useSSL)\n    {\n        this.smtpServer = smtpServer;\n        this.smtpPort = smtpPort;\n        this.username = username;\n        this.password = password;\n        this.useSSL = useSSL;\n        \n        var dbProperties = new Dictionary<string, string>\n        {\n            { \"useSSL\", \"true\" },\n            { \"serverTimezone\", \"UTC\" }\n        };\n        \n        this.database = new MySQLDatabase(\"mysql://localhost:3306/enterprise_users?useSSL=true&serverTimezone=UTC\", dbProperties);\n    }\n    \n    public async Task SendEmailAsync(int userId, string subject, string message, string priority)\n    {\n        await database.ConnectAsync();\n        \n        try\n        {\n            if (!await database.ValidateUserAsync(userId))\n            {\n                Console.WriteLine($\"User validation failed for ID: {userId}\");\n                return;\n            }\n            \n            var email = await database.GetUserEmailAsync(userId);\n            var groups = await database.GetUserGroupsAsync(userId);\n            \n            Console.WriteLine(\"Configuring SMTP connection:\");\n            Console.WriteLine($\"Server: {smtpServer}:{smtpPort}\");\n            Console.WriteLine($\"SSL: {useSSL}\");\n            Console.WriteLine($\"Authentication: {username}\");\n            \n            var messageId = Guid.NewGuid().ToString();\n            \n            Console.WriteLine(\"Sending email:\");\n            Console.WriteLine($\"To: {email}\");\n            Console.WriteLine($\"Subject: {subject}\");\n            Console.WriteLine($\"Message: {message}\");\n            Console.WriteLine($\"Priority: {priority}\");\n            Console.WriteLine($\"User Groups: {string.Join(\", \", groups)}\");\n            Console.WriteLine($\"Message ID: {messageId}\");\n            \n            await database.UpdateEmailSentStatusAsync(userId, messageId);\n            \n        }\n        finally\n        {\n            database.Disconnect();\n        }\n    }\n    \n    public async Task SendBulkEmailsAsync(List<int> userIds, string subject, string message, string priority)\n    {\n        await database.ConnectAsync();\n        \n        try\n        {\n            var tasks = new List<Task>();\n            foreach (var userId in userIds)\n            {\n                tasks.Add(SendSingleBulkEmailAsync(userId, subject, message, priority));\n            }\n            \n            await Task.WhenAll(tasks);\n            \n        }\n        finally\n        {\n            database.Disconnect();\n        }\n    }\n    \n    private async Task SendSingleBulkEmailAsync(int userId, string subject, string message, string priority)\n    {\n        try\n        {\n            if (await database.ValidateUserAsync(userId))\n            {\n                var email = await database.GetUserEmailAsync(userId);\n                var groups = await database.GetUserGroupsAsync(userId);\n                var messageId = Guid.NewGuid().ToString();\n                \n                Console.WriteLine($\"Bulk email sent to: {email} (Groups: {string.Join(\", \", groups)})\");\n                await database.UpdateEmailSentStatusAsync(userId, messageId);\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Failed to send email to user {userId}: {ex.Message}\");\n        }\n    }\n    \n    public async Task SendScheduledEmailsAsync(Dictionary<int, string> userMessages, string subject, int delaySeconds)\n    {\n        await database.ConnectAsync();\n        \n        try\n        {\n            foreach (var kvp in userMessages)\n            {\n                var userId = kvp.Key;\n                var personalizedMessage = kvp.Value;\n                \n                await Task.Delay(delaySeconds * 1000);\n                \n                try\n                {\n                    if (await database.ValidateUserAsync(userId))\n                    {\n                        var email = await database.GetUserEmailAsync(userId);\n                        var groups = await database.GetUserGroupsAsync(userId);\n                        var messageId = Guid.NewGuid().ToString();\n                        \n                        Console.WriteLine($\"Scheduled email sent to: {email}\");\n                        Console.WriteLine($\"Personalized message: {personalizedMessage}\");\n                        await database.UpdateEmailSentStatusAsync(userId, messageId);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($\"Failed to send scheduled email to user {userId}: {ex.Message}\");\n                }\n            }\n            \n        }\n        finally\n        {\n            database.Disconnect();\n        }\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "C#",
    "violation": "DIP"
  },
    {
    "input": "public class PayPalGateway {\n    public boolean processPayment(double amount) {\n        System.out.println(\"Processing $\" + amount + \" via PayPal\");\n        return true;\n    }\n}\n\npublic class PaymentProcessor {\n    private PayPalGateway paypalGateway;\n    \n    public PaymentProcessor() {\n        this.paypalGateway = new PayPalGateway();\n    }\n    \n    public boolean processTransaction(double amount) {\n        return paypalGateway.processPayment(amount);\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "class PayPalGateway:\n    def process_payment(self, amount):\n        print(f\"Processing ${amount} via PayPal\")\n        return True\n\nclass PaymentProcessor:\n    def __init__(self):\n        self.paypal_gateway = PayPalGateway()\n    \n    def process_transaction(self, amount):\n        return self.paypal_gateway.process_payment(amount)",
    "output": "",
    "level": "EASY",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "class PayPalGateway {\n    fun processPayment(amount: Double): Boolean {\n        println(\"Processing $${amount} via PayPal\")\n        return true\n    }\n}\n\nclass PaymentProcessor {\n    private val paypalGateway = PayPalGateway()\n    \n    fun processTransaction(amount: Double): Boolean {\n        return paypalGateway.processPayment(amount)\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "public class PayPalGateway\n{\n    public bool ProcessPayment(double amount)\n    {\n        Console.WriteLine($\"Processing ${amount} via PayPal\");\n        return true;\n    }\n}\n\npublic class PaymentProcessor\n{\n    private PayPalGateway _paypalGateway;\n    \n    public PaymentProcessor()\n    {\n        _paypalGateway = new PayPalGateway();\n    }\n    \n    public bool ProcessTransaction(double amount)\n    {\n        return _paypalGateway.ProcessPayment(amount);\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "public class PayPalGateway {\n    public boolean processPayment(double amount, String currency) {\n        System.out.println(\"Processing \" + amount + \" \" + currency + \" via PayPal\");\n        return amount > 0;\n    }\n    \n    public String getTransactionId() {\n        return \"PP_\" + System.currentTimeMillis();\n    }\n}\n\npublic class StripeGateway {\n    public boolean chargeCard(double amount, String currency) {\n        System.out.println(\"Charging \" + amount + \" \" + currency + \" via Stripe\");\n        return amount > 0;\n    }\n    \n    public String getChargeId() {\n        return \"ST_\" + System.currentTimeMillis();\n    }\n}\n\npublic class PaymentProcessor {\n    private PayPalGateway paypalGateway;\n    private StripeGateway stripeGateway;\n    \n    public PaymentProcessor() {\n        this.paypalGateway = new PayPalGateway();\n        this.stripeGateway = new StripeGateway();\n    }\n    \n    public boolean processTransaction(double amount, String currency, String gateway) {\n        if (gateway.equals(\"paypal\")) {\n            boolean result = paypalGateway.processPayment(amount, currency);\n            if (result) {\n                System.out.println(\"Transaction ID: \" + paypalGateway.getTransactionId());\n            }\n            return result;\n        } else if (gateway.equals(\"stripe\")) {\n            boolean result = stripeGateway.chargeCard(amount, currency);\n            if (result) {\n                System.out.println(\"Charge ID: \" + stripeGateway.getChargeId());\n            }\n            return result;\n        }\n        return false;\n    }\n    \n    public void processRefund(double amount, String gateway) {\n        if (gateway.equals(\"paypal\")) {\n            System.out.println(\"Refunding \" + amount + \" via PayPal\");\n        } else if (gateway.equals(\"stripe\")) {\n            System.out.println(\"Refunding \" + amount + \" via Stripe\");\n        }\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import time\n\nclass PayPalGateway:\n    def process_payment(self, amount, currency):\n        print(f\"Processing {amount} {currency} via PayPal\")\n        return amount > 0\n    \n    def get_transaction_id(self):\n        return f\"PP_{int(time.time() * 1000)}\"\n\nclass StripeGateway:\n    def charge_card(self, amount, currency):\n        print(f\"Charging {amount} {currency} via Stripe\")\n        return amount > 0\n    \n    def get_charge_id(self):\n        return f\"ST_{int(time.time() * 1000)}\"\n\nclass PaymentProcessor:\n    def __init__(self):\n        self.paypal_gateway = PayPalGateway()\n        self.stripe_gateway = StripeGateway()\n    \n    def process_transaction(self, amount, currency, gateway):\n        if gateway == \"paypal\":\n            result = self.paypal_gateway.process_payment(amount, currency)\n            if result:\n                print(f\"Transaction ID: {self.paypal_gateway.get_transaction_id()}\")\n            return result\n        elif gateway == \"stripe\":\n            result = self.stripe_gateway.charge_card(amount, currency)\n            if result:\n                print(f\"Charge ID: {self.stripe_gateway.get_charge_id()}\")\n            return result\n        return False\n    \n    def process_refund(self, amount, gateway):\n        if gateway == \"paypal\":\n            print(f\"Refunding {amount} via PayPal\")\n        elif gateway == \"stripe\":\n            print(f\"Refunding {amount} via Stripe\")",
    "output": "",
    "level": "MODERATE",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "class PayPalGateway {\n    fun processPayment(amount: Double, currency: String): Boolean {\n        println(\"Processing $amount $currency via PayPal\")\n        return amount > 0\n    }\n    \n    fun getTransactionId(): String {\n        return \"PP_${System.currentTimeMillis()}\"\n    }\n}\n\nclass StripeGateway {\n    fun chargeCard(amount: Double, currency: String): Boolean {\n        println(\"Charging $amount $currency via Stripe\")\n        return amount > 0\n    }\n    \n    fun getChargeId(): String {\n        return \"ST_${System.currentTimeMillis()}\"\n    }\n}\n\nclass PaymentProcessor {\n    private val paypalGateway = PayPalGateway()\n    private val stripeGateway = StripeGateway()\n    \n    fun processTransaction(amount: Double, currency: String, gateway: String): Boolean {\n        return when (gateway) {\n            \"paypal\" -> {\n                val result = paypalGateway.processPayment(amount, currency)\n                if (result) {\n                    println(\"Transaction ID: ${paypalGateway.getTransactionId()}\")\n                }\n                result\n            }\n            \"stripe\" -> {\n                val result = stripeGateway.chargeCard(amount, currency)\n                if (result) {\n                    println(\"Charge ID: ${stripeGateway.getChargeId()}\")\n                }\n                result\n            }\n            else -> false\n        }\n    }\n    \n    fun processRefund(amount: Double, gateway: String) {\n        when (gateway) {\n            \"paypal\" -> println(\"Refunding $amount via PayPal\")\n            \"stripe\" -> println(\"Refunding $amount via Stripe\")\n        }\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\n\npublic class PayPalGateway\n{\n    public bool ProcessPayment(double amount, string currency)\n    {\n        Console.WriteLine($\"Processing {amount} {currency} via PayPal\");\n        return amount > 0;\n    }\n    \n    public string GetTransactionId()\n    {\n        return $\"PP_{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}\";\n    }\n}\n\npublic class StripeGateway\n{\n    public bool ChargeCard(double amount, string currency)\n    {\n        Console.WriteLine($\"Charging {amount} {currency} via Stripe\");\n        return amount > 0;\n    }\n    \n    public string GetChargeId()\n    {\n        return $\"ST_{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}\";\n    }\n}\n\npublic class PaymentProcessor\n{\n    private PayPalGateway _paypalGateway;\n    private StripeGateway _stripeGateway;\n    \n    public PaymentProcessor()\n    {\n        _paypalGateway = new PayPalGateway();\n        _stripeGateway = new StripeGateway();\n    }\n    \n    public bool ProcessTransaction(double amount, string currency, string gateway)\n    {\n        if (gateway == \"paypal\")\n        {\n            var result = _paypalGateway.ProcessPayment(amount, currency);\n            if (result)\n            {\n                Console.WriteLine($\"Transaction ID: {_paypalGateway.GetTransactionId()}\");\n            }\n            return result;\n        }\n        else if (gateway == \"stripe\")\n        {\n            var result = _stripeGateway.ChargeCard(amount, currency);\n            if (result)\n            {\n                Console.WriteLine($\"Charge ID: {_stripeGateway.GetChargeId()}\");\n            }\n            return result;\n        }\n        return false;\n    }\n    \n    public void ProcessRefund(double amount, string gateway)\n    {\n        if (gateway == \"paypal\")\n        {\n            Console.WriteLine($\"Refunding {amount} via PayPal\");\n        }\n        else if (gateway == \"stripe\")\n        {\n            Console.WriteLine($\"Refunding {amount} via Stripe\");\n        }\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "import java.util.*;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class PayPalGateway {\n    private Map<String, Object> config;\n    \n    public PayPalGateway() {\n        this.config = new HashMap<>();\n        this.config.put(\"apiKey\", \"paypal_api_key\");\n        this.config.put(\"environment\", \"sandbox\");\n    }\n    \n    public PaymentResult processPayment(double amount, String currency, CustomerInfo customer) {\n        System.out.println(\"Initializing PayPal payment for \" + customer.getName());\n        \n        if (validatePayPalPayment(amount, currency)) {\n            String transactionId = generatePayPalTransactionId();\n            logPayPalTransaction(transactionId, amount, currency, customer);\n            return new PaymentResult(true, transactionId, \"Payment processed successfully via PayPal\");\n        }\n        return new PaymentResult(false, null, \"PayPal payment validation failed\");\n    }\n    \n    private boolean validatePayPalPayment(double amount, String currency) {\n        return amount > 0 && currency != null && !currency.isEmpty();\n    }\n    \n    private String generatePayPalTransactionId() {\n        return \"PP_\" + System.currentTimeMillis() + \"_\" + new Random().nextInt(10000);\n    }\n    \n    private void logPayPalTransaction(String transactionId, double amount, String currency, CustomerInfo customer) {\n        System.out.println(\"PayPal Transaction Log: \" + transactionId + \" - \" + amount + \" \" + currency + \" for \" + customer.getEmail());\n    }\n    \n    public boolean processRefund(String transactionId, double amount) {\n        System.out.println(\"Processing PayPal refund for transaction: \" + transactionId);\n        return true;\n    }\n}\n\npublic class StripeGateway {\n    private Map<String, Object> config;\n    \n    public StripeGateway() {\n        this.config = new HashMap<>();\n        this.config.put(\"secretKey\", \"stripe_secret_key\");\n        this.config.put(\"publishableKey\", \"stripe_publishable_key\");\n    }\n    \n    public PaymentResult chargeCard(double amount, String currency, CustomerInfo customer) {\n        System.out.println(\"Creating Stripe charge for \" + customer.getName());\n        \n        if (validateStripePayment(amount, currency)) {\n            String chargeId = generateStripeChargeId();\n            logStripeTransaction(chargeId, amount, currency, customer);\n            return new PaymentResult(true, chargeId, \"Card charged successfully via Stripe\");\n        }\n        return new PaymentResult(false, null, \"Stripe payment validation failed\");\n    }\n    \n    private boolean validateStripePayment(double amount, String currency) {\n        return amount > 0 && currency != null && Arrays.asList(\"USD\", \"EUR\", \"GBP\").contains(currency.toUpperCase());\n    }\n    \n    private String generateStripeChargeId() {\n        return \"ST_\" + System.currentTimeMillis() + \"_\" + new Random().nextInt(10000);\n    }\n    \n    private void logStripeTransaction(String chargeId, double amount, String currency, CustomerInfo customer) {\n        System.out.println(\"Stripe Transaction Log: \" + chargeId + \" - \" + amount + \" \" + currency + \" for \" + customer.getEmail());\n    }\n    \n    public boolean processRefund(String chargeId, double amount) {\n        System.out.println(\"Processing Stripe refund for charge: \" + chargeId);\n        return true;\n    }\n}\n\npublic class SquareGateway {\n    private Map<String, Object> config;\n    \n    public SquareGateway() {\n        this.config = new HashMap<>();\n        this.config.put(\"applicationId\", \"square_app_id\");\n        this.config.put(\"accessToken\", \"square_access_token\");\n    }\n    \n    public PaymentResult createPayment(double amount, String currency, CustomerInfo customer) {\n        System.out.println(\"Creating Square payment for \" + customer.getName());\n        \n        if (validateSquarePayment(amount, currency)) {\n            String paymentId = generateSquarePaymentId();\n            logSquareTransaction(paymentId, amount, currency, customer);\n            return new PaymentResult(true, paymentId, \"Payment created successfully via Square\");\n        }\n        return new PaymentResult(false, null, \"Square payment validation failed\");\n    }\n    \n    private boolean validateSquarePayment(double amount, String currency) {\n        return amount > 0 && currency != null && currency.equals(\"USD\");\n    }\n    \n    private String generateSquarePaymentId() {\n        return \"SQ_\" + System.currentTimeMillis() + \"_\" + new Random().nextInt(10000);\n    }\n    \n    private void logSquareTransaction(String paymentId, double amount, String currency, CustomerInfo customer) {\n        System.out.println(\"Square Transaction Log: \" + paymentId + \" - \" + amount + \" \" + currency + \" for \" + customer.getEmail());\n    }\n    \n    public boolean processRefund(String paymentId, double amount) {\n        System.out.println(\"Processing Square refund for payment: \" + paymentId);\n        return true;\n    }\n}\n\npublic class PaymentProcessor {\n    private PayPalGateway paypalGateway;\n    private StripeGateway stripeGateway;\n    private SquareGateway squareGateway;\n    private List<PaymentResult> transactionHistory;\n    \n    public PaymentProcessor() {\n        this.paypalGateway = new PayPalGateway();\n        this.stripeGateway = new StripeGateway();\n        this.squareGateway = new SquareGateway();\n        this.transactionHistory = new ArrayList<>();\n    }\n    \n    public PaymentResult processTransaction(double amount, String currency, String gateway, CustomerInfo customer) {\n        PaymentResult result = null;\n        \n        switch (gateway.toLowerCase()) {\n            case \"paypal\":\n                result = paypalGateway.processPayment(amount, currency, customer);\n                break;\n            case \"stripe\":\n                result = stripeGateway.chargeCard(amount, currency, customer);\n                break;\n            case \"square\":\n                result = squareGateway.createPayment(amount, currency, customer);\n                break;\n            default:\n                result = new PaymentResult(false, null, \"Unsupported payment gateway\");\n        }\n        \n        if (result != null) {\n            transactionHistory.add(result);\n            generateTransactionReport(result, gateway, customer);\n        }\n        \n        return result;\n    }\n    \n    public boolean processRefund(String transactionId, double amount, String gateway) {\n        switch (gateway.toLowerCase()) {\n            case \"paypal\":\n                return paypalGateway.processRefund(transactionId, amount);\n            case \"stripe\":\n                return stripeGateway.processRefund(transactionId, amount);\n            case \"square\":\n                return squareGateway.processRefund(transactionId, amount);\n            default:\n                return false;\n        }\n    }\n    \n    private void generateTransactionReport(PaymentResult result, String gateway, CustomerInfo customer) {\n        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n        System.out.println(\"Transaction Report [\" + timestamp + \"]: Gateway=\" + gateway + \", Customer=\" + customer.getName() + \", Status=\" + (result.isSuccess() ? \"SUCCESS\" : \"FAILED\"));\n    }\n    \n    public List<PaymentResult> getTransactionHistory() {\n        return new ArrayList<>(transactionHistory);\n    }\n}\n\nclass CustomerInfo {\n    private String name;\n    private String email;\n    \n    public CustomerInfo(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n    \n    public String getName() { return name; }\n    public String getEmail() { return email; }\n}\n\nclass PaymentResult {\n    private boolean success;\n    private String transactionId;\n    private String message;\n    \n    public PaymentResult(boolean success, String transactionId, String message) {\n        this.success = success;\n        this.transactionId = transactionId;\n        this.message = message;\n    }\n    \n    public boolean isSuccess() { return success; }\n    public String getTransactionId() { return transactionId; }\n    public String getMessage() { return message; }\n}",
    "output": "",
    "level": "HARD",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import time\nimport random\nfrom datetime import datetime\nfrom typing import List, Dict, Any, Optional\n\nclass PayPalGateway:\n    def __init__(self):\n        self.config = {\n            'api_key': 'paypal_api_key',\n            'environment': 'sandbox'\n        }\n    \n    def process_payment(self, amount: float, currency: str, customer: 'CustomerInfo') -> 'PaymentResult':\n        print(f\"Initializing PayPal payment for {customer.name}\")\n        \n        if self._validate_paypal_payment(amount, currency):\n            transaction_id = self._generate_paypal_transaction_id()\n            self._log_paypal_transaction(transaction_id, amount, currency, customer)\n            return PaymentResult(True, transaction_id, \"Payment processed successfully via PayPal\")\n        return PaymentResult(False, None, \"PayPal payment validation failed\")\n    \n    def _validate_paypal_payment(self, amount: float, currency: str) -> bool:\n        return amount > 0 and currency is not None and currency.strip() != \"\"\n    \n    def _generate_paypal_transaction_id(self) -> str:\n        return f\"PP_{int(time.time() * 1000)}_{random.randint(1000, 9999)}\"\n    \n    def _log_paypal_transaction(self, transaction_id: str, amount: float, currency: str, customer: 'CustomerInfo'):\n        print(f\"PayPal Transaction Log: {transaction_id} - {amount} {currency} for {customer.email}\")\n    \n    def process_refund(self, transaction_id: str, amount: float) -> bool:\n        print(f\"Processing PayPal refund for transaction: {transaction_id}\")\n        return True\n\nclass StripeGateway:\n    def __init__(self):\n        self.config = {\n            'secret_key': 'stripe_secret_key',\n            'publishable_key': 'stripe_publishable_key'\n        }\n    \n    def charge_card(self, amount: float, currency: str, customer: 'CustomerInfo') -> 'PaymentResult':\n        print(f\"Creating Stripe charge for {customer.name}\")\n        \n        if self._validate_stripe_payment(amount, currency):\n            charge_id = self._generate_stripe_charge_id()\n            self._log_stripe_transaction(charge_id, amount, currency, customer)\n            return PaymentResult(True, charge_id, \"Card charged successfully via Stripe\")\n        return PaymentResult(False, None, \"Stripe payment validation failed\")\n    \n    def _validate_stripe_payment(self, amount: float, currency: str) -> bool:\n        return amount > 0 and currency is not None and currency.upper() in ['USD', 'EUR', 'GBP']\n    \n    def _generate_stripe_charge_id(self) -> str:\n        return f\"ST_{int(time.time() * 1000)}_{random.randint(1000, 9999)}\"\n    \n    def _log_stripe_transaction(self, charge_id: str, amount: float, currency: str, customer: 'CustomerInfo'):\n        print(f\"Stripe Transaction Log: {charge_id} - {amount} {currency} for {customer.email}\")\n    \n    def process_refund(self, charge_id: str, amount: float) -> bool:\n        print(f\"Processing Stripe refund for charge: {charge_id}\")\n        return True\n\nclass SquareGateway:\n    def __init__(self):\n        self.config = {\n            'application_id': 'square_app_id',\n            'access_token': 'square_access_token'\n        }\n    \n    def create_payment(self, amount: float, currency: str, customer: 'CustomerInfo') -> 'PaymentResult':\n        print(f\"Creating Square payment for {customer.name}\")\n        \n        if self._validate_square_payment(amount, currency):\n            payment_id = self._generate_square_payment_id()\n            self._log_square_transaction(payment_id, amount, currency, customer)\n            return PaymentResult(True, payment_id, \"Payment created successfully via Square\")\n        return PaymentResult(False, None, \"Square payment validation failed\")\n    \n    def _validate_square_payment(self, amount: float, currency: str) -> bool:\n        return amount > 0 and currency is not None and currency == \"USD\"\n    \n    def _generate_square_payment_id(self) -> str:\n        return f\"SQ_{int(time.time() * 1000)}_{random.randint(1000, 9999)}\"\n    \n    def _log_square_transaction(self, payment_id: str, amount: float, currency: str, customer: 'CustomerInfo'):\n        print(f\"Square Transaction Log: {payment_id} - {amount} {currency} for {customer.email}\")\n    \n    def process_refund(self, payment_id: str, amount: float) -> bool:\n        print(f\"Processing Square refund for payment: {payment_id}\")\n        return True\n\nclass PaymentProcessor:\n    def __init__(self):\n        self.paypal_gateway = PayPalGateway()\n        self.stripe_gateway = StripeGateway()\n        self.square_gateway = SquareGateway()\n        self.transaction_history = []\n    \n    def process_transaction(self, amount: float, currency: str, gateway: str, customer: 'CustomerInfo') -> 'PaymentResult':\n        result = None\n        \n        if gateway.lower() == \"paypal\":\n            result = self.paypal_gateway.process_payment(amount, currency, customer)\n        elif gateway.lower() == \"stripe\":\n            result = self.stripe_gateway.charge_card(amount, currency, customer)\n        elif gateway.lower() == \"square\":\n            result = self.square_gateway.create_payment(amount, currency, customer)\n        else:\n            result = PaymentResult(False, None, \"Unsupported payment gateway\")\n        \n        if result:\n            self.transaction_history.append(result)\n            self._generate_transaction_report(result, gateway, customer)\n        \n        return result\n    \n    def process_refund(self, transaction_id: str, amount: float, gateway: str) -> bool:\n        if gateway.lower() == \"paypal\":\n            return self.paypal_gateway.process_refund(transaction_id, amount)\n        elif gateway.lower() == \"stripe\":\n            return self.stripe_gateway.process_refund(transaction_id, amount)\n        elif gateway.lower() == \"square\":\n            return self.square_gateway.process_refund(transaction_id, amount)\n        else:\n            return False\n    \n    def _generate_transaction_report(self, result: 'PaymentResult', gateway: str, customer: 'CustomerInfo'):\n        timestamp = datetime.now().isoformat()\n        status = \"SUCCESS\" if result.success else \"FAILED\"\n        print(f\"Transaction Report [{timestamp}]: Gateway={gateway}, Customer={customer.name}, Status={status}\")\n    \n    def get_transaction_history(self) -> List['PaymentResult']:\n        return self.transaction_history.copy()\n\nclass CustomerInfo:\n    def __init__(self, name: str, email: str):\n        self.name = name\n        self.email = email\n\nclass PaymentResult:\n    def __init__(self, success: bool, transaction_id: Optional[str], message: str):\n        self.success = success\n        self.transaction_id = transaction_id\n        self.message = message",
    "output": "",
    "level": "HARD",
    "language": "PYTHON",
    "violation": "DIP"
  },
    {
    "input": "import kotlin.random.Random\nimport java.time.LocalDateTime\nimport java.time.format.DateTimeFormatter\n\nclass PayPalGateway {\n    private val config = mapOf(\n        \"api_key\" to \"paypal_api_key\",\n        \"environment\" to \"sandbox\"\n    )\n    \n    fun processPayment(amount: Double, currency: String, customer: CustomerInfo): PaymentResult {\n        println(\"Initializing PayPal payment for ${customer.name}\")\n        \n        return if (validatePayPalPayment(amount, currency)) {\n            val transactionId = generatePayPalTransactionId()\n            logPayPalTransaction(transactionId, amount, currency, customer)\n            PaymentResult(true, transactionId, \"Payment processed successfully via PayPal\")\n        } else {\n            PaymentResult(false, null, \"PayPal payment validation failed\")\n        }\n    }\n    \n    private fun validatePayPalPayment(amount: Double, currency: String): Boolean {\n        return amount > 0 && currency.isNotBlank()\n    }\n    \n    private fun generatePayPalTransactionId(): String {\n        return \"PP_${System.currentTimeMillis()}_${Random.nextInt(1000, 9999)}\"\n    }\n    \n    private fun logPayPalTransaction(transactionId: String, amount: Double, currency: String, customer: CustomerInfo) {\n        println(\"PayPal Transaction Log: $transactionId - $amount $currency for ${customer.email}\")\n    }\n    \n    fun processRefund(transactionId: String, amount: Double): Boolean {\n        println(\"Processing PayPal refund for transaction: $transactionId\")\n        return true\n    }\n}\n\nclass StripeGateway {\n    private val config = mapOf(\n        \"secret_key\" to \"stripe_secret_key\",\n        \"publishable_key\" to \"stripe_publishable_key\"\n    )\n    \n    fun chargeCard(amount: Double, currency: String, customer: CustomerInfo): PaymentResult {\n        println(\"Creating Stripe charge for ${customer.name}\")\n        \n        return if (validateStripePayment(amount, currency)) {\n            val chargeId = generateStripeChargeId()\n            logStripeTransaction(chargeId, amount, currency, customer)\n            PaymentResult(true, chargeId, \"Card charged successfully via Stripe\")\n        } else {\n            PaymentResult(false, null, \"Stripe payment validation failed\")\n        }\n    }\n    \n    private fun validateStripePayment(amount: Double, currency: String): Boolean {\n        return amount > 0 && currency.uppercase() in listOf(\"USD\", \"EUR\", \"GBP\")\n    }\n    \n    private fun generateStripeChargeId(): String {\n        return \"ST_${System.currentTimeMillis()}_${Random.nextInt(1000, 9999)}\"\n    }\n    \n    private fun logStripeTransaction(chargeId: String, amount: Double, currency: String, customer: CustomerInfo) {\n        println(\"Stripe Transaction Log: $chargeId - $amount $currency for ${customer.email}\")\n    }\n    \n    fun processRefund(chargeId: String, amount: Double): Boolean {\n        println(\"Processing Stripe refund for charge: $chargeId\")\n        return true\n    }\n}\n\nclass SquareGateway {\n    private val config = mapOf(\n        \"application_id\" to \"square_app_id\",\n        \"access_token\" to \"square_access_token\"\n    )\n    \n    fun createPayment(amount: Double, currency: String, customer: CustomerInfo): PaymentResult {\n        println(\"Creating Square payment for ${customer.name}\")\n        \n        return if (validateSquarePayment(amount, currency)) {\n            val paymentId = generateSquarePaymentId()\n            logSquareTransaction(paymentId, amount, currency, customer)\n            PaymentResult(true, paymentId, \"Payment created successfully via Square\")\n        } else {\n            PaymentResult(false, null, \"Square payment validation failed\")\n        }\n    }\n    \n    private fun validateSquarePayment(amount: Double, currency: String): Boolean {\n        return amount > 0 && currency == \"USD\"\n    }\n    \n    private fun generateSquarePaymentId(): String {\n        return \"SQ_${System.currentTimeMillis()}_${Random.nextInt(1000, 9999)}\"\n    }\n    \n    private fun logSquareTransaction(paymentId: String, amount: Double, currency: String, customer: CustomerInfo) {\n        println(\"Square Transaction Log: $paymentId - $amount $currency for ${customer.email}\")\n    }\n    \n    fun processRefund(paymentId: String, amount: Double): Boolean {\n        println(\"Processing Square refund for payment: $paymentId\")\n        return true\n    }\n}\n\nclass PaymentProcessor {\n    private val paypalGateway = PayPalGateway()\n    private val stripeGateway = StripeGateway()\n    private val squareGateway = SquareGateway()\n    private val transactionHistory = mutableListOf<PaymentResult>()\n    \n    fun processTransaction(amount: Double, currency: String, gateway: String, customer: CustomerInfo): PaymentResult {\n        val result = when (gateway.lowercase()) {\n            \"paypal\" -> paypalGateway.processPayment(amount, currency, customer)\n            \"stripe\" -> stripeGateway.chargeCard(amount, currency, customer)\n            \"square\" -> squareGateway.createPayment(amount, currency, customer)\n            else -> PaymentResult(false, null, \"Unsupported payment gateway\")\n        }\n        \n        transactionHistory.add(result)\n        generateTransactionReport(result, gateway, customer)\n        \n        return result\n    }\n    \n    fun processRefund(transactionId: String, amount: Double, gateway: String): Boolean {\n        return when (gateway.lowercase()) {\n            \"paypal\" -> paypalGateway.processRefund(transactionId, amount)\n            \"stripe\" -> stripeGateway.processRefund(transactionId, amount)\n            \"square\" -> squareGateway.processRefund(transactionId, amount)\n            else -> false\n        }\n    }\n    \n    private fun generateTransactionReport(result: PaymentResult, gateway: String, customer: CustomerInfo) {\n        val timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n        val status = if (result.success) \"SUCCESS\" else \"FAILED\"\n        println(\"Transaction Report [$timestamp]: Gateway=$gateway, Customer=${customer.name}, Status=$status\")\n    }\n    \n    fun getTransactionHistory(): List<PaymentResult> {\n        return transactionHistory.toList()\n    }\n}\n\ndata class CustomerInfo(val name: String, val email: String)\n\ndata class PaymentResult(val success: Boolean, val transactionId: String?, val message: String)",
    "output": "",
    "level": "HARD",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace PaymentProcessing\n{\n    public class PayPalGateway\n    {\n        private readonly Dictionary<string, string> _config;\n        \n        public PayPalGateway()\n        {\n            _config = new Dictionary<string, string>\n            {\n                { \"api_key\", \"paypal_api_key\" },\n                { \"environment\", \"sandbox\" }\n            };\n        }\n        \n        public PaymentResult ProcessPayment(double amount, string currency, CustomerInfo customer)\n        {\n            Console.WriteLine($\"Initializing PayPal payment for {customer.Name}\");\n            \n            if (ValidatePayPalPayment(amount, currency))\n            {\n                var transactionId = GeneratePayPalTransactionId();\n                LogPayPalTransaction(transactionId, amount, currency, customer);\n                return new PaymentResult(true, transactionId, \"Payment processed successfully via PayPal\");\n            }\n            return new PaymentResult(false, null, \"PayPal payment validation failed\");\n        }\n        \n        private bool ValidatePayPalPayment(double amount, string currency)\n        {\n            return amount > 0 && !string.IsNullOrWhiteSpace(currency);\n        }\n        \n        private string GeneratePayPalTransactionId()\n        {\n            var random = new Random();\n            return $\"PP_{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}_{random.Next(1000, 9999)}\";\n        }\n        \n        private void LogPayPalTransaction(string transactionId, double amount, string currency, CustomerInfo customer)\n        {\n            Console.WriteLine($\"PayPal Transaction Log: {transactionId} - {amount} {currency} for {customer.Email}\");\n        }\n        \n        public bool ProcessRefund(string transactionId, double amount)\n        {\n            Console.WriteLine($\"Processing PayPal refund for transaction: {transactionId}\");\n            return true;\n        }\n    }\n    \n    public class StripeGateway\n    {\n        private readonly Dictionary<string, string> _config;\n        \n        public StripeGateway()\n        {\n            _config = new Dictionary<string, string>\n            {\n                { \"secret_key\", \"stripe_secret_key\" },\n                { \"publishable_key\", \"stripe_publishable_key\" }\n            };\n        }\n        \n        public PaymentResult ChargeCard(double amount, string currency, CustomerInfo customer)\n        {\n            Console.WriteLine($\"Creating Stripe charge for {customer.Name}\");\n            \n            if (ValidateStripePayment(amount, currency))\n            {\n                var chargeId = GenerateStripeChargeId();\n                LogStripeTransaction(chargeId, amount, currency, customer);\n                return new PaymentResult(true, chargeId, \"Card charged successfully via Stripe\");\n            }\n            return new PaymentResult(false, null, \"Stripe payment validation failed\");\n        }\n        \n        private bool ValidateStripePayment(double amount, string currency)\n        {\n            var supportedCurrencies = new[] { \"USD\", \"EUR\", \"GBP\" };\n            return amount > 0 && supportedCurrencies.Contains(currency?.ToUpper());\n        }\n        \n        private string GenerateStripeChargeId()\n        {\n            var random = new Random();\n            return $\"ST_{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}_{random.Next(1000, 9999)}\";\n        }\n        \n        private void LogStripeTransaction(string chargeId, double amount, string currency, CustomerInfo customer)\n        {\n            Console.WriteLine($\"Stripe Transaction Log: {chargeId} - {amount} {currency} for {customer.Email}\");\n        }\n        \n        public bool ProcessRefund(string chargeId, double amount)\n        {\n            Console.WriteLine($\"Processing Stripe refund for charge: {chargeId}\");\n            return true;\n        }\n    }\n    \n    public class SquareGateway\n    {\n        private readonly Dictionary<string, string> _config;\n        \n        public SquareGateway()\n        {\n            _config = new Dictionary<string, string>\n            {\n                { \"application_id\", \"square_app_id\" },\n                { \"access_token\", \"square_access_token\" }\n            };\n        }\n        \n        public PaymentResult CreatePayment(double amount, string currency, CustomerInfo customer)\n        {\n            Console.WriteLine($\"Creating Square payment for {customer.Name}\");\n            \n            if (ValidateSquarePayment(amount, currency))\n            {\n                var paymentId = GenerateSquarePaymentId();\n                LogSquareTransaction(paymentId, amount, currency, customer);\n                return new PaymentResult(true, paymentId, \"Payment created successfully via Square\");\n            }\n            return new PaymentResult(false, null, \"Square payment validation failed\");\n        }\n        \n        private bool ValidateSquarePayment(double amount, string currency)\n        {\n            return amount > 0 && currency == \"USD\";\n        }\n        \n        private string GenerateSquarePaymentId()\n        {\n            var random = new Random();\n            return $\"SQ_{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}_{random.Next(1000, 9999)}\";\n        }\n        \n        private void LogSquareTransaction(string paymentId, double amount, string currency, CustomerInfo customer)\n        {\n            Console.WriteLine($\"Square Transaction Log: {paymentId} - {amount} {currency} for {customer.Email}\");\n        }\n        \n        public bool ProcessRefund(string paymentId, double amount)\n        {\n            Console.WriteLine($\"Processing Square refund for payment: {paymentId}\");\n            return true;\n        }\n    }\n    \n    public class PaymentProcessor\n    {\n        private readonly PayPalGateway _paypalGateway;\n        private readonly StripeGateway _stripeGateway;\n        private readonly SquareGateway _squareGateway;\n        private readonly List<PaymentResult> _transactionHistory;\n        \n        public PaymentProcessor()\n        {\n            _paypalGateway = new PayPalGateway();\n            _stripeGateway = new StripeGateway();\n            _squareGateway = new SquareGateway();\n            _transactionHistory = new List<PaymentResult>();\n        }\n        \n        public PaymentResult ProcessTransaction(double amount, string currency, string gateway, CustomerInfo customer)\n        {\n            PaymentResult result = gateway.ToLower() switch\n            {\n                \"paypal\" => _paypalGateway.ProcessPayment(amount, currency, customer),\n                \"stripe\" => _stripeGateway.ChargeCard(amount, currency, customer),\n                \"square\" => _squareGateway.CreatePayment(amount, currency, customer),\n                _ => new PaymentResult(false, null, \"Unsupported payment gateway\")\n            };\n            \n            _transactionHistory.Add(result);\n            GenerateTransactionReport(result, gateway, customer);\n            \n            return result;\n        }\n        \n        public bool ProcessRefund(string transactionId, double amount, string gateway)\n        {\n            return gateway.ToLower() switch\n            {\n                \"paypal\" => _paypalGateway.ProcessRefund(transactionId, amount),\n                \"stripe\" => _stripeGateway.ProcessRefund(transactionId, amount),\n                \"square\" => _squareGateway.ProcessRefund(transactionId, amount),\n                _ => false\n            };\n        }\n        \n        private void GenerateTransactionReport(PaymentResult result, string gateway, CustomerInfo customer)\n        {\n            var timestamp = DateTime.Now.ToString(\"yyyy-MM-ddTHH:mm:ss\");\n            var status = result.Success ? \"SUCCESS\" : \"FAILED\";\n            Console.WriteLine($\"Transaction Report [{timestamp}]: Gateway={gateway}, Customer={customer.Name}, Status={status}\");\n        }\n        \n        public List<PaymentResult> GetTransactionHistory()\n        {\n            return new List<PaymentResult>(_transactionHistory);\n        }\n    }\n    \n    public class CustomerInfo\n    {\n        public string Name { get; set; }\n        public string Email { get; set; }\n        \n        public CustomerInfo(string name, string email)\n        {\n            Name = name;\n            Email = email;\n        }\n    }\n    \n    public class PaymentResult\n    {\n        public bool Success { get; set; }\n        public string TransactionId { get; set; }\n        public string Message { get; set; }\n        \n        public PaymentResult(bool success, string transactionId, string message)\n        {\n            Success = success;\n            TransactionId = transactionId;\n            Message = message;\n        }\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "C#",
    "violation": "DIP"
  },
    {
    "input": "import java.io.*;\nimport java.nio.file.*;\n\npublic class FileProcessor {\n    public String processFile(String fileName) {\n        try {\n            String content = Files.readString(Paths.get(fileName));\n            return content.toUpperCase();\n        } catch (IOException e) {\n            return \"Error reading file\";\n        }\n    }\n    \n    public boolean saveResult(String fileName, String content) {\n        try {\n            Files.writeString(Paths.get(fileName), content);\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import os\n\nclass FileProcessor:\n    def process_file(self, file_name):\n        try:\n            with open(file_name, 'r') as file:\n                content = file.read()\n                return content.upper()\n        except IOError:\n            return \"Error reading file\"\n    \n    def save_result(self, file_name, content):\n        try:\n            with open(file_name, 'w') as file:\n                file.write(content)\n                return True\n        except IOError:\n            return False",
    "output": "",
    "level": "EASY",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "import java.io.File\nimport java.io.IOException\n\nclass FileProcessor {\n    fun processFile(fileName: String): String {\n        return try {\n            val content = File(fileName).readText()\n            content.uppercase()\n        } catch (e: IOException) {\n            \"Error reading file\"\n        }\n    }\n    \n    fun saveResult(fileName: String, content: String): Boolean {\n        return try {\n            File(fileName).writeText(content)\n            true\n        } catch (e: IOException) {\n            false\n        }\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\nusing System.IO;\n\npublic class FileProcessor\n{\n    public string ProcessFile(string fileName)\n    {\n        try\n        {\n            string content = File.ReadAllText(fileName);\n            return content.ToUpper();\n        }\n        catch (IOException)\n        {\n            return \"Error reading file\";\n        }\n    }\n    \n    public bool SaveResult(string fileName, string content)\n    {\n        try\n        {\n            File.WriteAllText(fileName, content);\n            return true;\n        }\n        catch (IOException)\n        {\n            return false;\n        }\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "import java.io.*;\nimport java.nio.file.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class FileProcessor {\n    private String outputDirectory;\n    \n    public FileProcessor(String outputDirectory) {\n        this.outputDirectory = outputDirectory;\n    }\n    \n    public List<String> processMultipleFiles(List<String> fileNames) {\n        List<String> results = new ArrayList<>();\n        \n        for (String fileName : fileNames) {\n            try {\n                String content = Files.readString(Paths.get(fileName));\n                String processed = content.toUpperCase().trim();\n                \n                String outputFileName = outputDirectory + \"/processed_\" + \n                    Paths.get(fileName).getFileName().toString();\n                Files.writeString(Paths.get(outputFileName), processed);\n                \n                results.add(\"Processed: \" + fileName);\n            } catch (IOException e) {\n                results.add(\"Failed: \" + fileName + \" - \" + e.getMessage());\n            }\n        }\n        \n        return results;\n    }\n    \n    public boolean createBackup(String fileName) {\n        try {\n            String backupName = fileName + \".backup\";\n            Files.copy(Paths.get(fileName), Paths.get(backupName), \n                StandardCopyOption.REPLACE_EXISTING);\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n    \n    public List<String> getFileList(String directory) {\n        try {\n            return Files.list(Paths.get(directory))\n                .filter(Files::isRegularFile)\n                .map(path -> path.toString())\n                .collect(Collectors.toList());\n        } catch (IOException e) {\n            return new ArrayList<>();\n        }\n    }\n    \n    public long getFileSize(String fileName) {\n        try {\n            return Files.size(Paths.get(fileName));\n        } catch (IOException e) {\n            return -1;\n        }\n    }\n    \n    public boolean deleteFile(String fileName) {\n        try {\n            Files.delete(Paths.get(fileName));\n            return true;\n        } catch (IOException e) {\n            return false;\n        }\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import os\nimport shutil\nfrom typing import List\n\nclass FileProcessor:\n    def __init__(self, output_directory: str):\n        self.output_directory = output_directory\n    \n    def process_multiple_files(self, file_names: List[str]) -> List[str]:\n        results = []\n        \n        for file_name in file_names:\n            try:\n                with open(file_name, 'r') as file:\n                    content = file.read()\n                    processed = content.upper().strip()\n                    \n                    output_file_name = os.path.join(\n                        self.output_directory, \n                        f\"processed_{os.path.basename(file_name)}\"\n                    )\n                    \n                    with open(output_file_name, 'w') as output_file:\n                        output_file.write(processed)\n                    \n                    results.append(f\"Processed: {file_name}\")\n            except IOError as e:\n                results.append(f\"Failed: {file_name} - {str(e)}\")\n        \n        return results\n    \n    def create_backup(self, file_name: str) -> bool:\n        try:\n            backup_name = f\"{file_name}.backup\"\n            shutil.copy2(file_name, backup_name)\n            return True\n        except IOError:\n            return False\n    \n    def get_file_list(self, directory: str) -> List[str]:\n        try:\n            return [os.path.join(directory, f) for f in os.listdir(directory) \n                   if os.path.isfile(os.path.join(directory, f))]\n        except OSError:\n            return []\n    \n    def get_file_size(self, file_name: str) -> int:\n        try:\n            return os.path.getsize(file_name)\n        except OSError:\n            return -1\n    \n    def delete_file(self, file_name: str) -> bool:\n        try:\n            os.remove(file_name)\n            return True\n        except OSError:\n            return False",
    "output": "",
    "level": "MODERATE",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "import java.io.File\nimport java.io.IOException\nimport java.nio.file.Files\nimport java.nio.file.Paths\nimport java.nio.file.StandardCopyOption\n\nclass FileProcessor(private val outputDirectory: String) {\n    \n    fun processMultipleFiles(fileNames: List<String>): List<String> {\n        val results = mutableListOf<String>()\n        \n        for (fileName in fileNames) {\n            try {\n                val content = File(fileName).readText()\n                val processed = content.uppercase().trim()\n                \n                val outputFileName = \"$outputDirectory/processed_${File(fileName).name}\"\n                File(outputFileName).writeText(processed)\n                \n                results.add(\"Processed: $fileName\")\n            } catch (e: IOException) {\n                results.add(\"Failed: $fileName - ${e.message}\")\n            }\n        }\n        \n        return results\n    }\n    \n    fun createBackup(fileName: String): Boolean {\n        return try {\n            val backupName = \"$fileName.backup\"\n            Files.copy(Paths.get(fileName), Paths.get(backupName), \n                StandardCopyOption.REPLACE_EXISTING)\n            true\n        } catch (e: IOException) {\n            false\n        }\n    }\n    \n    fun getFileList(directory: String): List<String> {\n        return try {\n            File(directory).listFiles()?.filter { it.isFile }?.map { it.absolutePath } ?: emptyList()\n        } catch (e: Exception) {\n            emptyList()\n        }\n    }\n    \n    fun getFileSize(fileName: String): Long {\n        return try {\n            File(fileName).length()\n        } catch (e: Exception) {\n            -1L\n        }\n    }\n    \n    fun deleteFile(fileName: String): Boolean {\n        return try {\n            File(fileName).delete()\n        } catch (e: Exception) {\n            false\n        }\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\npublic class FileProcessor\n{\n    private readonly string outputDirectory;\n    \n    public FileProcessor(string outputDirectory)\n    {\n        this.outputDirectory = outputDirectory;\n    }\n    \n    public List<string> ProcessMultipleFiles(List<string> fileNames)\n    {\n        var results = new List<string>();\n        \n        foreach (var fileName in fileNames)\n        {\n            try\n            {\n                string content = File.ReadAllText(fileName);\n                string processed = content.ToUpper().Trim();\n                \n                string outputFileName = Path.Combine(outputDirectory, \n                    $\"processed_{Path.GetFileName(fileName)}\");\n                File.WriteAllText(outputFileName, processed);\n                \n                results.Add($\"Processed: {fileName}\");\n            }\n            catch (IOException e)\n            {\n                results.Add($\"Failed: {fileName} - {e.Message}\");\n            }\n        }\n        \n        return results;\n    }\n    \n    public bool CreateBackup(string fileName)\n    {\n        try\n        {\n            string backupName = $\"{fileName}.backup\";\n            File.Copy(fileName, backupName, true);\n            return true;\n        }\n        catch (IOException)\n        {\n            return false;\n        }\n    }\n    \n    public List<string> GetFileList(string directory)\n    {\n        try\n        {\n            return Directory.GetFiles(directory).ToList();\n        }\n        catch (IOException)\n        {\n            return new List<string>();\n        }\n    }\n    \n    public long GetFileSize(string fileName)\n    {\n        try\n        {\n            return new FileInfo(fileName).Length;\n        }\n        catch (IOException)\n        {\n            return -1;\n        }\n    }\n    \n    public bool DeleteFile(string fileName)\n    {\n        try\n        {\n            File.Delete(fileName);\n            return true;\n        }\n        catch (IOException)\n        {\n            return false;\n        }\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "import java.io.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.Collectors;\nimport java.util.zip.*;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class FileProcessor {\n    private final String outputDirectory;\n    private final String tempDirectory;\n    private final ExecutorService executorService;\n    private final Map<String, String> processingHistory;\n    \n    public FileProcessor(String outputDirectory, String tempDirectory) {\n        this.outputDirectory = outputDirectory;\n        this.tempDirectory = tempDirectory;\n        this.executorService = Executors.newFixedThreadPool(4);\n        this.processingHistory = new ConcurrentHashMap<>();\n    }\n    \n    public CompletableFuture<List<ProcessingResult>> processFilesAsync(List<String> fileNames, ProcessingOptions options) {\n        List<CompletableFuture<ProcessingResult>> futures = fileNames.stream()\n            .map(fileName -> CompletableFuture.supplyAsync(() -> processIndividualFile(fileName, options), executorService))\n            .collect(Collectors.toList());\n        \n        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n            .thenApply(v -> futures.stream().map(CompletableFuture::join).collect(Collectors.toList()));\n    }\n    \n    private ProcessingResult processIndividualFile(String fileName, ProcessingOptions options) {\n        try {\n            String content = Files.readString(Paths.get(fileName));\n            String checksum = calculateChecksum(content);\n            \n            if (processingHistory.containsKey(checksum)) {\n                return new ProcessingResult(fileName, \"Skipped - Already processed\", false);\n            }\n            \n            String processed = applyTransformations(content, options);\n            \n            if (options.compress) {\n                processed = compressContent(processed);\n            }\n            \n            String outputFileName = generateOutputFileName(fileName, options);\n            Files.writeString(Paths.get(outputFileName), processed);\n            \n            if (options.createBackup) {\n                createVersionedBackup(fileName);\n            }\n            \n            if (options.validateOutput) {\n                validateOutputFile(outputFileName);\n            }\n            \n            processingHistory.put(checksum, outputFileName);\n            updateProcessingLog(fileName, outputFileName);\n            \n            return new ProcessingResult(fileName, \"Successfully processed\", true);\n        } catch (IOException | NoSuchAlgorithmException e) {\n            return new ProcessingResult(fileName, \"Error: \" + e.getMessage(), false);\n        }\n    }\n    \n    private String applyTransformations(String content, ProcessingOptions options) {\n        String result = content;\n        \n        if (options.toUpperCase) {\n            result = result.toUpperCase();\n        }\n        \n        if (options.removeEmptyLines) {\n            result = Arrays.stream(result.split(\"\\n\"))\n                .filter(line -> !line.trim().isEmpty())\n                .collect(Collectors.joining(\"\\n\"));\n        }\n        \n        if (options.addTimestamp) {\n            result = \"Processed at: \" + new Date() + \"\\n\" + result;\n        }\n        \n        return result;\n    }\n    \n    private String compressContent(String content) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (GZIPOutputStream gzipOut = new GZIPOutputStream(baos)) {\n            gzipOut.write(content.getBytes());\n        }\n        return Base64.getEncoder().encodeToString(baos.toByteArray());\n    }\n    \n    private String calculateChecksum(String content) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] hash = md.digest(content.getBytes());\n        return Base64.getEncoder().encodeToString(hash);\n    }\n    \n    private void createVersionedBackup(String fileName) throws IOException {\n        String backupDir = tempDirectory + \"/backups\";\n        Files.createDirectories(Paths.get(backupDir));\n        \n        String timestamp = String.valueOf(System.currentTimeMillis());\n        String backupFileName = backupDir + \"/\" + Paths.get(fileName).getFileName() + \".\" + timestamp + \".backup\";\n        \n        Files.copy(Paths.get(fileName), Paths.get(backupFileName));\n    }\n    \n    private void validateOutputFile(String outputFileName) throws IOException {\n        if (!Files.exists(Paths.get(outputFileName))) {\n            throw new IOException(\"Output file was not created successfully\");\n        }\n        \n        if (Files.size(Paths.get(outputFileName)) == 0) {\n            throw new IOException(\"Output file is empty\");\n        }\n    }\n    \n    private String generateOutputFileName(String inputFileName, ProcessingOptions options) {\n        String baseName = Paths.get(inputFileName).getFileName().toString();\n        String extension = options.compress ? \".gz\" : \".txt\";\n        return outputDirectory + \"/processed_\" + System.currentTimeMillis() + \"_\" + baseName + extension;\n    }\n    \n    private void updateProcessingLog(String inputFile, String outputFile) throws IOException {\n        String logEntry = String.format(\"%s: %s -> %s%n\", new Date(), inputFile, outputFile);\n        Files.writeString(Paths.get(tempDirectory + \"/processing.log\"), logEntry, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n    }\n    \n    public void cleanup() {\n        executorService.shutdown();\n        try {\n            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {\n                executorService.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executorService.shutdownNow();\n        }\n    }\n    \n    public static class ProcessingOptions {\n        public boolean toUpperCase = true;\n        public boolean removeEmptyLines = false;\n        public boolean addTimestamp = false;\n        public boolean compress = false;\n        public boolean createBackup = true;\n        public boolean validateOutput = true;\n    }\n    \n    public static class ProcessingResult {\n        public final String fileName;\n        public final String message;\n        public final boolean success;\n        \n        public ProcessingResult(String fileName, String message, boolean success) {\n            this.fileName = fileName;\n            this.message = message;\n            this.success = success;\n        }\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import os\nimport shutil\nimport gzip\nimport base64\nimport hashlib\nimport asyncio\nimport aiofiles\nfrom datetime import datetime\nfrom typing import List, Dict, Optional, NamedTuple\nfrom concurrent.futures import ThreadPoolExecutor\nfrom dataclasses import dataclass\nimport json\n\n@dataclass\nclass ProcessingOptions:\n    to_upper_case: bool = True\n    remove_empty_lines: bool = False\n    add_timestamp: bool = False\n    compress: bool = False\n    create_backup: bool = True\n    validate_output: bool = True\n\nclass ProcessingResult(NamedTuple):\n    file_name: str\n    message: str\n    success: bool\n\nclass FileProcessor:\n    def __init__(self, output_directory: str, temp_directory: str):\n        self.output_directory = output_directory\n        self.temp_directory = temp_directory\n        self.executor = ThreadPoolExecutor(max_workers=4)\n        self.processing_history: Dict[str, str] = {}\n        self._ensure_directories_exist()\n    \n    def _ensure_directories_exist(self):\n        os.makedirs(self.output_directory, exist_ok=True)\n        os.makedirs(self.temp_directory, exist_ok=True)\n        os.makedirs(f\"{self.temp_directory}/backups\", exist_ok=True)\n    \n    async def process_files_async(self, file_names: List[str], options: ProcessingOptions) -> List[ProcessingResult]:\n        tasks = [self._process_individual_file(file_name, options) for file_name in file_names]\n        return await asyncio.gather(*tasks)\n    \n    async def _process_individual_file(self, file_name: str, options: ProcessingOptions) -> ProcessingResult:\n        try:\n            async with aiofiles.open(file_name, 'r') as file:\n                content = await file.read()\n            \n            checksum = self._calculate_checksum(content)\n            \n            if checksum in self.processing_history:\n                return ProcessingResult(file_name, \"Skipped - Already processed\", False)\n            \n            processed = self._apply_transformations(content, options)\n            \n            if options.compress:\n                processed = self._compress_content(processed)\n            \n            output_file_name = self._generate_output_filename(file_name, options)\n            \n            async with aiofiles.open(output_file_name, 'w') as output_file:\n                await output_file.write(processed)\n            \n            if options.create_backup:\n                await self._create_versioned_backup(file_name)\n            \n            if options.validate_output:\n                self._validate_output_file(output_file_name)\n            \n            self.processing_history[checksum] = output_file_name\n            await self._update_processing_log(file_name, output_file_name)\n            \n            return ProcessingResult(file_name, \"Successfully processed\", True)\n        \n        except Exception as e:\n            return ProcessingResult(file_name, f\"Error: {str(e)}\", False)\n    \n    def _apply_transformations(self, content: str, options: ProcessingOptions) -> str:\n        result = content\n        \n        if options.to_upper_case:\n            result = result.upper()\n        \n        if options.remove_empty_lines:\n            result = '\\n'.join(line for line in result.split('\\n') if line.strip())\n        \n        if options.add_timestamp:\n            result = f\"Processed at: {datetime.now()}\\n{result}\"\n        \n        return result\n    \n    def _compress_content(self, content: str) -> str:\n        compressed = gzip.compress(content.encode('utf-8'))\n        return base64.b64encode(compressed).decode('utf-8')\n    \n    def _calculate_checksum(self, content: str) -> str:\n        return hashlib.sha256(content.encode('utf-8')).hexdigest()\n    \n    async def _create_versioned_backup(self, file_name: str):\n        timestamp = str(int(datetime.now().timestamp() * 1000))\n        backup_filename = f\"{self.temp_directory}/backups/{os.path.basename(file_name)}.{timestamp}.backup\"\n        \n        await asyncio.get_event_loop().run_in_executor(\n            self.executor, shutil.copy2, file_name, backup_filename\n        )\n    \n    def _validate_output_file(self, output_file_name: str):\n        if not os.path.exists(output_file_name):\n            raise IOError(\"Output file was not created successfully\")\n        \n        if os.path.getsize(output_file_name) == 0:\n            raise IOError(\"Output file is empty\")\n    \n    def _generate_output_filename(self, input_file_name: str, options: ProcessingOptions) -> str:\n        base_name = os.path.basename(input_file_name)\n        extension = \".gz\" if options.compress else \".txt\"\n        timestamp = int(datetime.now().timestamp() * 1000)\n        return f\"{self.output_directory}/processed_{timestamp}_{base_name}{extension}\"\n    \n    async def _update_processing_log(self, input_file: str, output_file: str):\n        log_entry = f\"{datetime.now()}: {input_file} -> {output_file}\\n\"\n        log_file = f\"{self.temp_directory}/processing.log\"\n        \n        async with aiofiles.open(log_file, 'a') as log:\n            await log.write(log_entry)\n    \n    def cleanup(self):\n        self.executor.shutdown(wait=True)\n    \n    def get_processing_statistics(self) -> Dict[str, any]:\n        try:\n            total_files = len(os.listdir(self.output_directory))\n            total_size = sum(os.path.getsize(os.path.join(self.output_directory, f)) \n                           for f in os.listdir(self.output_directory) \n                           if os.path.isfile(os.path.join(self.output_directory, f)))\n            \n            return {\n                \"total_processed_files\": total_files,\n                \"total_output_size\": total_size,\n                \"processing_history_count\": len(self.processing_history)\n            }\n        except OSError:\n            return {\"error\": \"Unable to calculate statistics\"}\n    \n    def export_processing_history(self, export_file: str) -> bool:\n        try:\n            with open(export_file, 'w') as f:\n                json.dump(self.processing_history, f, indent=2)\n            return True\n        except IOError:\n            return False",
    "output": "",
    "level": "HARD",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel\nimport java.io.File\nimport java.nio.file.Files\nimport java.nio.file.Paths\nimport java.nio.file.StandardCopyOption\nimport java.security.MessageDigest\nimport java.util.*\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.zip.GZIPOutputStream\nimport java.io.ByteArrayOutputStream\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.json.Json\nimport kotlinx.serialization.encodeToString\n\n@Serializable\ndata class ProcessingOptions(\n    val toUpperCase: Boolean = true,\n    val removeEmptyLines: Boolean = false,\n    val addTimestamp: Boolean = false,\n    val compress: Boolean = false,\n    val createBackup: Boolean = true,\n    val validateOutput: Boolean = true\n)\n\ndata class ProcessingResult(\n    val fileName: String,\n    val message: String,\n    val success: Boolean\n)\n\nclass FileProcessor(private val outputDirectory: String, private val tempDirectory: String) {\n    private val processingHistory = ConcurrentHashMap<String, String>()\n    private val processingScope = CoroutineScope(Dispatchers.IO + SupervisorJob())\n    \n    init {\n        ensureDirectoriesExist()\n    }\n    \n    private fun ensureDirectoriesExist() {\n        File(outputDirectory).mkdirs()\n        File(tempDirectory).mkdirs()\n        File(\"$tempDirectory/backups\").mkdirs()\n    }\n    \n    suspend fun processFilesAsync(fileNames: List<String>, options: ProcessingOptions): List<ProcessingResult> {\n        return withContext(Dispatchers.IO) {\n            fileNames.map { fileName ->\n                async { processIndividualFile(fileName, options) }\n            }.awaitAll()\n        }\n    }\n    \n    private suspend fun processIndividualFile(fileName: String, options: ProcessingOptions): ProcessingResult {\n        return try {\n            val content = withContext(Dispatchers.IO) { File(fileName).readText() }\n            val checksum = calculateChecksum(content)\n            \n            if (processingHistory.containsKey(checksum)) {\n                return ProcessingResult(fileName, \"Skipped - Already processed\", false)\n            }\n            \n            var processed = applyTransformations(content, options)\n            \n            if (options.compress) {\n                processed = compressContent(processed)\n            }\n            \n            val outputFileName = generateOutputFileName(fileName, options)\n            \n            withContext(Dispatchers.IO) {\n                File(outputFileName).writeText(processed)\n            }\n            \n            if (options.createBackup) {\n                createVersionedBackup(fileName)\n            }\n            \n            if (options.validateOutput) {\n                validateOutputFile(outputFileName)\n            }\n            \n            processingHistory[checksum] = outputFileName\n            updateProcessingLog(fileName, outputFileName)\n            \n            ProcessingResult(fileName, \"Successfully processed\", true)\n        } catch (e: Exception) {\n            ProcessingResult(fileName, \"Error: ${e.message}\", false)\n        }\n    }\n    \n    private fun applyTransformations(content: String, options: ProcessingOptions): String {\n        var result = content\n        \n        if (options.toUpperCase) {\n            result = result.uppercase()\n        }\n        \n        if (options.removeEmptyLines) {\n            result = result.lines().filter { it.trim().isNotEmpty() }.joinToString(\"\\n\")\n        }\n        \n        if (options.addTimestamp) {\n            result = \"Processed at: ${Date()}\\n$result\"\n        }\n        \n        return result\n    }\n    \n    private fun compressContent(content: String): String {\n        val outputStream = ByteArrayOutputStream()\n        GZIPOutputStream(outputStream).use { gzip ->\n            gzip.write(content.toByteArray())\n        }\n        return Base64.getEncoder().encodeToString(outputStream.toByteArray())\n    }\n    \n    private fun calculateChecksum(content: String): String {\n        val digest = MessageDigest.getInstance(\"SHA-256\")\n        return digest.digest(content.toByteArray()).joinToString(\"\") { \"%02x\".format(it) }\n    }\n    \n    private suspend fun createVersionedBackup(fileName: String) {\n        val timestamp = System.currentTimeMillis()\n        val backupFileName = \"$tempDirectory/backups/${File(fileName).name}.$timestamp.backup\"\n        \n        withContext(Dispatchers.IO) {\n            Files.copy(Paths.get(fileName), Paths.get(backupFileName), StandardCopyOption.REPLACE_EXISTING)\n        }\n    }\n    \n    private fun validateOutputFile(outputFileName: String) {\n        val file = File(outputFileName)\n        if (!file.exists()) {\n            throw java.io.IOException(\"Output file was not created successfully\")\n        }\n        \n        if (file.length() == 0L) {\n            throw java.io.IOException(\"Output file is empty\")\n        }\n    }\n    \n    private fun generateOutputFileName(inputFileName: String, options: ProcessingOptions): String {\n        val baseName = File(inputFileName).name\n        val extension = if (options.compress) \".gz\" else \".txt\"\n        val timestamp = System.currentTimeMillis()\n        return \"$outputDirectory/processed_${timestamp}_$baseName$extension\"\n    }\n    \n    private suspend fun updateProcessingLog(inputFile: String, outputFile: String) {\n        val logEntry = \"${Date()}: $inputFile -> $outputFile\\n\"\n        val logFile = \"$tempDirectory/processing.log\"\n        \n        withContext(Dispatchers.IO) {\n            File(logFile).appendText(logEntry)\n        }\n    }\n    \n    fun cleanup() {\n        processingScope.cancel()\n    }\n    \n    fun getProcessingStatistics(): Map<String, Any> {\n        return try {\n            val outputDir = File(outputDirectory)\n            val files = outputDir.listFiles()?.filter { it.isFile } ?: emptyList()\n            val totalFiles = files.size\n            val totalSize = files.sumOf { it.length() }\n            \n            mapOf(\n                \"total_processed_files\" to totalFiles,\n                \"total_output_size\" to totalSize,\n                \"processing_history_count\" to processingHistory.size\n            )\n        } catch (e: Exception) {\n            mapOf(\"error\" to \"Unable to calculate statistics\")\n        }\n    }\n    \n    fun exportProcessingHistory(exportFile: String): Boolean {\n        return try {\n            val json = Json.encodeToString(processingHistory)\n            File(exportFile).writeText(json)\n            true\n        } catch (e: Exception) {\n            false\n        }\n    }\n    \n    suspend fun batchProcessWithRetry(fileNames: List<String>, options: ProcessingOptions, maxRetries: Int = 3): List<ProcessingResult> {\n        val results = mutableListOf<ProcessingResult>()\n        \n        for (fileName in fileNames) {\n            var attempts = 0\n            var lastResult: ProcessingResult\n            \n            do {\n                attempts++\n                lastResult = processIndividualFile(fileName, options)\n                \n                if (lastResult.success) {\n                    results.add(lastResult)\n                    break\n                }\n                \n                if (attempts < maxRetries) {\n                    delay(1000 * attempts)\n                }\n            } while (attempts < maxRetries)\n            \n            if (!lastResult.success) {\n                results.add(lastResult)\n            }\n        }\n        \n        return results\n    }\n    \n    fun getDetailedProcessingReport(): String {\n        val outputDir = File(outputDirectory)\n        val backupDir = File(\"$tempDirectory/backups\")\n        \n        val outputFiles = outputDir.listFiles()?.filter { it.isFile } ?: emptyList()\n        val backupFiles = backupDir.listFiles()?.filter { it.isFile } ?: emptyList()\n        \n        return buildString {\n            appendLine(\"=== File Processing Report ===\")\n            appendLine(\"Generated: ${Date()}\")\n            appendLine(\"Output Directory: $outputDirectory\")\n            appendLine(\"Temp Directory: $tempDirectory\")\n            appendLine(\"\")\n            appendLine(\"Processing Statistics:\")\n            appendLine(\"- Total processed files: ${outputFiles.size}\")\n            appendLine(\"- Total backup files: ${backupFiles.size}\")\n            appendLine(\"- Processing history entries: ${processingHistory.size}\")\n            appendLine(\"- Total output size: ${outputFiles.sumOf { it.length() }} bytes\")\n            appendLine(\"\")\n            appendLine(\"Recent Files:\")\n            outputFiles.sortedByDescending { it.lastModified() }.take(10).forEach { file ->\n                appendLine(\"- ${file.name} (${file.length()} bytes, ${Date(file.lastModified())})\")\n            }\n        }\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class ProcessingOptions\n{\n    public bool ToUpperCase { get; set; } = true;\n    public bool RemoveEmptyLines { get; set; } = false;\n    public bool AddTimestamp { get; set; } = false;\n    public bool Compress { get; set; } = false;\n    public bool CreateBackup { get; set; } = true;\n    public bool ValidateOutput { get; set; } = true;\n}\n\npublic class ProcessingResult\n{\n    public string FileName { get; set; }\n    public string Message { get; set; }\n    public bool Success { get; set; }\n    \n    public ProcessingResult(string fileName, string message, bool success)\n    {\n        FileName = fileName;\n        Message = message;\n        Success = success;\n    }\n}\n\npublic class FileProcessor\n{\n    private readonly string outputDirectory;\n    private readonly string tempDirectory;\n    private readonly ConcurrentDictionary<string, string> processingHistory;\n    private readonly SemaphoreSlim semaphore;\n    \n    public FileProcessor(string outputDirectory, string tempDirectory)\n    {\n        this.outputDirectory = outputDirectory;\n        this.tempDirectory = tempDirectory;\n        this.processingHistory = new ConcurrentDictionary<string, string>();\n        this.semaphore = new SemaphoreSlim(Environment.ProcessorCount, Environment.ProcessorCount);\n        EnsureDirectoriesExist();\n    }\n    \n    private void EnsureDirectoriesExist()\n    {\n        Directory.CreateDirectory(outputDirectory);\n        Directory.CreateDirectory(tempDirectory);\n        Directory.CreateDirectory(Path.Combine(tempDirectory, \"backups\"));\n    }\n    \n    public async Task<List<ProcessingResult>> ProcessFilesAsync(List<string> fileNames, ProcessingOptions options)\n    {\n        var tasks = fileNames.Select(fileName => ProcessIndividualFileAsync(fileName, options));\n        var results = await Task.WhenAll(tasks);\n        return results.ToList();\n    }\n    \n    private async Task<ProcessingResult> ProcessIndividualFileAsync(string fileName, ProcessingOptions options)\n    {\n        await semaphore.WaitAsync();\n        try\n        {\n            var content = await File.ReadAllTextAsync(fileName);\n            var checksum = CalculateChecksum(content);\n            \n            if (processingHistory.ContainsKey(checksum))\n            {\n                return new ProcessingResult(fileName, \"Skipped - Already processed\", false);\n            }\n            \n            var processed = ApplyTransformations(content, options);\n            \n            if (options.Compress)\n            {\n                processed = CompressContent(processed);\n            }\n            \n            var outputFileName = GenerateOutputFileName(fileName, options);\n            \n            await File.WriteAllTextAsync(outputFileName, processed);\n            \n            if (options.CreateBackup)\n            {\n                await CreateVersionedBackupAsync(fileName);\n            }\n            \n            if (options.ValidateOutput)\n            {\n                ValidateOutputFile(outputFileName);\n            }\n            \n            processingHistory[checksum] = outputFileName;\n            await UpdateProcessingLogAsync(fileName, outputFileName);\n            \n            return new ProcessingResult(fileName, \"Successfully processed\", true);\n        }\n        catch (Exception ex)\n        {\n            return new ProcessingResult(fileName, $\"Error: {ex.Message}\", false);\n        }\n        finally\n        {\n            semaphore.Release();\n        }\n    }\n    \n    private string ApplyTransformations(string content, ProcessingOptions options)\n    {\n        var result = content;\n        \n        if (options.ToUpperCase)\n        {\n            result = result.ToUpper();\n        }\n        \n        if (options.RemoveEmptyLines)\n        {\n            result = string.Join(\"\\n\", result.Split('\\n').Where(line => !string.IsNullOrWhiteSpace(line)));\n        }\n        \n        if (options.AddTimestamp)\n        {\n            result = $\"Processed at: {DateTime.Now}\\n{result}\";\n        }\n        \n        return result;\n    }\n    \n    private string CompressContent(string content)\n    {\n        var bytes = Encoding.UTF8.GetBytes(content);\n        \n        using (var output = new MemoryStream())\n        using (var gzip = new GZipStream(output, CompressionMode.Compress))\n        {\n            gzip.Write(bytes, 0, bytes.Length);\n            gzip.Close();\n            return Convert.ToBase64String(output.ToArray());\n        }\n    }\n    \n    private string CalculateChecksum(string content)\n    {\n        using (var sha256 = SHA256.Create())\n        {\n            var bytes = Encoding.UTF8.GetBytes(content);\n            var hash = sha256.ComputeHash(bytes);\n            return BitConverter.ToString(hash).Replace(\"-\", \"\").ToLower();\n        }\n    }\n    \n    private async Task CreateVersionedBackupAsync(string fileName)\n    {\n        var timestamp = DateTimeOffset.Now.ToUnixTimeMilliseconds();\n        var backupFileName = Path.Combine(tempDirectory, \"backups\", $\"{Path.GetFileName(fileName)}.{timestamp}.backup\");\n        \n        await Task.Run(() => File.Copy(fileName, backupFileName, true));\n    }\n    \n    private void ValidateOutputFile(string outputFileName)\n    {\n        if (!File.Exists(outputFileName))\n        {\n            throw new IOException(\"Output file was not created successfully\");\n        }\n        \n        var fileInfo = new FileInfo(outputFileName);\n        if (fileInfo.Length == 0)\n        {\n            throw new IOException(\"Output file is empty\");\n        }\n    }\n    \n    private string GenerateOutputFileName(string inputFileName, ProcessingOptions options)\n    {\n        var baseName = Path.GetFileName(inputFileName);\n        var extension = options.Compress ? \".gz\" : \".txt\";\n        var timestamp = DateTimeOffset.Now.ToUnixTimeMilliseconds();\n        return Path.Combine(outputDirectory, $\"processed_{timestamp}_{baseName}{extension}\");\n    }\n    \n    private async Task UpdateProcessingLogAsync(string inputFile, string outputFile)\n    {\n        var logEntry = $\"{DateTime.Now}: {inputFile} -> {outputFile}\\n\";\n        var logFile = Path.Combine(tempDirectory, \"processing.log\");\n        \n        await File.AppendAllTextAsync(logFile, logEntry);\n    }\n    \n    public Dictionary<string, object> GetProcessingStatistics()\n    {\n        try\n        {\n            var outputDir = new DirectoryInfo(outputDirectory);\n            var files = outputDir.GetFiles().Where(f => f.Exists).ToList();\n            var totalFiles = files.Count;\n            var totalSize = files.Sum(f => f.Length);\n            \n            return new Dictionary<string, object>\n            {\n                [\"total_processed_files\"] = totalFiles,\n                [\"total_output_size\"] = totalSize,\n                [\"processing_history_count\"] = processingHistory.Count\n            };\n        }\n        catch (Exception)\n        {\n            return new Dictionary<string, object> { [\"error\"] = \"Unable to calculate statistics\" };\n        }\n    }\n    \n    public bool ExportProcessingHistory(string exportFile)\n    {\n        try\n        {\n            var json = JsonSerializer.Serialize(processingHistory, new JsonSerializerOptions { WriteIndented = true });\n            File.WriteAllText(exportFile, json);\n            return true;\n        }\n        catch (Exception)\n        {\n            return false;\n        }\n    }\n    \n    public async Task<List<ProcessingResult>> BatchProcessWithRetryAsync(List<string> fileNames, ProcessingOptions options, int maxRetries = 3)\n    {\n        var results = new List<ProcessingResult>();\n        \n        foreach (var fileName in fileNames)\n        {\n            var attempts = 0;\n            ProcessingResult lastResult;\n            \n            do\n            {\n                attempts++;\n                lastResult = await ProcessIndividualFileAsync(fileName, options);\n                \n                if (lastResult.Success)\n                {\n                    results.Add(lastResult);\n                    break;\n                }\n                \n                if (attempts < maxRetries)\n                {\n                    await Task.Delay(1000 * attempts);\n                }\n            } while (attempts < maxRetries);\n            \n            if (!lastResult.Success)\n            {\n                results.Add(lastResult);\n            }\n        }\n        \n        return results;\n    }\n    \n    public string GetDetailedProcessingReport()\n    {\n        var outputDir = new DirectoryInfo(outputDirectory);\n        var backupDir = new DirectoryInfo(Path.Combine(tempDirectory, \"backups\"));\n        \n        var outputFiles = outputDir.Exists ? outputDir.GetFiles().Where(f => f.Exists).ToList() : new List<FileInfo>();\n        var backupFiles = backupDir.Exists ? backupDir.GetFiles().Where(f => f.Exists).ToList() : new List<FileInfo>();\n        \n        var report = new StringBuilder();\n        report.AppendLine(\"=== File Processing Report ===\");\n        report.AppendLine($\"Generated: {DateTime.Now}\");\n        report.AppendLine($\"Output Directory: {outputDirectory}\");\n        report.AppendLine($\"Temp Directory: {tempDirectory}\");\n        report.AppendLine();\n        report.AppendLine(\"Processing Statistics:\");\n        report.AppendLine($\"- Total processed files: {outputFiles.Count}\");\n        report.AppendLine($\"- Total backup files: {backupFiles.Count}\");\n        report.AppendLine($\"- Processing history entries: {processingHistory.Count}\");\n        report.AppendLine($\"- Total output size: {outputFiles.Sum(f => f.Length)} bytes\");\n        report.AppendLine();\n        report.AppendLine(\"Recent Files:\");\n        \n        var recentFiles = outputFiles.OrderByDescending(f => f.LastWriteTime).Take(10);\n        foreach (var file in recentFiles)\n        {\n            report.AppendLine($\"- {file.Name} ({file.Length} bytes, {file.LastWriteTime})\");\n        }\n        \n        return report.ToString();\n    }\n    \n    public void Dispose()\n    {\n        semaphore?.Dispose();\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "C#",
    "violation": "DIP"
  },
    {
    "input": "public class TwilioSMS {\n    public void sendSMS(String phoneNumber, String message) {\n        System.out.println(\"Sending SMS via Twilio to \" + phoneNumber + \": \" + message);\n    }\n}\n\npublic class NotificationService {\n    private TwilioSMS smsProvider;\n    \n    public NotificationService() {\n        this.smsProvider = new TwilioSMS();\n    }\n    \n    public void sendNotification(String phoneNumber, String message) {\n        smsProvider.sendSMS(phoneNumber, message);\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "class TwilioSMS:\n    def send_sms(self, phone_number, message):\n        print(f\"Sending SMS via Twilio to {phone_number}: {message}\")\n\nclass NotificationService:\n    def __init__(self):\n        self.sms_provider = TwilioSMS()\n    \n    def send_notification(self, phone_number, message):\n        self.sms_provider.send_sms(phone_number, message)",
    "output": "",
    "level": "EASY",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "class TwilioSMS {\n    fun sendSMS(phoneNumber: String, message: String) {\n        println(\"Sending SMS via Twilio to $phoneNumber: $message\")\n    }\n}\n\nclass NotificationService {\n    private val smsProvider = TwilioSMS()\n    \n    fun sendNotification(phoneNumber: String, message: String) {\n        smsProvider.sendSMS(phoneNumber, message)\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "public class TwilioSMS\n{\n    public void SendSMS(string phoneNumber, string message)\n    {\n        Console.WriteLine($\"Sending SMS via Twilio to {phoneNumber}: {message}\");\n    }\n}\n\npublic class NotificationService\n{\n    private TwilioSMS smsProvider;\n    \n    public NotificationService()\n    {\n        smsProvider = new TwilioSMS();\n    }\n    \n    public void SendNotification(string phoneNumber, string message)\n    {\n        smsProvider.SendSMS(phoneNumber, message);\n    }\n}",
    "output": "",
    "level": "EASY",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "public class TwilioSMS {\n    private String apiKey;\n    private String accountSid;\n    \n    public TwilioSMS(String apiKey, String accountSid) {\n        this.apiKey = apiKey;\n        this.accountSid = accountSid;\n    }\n    \n    public void sendSMS(String phoneNumber, String message) {\n        System.out.println(\"Connecting to Twilio API...\");\n        System.out.println(\"Authenticating with SID: \" + accountSid);\n        System.out.println(\"Sending SMS to \" + phoneNumber + \": \" + message);\n    }\n    \n    public void sendBulkSMS(String[] phoneNumbers, String message) {\n        for (String number : phoneNumbers) {\n            sendSMS(number, message);\n        }\n    }\n}\n\npublic class NotificationService {\n    private TwilioSMS smsProvider;\n    \n    public NotificationService() {\n        this.smsProvider = new TwilioSMS(\"test-api-key\", \"test-account-sid\");\n    }\n    \n    public void sendNotification(String phoneNumber, String message) {\n        smsProvider.sendSMS(phoneNumber, message);\n    }\n    \n    public void sendBulkNotification(String[] phoneNumbers, String message) {\n        smsProvider.sendBulkSMS(phoneNumbers, message);\n    }\n    \n    public void sendPriorityNotification(String phoneNumber, String message) {\n        String priorityMessage = \"[URGENT] \" + message;\n        smsProvider.sendSMS(phoneNumber, priorityMessage);\n    }\n}\n\npublic class UserNotificationManager {\n    private NotificationService notificationService;\n    \n    public UserNotificationManager() {\n        this.notificationService = new NotificationService();\n    }\n    \n    public void notifyUser(String phoneNumber, String message) {\n        notificationService.sendNotification(phoneNumber, message);\n    }\n    \n    public void notifyAllUsers(String[] phoneNumbers, String message) {\n        notificationService.sendBulkNotification(phoneNumbers, message);\n    }\n    \n    public void sendAlert(String phoneNumber, String alertMessage) {\n        notificationService.sendPriorityNotification(phoneNumber, alertMessage);\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "class TwilioSMS:\n    def __init__(self, api_key, account_sid):\n        self.api_key = api_key\n        self.account_sid = account_sid\n    \n    def send_sms(self, phone_number, message):\n        print(\"Connecting to Twilio API...\")\n        print(f\"Authenticating with SID: {self.account_sid}\")\n        print(f\"Sending SMS to {phone_number}: {message}\")\n    \n    def send_bulk_sms(self, phone_numbers, message):\n        for number in phone_numbers:\n            self.send_sms(number, message)\n\nclass NotificationService:\n    def __init__(self):\n        self.sms_provider = TwilioSMS(\"test-api-key\", \"test-account-sid\")\n    \n    def send_notification(self, phone_number, message):\n        self.sms_provider.send_sms(phone_number, message)\n    \n    def send_bulk_notification(self, phone_numbers, message):\n        self.sms_provider.send_bulk_sms(phone_numbers, message)\n    \n    def send_priority_notification(self, phone_number, message):\n        priority_message = f\"[URGENT] {message}\"\n        self.sms_provider.send_sms(phone_number, priority_message)\n\nclass UserNotificationManager:\n    def __init__(self):\n        self.notification_service = NotificationService()\n    \n    def notify_user(self, phone_number, message):\n        self.notification_service.send_notification(phone_number, message)\n    \n    def notify_all_users(self, phone_numbers, message):\n        self.notification_service.send_bulk_notification(phone_numbers, message)\n    \n    def send_alert(self, phone_number, alert_message):\n        self.notification_service.send_priority_notification(phone_number, alert_message)",
    "output": "",
    "level": "MODERATE",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "class TwilioSMS(private val apiKey: String, private val accountSid: String) {\n    fun sendSMS(phoneNumber: String, message: String) {\n        println(\"Connecting to Twilio API...\")\n        println(\"Authenticating with SID: $accountSid\")\n        println(\"Sending SMS to $phoneNumber: $message\")\n    }\n    \n    fun sendBulkSMS(phoneNumbers: Array<String>, message: String) {\n        phoneNumbers.forEach { number ->\n            sendSMS(number, message)\n        }\n    }\n}\n\nclass NotificationService {\n    private val smsProvider = TwilioSMS(\"test-api-key\", \"test-account-sid\")\n    \n    fun sendNotification(phoneNumber: String, message: String) {\n        smsProvider.sendSMS(phoneNumber, message)\n    }\n    \n    fun sendBulkNotification(phoneNumbers: Array<String>, message: String) {\n        smsProvider.sendBulkSMS(phoneNumbers, message)\n    }\n    \n    fun sendPriorityNotification(phoneNumber: String, message: String) {\n        val priorityMessage = \"[URGENT] $message\"\n        smsProvider.sendSMS(phoneNumber, priorityMessage)\n    }\n}\n\nclass UserNotificationManager {\n    private val notificationService = NotificationService()\n    \n    fun notifyUser(phoneNumber: String, message: String) {\n        notificationService.sendNotification(phoneNumber, message)\n    }\n    \n    fun notifyAllUsers(phoneNumbers: Array<String>, message: String) {\n        notificationService.sendBulkNotification(phoneNumbers, message)\n    }\n    \n    fun sendAlert(phoneNumber: String, alertMessage: String) {\n        notificationService.sendPriorityNotification(phoneNumber, alertMessage)\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "public class TwilioSMS\n{\n    private string apiKey;\n    private string accountSid;\n    \n    public TwilioSMS(string apiKey, string accountSid)\n    {\n        this.apiKey = apiKey;\n        this.accountSid = accountSid;\n    }\n    \n    public void SendSMS(string phoneNumber, string message)\n    {\n        Console.WriteLine(\"Connecting to Twilio API...\");\n        Console.WriteLine($\"Authenticating with SID: {accountSid}\");\n        Console.WriteLine($\"Sending SMS to {phoneNumber}: {message}\");\n    }\n    \n    public void SendBulkSMS(string[] phoneNumbers, string message)\n    {\n        foreach (string number in phoneNumbers)\n        {\n            SendSMS(number, message);\n        }\n    }\n}\n\npublic class NotificationService\n{\n    private TwilioSMS smsProvider;\n    \n    public NotificationService()\n    {\n        smsProvider = new TwilioSMS(\"test-api-key\", \"test-account-sid\");\n    }\n    \n    public void SendNotification(string phoneNumber, string message)\n    {\n        smsProvider.SendSMS(phoneNumber, message);\n    }\n    \n    public void SendBulkNotification(string[] phoneNumbers, string message)\n    {\n        smsProvider.SendBulkSMS(phoneNumbers, message);\n    }\n    \n    public void SendPriorityNotification(string phoneNumber, string message)\n    {\n        string priorityMessage = $\"[URGENT] {message}\";\n        smsProvider.SendSMS(phoneNumber, priorityMessage);\n    }\n}\n\npublic class UserNotificationManager\n{\n    private NotificationService notificationService;\n    \n    public UserNotificationManager()\n    {\n        notificationService = new NotificationService();\n    }\n    \n    public void NotifyUser(string phoneNumber, string message)\n    {\n        notificationService.SendNotification(phoneNumber, message);\n    }\n    \n    public void NotifyAllUsers(string[] phoneNumbers, string message)\n    {\n        notificationService.SendBulkNotification(phoneNumbers, message);\n    }\n    \n    public void SendAlert(string phoneNumber, string alertMessage)\n    {\n        notificationService.SendPriorityNotification(phoneNumber, alertMessage);\n    }\n}",
    "output": "",
    "level": "MODERATE",
    "language": "C#",
    "violation": "DIP"
  },
  {
    "input": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic class TwilioSMS {\n    private String apiKey;\n    private String accountSid;\n    private String authToken;\n    private Map<String, String> configuration;\n    \n    public TwilioSMS(String apiKey, String accountSid, String authToken) {\n        this.apiKey = apiKey;\n        this.accountSid = accountSid;\n        this.authToken = authToken;\n        this.configuration = new HashMap<>();\n        initializeConfiguration();\n    }\n    \n    private void initializeConfiguration() {\n        configuration.put(\"timeout\", \"30000\");\n        configuration.put(\"retries\", \"3\");\n        configuration.put(\"baseUrl\", \"https://api.twilio.com/2010-04-01\");\n    }\n    \n    public void sendSMS(String phoneNumber, String message) {\n        authenticateWithTwilio();\n        validatePhoneNumber(phoneNumber);\n        System.out.println(\"Sending SMS via Twilio to \" + phoneNumber + \": \" + message);\n    }\n    \n    public void sendBulkSMS(String[] phoneNumbers, String message) {\n        ExecutorService executor = Executors.newFixedThreadPool(5);\n        for (String number : phoneNumbers) {\n            executor.submit(() -> sendSMS(number, message));\n        }\n        executor.shutdown();\n    }\n    \n    public void sendScheduledSMS(String phoneNumber, String message, long delaySeconds) {\n        Timer timer = new Timer();\n        timer.schedule(new TimerTask() {\n            @Override\n            public void run() {\n                sendSMS(phoneNumber, message);\n            }\n        }, delaySeconds * 1000);\n    }\n    \n    private void authenticateWithTwilio() {\n        System.out.println(\"Authenticating with Twilio API using SID: \" + accountSid);\n        System.out.println(\"Using auth token: \" + authToken.substring(0, 5) + \"...\");\n    }\n    \n    private void validatePhoneNumber(String phoneNumber) {\n        if (!phoneNumber.matches(\"^\\\\+?[1-9]\\\\d{1,14}$\")) {\n            throw new IllegalArgumentException(\"Invalid phone number format\");\n        }\n    }\n    \n    public void updateConfiguration(String key, String value) {\n        configuration.put(key, value);\n    }\n}\n\npublic class NotificationService {\n    private TwilioSMS smsProvider;\n    private Map<String, String> templates;\n    \n    public NotificationService() {\n        this.smsProvider = new TwilioSMS(\"test-api-key\", \"test-account-sid\", \"test-auth-token\");\n        this.templates = new HashMap<>();\n        initializeTemplates();\n    }\n    \n    private void initializeTemplates() {\n        templates.put(\"welcome\", \"Welcome to our service! Your account has been created.\");\n        templates.put(\"alert\", \"[ALERT] Important notification: {message}\");\n        templates.put(\"reminder\", \"Reminder: {message}\");\n    }\n    \n    public void sendNotification(String phoneNumber, String message) {\n        smsProvider.sendSMS(phoneNumber, message);\n    }\n    \n    public void sendTemplatedNotification(String phoneNumber, String templateName, String message) {\n        String template = templates.get(templateName);\n        if (template != null) {\n            String formattedMessage = template.replace(\"{message}\", message);\n            smsProvider.sendSMS(phoneNumber, formattedMessage);\n        }\n    }\n    \n    public void sendBulkNotification(String[] phoneNumbers, String message) {\n        smsProvider.sendBulkSMS(phoneNumbers, message);\n    }\n    \n    public void sendScheduledNotification(String phoneNumber, String message, long delaySeconds) {\n        smsProvider.sendScheduledSMS(phoneNumber, message, delaySeconds);\n    }\n}\n\npublic class UserNotificationManager {\n    private NotificationService notificationService;\n    private Map<String, List<String>> userGroups;\n    \n    public UserNotificationManager() {\n        this.notificationService = new NotificationService();\n        this.userGroups = new HashMap<>();\n    }\n    \n    public void addUserToGroup(String groupName, String phoneNumber) {\n        userGroups.computeIfAbsent(groupName, k -> new ArrayList<>()).add(phoneNumber);\n    }\n    \n    public void notifyUser(String phoneNumber, String message) {\n        notificationService.sendNotification(phoneNumber, message);\n    }\n    \n    public void notifyGroup(String groupName, String message) {\n        List<String> phoneNumbers = userGroups.get(groupName);\n        if (phoneNumbers != null) {\n            String[] numbersArray = phoneNumbers.toArray(new String[0]);\n            notificationService.sendBulkNotification(numbersArray, message);\n        }\n    }\n    \n    public void sendWelcomeMessage(String phoneNumber) {\n        notificationService.sendTemplatedNotification(phoneNumber, \"welcome\", \"\");\n    }\n    \n    public void sendAlert(String phoneNumber, String alertMessage) {\n        notificationService.sendTemplatedNotification(phoneNumber, \"alert\", alertMessage);\n    }\n    \n    public void sendReminder(String phoneNumber, String reminderMessage, long delaySeconds) {\n        String formattedMessage = \"Reminder: \" + reminderMessage;\n        notificationService.sendScheduledNotification(phoneNumber, formattedMessage, delaySeconds);\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "JAVA",
    "violation": "DIP"
  },
  {
    "input": "import threading\nimport time\nfrom typing import Dict, List\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass TwilioSMS:\n    def __init__(self, api_key: str, account_sid: str, auth_token: str):\n        self.api_key = api_key\n        self.account_sid = account_sid\n        self.auth_token = auth_token\n        self.configuration = {}\n        self._initialize_configuration()\n    \n    def _initialize_configuration(self):\n        self.configuration = {\n            'timeout': 30000,\n            'retries': 3,\n            'base_url': 'https://api.twilio.com/2010-04-01'\n        }\n    \n    def send_sms(self, phone_number: str, message: str):\n        self._authenticate_with_twilio()\n        self._validate_phone_number(phone_number)\n        print(f\"Sending SMS via Twilio to {phone_number}: {message}\")\n    \n    def send_bulk_sms(self, phone_numbers: List[str], message: str):\n        with ThreadPoolExecutor(max_workers=5) as executor:\n            futures = [executor.submit(self.send_sms, number, message) for number in phone_numbers]\n            for future in futures:\n                future.result()\n    \n    def send_scheduled_sms(self, phone_number: str, message: str, delay_seconds: int):\n        def delayed_send():\n            time.sleep(delay_seconds)\n            self.send_sms(phone_number, message)\n        \n        thread = threading.Thread(target=delayed_send)\n        thread.start()\n    \n    def _authenticate_with_twilio(self):\n        print(f\"Authenticating with Twilio API using SID: {self.account_sid}\")\n        print(f\"Using auth token: {self.auth_token[:5]}...\")\n    \n    def _validate_phone_number(self, phone_number: str):\n        import re\n        if not re.match(r'^\\+?[1-9]\\d{1,14}$', phone_number):\n            raise ValueError(\"Invalid phone number format\")\n    \n    def update_configuration(self, key: str, value: str):\n        self.configuration[key] = value\n\nclass NotificationService:\n    def __init__(self):\n        self.sms_provider = TwilioSMS(\"test-api-key\", \"test-account-sid\", \"test-auth-token\")\n        self.templates = {}\n        self._initialize_templates()\n    \n    def _initialize_templates(self):\n        self.templates = {\n            'welcome': 'Welcome to our service! Your account has been created.',\n            'alert': '[ALERT] Important notification: {message}',\n            'reminder': 'Reminder: {message}'\n        }\n    \n    def send_notification(self, phone_number: str, message: str):\n        self.sms_provider.send_sms(phone_number, message)\n    \n    def send_templated_notification(self, phone_number: str, template_name: str, message: str):\n        template = self.templates.get(template_name)\n        if template:\n            formatted_message = template.format(message=message)\n            self.sms_provider.send_sms(phone_number, formatted_message)\n    \n    def send_bulk_notification(self, phone_numbers: List[str], message: str):\n        self.sms_provider.send_bulk_sms(phone_numbers, message)\n    \n    def send_scheduled_notification(self, phone_number: str, message: str, delay_seconds: int):\n        self.sms_provider.send_scheduled_sms(phone_number, message, delay_seconds)\n\nclass UserNotificationManager:\n    def __init__(self):\n        self.notification_service = NotificationService()\n        self.user_groups: Dict[str, List[str]] = {}\n    \n    def add_user_to_group(self, group_name: str, phone_number: str):\n        if group_name not in self.user_groups:\n            self.user_groups[group_name] = []\n        self.user_groups[group_name].append(phone_number)\n    \n    def notify_user(self, phone_number: str, message: str):\n        self.notification_service.send_notification(phone_number, message)\n    \n    def notify_group(self, group_name: str, message: str):\n        phone_numbers = self.user_groups.get(group_name, [])\n        if phone_numbers:\n            self.notification_service.send_bulk_notification(phone_numbers, message)\n    \n    def send_welcome_message(self, phone_number: str):\n        self.notification_service.send_templated_notification(phone_number, 'welcome', '')\n    \n    def send_alert(self, phone_number: str, alert_message: str):\n        self.notification_service.send_templated_notification(phone_number, 'alert', alert_message)\n    \n    def send_reminder(self, phone_number: str, reminder_message: str, delay_seconds: int):\n        formatted_message = f\"Reminder: {reminder_message}\"\n        self.notification_service.send_scheduled_notification(phone_number, formatted_message, delay_seconds)",
    "output": "",
    "level": "HARD",
    "language": "PYTHON",
    "violation": "DIP"
  },
  {
    "input": "import java.util.*\nimport java.util.concurrent.*\nimport kotlinx.coroutines.*\n\nclass TwilioSMS(private val apiKey: String, private val accountSid: String, private val authToken: String) {\n    private val configuration = mutableMapOf<String, String>()\n    \n    init {\n        initializeConfiguration()\n    }\n    \n    private fun initializeConfiguration() {\n        configuration[\"timeout\"] = \"30000\"\n        configuration[\"retries\"] = \"3\"\n        configuration[\"baseUrl\"] = \"https://api.twilio.com/2010-04-01\"\n    }\n    \n    fun sendSMS(phoneNumber: String, message: String) {\n        authenticateWithTwilio()\n        validatePhoneNumber(phoneNumber)\n        println(\"Sending SMS via Twilio to $phoneNumber: $message\")\n    }\n    \n    suspend fun sendBulkSMS(phoneNumbers: Array<String>, message: String) {\n        coroutineScope {\n            phoneNumbers.map { number ->\n                async {\n                    sendSMS(number, message)\n                }\n            }.awaitAll()\n        }\n    }\n    \n    fun sendScheduledSMS(phoneNumber: String, message: String, delaySeconds: Long) {\n        val timer = Timer()\n        timer.schedule(object : TimerTask() {\n            override fun run() {\n                sendSMS(phoneNumber, message)\n            }\n        }, delaySeconds * 1000)\n    }\n    \n    private fun authenticateWithTwilio() {\n        println(\"Authenticating with Twilio API using SID: $accountSid\")\n        println(\"Using auth token: ${authToken.take(5)}...\")\n    }\n    \n    private fun validatePhoneNumber(phoneNumber: String) {\n        val phoneRegex = Regex(\"^\\\\+?[1-9]\\\\d{1,14}$\")\n        if (!phoneNumber.matches(phoneRegex)) {\n            throw IllegalArgumentException(\"Invalid phone number format\")\n        }\n    }\n    \n    fun updateConfiguration(key: String, value: String) {\n        configuration[key] = value\n    }\n}\n\nclass NotificationService {\n    private val smsProvider = TwilioSMS(\"test-api-key\", \"test-account-sid\", \"test-auth-token\")\n    private val templates = mutableMapOf<String, String>()\n    \n    init {\n        initializeTemplates()\n    }\n    \n    private fun initializeTemplates() {\n        templates[\"welcome\"] = \"Welcome to our service! Your account has been created.\"\n        templates[\"alert\"] = \"[ALERT] Important notification: {message}\"\n        templates[\"reminder\"] = \"Reminder: {message}\"\n    }\n    \n    fun sendNotification(phoneNumber: String, message: String) {\n        smsProvider.sendSMS(phoneNumber, message)\n    }\n    \n    fun sendTemplatedNotification(phoneNumber: String, templateName: String, message: String) {\n        val template = templates[templateName]\n        if (template != null) {\n            val formattedMessage = template.replace(\"{message}\", message)\n            smsProvider.sendSMS(phoneNumber, formattedMessage)\n        }\n    }\n    \n    suspend fun sendBulkNotification(phoneNumbers: Array<String>, message: String) {\n        smsProvider.sendBulkSMS(phoneNumbers, message)\n    }\n    \n    fun sendScheduledNotification(phoneNumber: String, message: String, delaySeconds: Long) {\n        smsProvider.sendScheduledSMS(phoneNumber, message, delaySeconds)\n    }\n}\n\nclass UserNotificationManager {\n    private val notificationService = NotificationService()\n    private val userGroups = mutableMapOf<String, MutableList<String>>()\n    \n    fun addUserToGroup(groupName: String, phoneNumber: String) {\n        userGroups.getOrPut(groupName) { mutableListOf() }.add(phoneNumber)\n    }\n    \n    fun notifyUser(phoneNumber: String, message: String) {\n        notificationService.sendNotification(phoneNumber, message)\n    }\n    \n    suspend fun notifyGroup(groupName: String, message: String) {\n        val phoneNumbers = userGroups[groupName]\n        if (phoneNumbers != null) {\n            val numbersArray = phoneNumbers.toTypedArray()\n            notificationService.sendBulkNotification(numbersArray, message)\n        }\n    }\n    \n    fun sendWelcomeMessage(phoneNumber: String) {\n        notificationService.sendTemplatedNotification(phoneNumber, \"welcome\", \"\")\n    }\n    \n    fun sendAlert(phoneNumber: String, alertMessage: String) {\n        notificationService.sendTemplatedNotification(phoneNumber, \"alert\", alertMessage)\n    }\n    \n    fun sendReminder(phoneNumber: String, reminderMessage: String, delaySeconds: Long) {\n        val formattedMessage = \"Reminder: $reminderMessage\"\n        notificationService.sendScheduledNotification(phoneNumber, formattedMessage, delaySeconds)\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "KOTLIN",
    "violation": "DIP"
  },
  {
    "input": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\n\npublic class TwilioSMS\n{\n    private string apiKey;\n    private string accountSid;\n    private string authToken;\n    private Dictionary<string, string> configuration;\n    \n    public TwilioSMS(string apiKey, string accountSid, string authToken)\n    {\n        this.apiKey = apiKey;\n        this.accountSid = accountSid;\n        this.authToken = authToken;\n        this.configuration = new Dictionary<string, string>();\n        InitializeConfiguration();\n    }\n    \n    private void InitializeConfiguration()\n    {\n        configuration[\"timeout\"] = \"30000\";\n        configuration[\"retries\"] = \"3\";\n        configuration[\"baseUrl\"] = \"https://api.twilio.com/2010-04-01\";\n    }\n    \n    public void SendSMS(string phoneNumber, string message)\n    {\n        AuthenticateWithTwilio();\n        ValidatePhoneNumber(phoneNumber);\n        Console.WriteLine($\"Sending SMS via Twilio to {phoneNumber}: {message}\");\n    }\n    \n    public async Task SendBulkSMS(string[] phoneNumbers, string message)\n    {\n        var tasks = new List<Task>();\n        foreach (var number in phoneNumbers)\n        {\n            tasks.Add(Task.Run(() => SendSMS(number, message)));\n        }\n        await Task.WhenAll(tasks);\n    }\n    \n    public void SendScheduledSMS(string phoneNumber, string message, int delaySeconds)\n    {\n        var timer = new Timer(callback =>\n        {\n            SendSMS(phoneNumber, message);\n        }, null, delaySeconds * 1000, Timeout.Infinite);\n    }\n    \n    private void AuthenticateWithTwilio()\n    {\n        Console.WriteLine($\"Authenticating with Twilio API using SID: {accountSid}\");\n        Console.WriteLine($\"Using auth token: {authToken.Substring(0, 5)}...\");\n    }\n    \n    private void ValidatePhoneNumber(string phoneNumber)\n    {\n        var phoneRegex = new Regex(@\"^\\+?[1-9]\\d{1,14}$\");\n        if (!phoneRegex.IsMatch(phoneNumber))\n        {\n            throw new ArgumentException(\"Invalid phone number format\");\n        }\n    }\n    \n    public void UpdateConfiguration(string key, string value)\n    {\n        configuration[key] = value;\n    }\n}\n\npublic class NotificationService\n{\n    private TwilioSMS smsProvider;\n    private Dictionary<string, string> templates;\n    \n    public NotificationService()\n    {\n        this.smsProvider = new TwilioSMS(\"test-api-key\", \"test-account-sid\", \"test-auth-token\");\n        this.templates = new Dictionary<string, string>();\n        InitializeTemplates();\n    }\n    \n    private void InitializeTemplates()\n    {\n        templates[\"welcome\"] = \"Welcome to our service! Your account has been created.\";\n        templates[\"alert\"] = \"[ALERT] Important notification: {message}\";\n        templates[\"reminder\"] = \"Reminder: {message}\";\n    }\n    \n    public void SendNotification(string phoneNumber, string message)\n    {\n        smsProvider.SendSMS(phoneNumber, message);\n    }\n    \n    public void SendTemplatedNotification(string phoneNumber, string templateName, string message)\n    {\n        if (templates.ContainsKey(templateName))\n        {\n            var template = templates[templateName];\n            var formattedMessage = template.Replace(\"{message}\", message);\n            smsProvider.SendSMS(phoneNumber, formattedMessage);\n        }\n    }\n    \n    public async Task SendBulkNotification(string[] phoneNumbers, string message)\n    {\n        await smsProvider.SendBulkSMS(phoneNumbers, message);\n    }\n    \n    public void SendScheduledNotification(string phoneNumber, string message, int delaySeconds)\n    {\n        smsProvider.SendScheduledSMS(phoneNumber, message, delaySeconds);\n    }\n}\n\npublic class UserNotificationManager\n{\n    private NotificationService notificationService;\n    private Dictionary<string, List<string>> userGroups;\n    \n    public UserNotificationManager()\n    {\n        this.notificationService = new NotificationService();\n        this.userGroups = new Dictionary<string, List<string>>();\n    }\n    \n    public void AddUserToGroup(string groupName, string phoneNumber)\n    {\n        if (!userGroups.ContainsKey(groupName))\n        {\n            userGroups[groupName] = new List<string>();\n        }\n        userGroups[groupName].Add(phoneNumber);\n    }\n    \n    public void NotifyUser(string phoneNumber, string message)\n    {\n        notificationService.SendNotification(phoneNumber, message);\n    }\n    \n    public async Task NotifyGroup(string groupName, string message)\n    {\n        if (userGroups.ContainsKey(groupName))\n        {\n            var phoneNumbers = userGroups[groupName].ToArray();\n            await notificationService.SendBulkNotification(phoneNumbers, message);\n        }\n    }\n    \n    public void SendWelcomeMessage(string phoneNumber)\n    {\n        notificationService.SendTemplatedNotification(phoneNumber, \"welcome\", \"\");\n    }\n    \n    public void SendAlert(string phoneNumber, string alertMessage)\n    {\n        notificationService.SendTemplatedNotification(phoneNumber, \"alert\", alertMessage);\n    }\n    \n    public void SendReminder(string phoneNumber, string reminderMessage, int delaySeconds)\n    {\n        var formattedMessage = $\"Reminder: {reminderMessage}\";\n        notificationService.SendScheduledNotification(phoneNumber, formattedMessage, delaySeconds);\n    }\n}",
    "output": "",
    "level": "HARD",
    "language": "C#",
    "violation": "DIP"
  }
]