{
  "code_examples": [
    {
      "input": "class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Bird bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Ostrich());\n    }\n}",
      "output": "class Bird {\n    public void move() {\n        System.out.println(\"Bird is moving\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void move() {\n        System.out.println(\"Ostrich is running\");\n    }\n}\n\npublic class Main {\n    public static void makeBirdMove(Bird bird) {\n        bird.move();\n    }\n    public static void main(String[] args) {\n        makeBirdMove(new Ostrich());\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Square();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n    }\n}",
      "output": "abstract class Shape {\n    public abstract int getArea();\n}\n\nclass Rectangle extends Shape {\n    protected int width;\n    protected int height;\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    @Override\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Shape {\n    protected int side;\n    public Square(int side) {\n        this.side = side;\n    }\n    @Override\n    public int getArea() { return side * side; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape s = new Square(5);\n        System.out.println(s.getArea());\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        throw new RuntimeException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
      "output": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Payment {\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
      "output": "abstract class Payment {\n    public abstract void pay();\n}\n\nclass PaidPayment extends Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"No payment needed\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Vehicle {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.startEngine();\n    }\n}",
      "output": "abstract class Vehicle {\n    public abstract void move();\n}\n\nclass Car extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Car is moving\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Bicycle is moving\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.move();\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class FileReader {\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "output": "abstract class Reader {\n    public abstract String read();\n}\n\nclass FileReader extends Reader {\n    @Override\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends Reader {\n    @Override\n    public String read() {\n        return \"Reading from secure file\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Reader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Writer {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
      "output": "abstract class Writer {\n    public abstract void write(String data);\n}\n\nclass FileWriter extends Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Cannot write: Read only\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 0));\n    }\n}",
      "output": "class Calculator {\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        return super.divide(a, b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 2));\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Shape {\n    public double area() {\n        System.out.println(\"Base Shape Area: 0.0\");\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: \" + Double.NaN + \" (Violation)\");\n        return Double.NaN;\n    }\n}",
      "output": "import java.lang.Math;\n\ninterface IShape {\n    double area();\n}\n\nclass Circle implements IShape {\n    private double radius;\n    public Circle(double radius) { this.radius = radius; }\n    @Override\n    public double area() {\n        double calculatedArea = Math.PI * radius * radius;\n        System.out.println(\"Circle Area: \" + calculatedArea);\n        return calculatedArea;\n    }\n}\n\nclass NullShape implements IShape {\n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: 0.0 (LSP Compliant)\");\n        return 0.0;\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\nclass FileProcessor {\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "import java.io.File;\n\ninterface FileStatusProvider {\n    String getStatus(String filePath);\n}\n\ninterface FileProcessor extends FileStatusProvider {\n    void processFile(String filePath);\n}\n\nclass RealFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"RealProcessor: Error - File not found.\");\n            return;\n        }\n        System.out.println(\"RealProcessor: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileStatusProvider implements FileStatusProvider {\n     @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        fakeMessagesLogged++;\n    }\n}",
      "output": "interface SimpleLogger {\n    void log(String message);\n}\n\nclass CountingLogger implements SimpleLogger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        System.out.println(\"[COUNTING LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentLogger implements SimpleLogger {\n    @Override\n    public void log(String message) {\n        // This implementation simply does nothing, which is a valid behavior\n        // for a SimpleLogger if the contract doesn't guarantee visible output.\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    \n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    \n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    \n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n\n    \n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}\n\n",
      "output": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Define interfaces for different capabilities\ninterface DataLoader {\n    boolean loadData(String source);\n}\n\ninterface DataProcessorCapability {\n    boolean processData();\n}\n\ninterface DataSaverCapability {\n    boolean saveResults(String destination);\n}\n\n// A concrete implementation that can do all three\nclass FullDataProcessor implements DataLoader, DataProcessorCapability, DataSaverCapability {\n    private Map<String, Object> data = null;\n\n    public FullDataProcessor() {\n        System.out.println(\"FullDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Full: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Full: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Full: Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Full: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Full: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        // Simulate processing\n        data.put(\"processed\", true);\n        System.out.println(\"Full: Data processed.\");\n        return true;\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"Full: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Full: No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        // Simulate saving\n        // Example: try { new File(destination).createNewFile(); } catch (IOException e) { e.printStackTrace(); return false; }\n        System.out.println(\"Full: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\n// A concrete implementation that can load and process (read-only concept)\n// It implements DataLoader and DataProcessorCapability but NOT DataSaverCapability.\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessorCapability {\n    private Map<String, Object> data = null; // Manage its own state\n\n    public ReadOnlyDataProcessor() {\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"ReadOnly: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"ReadOnly: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"ReadOnly: Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"ReadOnly: Processing data (read-only simulation)...\");\n        if (data == null) {\n            System.out.println(\"ReadOnly: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        // Simulate processing without making it 'savable' in the sense required by DataSaverCapability\n        // Could even work on a shallow copy of 'data' if deep processing wasn't intended to modify the original\n        // data = new HashMap<>(data); // Example: process on a copy\n        data.put(\"processed\", true); // Still mark as processed internally for its own logic\n        System.out.println(\"ReadOnly: Data processed (read-only).\");\n        return true;\n    }\n\n    // This class does NOT have a saveResults method from the DataSaverCapability interface.\n    // Therefore, it cannot be substituted where DataSaverCapability is required.\n}\n\n// Example Usage (LSP Compliant - requires specific capabilities):\n/*\nimport java.io.File;\n\npublic class ComplianceDemo {\n    // A method requiring saving capability MUST ask for DataSaverCapability (or FullDataProcessor)\n    public static void saveProcessedData(DataSaverCapability saver, String destination) {\n         // This method knows it can save\n         System.out.println(\"Attempting to save using a saver...\");\n         // saver.loadData(...) // This would be a compile-time error - DataSaverCapability doesn't have loadData\n         // saver.processData() // This would be a compile-time error - DataSaverCapability doesn't have processData\n         saver.saveResults(destination); // This call is guaranteed to exist (though might fail for other reasons like disk full)\n    }\n\n    // A method requiring only processing capability can ask for DataProcessorCapability\n    public static void processSomeData(DataProcessorCapability processor) {\n         // This method knows it can process\n         System.out.println(\"Attempting to process using a processor...\");\n         // processor.loadData(...) // Compile-time error\n         processor.processData(); // This call is guaranteed to exist\n         // processor.saveResults(...) // Compile-time error\n    }\n\n    // A method requiring only loading capability can ask for DataLoader\n    public static void loadSomeData(DataLoader loader) {\n         // This method knows it can load\n         System.out.println(\"Attempting to load using a loader...\");\n         loader.loadData(\"valid_source\"); // This call is guaranteed to exist\n         // loader.processData() // Compile-time error\n         // loader.saveResults(...) // Compile-time error\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"--- Demonstrating Compliance ---\");\n\n        // Instantiate classes\n        FullDataProcessor fullProc = new FullDataProcessor();\n        ReadOnlyDataProcessor readOnlyProc = new ReadOnlyDataProcessor();\n\n        System.out.println(\"\\nUsing FullDataProcessor where saver is needed:\");\n        // Need to load/process first if save logic requires state\n        if (fullProc.loadData(\"valid_source\")) {\n            if (fullProc.processData()) {\n                saveProcessedData(fullProc, \"output_compliant.txt\"); // Works (FullDataProcessor implements DataSaverCapability)\n            }\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\");\n        // saveProcessedData(readOnlyProc, \"output_compliant.txt\"); // This line would cause a compile-time type error\n        System.out.println(\"// Cannot pass ReadOnlyDataProcessor where DataSaverCapability is expected.\");\n\n        System.out.println(\"\\nUsing FullDataProcessor where processor is needed:\");\n        // Need to load first if process logic requires state\n        if (fullProc.loadData(\"valid_source\")) {\n             processSomeData(fullProc); // Works (FullDataProcessor implements DataProcessorCapability)\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\");\n        // Need to load first if process logic requires state\n        if (readOnlyProc.loadData(\"valid_source\")) {\n            processSomeData(readOnlyProc); // Works (ReadOnlyDataProcessor implements DataProcessorCapability)\n        }\n\n        System.out.println(\"\\nUsing FullDataProcessor where loader is needed:\");\n        loadSomeData(fullProc); // Works (FullDataProcessor implements DataLoader)\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\");\n        loadSomeData(readOnlyProc); // Works (ReadOnlyDataProcessor implements DataLoader)\n\n        // Clean up\n        File dummyFile = new File(\"output_compliant.txt\");\n        if (dummyFile.exists()) dummyFile.delete();\n    }\n}\n*/",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP"
    },
    {
      "input": "class Bird:\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise Exception('Ostriches cannot fly')",
      "output": "class Bird:\n    def move(self):\n        print('Moving')\n\nclass Ostrich(Bird):\n    def move(self):\n        print('Running')\n",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class Rectangle:\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.height = height\n        self.width = height",
      "output": "class Shape:\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side * self.side\n",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class Animal:\n    def make_sound(self):\n        print('Some sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        raise NotImplementedError('Fish cannot make sounds')",
      "output": "class Animal:\n    def move(self):\n        print('Moving')\n\nclass Fish(Animal):\n    def move(self):\n        print('Swimming')\n",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
      "output": "class FileHandler:\n    def read(self):\n        print('Reading file')\n\nclass Writer(FileHandler):\n    def write(self):\n        print('Writing to file')\n",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')",
      "output": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor:\n    def process_free(self):\n        print('Processed free payment')\n",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
      "output": "class Document:\n    def show(self):\n        print('Showing document')\n\nclass SecureDocument(Document):\n    def show(self):\n        print('Showing secure document')\n",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
      "output": "class Vehicle:\n    def move(self):\n        print('Vehicle is moving')\n\nclass Bicycle(Vehicle):\n    def move(self):\n        print('Bicycle is moving')\n",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise Exception('Cannot send email')",
      "output": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass Logger:\n    def log(self, message):\n        print(message)\n",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor(DataProcessor):\n    def __init__(self):\n        super().__init__()\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "output": "import abc\nimport os\nimport time\n\n# Define ABCs for different capabilities\nclass DataLoader(abc.ABC):\n    @abc.abstractmethod\n    def load_data(self, source):\n        pass\n\nclass DataProcessorCapability(abc.ABC):\n    @abc.abstractmethod\n    def process_data(self):\n        pass\n\nclass DataSaverCapability(abc.ABC):\n    @abc.abstractmethod\n    def save_results(self, destination):\n        pass\n\n# A concrete implementation that can do all three\nclass FullDataProcessor(DataLoader, DataProcessorCapability, DataSaverCapability):\n    def __init__(self):\n        self._data = None\n        print(\"FullDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"Full: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Full: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Full: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"Full: Processing data...\")\n        if self._data is None:\n            print(\"Full: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing\n        self._data[\"processed\"] = True\n        print(\"Full: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        print(f\"Full: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Full: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        # Simulate saving\n        print(f\"Full: Results saved to {destination}.\")\n        return True\n\n# A concrete implementation that can load and process (read-only concept)\n# It implements DataLoader and DataProcessorCapability but NOT DataSaverCapability.\nclass ReadOnlyDataProcessor(DataLoader, DataProcessorCapability):\n    def __init__(self):\n        self._data = None # Manage its own state\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"ReadOnly: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"ReadOnly: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"ReadOnly: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"ReadOnly: Processing data (read-only simulation)...\")\n        if self._data is None:\n            print(\"ReadOnly: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing without making it 'savable'\n        # Could even shallow copy self._data if deep processing wasn't intended\n        print(\"ReadOnly: Data processed (read-only).\")\n        return True\n\n    # This class does NOT have a save_results method.\n    # Therefore, it cannot be substituted where DataSaverCapability is required.\n\n# Example Usage (LSP Compliant - requires specific capabilities):\n# def demonstrate_compliance():\n#     print(\"--- Demonstrating Compliance ---\")\n\n#     # A function requiring saving capability MUST ask for DataSaverCapability (or FullDataProcessor)\n#     def save_processed_data(saver: DataSaverCapability, destination):\n#          # This function knows it can save\n#          print(\"Attempting to save using a saver...\")\n#          # saver.load_data() # This would be a type error - DataSaverCapability doesn't have load_data\n#          # saver.process_data() # This would be a type error - DataSaverCapability doesn't have process_data\n#          saver.save_results(destination) # This call is guaranteed to exist (though might fail for other reasons like disk full)\n\n#     # A function requiring only processing capability can ask for DataProcessorCapability\n#     def process_some_data(processor: DataProcessorCapability):\n#          # This function knows it can process\n#          print(\"Attempting to process using a processor...\")\n#          # processor.load_data() # Type error\n#          processor.process_data() # This call is guaranteed to exist\n#          # processor.save_results() # Type error\n\n#     # A function requiring only loading capability can ask for DataLoader\n#     def load_some_data(loader: DataLoader):\n#          # This function knows it can load\n#          print(\"Attempting to load using a loader...\")\n#          loader.load_data(\"valid_source\") # This call is guaranteed to exist\n#          # loader.process_data() # Type error\n#          # loader.save_results() # Type error\n\n#     # Instantiate classes\n#     full_proc = FullDataProcessor()\n#     read_only_proc = ReadOnlyDataProcessor()\n\n#     print(\"\\nUsing FullDataProcessor where saver is needed:\")\n#     # Need to load/process first if save logic requires state\n#     if full_proc.load_data(\"valid_source\"): full_proc.process_data()\n#     save_processed_data(full_proc, \"output_compliant.txt\") # Works (FullDataProcessor implements DataSaverCapability)\n\n#     print(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\")\n#     # save_processed_data(read_only_proc, \"output_compliant.txt\") # This line would cause a TypeError\n#     print(\"// Cannot pass ReadOnlyDataProcessor where DataSaverCapability is expected.\")\n\n#     print(\"\\nUsing FullDataProcessor where processor is needed:\")\n#     # Need to load first if process logic requires state\n#     if full_proc.load_data(\"valid_source\"): process_some_data(full_proc) # Works (FullDataProcessor implements DataProcessorCapability)\n\n#     print(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\")\n#     # Need to load first if process logic requires state\n#     if read_only_proc.load_data(\"valid_source\"): process_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataProcessorCapability)\n\n#     print(\"\\nUsing FullDataProcessor where loader is needed:\")\n#     load_some_data(full_proc) # Works (FullDataProcessor implements DataLoader)\n\n#     print(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\")\n#     load_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataLoader)\n\n#     # Clean up\n#     if os.path.exists(\"output_compliant.txt\"): os.remove(\"output_compliant.txt\")\n\n# demonstrate_compliance()\n",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentCounterLogger(Logger):\n    def __init__(self):\n        super().__init__()\n        self._fake_messages_logged = 0\n\n    def log(self, message):\n        self._fake_messages_logged += 1\n",
      "output": "import abc\n\n# Define an ABC for the core logging capability\nclass SimpleLogger(abc.ABC):\n    @abc.abstractmethod\n    def log(self, message):\n        pass\n\n# An implementation that logs and also tracks a count\nclass CountingLogger(SimpleLogger):\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[COUNTING LOG] {message}\")\n        self._messages_logged += 1\n\n# An implementation that simply logs (or does nothing)\n# It fulfills the SimpleLogger interface but doesn't support counting via an inherited method.\nclass SilentLogger(SimpleLogger):\n    def log(self, message):\n        # This implementation simply does nothing, which is a valid behavior\n        # for a SimpleLogger if the contract doesn't guarantee visible output.\n        pass\n\n# If you need a logger that *must* provide a count, you could define a separate ABC:\n# class CountableLogger(SimpleLogger, abc.ABC):\n#     @abc.abstractmethod\n#     def get_messages_logged_count(self):\n#         pass\n# Then CountingLogger would inherit from CountableLogger, and SilentLogger would not.\n# Code expecting CountableLogger would only accept types that can provide a count reliably.\n",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "import os # Using os module for file operations\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return # Simplified: graceful exit if file missing\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\n\n\n\n\n",
      "output": "import abc\nimport os\n\n# Represents a component that can provide the status of a file\nclass FileStatusProvider(abc.ABC):\n    @abc.abstractmethod\n    def get_status(self, file_path):\n        pass\n\n# Represents a component that can process files (inherits status capability by implementing both)\nclass FileProcessor(FileStatusProvider, abc.ABC): # FileProcessor *is a* FileStatusProvider\n     @abc.abstractmethod\n     def process_file(self, file_path):\n         pass\n\n# A concrete implementation of a processor\nclass RealFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Ready for processing\" if file_exists else \"File not found\"\n        print(f\"RealProcessor: Checking status for {file_path} - {status}.\")\n        return status\n\n    def process_file(self, file_path):\n        print(f\"RealProcessor: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n             print(f\"RealProcessor: Error - File {file_path} not found for processing.\")\n            return\n        # Simulate processing...\n        # Example: with open(file_path, 'a') as f: f.write('\\nProcessed by real')\n        print(f\"RealProcessor: File {file_path} processed successfully.\")\n\n# Represents a component that can *only* check file status (read-only)\n# It implements FileStatusProvider but NOT FileProcessor.\nclass ReadOnlyFileStatusProvider(FileStatusProvider): # Only implements status capability\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Available (Read-only)\" if file_exists else \"File not found (Read-only)\"\n        print(f\"ReadOnlyStatusProvider: Checking status for {file_path} - {status}.\")\n        return status\n    # This class simply *does not have* a process_file method.\n    # Therefore, it cannot be substituted where a FileProcessor is expected,\n    # preventing the LSP violation.\n\n# Example Usage (LSP Compliant):\n# import os\n\n# test_file_path = \"dummy_refactored.txt\"\n# with open(test_file_path, \"w\") as f: f.write(\"Some content\") # Create a dummy file\n\n# # When you need processing capability, you must use FileProcessor:\n# processor: FileProcessor = RealFileProcessor() # Substitutes for FileProcessor\n# print(processor.get_status(test_file_path)) # RealProcessor: ... Ready.\n# processor.process_file(test_file_path)     # RealProcessor: ... processed successfully.\n\n# print(\"---\")\n\n# # When you only need status capability, you can use FileStatusProvider:\n# status_provider1: FileStatusProvider = RealFileProcessor() # Substitutes for FileStatusProvider\n# print(status_provider1.get_status(test_file_path)) # RealProcessor: ... Ready.\n\n# status_provider2: FileStatusProvider = ReadOnlyFileStatusProvider() # LSP compliant substitution\n# print(status_provider2.get_status(test_file_path)) # ReadOnlyStatusProvider: ... Available (Read-only)\n\n# # The critical part: A ReadOnlyFileStatusProvider CANNOT be treated as a FileProcessor.\n# # The following line would cause a type error at runtime if type hints were enforced, or logical error:\n# # invalid_processor: FileProcessor = ReadOnlyFileStatusProvider() # Type checker error / Runtime error if instantiated\n# # If you tried to call invalid_processor.process_file(...), it would fail because the method doesn't exist.\n\n# if os.path.exists(test_file_path): os.remove(test_file_path) # Clean up dummy file\n",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "import math\n\nclass Shape:\n    def area(self):\n        print(\"Base Shape Area: 0.0\")\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        print(f\"Null Shape Area: {float('nan')} (Violation)\")\n        return float('nan') # Returning NaN is a subtle violation\n\n\n\n\n",
      "output": "import abc\nimport math\n\n# Define an ABC for shapes that can provide an area.\n# The ABC contract simply says 'there is an area() method returning float'.\n# The expectation that this is a meaningful non-negative number is implicit in the *concept* of \"Area\".\nclass IShape(abc.ABC):\n    @abc.abstractmethod\n    def area(self) -> float:\n        pass\n\n# A standard shape implementation (like a circle)\nclass Circle(IShape):\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    def area(self) -> float:\n        calculated_area = math.pi * self.radius * self.radius\n        print(f\"Circle Area: {calculated_area}\")\n        return calculated_area # Returns a valid, non-negative number\n\n# An implementation representing a shape with no area (the \"null\" concept).\n# This now adheres to LSP by returning a valid numerical area (0.0),\n# which is the correct representation for a shape with no size.\nclass NullShape(IShape): # Now implements the ABC\n    # This is LSP compliant because returning 0.0 is a valid float value\n    # and represents a shape having no area, which is a sensible\n    # specialization of the IShape contract (returning a float).\n    def area(self) -> float:\n        print(\"Null Shape Area: 0.0 (LSP Compliant)\")\n        return 0.0 # Returning 0.0 makes this compliant\n\n# Example Usage (LSP Compliant):\n# concrete = Circle(5.0) # Substitutes for IShape\n# concrete_area = concrete.area() # Returns a valid number\n# print(f\"Concrete Area: {concrete_area}\")\n\n# print(\"---\")\n\n# null_shape_compliant = NullShape() # Substitutes for IShape\n# null_area_compliant = null_shape_compliant.area() # Returns 0.0\n# print(f\"Null Area (Compliant): {null_area_compliant}\")\n\n# # Downstream code works correctly:\n# total_area = concrete_area + null_area_compliant # total_area is ~78.54 + 0.0\n# print(f\"Total Area: {total_area}\")\n\n# if null_area_compliant >= 0.0: # This check works as expected with 0.0\n#     print(\"Area is non-negative (check passes for 0.0)\")\n# else:\n#     print(\"Area is negative or NaN\")\n",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP"
    },
    {
      "input": "open class Bird {\n    open fun fly() {}\n}\n\nclass Ostrich : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun makeBirdFly(bird: Bird) {\n    bird.fly()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdFly(ostrich)\n}",
      "output": "open class Bird {\n    open fun move() {}\n}\n\nclass Ostrich : Bird() {\n    override fun move() {\n        // Ostrich runs\n    }\n}\n\nclass Sparrow : Bird() {\n    override fun move() {\n        // Sparrow flies\n    }\n}\n\nfun makeBirdMove(bird: Bird) {\n    bird.move()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdMove(ostrich)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override fun setWidth(w: Int) {\n        width = w\n        height = w\n    }\n    override fun setHeight(h: Int) {\n        width = h\n        height = h\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
      "output": "open class Shape {\n    open fun area(): Int = 0\n}\n\nclass Rectangle(var width: Int, var height: Int) : Shape() {\n    override fun area(): Int = width * height\n}\n\nclass Square(size: Int) : Shape() {\n    private val side = size\n    override fun area(): Int = side * side\n}\n\nfun printArea(shape: Shape) {\n    println(shape.area())\n}\n\nfun main() {\n    val square = Square(5)\n    printArea(square)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
      "output": "open class Animal {\n    open fun move() {}\n}\n\nclass Dog : Animal() {\n    override fun move() {\n        println(\"Dog runs\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun move() {\n        println(\"Fish swims\")\n    }\n}\n\nfun animalMove(animal: Animal) {\n    animal.move()\n}\n\nfun main() {\n    val fish = Fish()\n    animalMove(fish)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Payment {\n    open fun pay(amount: Double) {}\n}\n\nclass CashPayment : Payment() {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment() {\n    override fun pay(amount: Double) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
      "output": "interface Payment {\n    fun pay(amount: Double)\n}\n\nclass CashPayment : Payment {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount by credit card\")\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Writer {\n    open fun write(data: String) {}\n}\n\nclass FileWriter : Writer() {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nclass ReadOnlyFileWriter : Writer() {\n    override fun write(data: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val readOnly = ReadOnlyFileWriter()\n    save(readOnly, \"Hello\")\n}",
      "output": "interface Writer {\n    fun write(data: String)\n}\n\nclass FileWriter : Writer {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val fileWriter = FileWriter()\n    save(fileWriter, \"Hello\")\n}",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    override fun startEngine() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
      "output": "open class Vehicle {\n    open fun move() {}\n}\n\nclass Car : Vehicle() {\n    override fun move() {\n        println(\"Car drives\")\n    }\n}\n\nclass Bicycle : Vehicle() {\n    override fun move() {\n        println(\"Bicycle pedals\")\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.move()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Notification {\n    open fun send(message: String) {}\n}\n\nclass EmailNotification : Notification() {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nclass SilentNotification : Notification() {\n    override fun send(message: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val silent = SilentNotification()\n    notifyUser(silent, \"Hello\")\n}",
      "output": "interface Notification {\n    fun send(message: String)\n}\n\nclass EmailNotification : Notification {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val email = EmailNotification()\n    notifyUser(email, \"Hello\")\n}",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Printer {\n    open fun printDocument(document: String) {}\n}\n\nclass NetworkPrinter : Printer() {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nclass DummyPrinter : Printer() {\n    override fun printDocument(document: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val dummy = DummyPrinter()\n    print(dummy, \"Test\")\n}",
      "output": "interface Printer {\n    fun printDocument(document: String)\n}\n\nclass NetworkPrinter : Printer {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val networkPrinter = NetworkPrinter()\n    print(networkPrinter, \"Test\")\n}",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Logger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    open fun log(message: String) {\n        println(\"[BASE LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentCounterLogger : Logger() {\n    private var fakeMessagesLogged: Int = 0\n\n    override fun log(message: String) {\n        fakeMessagesLogged++\n    }\n}",
      "output": "interface SimpleLogger {\n    fun log(message: String)\n}\n\nclass CountingLogger : SimpleLogger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    override fun log(message: String) {\n        println(\"[COUNTING LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentLogger : SimpleLogger {\n    override fun log(message: String) {\n\n    }\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "import java.util.concurrent.CopyOnWriteArrayList\n\nopen class Logger {\n    open fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger() {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "output": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\nclass ThreadSafeLogger : Logger {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(\"[THREAD SAFE] $message\")\n        println(\"[THREAD SAFE CONSOLE] $message\")\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogger : Logger {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(\"[UNSAFE] $message\")\n        println(\"[UNSAFE CONSOLE] $message\")\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "open class Shape {\n    open fun area(): Double {\n        println(\"Base Shape Area: 0.0\")\n        return 0.0\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        println(\"Null Shape Area: ${Double.NaN} (Violation)\")\n        return Double.NaN\n    }\n}",
      "output": "import kotlin.math.PI\n\ninterface IShape {\n    fun area(): Double\n}\n\nclass Circle(val radius: Double) : IShape {\n    override fun area(): Double {\n        val calculatedArea = PI * radius * radius\n        println(\"Circle Area: $calculatedArea\")\n        return calculatedArea\n    }\n}\n\nclass NullShape : IShape {\n    override fun area(): Double {\n        println(\"Null Shape Area: 0.0 (LSP Compliant)\")\n        return 0.0\n    }\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "import java.io.File\n\nopen class FileProcessor {\n    open fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"Base: Checking status for $filePath - Found.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"Base: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    open fun processFile(filePath: String) {\n        println(\"Base: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n            println(\"Base: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"Base: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor() {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnly: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"ReadOnly: Attempted to process file $filePath.\")\n        throw UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n    }\n}",
      "output": "import java.io.File\n\ninterface FileStatusProvider {\n    fun getStatus(filePath: String): String\n}\n\ninterface FileProcessor : FileStatusProvider {\n    fun processFile(filePath: String)\n}\n\nclass RealFileProcessor : FileProcessor {\n    override fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"RealProcessor: Checking status for $filePath - Ready.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"RealProcessor: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"RealProcessor: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n             println(\"RealProcessor: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"RealProcessor: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileStatusProvider : FileStatusProvider {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnlyStatusProvider: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP"
    },
    {
      "input": "class Bird { public virtual void Fly() { } } class Ostrich : Bird { public override void Fly() { throw new Exception(); } }",
      "output": "class Bird { public virtual void Move() { } } class Ostrich : Bird { public override void Move() { } }",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width * Height; } } class Square : Rectangle { public override int Width { get => base.Width; set { base.Width = value; base.Height = value; } } public override int Height { get => base.Height; set { base.Width = value; base.Height = value; } } }",
      "output": "abstract class Shape { public abstract int Area(); } class Rectangle : Shape { public int Width { get; set; } public int Height { get; set; } public override int Area() { return Width * Height; } } class Square : Shape { public int Side { get; set; } public override int Area() { return Side * Side; } }",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
      "output": "class Animal { public virtual void Move() { } } class Fish : Animal { public override void Move() { } }",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class Payment { public virtual void Pay() { } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
      "output": "interface IPayment { void Pay(); } class PaidPayment : IPayment { public void Pay() { } } class FreePayment : IPayment { public void Pay() { } }",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
      "output": "interface IFileWriter { void Write(string data); } class FileWriter : IFileWriter { public void Write(string data) { } } class ReadOnlyFileWriter : IFileWriter { public void Write(string data) { } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new NotImplementedException(); } }",
      "output": "abstract class Vehicle { public abstract void Move(); } class Car : Vehicle { public override void Move() { } } class Bicycle : Vehicle { public override void Move() { } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class Document { public virtual void Print() { } } class DigitalDocument : Document { public override void Print() { throw new NotSupportedException(); } }",
      "output": "interface IDocument { void Print(); } class PaperDocument : IDocument { public void Print() { } } class DigitalDocument : IDocument { public void Print() { } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Stop() { throw new NotSupportedException(); } }",
      "output": "interface ITimer { void Start(); void Stop(); } class RegularTimer : ITimer { public void Start() { } public void Stop() { } } class OneShotTimer : ITimer { public void Start() { } public void Stop() { } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "using System;\nusing System.IO;\n\nclass FileProcessor\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\n            return \"Ready for processing\";\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n\n    public virtual void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n\n    public override void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\n        throw new InvalidOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "using System;\nusing System.IO;\n\nclass FileStatusProvider\n{\n    public virtual string GetStatus(string filePath)\n    {\n         if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Found.\");\n            return \"Ready for status check\";\n        }\n        else\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n}\n\nclass FileProcessor : FileStatusProvider\n{\n    public void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Processor: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Processor: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Processor: File {filePath} processed successfully.\");\n    }\n\n    public override string GetStatus(string filePath)\n    {\n        string baseStatus = base.GetStatus(filePath);\n        if(baseStatus == \"Ready for status check\") return \"Ready for processing\";\n        return baseStatus;\n    }\n}\n\nclass ReadOnlyFileStatusProvider : FileStatusProvider\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnlyStatus: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n}",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "using System;\n\nclass Account\n{\n    public decimal Balance { get; protected set; } = 1000m;\n\n    public virtual void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (Balance >= amount)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : Account\n{\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public override void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount <= MaxWithdrawalLimit)\n        {\n            if (Balance >= amount)\n            {\n                Balance -= amount;\n                Console.WriteLine($\"Limited (Small): Successfully withdrew {amount}. New Balance: {Balance}\");\n            }\n            else\n            {\n                 Console.WriteLine($\"Limited (Small): Insufficient funds for withdrawal ({amount}). Balance: {Balance}\");\n            }\n        }\n        else\n        {\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\n        }\n    }\n}",
      "output": "using System;\n\ninterface IAccount\n{\n    void Withdraw(decimal amount);\n    decimal GetBalance();\n}\n\nclass ActiveAccount : IAccount\n{\n    private decimal _balance = 1000m;\n\n    public decimal GetBalance()\n    {\n        return _balance;\n    }\n\n    public void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (_balance >= amount)\n        {\n            _balance -= amount;\n            Console.WriteLine($\"Active: Successfully withdrew {amount}. New Balance: {_balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Active: Insufficient funds. Cannot withdraw {amount}. Balance: {_balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : IAccount\n{\n    private decimal _balance = 1000m;\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public decimal GetBalance()\n    {\n        return _balance;\n    }\n\n    public void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount > MaxWithdrawalLimit)\n        {\n            Console.WriteLine($\"Limited: Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {_balance}\");\n        }\n        else if (_balance >= amount)\n        {\n            _balance -= amount;\n            Console.WriteLine($\"Limited: Successfully withdrew {amount}. New Balance: {_balance}\");\n        }\n        else\n        {\n             Console.WriteLine($\"Limited: Insufficient funds for withdrawal ({amount}). Balance: {_balance}\");\n        }\n    }\n}",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
      "output": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP"
    },
    {
      "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class CollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : CollectionProcessor\n{\n    public override void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ViolatingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n             var item = data[i];\n             Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\n             System.Threading.Thread.Sleep(10);\n\n             if (item.StartsWith(\"B\"))\n             {\n                 Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\n                 data.RemoveAt(i);\n                 i--;\n             }\n        }\n        Console.WriteLine(\"[ViolatingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n",
      "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic interface ICollectionProcessor\n{\n    void ProcessCollection(IEnumerable<string> data);\n}\n\npublic class StandardCollectionProcessor : ICollectionProcessor\n{\n    public void ProcessCollection(IEnumerable<string> data)\n    {\n        Console.WriteLine(\"[StandardProcessor] Starting processing...\");\n        foreach (var item in data.ToList())\n        {\n            Console.WriteLine($\"[StandardProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[StandardProcessor] Processing finished.\");\n    }\n}\n",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP"
    }
  ]
}