{
  "code_examples": [
    {
      "input": "class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Bird bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Ostrich());\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original code violated LSP because the `Ostrich` class threw an exception when the `fly` method was called, breaking the expected behavior of the `Bird` class. The refactored code introduces an abstract class `Bird` with an abstract `fly` method, allowing subclasses to provide their own implementation without violating the contract."
    },
    {
      "input": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Square();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original code violated the Liskov Substitution Principle because the `Square` class did not behave as a proper subclass of `Rectangle`. The refactored code introduces an abstract `Shape` class, ensuring that both `Rectangle` and `Square` implement their own logic for setting dimensions and calculating area, thus maintaining the expected behavior."
    },
    {
      "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        throw new RuntimeException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The `Dog` class previously threw an exception when `makeSound` was called, violating the Liskov Substitution Principle. Now, it properly overrides the method to provide a valid implementation, ensuring that subclasses can be used interchangeably with their base class."
    },
    {
      "input": "class Payment {\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original `FreePayment` class violated the Liskov Substitution Principle by throwing an exception when the `pay` method was called, which is not expected behavior for a subclass. The refactored code introduces an abstract class `Payment` and ensures that all subclasses implement the `pay` method without throwing exceptions, thus adhering to LSP."
    },
    {
      "input": "class Vehicle {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.startEngine();\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original `Bicycle` class violated the Liskov Substitution Principle by throwing an exception when `startEngine` was called, which is not expected behavior for a subclass. The refactored code introduces an abstract class `Vehicle` and ensures that all subclasses provide a valid implementation of `startEngine`, thus adhering to LSP."
    },
    {
      "input": "class FileReader {\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original `SecureFileReader` class violated the Liskov Substitution Principle by throwing a `SecurityException`, which breaks the expected behavior of the `read` method in the base class. The refactored code introduces an abstract class `FileReader` and separates the implementations into `RegularFileReader` and `SecureFileReader`, ensuring that all subclasses adhere to the expected contract of the base class."
    },
    {
      "input": "class Writer {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original `ReadOnlyWriter` class violated the Liskov Substitution Principle by throwing an exception when the `write` method was called, which is not expected behavior for a subclass. The refactored code introduces an abstract class `Writer` and a concrete implementation `ConcreteWriter`, ensuring that all subclasses adhere to the expected behavior of the base class."
    },
    {
      "input": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 0));\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original `SafeCalculator` class violated LSP by throwing an exception in a method that was expected to behave like its superclass `Calculator`. The refactored code now maintains the contract of the base class by calling `super.divide(a, b)` for valid inputs and handling the exception gracefully in the `Main` class."
    },
    {
      "input": "class Shape {\n    \n    \n    public double area() {\n        System.out.println(\"Base Shape Area: 0.0\");\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    \n    \n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: \" + Double.NaN + \" (Violation)\");\n        return Double.NaN;\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The refactoring ensures that the `NullShape` class adheres to the contract established by the `Shape` class. Instead of returning `Double.NaN`, which violates the expected behavior of returning a non-negative value, it now throws an exception, maintaining the integrity of the Liskov Substitution Principle."
    },
    {
      "input": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\nclass FileProcessor {\n    \n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    \n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    \n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    \n    \n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The refactoring introduces an abstract class `FileProcessor` that defines the contract for file processing. The `WritableFileProcessor` class implements the processing logic, while `ReadOnlyFileProcessor` adheres to the contract without breaking it. This resolves the LSP violation by ensuring that all subclasses can be used interchangeably without unexpected behavior."
    },
    {
      "input": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        \n        \n        fakeMessagesLogged++;\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The `SilentCounterLogger` class was overriding the `log` method in a way that did not fulfill the expected behavior of the base class `Logger`, which could lead to confusion. The refactoring ensures that `SilentCounterLogger` maintains its own logging count while still adhering to the contract of the base class."
    },
    {
      "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    \n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        \n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    \n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        \n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    \n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        \n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        \n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n        \n        \n        \n    }\n\n    \n    \n\n    \n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        \n        \n        \n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}\n\n\n",
      "output": "",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original `ReadOnlyDataProcessor` class violated the Liskov Substitution Principle (LSP) by overriding the `saveResults` method to throw an exception, which was not expected behavior from the base class. The refactored code makes `saveResults` an abstract method in the base class, allowing subclasses to define their own behavior without breaking the contract. The `ReadOnlyDataProcessor` now simply returns false to indicate that saving is not supported, maintaining LSP compliance."
    },
    {
      "input": "class Bird:\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise Exception('Ostriches cannot fly')",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original code violated the Liskov Substitution Principle because the `Ostrich` class threw an exception when calling the `fly` method, which breaks the expected behavior of the `Bird` class. The refactored code removes the `fly` method from `Ostrich`, ensuring that it adheres to the contract of the base class without causing exceptions."
    },
    {
      "input": "class Rectangle:\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.height = height\n        self.width = height",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original `Square` class violated the Liskov Substitution Principle by overriding the `setWidth` and `setHeight` methods in a way that changed the expected behavior of the `Rectangle` class. The refactored code maintains the contract of the base class while ensuring that `Square` behaves correctly as a subclass."
    },
    {
      "input": "class Animal:\n    def make_sound(self):\n        print('Some sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        raise NotImplementedError('Fish cannot make sounds')",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The Fish class previously raised an exception when calling makeSound, violating the Liskov Substitution Principle. Now, it provides a no-op implementation, allowing it to be used interchangeably with other Animal subclasses without breaking the expected behavior."
    },
    {
      "input": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The `ReadOnlyWriter` class violates the Liskov Substitution Principle by throwing an exception in the overridden `write` method, which breaks the expected behavior of the base class. The refactored code maintains the contract of the base class by using an exception that indicates unsupported operations without altering the expected interface behavior."
    },
    {
      "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The subclass `FreePaymentProcessor` previously threw a generic exception that violated the expected behavior of the base class `PaymentProcessor`. The refactored code now throws a more specific `UnsupportedOperationException`, maintaining the contract of the base class while clearly indicating the restriction for free accounts."
    },
    {
      "input": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The subclass `SecureDocument` violates the Liskov Substitution Principle by throwing an exception when the `printDocument` method is called, which breaks the expected behavior of the base class `Document`. The refactored code maintains the contract of the base class by using an `UnsupportedOperationException`, which is a more appropriate way to indicate that the operation is not supported."
    },
    {
      "input": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The subclass `Bicycle` violates the Liskov Substitution Principle by throwing an exception when `startEngine` is called, which breaks the expected behavior of the base class `Vehicle`. The refactored code maintains the contract of the base class by allowing subclasses to implement the method without throwing exceptions."
    },
    {
      "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise Exception('Cannot send email')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The subclass `NullEmailSender` violates the Liskov Substitution Principle by throwing an exception when the `sendEmail` method is called, which is not expected behavior from the base class. The refactored code ensures that `NullEmailSender` adheres to the contract of `EmailSender` by throwing a more appropriate exception type."
    },
    {
      "input": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor(DataProcessor):\n    def __init__(self):\n        super().__init__()\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "output": "",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original `ReadOnlyDataProcessor` class violated the Liskov Substitution Principle by raising an exception in the `save_results` method, which is not expected behavior for a subclass. The refactored version now returns `False` instead of raising an exception, maintaining the expected behavior of the base class."
    },
    {
      "input": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentCounterLogger(Logger):\n    def __init__(self):\n        super().__init__()\n        self._fake_messages_logged = 0\n\n    def log(self, message):\n        self._fake_messages_logged += 1\n",
      "output": "",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The `SilentCounterLogger` class violates the Liskov Substitution Principle because it overrides the `log` method in a way that changes the expected behavior of the base class. The refactored code ensures that both classes maintain consistent logging behavior and message counting, aligning with the expectations set by the base class."
    },
    {
      "input": "import os # Using os module for file operations\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return # Simplified: graceful exit if file missing\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\n\n\n\n\n",
      "output": "",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The `process_file` method in `ReadOnlyFileProcessor` previously raised a `RuntimeError`, violating the Liskov Substitution Principle (LSP) by breaking the expected behavior of the base class. The refactored code now returns a message instead of raising an exception, ensuring that the derived class can be used interchangeably with the base class without unexpected behavior."
    },
    {
      "input": "import math\n\nclass Shape:\n    def area(self):\n        print(\"Base Shape Area: 0.0\")\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        print(f\"Null Shape Area: {float('nan')} (Violation)\")\n        return float('nan') # Returning NaN is a subtle violation\n\n\n\n\n",
      "output": "",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The `NullShape` class previously violated the Liskov Substitution Principle by returning `float('nan')`, which is not a valid area. The refactored code ensures that `NullShape` returns `0.0`, maintaining the contract that `area()` should return a non-negative float."
    },
    {
      "input": "open class Bird {\n    open fun fly() {}\n}\n\nclass Ostrich : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun makeBirdFly(bird: Bird) {\n    bird.fly()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdFly(ostrich)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The original code violated the Liskov Substitution Principle because the `Ostrich` class incorrectly implemented the `fly` method, throwing an exception. The refactored code introduces a `FlyingBird` subclass to represent birds that can fly, ensuring that `Ostrich` does not override `fly`, thus maintaining the contract of the base class."
    },
    {
      "input": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override fun setWidth(w: Int) {\n        width = w\n        height = w\n    }\n    override fun setHeight(h: Int) {\n        width = h\n        height = h\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `Square` class violates the Liskov Substitution Principle because it alters the behavior of the `setWidth` and `setHeight` methods in a way that can lead to unexpected results when a `Square` is used in place of a `Rectangle`. The refactoring maintains the original behavior of the `Rectangle` class while ensuring that the `Square` class adheres to the expected contract."
    },
    {
      "input": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `Fish` class previously threw an exception when `makeSound` was called, violating the Liskov Substitution Principle. Now, it provides a valid implementation of `makeSound`, ensuring that all subclasses can be used interchangeably without causing errors."
    },
    {
      "input": "open class Payment {\n    open fun pay(amount: Double) {}\n}\n\nclass CashPayment : Payment() {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment() {\n    override fun pay(amount: Double) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `CreditPayment` class previously threw an exception when the `pay` method was called, violating the Liskov Substitution Principle (LSP). Now, it provides a valid implementation of the `pay` method, ensuring that all subclasses can be used interchangeably without breaking the expected behavior."
    },
    {
      "input": "open class Writer {\n    open fun write(data: String) {}\n}\n\nclass FileWriter : Writer() {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nclass ReadOnlyFileWriter : Writer() {\n    override fun write(data: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val readOnly = ReadOnlyFileWriter()\n    save(readOnly, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `ReadOnlyFileWriter` class previously violated LSP by overriding the `write` method in a way that threw an exception. The refactoring removed the `write` method from `ReadOnlyFileWriter`, ensuring that it does not break the contract of the base class `Writer`. The `save` function now checks the type of writer before calling `write`, preventing misuse."
    },
    {
      "input": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    override fun startEngine() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The Bicycle class previously violated the Liskov Substitution Principle by throwing an exception when startEngine was called, which is not expected behavior for a subclass. The refactored code removes the override, allowing Bicycle to be used without breaking the contract of the Vehicle class."
    },
    {
      "input": "open class Notification {\n    open fun send(message: String) {}\n}\n\nclass EmailNotification : Notification() {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nclass SilentNotification : Notification() {\n    override fun send(message: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val silent = SilentNotification()\n    notifyUser(silent, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `SilentNotification` class previously threw an exception when the `send` method was called, violating the Liskov Substitution Principle (LSP). The refactored code ensures that `SilentNotification` does not throw an exception, allowing it to be used interchangeably with other `Notification` subclasses without breaking the expected behavior."
    },
    {
      "input": "open class Printer {\n    open fun printDocument(document: String) {}\n}\n\nclass NetworkPrinter : Printer() {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nclass DummyPrinter : Printer() {\n    override fun printDocument(document: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val dummy = DummyPrinter()\n    print(dummy, \"Test\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `DummyPrinter` class previously threw an exception when attempting to print, violating the Liskov Substitution Principle. Now it provides a valid implementation that indicates it does not print, allowing it to be used interchangeably with other `Printer` subclasses without breaking the expected behavior."
    },
    {
      "input": "open class Logger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    open fun log(message: String) {\n        println(\"[BASE LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentCounterLogger : Logger() {\n    private var fakeMessagesLogged: Int = 0\n\n    override fun log(message: String) {\n        fakeMessagesLogged++\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `SilentCounterLogger` class overrides the `log` method in a way that changes the expected behavior of the base class, violating the Liskov Substitution Principle. The refactored code introduces a `ConsoleLogger` that adheres to the expected behavior, ensuring that all subclasses can be used interchangeably without altering the expected functionality."
    },
    {
      "input": "import java.util.concurrent.CopyOnWriteArrayList\n\nopen class Logger {\n    open fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger() {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `NonThreadSafeLogger` class overrides the `log` method in a way that changes the expected behavior of the base `Logger` class, which is to log messages immediately. The refactoring maintains the contract of the base class while allowing for the specific behavior of the subclass."
    },
    {
      "input": "open class Shape {\n    open fun area(): Double {\n        println(\"Base Shape Area: 0.0\")\n        return 0.0\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        println(\"Null Shape Area: ${Double.NaN} (Violation)\")\n        return Double.NaN\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `NullShape` class previously returned `Double.NaN`, which violates the Liskov Substitution Principle by breaking the expected behavior of the `area` method. The refactored code now returns `0.0`, maintaining consistency with the base class."
    },
    {
      "input": "import java.io.File\n\nopen class FileProcessor {\n    open fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"Base: Checking status for $filePath - Found.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"Base: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    open fun processFile(filePath: String) {\n        println(\"Base: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n            println(\"Base: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"Base: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor() {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnly: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"ReadOnly: Attempted to process file $filePath.\")\n        throw UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The `ReadOnlyFileProcessor` class previously threw an exception when attempting to process a file, which violated the Liskov Substitution Principle. Now, it simply indicates that processing is not allowed without throwing an exception, ensuring that it adheres to the expected behavior of the base class."
    },
    {
      "input": "class Bird { public virtual void Fly() { } } class Ostrich : Bird { public override void Fly() { throw new Exception(); } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original code violated the Liskov Substitution Principle because the `Ostrich` class threw an exception when the `fly` method was called, breaking the expected behavior of the `Bird` class. The refactored code introduces a `FlyingBird` subclass to handle flying behavior, allowing `Ostrich` to inherit from `Bird` without violating the contract."
    },
    {
      "input": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width * Height; } } class Square : Rectangle { public override int Width { get => base.Width; set { base.Width = value; base.Height = value; } } public override int Height { get => base.Height; set { base.Width = value; base.Height = value; } } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original implementation of `Square` violated the Liskov Substitution Principle by overriding the `setWidth` and `setHeight` methods in a way that changed the expected behavior of the `Rectangle` class. The refactored code maintains the contract of the base class while ensuring that `Square` behaves correctly as a rectangle with equal width and height."
    },
    {
      "input": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The subclass `Fish` previously threw a `NotImplementedException`, which violates the Liskov Substitution Principle. The refactored code provides a valid implementation that does not break the contract of the base class."
    },
    {
      "input": "class Payment { public virtual void Pay() { } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original `FreePayment` class violated the Liskov Substitution Principle by throwing an exception in the overridden `Pay` method. The refactored code provides a default implementation in the base class and allows `FreePayment` to override it without throwing exceptions, ensuring that it can be used interchangeably with other `Payment` subclasses."
    },
    {
      "input": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The subclass `ReadOnlyFileWriter` violates the Liskov Substitution Principle by throwing an exception when the `write` method is called, which breaks the expected behavior of the base class `FileWriter`. The refactored code clarifies the intention by throwing a more specific exception, indicating that writing is not supported, thus maintaining the contract of the base class."
    },
    {
      "input": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new NotImplementedException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The Bicycle class previously threw an exception when trying to start the engine, which violates the Liskov Substitution Principle. The refactored code removes the override, ensuring that all subclasses can be used interchangeably without breaking the expected behavior."
    },
    {
      "input": "class Document { public virtual void Print() { } } class DigitalDocument : Document { public override void Print() { throw new NotSupportedException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original `DigitalDocument` class threw an exception when attempting to print, violating the Liskov Substitution Principle. The refactored code introduces a `PrintableDocument` class to ensure that only documents that can be printed implement the print functionality, allowing for proper substitution without exceptions."
    },
    {
      "input": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Stop() { throw new NotSupportedException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original `OneShotTimer` class violated the Liskov Substitution Principle by overriding the `Stop` method to throw an exception, which breaks the expected behavior of the base class. The refactored code introduces an abstract class `Timer` and ensures that all subclasses implement the `start` and `stop` methods, allowing for proper behavior without exceptions."
    },
    {
      "input": "using System;\nusing System.IO;\n\nclass FileProcessor\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\n            return \"Ready for processing\";\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n\n    public virtual void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n\n    public override void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\n        throw new InvalidOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original `ReadOnlyFileProcessor` class violated the Liskov Substitution Principle by throwing an exception in the `ProcessFile` method, which is not expected behavior for a `FileProcessor`. The refactored code introduces an abstract base class `FileProcessor` and separates the writable and read-only functionalities into distinct subclasses, ensuring that each subclass adheres to the expected behavior of the base class."
    },
    {
      "input": "using System;\n\nclass Account\n{\n    public decimal Balance { get; protected set; } = 1000m;\n\n    public virtual void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (Balance >= amount)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : Account\n{\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public override void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount <= MaxWithdrawalLimit)\n        {\n            if (Balance >= amount)\n            {\n                Balance -= amount;\n                Console.WriteLine($\"Limited (Small): Successfully withdrew {amount}. New Balance: {Balance}\");\n            }\n            else\n            {\n                 Console.WriteLine($\"Limited (Small): Insufficient funds for withdrawal ({amount}). Balance: {Balance}\");\n            }\n        }\n        else\n        {\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\n        }\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The `LimitedWithdrawalAccount` class previously had its own withdrawal logic that conflicted with the base class's contract, potentially leading to unexpected behavior. The refactored code now uses the base class's `Withdraw` method for valid withdrawals, ensuring that the subclass adheres to the base class's contract, thus following the Liskov Substitution Principle (LSP)."
    },
    {
      "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The subclass `LoggerWithIncorrectTimestamp` violated the Liskov Substitution Principle by using a fixed timestamp that could lead to unexpected behavior when substituting it for the base class. The refactored version uses a more appropriately named class `LoggerWithFixedTimestamp` to clarify its behavior while maintaining the contract of the base class."
    },
    {
      "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class CollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : CollectionProcessor\n{\n    public override void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ViolatingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n             var item = data[i];\n             Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\n             System.Threading.Thread.Sleep(10);\n\n             if (item.StartsWith(\"B\"))\n             {\n                 Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\n                 data.RemoveAt(i);\n                 i--;\n             }\n        }\n        Console.WriteLine(\"[ViolatingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n\n",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original `ModifyingCollectionProcessor` class modified the collection while iterating over it, which can lead to unexpected behavior and violates the Liskov Substitution Principle. The refactored code first collects items to remove and then processes the removal in a separate loop, ensuring that the base class's contract is upheld."
    }
  ]
}