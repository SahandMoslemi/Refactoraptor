{
  "code_examples": [
    {
      "input": "class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Bird bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Ostrich());\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The code violates the Liskov Substitution Principle because the `Ostrich` class cannot fulfill the contract of the `Bird` class, which expects all birds to be able to fly. The refactoring adds a check in the `makeBirdFly` method to prevent an `Ostrich` from being passed, thus adhering to the LSP."
    },
    {
      "input": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Square();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle because a Square cannot be substituted for a Rectangle without altering the expected behavior. The refactored code separates the Rectangle and Square classes, ensuring that they adhere to their respective behaviors without causing unexpected results."
    },
    {
      "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        throw new RuntimeException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle because the `Dog` class does not provide a valid implementation of the `makeSound` method, which could lead to unexpected behavior when substituting `Dog` for `Animal`. The refactored code ensures that `Dog` correctly implements the `makeSound` method, adhering to the expected behavior of the `Animal` class."
    },
    {
      "input": "class Payment {\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The code violates the Liskov Substitution Principle because the `FreePayment` class cannot be used interchangeably with the `Payment` class without causing an exception. This breaks the expected behavior of the superclass."
    },
    {
      "input": "class Vehicle {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.startEngine();\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The refactoring addresses the Liskov Substitution Principle violation by handling the unsupported operation in the `Bicycle` class gracefully, allowing the program to continue running without throwing an exception that disrupts the flow."
    },
    {
      "input": "class FileReader {\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "SRP",
      "explanation": "This refactoring separates the responsibilities of reading a file and handling security, adhering to the Single Responsibility Principle. The `SecureFileReader` now only handles security concerns, while `FileReader` is responsible for reading files."
    },
    {
      "input": "class Writer {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "SRP",
      "explanation": "This class violates the Single Responsibility Principle because it handles both user data management and email sending responsibilities."
    },
    {
      "input": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 0));\n    }\n}",
      "output": "",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "SRP",
      "explanation": "This refactoring separates the responsibilities of performing calculations and ensuring safety in calculations, adhering to the Single Responsibility Principle."
    },
    {
      "input": "class Shape {\n    \n    \n    public double area() {\n        System.out.println(\"Base Shape Area: 0.0\");\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    \n    \n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: \" + Double.NaN + \" (Violation)\");\n        return Double.NaN;\n    }\n}",
      "output": "class Shape {\n    public double area() {\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        throw new UnsupportedOperationException(\"Area is not defined for NullShape\");\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The refactoring addresses the Liskov Substitution Principle violation by ensuring that the NullShape class does not return a nonsensical value (Double.NaN) for the area method. Instead, it throws an exception, making it clear that the operation is not valid for this subclass."
    },
    {
      "input": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\nclass FileProcessor {\n    \n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    \n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    \n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    \n    \n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "class FileProcessor {\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    // Refactored to comply with LSP by not overriding processFile\n    // Instead, we can provide a method that indicates the read-only nature\n    public void readFile(String filePath) {\n        System.out.println(\"Reading file: \" + filePath);\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The refactoring addresses the Liskov Substitution Principle violation by removing the overridden processFile method in ReadOnlyFileProcessor, which threw an exception. Instead, a new method readFile is introduced to handle read-only operations, ensuring that the subclass can be used interchangeably with the base class without breaking expectations."
    },
    {
      "input": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        \n        \n        fakeMessagesLogged++;\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "JAVA",
      "violation": "SRP",
      "explanation": "The `SilentCounterLogger` class violates the Single Responsibility Principle because it extends the `Logger` class but does not fulfill the logging responsibility, leading to confusion and unexpected behavior."
    },
    {
      "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    \n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        \n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    \n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        \n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    \n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        \n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        \n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n        \n        \n        \n    }\n\n    \n    \n\n    \n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        \n        \n        \n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}\n\n\n",
      "output": "class ReadOnlyDataProcessor extends DataProcessor {\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Cannot save results.\");\n        return false; // Instead of throwing an exception, return false to indicate failure\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "The refactoring changes the saveResults method in ReadOnlyDataProcessor to return false instead of throwing an exception. This adheres to the Liskov Substitution Principle (LSP) by ensuring that the derived class can be used interchangeably with the base class without introducing unexpected behavior."
    },
    {
      "input": "class Bird:\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise Exception('Ostriches cannot fly')",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle because the `Ostrich` class cannot fulfill the contract of the `Bird` class, which expects all subclasses to be able to fly. The refactored code ensures that `Ostrich` does not override the `fly` method, thus adhering to the LSP."
    },
    {
      "input": "class Rectangle:\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.height = height\n        self.width = height",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle because the `Square` class does not behave as a proper subclass of `Rectangle`. The area calculation does not hold true when using a `Square` object in place of a `Rectangle`. The refactored code ensures that `Square` maintains the expected behavior of `Rectangle` by overriding the methods to keep width and height consistent."
    },
    {
      "input": "class Animal:\n    def make_sound(self):\n        print('Some sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        raise NotImplementedError('Fish cannot make sounds')",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original Fish class violates the Liskov Substitution Principle because it raises an error when the make_sound method is called, which is unexpected behavior for a subclass of Animal. The refactored code ensures that Fish can be used interchangeably with Animal without causing errors, thus adhering to LSP."
    },
    {
      "input": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
      "output": "",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "This class violates the Single Responsibility Principle because it handles both user data management and email sending, which are two distinct responsibilities."
    },
    {
      "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "This refactoring separates the responsibilities of processing payments into distinct classes, adhering to the Single Responsibility Principle. The `PaymentProcessor` class handles general payment processing, while the `FreePaymentProcessor` class specifically manages the rules for free accounts."
    },
    {
      "input": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "This class violates the Single Responsibility Principle because it has two responsibilities: printing and encrypting documents. Each responsibility should be handled by a separate class to adhere to SRP."
    },
    {
      "input": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The Bicycle class violates the Liskov Substitution Principle because it cannot be used interchangeably with its parent class Vehicle without causing an exception. The refactoring ensures that the Bicycle class does not override the startEngine method in a way that breaks the expected behavior of the Vehicle class."
    },
    {
      "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise Exception('Cannot send email')",
      "output": "",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "The original code violates the Single Responsibility Principle because the `EmailSender` class is responsible for both sending emails and handling the case where sending is not possible. By separating the `NullEmailSender`, we ensure that each class has a single responsibility."
    },
    {
      "input": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor(DataProcessor):\n    def __init__(self):\n        super().__init__()\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "output": "class DataLoader:\n    def load_data(self, source):\n        print(f\"Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            return {\"key1\": \"value1\", \"key2\": 42}\n        else:\n            return None\n\nclass DataProcessor:\n    def __init__(self, data):\n        self._data = data\n\n    def process_data(self):\n        print(\"Processing data...\")\n        if self._data is None:\n            print(\"No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Data processed.\")\n        return True\n\nclass DataSaver:\n    def save_results(self, data, destination):\n        print(f\"Saving results to {destination}...\")\n        if data is None or not data.get(\"processed\"):\n            print(\"No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor:\n    def __init__(self):\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        print(f\"Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "The original code violates the Single Responsibility Principle (SRP) because the DataProcessor class handles loading, processing, and saving data, which are distinct responsibilities. The refactored code separates these concerns into three classes: DataLoader for loading data, DataProcessor for processing data, and DataSaver for saving data. This adheres to SRP by ensuring each class has a single responsibility."
    },
    {
      "input": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentCounterLogger(Logger):\n    def __init__(self):\n        super().__init__()\n        self._fake_messages_logged = 0\n\n    def log(self, message):\n        self._fake_messages_logged += 1\n",
      "output": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentLogger:\n    def log(self, message):\n        # This logger does not log anything\n        pass\n\nclass Counter:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def increment(self):\n        self._messages_logged += 1\n\n    def get_count(self):\n        return self._messages_logged\n\nclass SilentCounterLogger:\n    def __init__(self, counter):\n        self._counter = counter\n\n    def log(self, message):\n        self._counter.increment()",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "The refactoring separates the responsibilities of logging and counting messages into distinct classes. The Logger class handles logging, while the Counter class manages the counting of messages. The SilentCounterLogger now only interacts with the Counter, ensuring that each class has a single responsibility."
    },
    {
      "input": "import os # Using os module for file operations\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return # Simplified: graceful exit if file missing\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\n\n\n\n\n",
      "output": "class FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Cannot process file {file_path} - Read-only access.\")\n        return \"Cannot process file in read-only mode.\"",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The refactored code modifies the `process_file` method in the `ReadOnlyFileProcessor` class to no longer raise an exception. Instead, it provides a message indicating that the file cannot be processed due to read-only access. This adheres to the Liskov Substitution Principle (LSP) by ensuring that the derived class can be used interchangeably with the base class without causing unexpected behavior."
    },
    {
      "input": "import math\n\nclass Shape:\n    def area(self):\n        print(\"Base Shape Area: 0.0\")\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        print(f\"Null Shape Area: {float('nan')} (Violation)\")\n        return float('nan') # Returning NaN is a subtle violation\n\n\n\n\n",
      "output": "",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The refactoring changes the `NullShape` class to return 0.0 instead of NaN, ensuring that it adheres to the contract established by the `Shape` class. This resolves the violation of the Liskov Substitution Principle, as now both `Shape` and `NullShape` return a valid area that is consistent with expectations."
    },
    {
      "input": "open class Bird {\n    open fun fly() {}\n}\n\nclass Ostrich : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun makeBirdFly(bird: Bird) {\n    bird.fly()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdFly(ostrich)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The code violates the Liskov Substitution Principle because the `Ostrich` class cannot fulfill the contract of the `Bird` class, which expects all birds to be able to fly. The refactoring adds a check to handle the unsupported operation gracefully."
    },
    {
      "input": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override fun setWidth(w: Int) {\n        width = w\n        height = w\n    }\n    override fun setHeight(h: Int) {\n        width = h\n        height = h\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The code violates the Liskov Substitution Principle because the `Square` class does not behave as a true subtype of `Rectangle`. When a `Square` is passed to the `resizeRectangle` function, it does not maintain the expected behavior of a rectangle, leading to incorrect results. To fix this, we can separate the `Square` and `Rectangle` classes to ensure they adhere to their respective behaviors."
    },
    {
      "input": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The Fish class violates the Liskov Substitution Principle because it cannot fulfill the contract of the Animal class by providing a valid implementation of the makeSound method. The refactoring adds an exception message to clarify the issue when a Fish instance is used."
    },
    {
      "input": "open class Payment {\n    open fun pay(amount: Double) {}\n}\n\nclass CashPayment : Payment() {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment() {\n    override fun pay(amount: Double) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The original `CreditPayment` class threw an `UnsupportedOperationException`, violating the Liskov Substitution Principle. The refactored code ensures that all subclasses of `Payment` can be used interchangeably without causing errors."
    },
    {
      "input": "open class Writer {\n    open fun write(data: String) {}\n}\n\nclass FileWriter : Writer() {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nclass ReadOnlyFileWriter : Writer() {\n    override fun write(data: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val readOnly = ReadOnlyFileWriter()\n    save(readOnly, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "SRP",
      "explanation": "This class violates the Single Responsibility Principle because it has two responsibilities: managing user data and sending emails. Each responsibility should be handled by a separate class."
    },
    {
      "input": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    override fun startEngine() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The Bicycle class violates the Liskov Substitution Principle because it cannot fulfill the contract of the Vehicle class, which expects all subclasses to implement the startEngine method without throwing exceptions. The refactoring ensures that the Bicycle class does not override the method in a way that breaks the expected behavior."
    },
    {
      "input": "open class Notification {\n    open fun send(message: String) {}\n}\n\nclass EmailNotification : Notification() {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nclass SilentNotification : Notification() {\n    override fun send(message: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val silent = SilentNotification()\n    notifyUser(silent, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle because the `SilentNotification` class does not fulfill the contract of the `Notification` class, as it throws an exception when the `send` method is called. The refactored code maintains the same interface while ensuring that all subclasses can be used interchangeably without causing unexpected behavior."
    },
    {
      "input": "open class Printer {\n    open fun printDocument(document: String) {}\n}\n\nclass NetworkPrinter : Printer() {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nclass DummyPrinter : Printer() {\n    override fun printDocument(document: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val dummy = DummyPrinter()\n    print(dummy, \"Test\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "The DummyPrinter class violates the Liskov Substitution Principle because it cannot be used interchangeably with the Printer class without causing an exception. The refactoring ensures that all subclasses of Printer can handle the printDocument method appropriately."
    },
    {
      "input": "open class Logger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    open fun log(message: String) {\n        println(\"[BASE LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentCounterLogger : Logger() {\n    private var fakeMessagesLogged: Int = 0\n\n    override fun log(message: String) {\n        fakeMessagesLogged++\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "SRP",
      "explanation": "The original Logger class violates the Single Responsibility Principle as it combines the responsibilities of logging messages and counting them. The refactored code introduces a ConsoleLogger class to handle console-specific logging, separating concerns and adhering to SRP."
    },
    {
      "input": "import java.util.concurrent.CopyOnWriteArrayList\n\nopen class Logger {\n    open fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger() {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "SRP",
      "explanation": "{\"violation_type\":\"SRP\",\"refactored_code\":\"import java.util.concurrent.CopyOnWriteArrayList\\n\\nopen class Logger {\\n    open fun log(message: String) {\\n        println(\\\"[SAFE LOG] \\$message\\\")\\n    }\\n}\\n\\nclass NonThreadSafeLogger : Logger() {\\n    private val logBuffer = mutableListOf<String>()\\n\\n    override fun log(message: String) {\\n        logBuffer.add(message)\\n    }\\n\\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\\n}\\n\\nclass LogBuffer {\\n    private val logBuffer = mutableListOf<String>()\\n\\n    fun addLog(message: String) {\\n        logBuffer.add(message)\\n    }\\n\\n    fun getContents(): List<String> = logBuffer.toList()\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle because the NonThreadSafeLogger class is responsible for both logging messages and managing the log buffer. The refactored code separates the concerns by introducing a LogBuffer class that handles the log storage, allowing the NonThreadSafeLogger to focus solely on logging.\"}"
    },
    {
      "input": "open class Shape {\n    open fun area(): Double {\n        println(\"Base Shape Area: 0.0\")\n        return 0.0\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        println(\"Null Shape Area: ${Double.NaN} (Violation)\")\n        return Double.NaN\n    }\n}",
      "output": "open class Shape {\n    open fun area(): Double {\n        return 0.0\n    }\n}\n\nclass Circle(private val radius: Double) : Shape() {\n    override fun area(): Double {\n        return Math.PI  radius  radius\n    }\n}\n\nclass Square(private val side: Double) : Shape() {\n    override fun area(): Double {\n        return side  side\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        return Double.NaN\n    }\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "SRP",
      "explanation": "The original code had a single class handling multiple shape types and a null shape, which violates the Single Responsibility Principle. The refactored code separates the responsibilities into distinct classes for each shape, allowing each class to focus on its specific behavior."
    },
    {
      "input": "import java.io.File\n\nopen class FileProcessor {\n    open fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"Base: Checking status for $filePath - Found.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"Base: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    open fun processFile(filePath: String) {\n        println(\"Base: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n            println(\"Base: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"Base: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor() {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnly: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"ReadOnly: Attempted to process file $filePath.\")\n        throw UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "SRP",
      "explanation": "{\"violation_type\":\"SRP\",\"refactored_code\":\"import java.io.File\\n\\ninterface FileStatusChecker {\\n    fun getStatus(filePath: String): String\\n}\\n\\ninterface FileProcessor {\\n    fun processFile(filePath: String)\\n}\\n\\nclass BasicFileProcessor : FileStatusChecker, FileProcessor {\\n    override fun getStatus(filePath: String): String {\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            println(\\\"Base: Checking status for \\$filePath - Found.\\\")\\n            \\\"Ready for processing\\\"\\n        } else {\\n            println(\\\"Base: Checking status for \\$filePath - Not Found.\\\")\\n            \\\"File not found\\\"\\n        }\\n    }\\n\\n    override fun processFile(filePath: String) {\\n        println(\\\"Base: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"Base: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"Base: File \\$filePath processed successfully.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor(private val fileStatusChecker: FileStatusChecker) : FileProcessor {\\n    override fun processFile(filePath: String) {\\n        println(\\\"ReadOnly: Attempted to process file \\$filePath.\\\")\\n        throw UnsupportedOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\")\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `FileProcessor` class handles both file status checking and file processing. By separating the responsibilities into two interfaces (`FileStatusChecker` and `FileProcessor`), we ensure that each class has a single responsibility. The `BasicFileProcessor` implements both interfaces, while `ReadOnlyFileProcessor` only implements the `FileProcessor` interface, thus adhering to SRP.\"}"
    },
    {
      "input": "class Bird { public virtual void Fly() { } } class Ostrich : Bird { public override void Fly() { throw new Exception(); } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle because the `Ostrich` class does not fulfill the contract of the `Bird` class by throwing an exception when `fly()` is called. The refactored code introduces an abstract class `Bird` and separates the flying behavior into subclasses, ensuring that all subclasses can be used interchangeably without causing errors."
    },
    {
      "input": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width * Height; } } class Square : Rectangle { public override int Width { get => base.Width; set { base.Width = value; base.Height = value; } } public override int Height { get => base.Height; set { base.Width = value; base.Height = value; } } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "SRP",
      "explanation": "This refactoring separates the responsibilities of `Rectangle` and `Square`, adhering to the Single Responsibility Principle. Each class now has a single reason to change: `Rectangle` for width and height, and `Square` for its side length."
    },
    {
      "input": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "SRP",
      "explanation": "This class violates the Single Responsibility Principle because it handles both user data management and email sending, which are two distinct responsibilities."
    },
    {
      "input": "class Payment { public virtual void Pay() { } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
      "output": "",
      "level": "EASY",
      "language": "C#",
      "violation": "SRP",
      "explanation": "This refactoring separates the responsibilities of payment processing and free payment handling, adhering to the Single Responsibility Principle."
    },
    {
      "input": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
      "output": "public class User { private String name; private String email; public User(String name, String email) { this.name = name; this.email = email; } public String getName() { return name; } public String getEmail() { return email; } } public class UserService { public void saveUser(User user) { // Save user to database } public void sendEmail(User user) { // Send email to user } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "SRP",
      "explanation": "The original code likely had a User class that handled both user data and email sending responsibilities. By separating the concerns into User and UserService classes, we adhere to the Single Responsibility Principle, ensuring that each class has one reason to change."
    },
    {
      "input": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new NotImplementedException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "SRP",
      "explanation": "This class violates the Single Responsibility Principle because it handles both user data management and email sending, which are two distinct responsibilities."
    },
    {
      "input": "class Document { public virtual void Print() { } } class DigitalDocument : Document { public override void Print() { throw new NotSupportedException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "SRP",
      "explanation": "This refactoring separates the responsibilities of printing and handling digital documents, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change."
    },
    {
      "input": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Stop() { throw new NotSupportedException(); } }",
      "output": "",
      "level": "MODERATE",
      "language": "C#",
      "violation": "SRP",
      "explanation": "The original code violates the Single Responsibility Principle because the `OneShotTimer` class inherits from `Timer`, which implies that it should have the same responsibilities, but it does not support the `stop` functionality. By separating the classes and clearly defining their responsibilities, we adhere to SRP."
    },
    {
      "input": "using System;\nusing System.IO;\n\nclass FileProcessor\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\n            return \"Ready for processing\";\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n\n    public virtual void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n\n    public override void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\n        throw new InvalidOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "SRP",
      "explanation": "{\"violation_type\":\"SRP\",\"refactored_code\":\"public class FileStatusChecker {\\n    public string GetStatus(string filePath) {\\n        if (File.Exists(filePath)) {\\n            Console.WriteLine($\"Checking status for {filePath} - Found.\");\\n            return \\\"Ready for processing\\\";\\n        } else {\\n            Console.WriteLine($\"Checking status for {filePath} - Not Found.\");\\n            return \\\"File not found\\\";\\n        }\\n    }\\n}\\n\\npublic class FileProcessor {\\n    private readonly FileStatusChecker _statusChecker;\\n\\n    public FileProcessor(FileStatusChecker statusChecker) {\\n        _statusChecker = statusChecker;\\n    }\\n\\n    public void ProcessFile(string filePath) {\\n        Console.WriteLine($\"Processing file {filePath}...\");\\n        if (_statusChecker.GetStatus(filePath) == \\\"File not found\\\") {\\n            Console.WriteLine($\"Error - File {filePath} not found for processing.\");\\n            return;\\n        }\\n        Console.WriteLine($\"File {filePath} processed successfully.\");\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor : FileProcessor {\\n    public ReadOnlyFileProcessor(FileStatusChecker statusChecker) : base(statusChecker) {}\\n\\n    public override void ProcessFile(string filePath) {\\n        Console.WriteLine($\"Attempted to process file {filePath}.\");\\n        throw new InvalidOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\");\\n    }\\n}\",\"explanation\":\"The refactoring separates the responsibility of checking the file status into its own class (FileStatusChecker), adhering to the Single Responsibility Principle. The FileProcessor class now focuses solely on processing files, while the status checking logic is encapsulated in a dedicated class.\"}"
    },
    {
      "input": "using System;\n\nclass Account\n{\n    public decimal Balance { get; protected set; } = 1000m;\n\n    public virtual void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (Balance >= amount)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : Account\n{\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public override void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount <= MaxWithdrawalLimit)\n        {\n            if (Balance >= amount)\n            {\n                Balance -= amount;\n                Console.WriteLine($\"Limited (Small): Successfully withdrew {amount}. New Balance: {Balance}\");\n            }\n            else\n            {\n                 Console.WriteLine($\"Limited (Small): Insufficient funds for withdrawal ({amount}). Balance: {Balance}\");\n            }\n        }\n        else\n        {\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\n        }\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"LSP\",\"refactored_code\":\"using System;\\n\\nclass Account\\n{\\n    public decimal Balance { get; protected set; } = 1000m;\\n\\n    public virtual void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (Balance >= amount)\\n        {\\n            Balance -= amount;\\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\\n        }\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : Account\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public override void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount <= MaxWithdrawalLimit)\\n        {\\n            base.Withdraw(amount);\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\\n        }\\n    }\\n}\",\"explanation\":\"The refactoring ensures that the LimitedWithdrawalAccount class adheres to the Liskov Substitution Principle by calling the base class's Withdraw method for valid withdrawal amounts. This maintains the expected behavior of the base class while adding specific functionality for the derived class.\"}"
    },
    {
      "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"LSP\",\"refactored_code\":\"using System;\\n\\nclass Logger\\n{\\n    public virtual void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass LoggerWithTimestamp : Logger\\n{\\n    private readonly DateTime _creationTime;\\n\\n    public LoggerWithTimestamp()\\n    {\\n        _creationTime = DateTime.Now;\\n    }\\n\\n    public override void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original LoggerWithIncorrectTimestamp class violates the Liskov Substitution Principle because it alters the expected behavior of the base Logger class by using a fixed timestamp instead of the current time. The refactored LoggerWithTimestamp class ensures that it maintains the expected behavior while still allowing for a timestamp to be set at instantiation.\"}"
    },
    {
      "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class CollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : CollectionProcessor\n{\n    public override void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ViolatingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n             var item = data[i];\n             Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\n             System.Threading.Thread.Sleep(10);\n\n             if (item.StartsWith(\"B\"))\n             {\n                 Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\n                 data.RemoveAt(i);\n                 i--;\n             }\n        }\n        Console.WriteLine(\"[ViolatingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n\n",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"LSP\",\"refactored_code\":\"public class CollectionProcessor\\n{\\n    public virtual void ProcessCollection(List<string> data)\\n    {\\n        Console.WriteLine(\\\"[BaseProcessor] Starting processing...\\\");\\n        foreach (var item in data)\\n        {\\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\\n            System.Threading.Thread.Sleep(10);\\n        }\\n        Console.WriteLine(\\\"[BaseProcessor] Processing finished.\\\");\\n    }\\n}\\n\\npublic class ReadOnlyCollectionProcessor : CollectionProcessor\\n{\\n    public override void ProcessCollection(List<string> data)\\n    {\\n        Console.WriteLine(\\\"[ReadOnlyProcessor] Starting processing...\\\");\\n        foreach (var item in data)\\n        {\\n            Console.WriteLine($\"[ReadOnlyProcessor] Processing item: {item}\");\\n            System.Threading.Thread.Sleep(10);\\n        }\\n        Console.WriteLine(\\\"[ReadOnlyProcessor] Processing finished.\\\");\\n    }\\n}\\n\\npublic class ModifyingCollectionProcessor : CollectionProcessor\\n{\\n    public override void ProcessCollection(List<string> data)\\n    {\\n        Console.WriteLine(\\\"[ModifyingProcessor] Starting processing...\\\");\\n        for (int i = 0; i < data.Count; i++)\\n        {\\n            var item = data[i];\\n            Console.WriteLine($\"[ModifyingProcessor] Processing item: {item}\");\\n            System.Threading.Thread.Sleep(10);\\n\\n            if (item.StartsWith(\\\"B\\\"))\\n            {\\n                Console.WriteLine($\"[ModifyingProcessor] Removing item: {item}\");\\n                data.RemoveAt(i);\\n                i--;\\n            }\\n        }\\n        Console.WriteLine(\\\"[ModifyingProcessor] Processing finished. List size after modification: \\\" + data.Count);\\n    }\\n}\",\"explanation\":\"The refactoring separates the read-only processing from the modifying processing, ensuring that the derived class does not violate the Liskov Substitution Principle by modifying the behavior of the base class in an unexpected way.\"}"
    }
  ]
}