{
    "code_examples": [
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"class Bird {\\n    public void move() {\\n        System.out.println(\\\"Bird is moving\\\");\\n    }\\n}\\n\\ninterface Movable {\\n    void move();\\n}\\n\\nclass Ostrich extends Bird implements Movable {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Ostrich is running\\\");\\n    }\\n}\\n\\nclass Sparrow extends Bird implements Movable {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Sparrow is flying\\\");\\n    }\\n}\\n\\npublic class Main {\\n    public static void makeBirdMove(Movable bird) {\\n        bird.move();\\n    }\\n    public static void main(String[] args) {\\n        makeBirdMove(new Ostrich());\\n        makeBirdMove(new Sparrow());\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the Bird class is not designed to be a general interface for all types of birds that can move in different ways. By introducing a Movable interface, we ensure that only classes that need to implement movement behavior do so, adhering to the ISP. Additionally, this refactoring allows for more flexibility and extensibility, as new bird types can be added without modifying existing code. The code now also adheres better to the Open/Closed Principle (OCP) by allowing new bird types to be added without changing the existing movement logic.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":4465251166}",
            "output": "public interface Movable {\n    void move();\n}\n\npublic class Bird {\n    // Bird specific properties and methods\n}\n\nclass Ostrich extends Bird implements Movable {\n    @Override\n    public void move() {\n        System.out.println(\"Ostrich is running\");\n    }\n}\n\nclass Sparrow extends Bird implements Movable {\n    @Override\n    public void move() {\n        System.out.println(\"Sparrow is flying\");\n    }\n}\n\npublic class Main {\n    public static void makeBirdMove(Movable bird) {\n        bird.move();\n    }\n    public static void main(String[] args) {\n        makeBirdMove(new Ostrich());\n        makeBirdMove(new Sparrow());\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the Bird class is not designed to be a general interface for all types of birds that can move in different ways. By introducing a Movable interface, we ensure that only classes that need to implement movement behavior do so, adhering to the ISP. Additionally, this refactoring allows for more flexibility and extensibility, as new bird types can be added without modifying existing code. The code now also adheres better to the Open/Closed Principle (OCP) by allowing new bird types to be added without changing the existing movement logic."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"public interface Shape {\\n    int getArea();\\n}\\n\\nclass Rectangle implements Shape {\\n    protected int width;\\n    protected int height;\\n    public Rectangle(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n    }\\n    @Override\\n    public int getArea() { return width  height; }\\n}\\n\\nclass Square implements Shape {\\n    protected int side;\\n    public Square(int side) {\\n        this.side = side;\\n    }\\n    @Override\\n    public int getArea() { return side  side; }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Shape s = new Square(5);\\n        System.out.println(s.getArea());\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because it uses an abstract class for shapes, which can lead to unnecessary dependencies if more shape types are added. By changing the abstract class to an interface, we allow for more flexibility and adherence to the ISP. Additionally, the Open/Closed Principle (OCP) is better supported as new shapes can be added without modifying existing code. The other principles are not significantly violated, but the most impactful violation is ISP.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":7378302000}",
            "output": "public interface Shape {\n    int getArea();\n}\n\nclass Rectangle implements Shape {\n    protected int width;\n    protected int height;\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    @Override\n    public int getArea() { return width  height; }\n}\n\nclass Square implements Shape {\n    protected int side;\n    public Square(int side) {\n        this.side = side;\n    }\n    @Override\n    public int getArea() { return side  side; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape s = new Square(5);\n        System.out.println(s.getArea());\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because it uses an abstract class for shapes, which can lead to unnecessary dependencies if more shape types are added. By changing the abstract class to an interface, we allow for more flexibility and adherence to the ISP. Additionally, the Open/Closed Principle (OCP) is better supported as new shapes can be added without modifying existing code. The other principles are not significantly violated, but the most impactful violation is ISP."
        },
        {
            "input": "interface Soundable {\n    void makeSound();\n}\n\nclass Animal implements Soundable {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Soundable a = new Dog();\n        a.makeSound();\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2370118917,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Animal` class is responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `Animal` class is responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.util.ArrayList;\\nimport java.util.List;\\n\\ninterface PaymentStrategy {\\n    void pay();\\n}\\n\\nclass PaidPayment implements PaymentStrategy {\\n    @Override\\n    public void pay() {\\n        System.out.println(\\\"Payment processed\\\");\\n    }\\n}\\n\\nclass FreePayment implements PaymentStrategy {\\n    @Override\\n    public void pay() {\\n        System.out.println(\\\"No payment needed\\\");\\n    }\\n}\\n\\nclass PaymentProcessor {\\n    private List<PaymentStrategy> payments = new ArrayList<>();\\n\\n    public void addPayment(PaymentStrategy payment) {\\n        payments.add(payment);\\n    }\\n\\n    public void processPayments() {\\n        for (PaymentStrategy payment : payments) {\\n            payment.pay();\\n        }\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        PaymentProcessor processor = new PaymentProcessor();\\n        processor.addPayment(new FreePayment());\\n        processor.addPayment(new PaidPayment());\\n        processor.processPayments();\\n    }\\n}\",\"explanation\":\"The refactored code introduces the PaymentStrategy interface to adhere to the Open/Closed Principle (OCP) by allowing new payment types to be added without modifying existing code. It also separates the payment processing logic into a PaymentProcessor class, which adheres to the Single Responsibility Principle (SRP) by ensuring that each class has one reason to change. This design allows for better extensibility and maintainability.\"},\"violation_type\":\"OCP, SRP\",\"total_duration\":4995361333}",
            "output": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface PaymentStrategy {\n    void pay();\n}\n\nclass PaidPayment implements PaymentStrategy {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment implements PaymentStrategy {\n    @Override\n    public void pay() {\n        System.out.println(\"No payment needed\");\n    }\n}\n\nclass PaymentProcessor {\n    private List<PaymentStrategy> payments = new ArrayList<>();\n\n    public void addPayment(PaymentStrategy payment) {\n        payments.add(payment);\n    }\n\n    public void processPayments() {\n        for (PaymentStrategy payment : payments) {\n            payment.pay();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        PaymentProcessor processor = new PaymentProcessor();\n        processor.addPayment(new FreePayment());\n        processor.addPayment(new PaidPayment());\n        processor.processPayments();\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "OCP, SRP",
            "explanation": "The refactored code introduces the PaymentStrategy interface to adhere to the Open/Closed Principle (OCP) by allowing new payment types to be added without modifying existing code. It also separates the payment processing logic into a PaymentProcessor class, which adheres to the Single Responsibility Principle (SRP) by ensuring that each class has one reason to change. This design allows for better extensibility and maintainability."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"java\\ninterface Movable {\\n    void move();\\n}\\n\\nabstract class Vehicle implements Movable {\\n    // Additional properties and methods can be added here\\n}\\n\\nclass Car extends Vehicle {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Car is moving\\\");\\n    }\\n}\\n\\nclass Bicycle extends Vehicle {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Bicycle is moving\\\");\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Movable v = new Bicycle();\\n        v.move();\\n    }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the Vehicle class is not utilizing any interfaces, which could lead to unnecessary dependencies if more vehicle types are added. By introducing a Movable interface, we ensure that classes only implement the methods they need. This also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes. The refactored code maintains the same functionality while improving adherence to SOLID principles.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":5545131709}",
            "output": "\"\"\"java\ninterface Movable {\n    void move();\n}\n\nabstract class Vehicle implements Movable {\n    // Additional properties and methods can be added here\n}\n\nclass Car extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Car is moving\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Bicycle is moving\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Movable v = new Bicycle();\n        v.move();\n    }\n}\n\"\"\"",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the Vehicle class is not utilizing any interfaces, which could lead to unnecessary dependencies if more vehicle types are added. By introducing a Movable interface, we ensure that classes only implement the methods they need. This also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes. The refactored code maintains the same functionality while improving adherence to SOLID principles."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"java\\ninterface Reader {\\n    String read();\\n}\\n\\nclass FileReader implements Reader {\\n    @Override\\n    public String read() {\\n        return \\\"Reading from file\\\";\\n    }\\n}\\n\\nclass SecureFileReader implements Reader {\\n    @Override\\n    public String read() {\\n        return \\\"Reading from secure file\\\";\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Reader fr = new SecureFileReader();\\n        System.out.println(fr.read());\\n    }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because it uses an abstract class instead of an interface. By changing the abstract class to an interface, we allow for more flexible implementations without forcing subclasses to inherit unnecessary methods. This change also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes. The refactored code maintains the same functionality while improving adherence to SOLID principles.\",\"violation_type\":\"Interface Segregation Principle (ISP)\"},\"total_duration\":4104747917}",
            "output": "```java\npublic class User {\n    private String name;\n    private String email;\n\n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n}\n\npublic class UserService {\n    public void saveUser(User user) {\n        // Code to save user to database\n    }\n}\n\npublic class EmailService {\n    public void sendEmail(String email) {\n        // Code to send email\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"John Doe\", \"john@example.com\");\n        UserService userService = new UserService();\n        userService.saveUser(user);\n        EmailService emailService = new EmailService();\n        emailService.sendEmail(user.getEmail());\n    }\n}\n```",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the User class was responsible for both user data and email functionality. By separating the responsibilities into UserService and EmailService, each class now has a single responsibility, making the code easier to maintain and extend."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.util.ArrayList;\\nimport java.util.List;\\n\\ninterface Writer {\\n    void write(String data);\\n}\\n\\nclass FileWriter implements Writer {\\n    @Override\\n    public void write(String data) {\\n        System.out.println(\\\"Writing: \\\" + data);\\n    }\\n}\\n\\nclass ReadOnlyWriter implements Writer {\\n    @Override\\n    public void write(String data) {\\n        System.out.println(\\\"Cannot write: Read only\\\");\\n    }\\n}\\n\\nclass WriterManager {\\n    private List<Writer> writers = new ArrayList<>();\\n\\n    public void addWriter(Writer writer) {\\n        writers.add(writer);\\n    }\\n\\n    public void writeAll(String data) {\\n        for (Writer writer : writers) {\\n            writer.write(data);\\n        }\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        WriterManager manager = new WriterManager();\\n        manager.addWriter(new FileWriter());\\n        manager.addWriter(new ReadOnlyWriter());\\n        manager.writeAll(\\\"Hello\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle (LSP) because the ReadOnlyWriter class does not fulfill the contract of the Writer interface, which expects all writers to be able to write data. This leads to unexpected behavior when using a ReadOnlyWriter in place of a Writer. The refactored code introduces a WriterManager class that manages multiple writers and allows for writing data to all writers, thus adhering to the LSP. Additionally, the use of an interface instead of an abstract class allows for better flexibility and adherence to the Open/Closed Principle (OCP). The refactored code also maintains the Single Responsibility Principle (SRP) by separating the concerns of writing and managing writers.\"},\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"total_duration\":8157778542}",
            "output": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface Writer {\n    void write(String data);\n}\n\nclass FileWriter implements Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter implements Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException(\"Cannot write: Read only\");\n    }\n}\n\nclass WriterManager {\n    private List<Writer> writers = new ArrayList<>();\n\n    public void addWriter(Writer writer) {\n        writers.add(writer);\n    }\n\n    public void writeAll(String data) {\n        for (Writer writer : writers) {\n            writer.write(data);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        WriterManager manager = new WriterManager();\n        manager.addWriter(new FileWriter());\n        manager.addWriter(new ReadOnlyWriter());\n        manager.writeAll(\"Hello\");\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "Liskov Substitution Principle (LSP)",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the ReadOnlyWriter class does not fulfill the contract of the Writer interface, which expects all writers to be able to write data. This leads to unexpected behavior when using a ReadOnlyWriter in place of a Writer. The refactored code modifies the ReadOnlyWriter to throw an exception when attempting to write, making it clear that it cannot perform the write operation, thus adhering to the LSP. Additionally, the WriterManager class remains responsible for managing writers, maintaining the Single Responsibility Principle (SRP)."
        },
        {
            "input": "interface Calculator {\n    int divide(int a, int b);\n}\n\nclass BasicCalculator implements Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Division by zero\");\n        }\n        return a / b;\n    }\n}\n\nclass SafeCalculator implements Calculator {\n    private final Calculator calculator;\n\n    public SafeCalculator(Calculator calculator) {\n        this.calculator = calculator;\n    }\n\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Division by zero\");\n        }\n        return calculator.divide(a, b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator(new BasicCalculator());\n        System.out.println(c.divide(4, 2));\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":4481721583,\"explanation\":\"This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks."
        },
        {
            "input": "import java.lang.Math;\n\ninterface IShape {\n    double area();\n}\n\nabstract class Shape implements IShape {\n    public abstract double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n    public Circle(double radius) { this.radius = radius; }\n    @Override\n    public double area() {\n        double calculatedArea = Math.PI  radius  radius;\n        return calculatedArea;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        return 0.0;\n    }\n}\n\nclass AreaCalculator {\n    public void printArea(IShape shape) {\n        double calculatedArea = shape.area();\n        System.out.println(shape.getClass().getSimpleName() + \" Area: \" + calculatedArea);\n    }\n}",
            "output": "import java.lang.Math;\n\ninterface IShape {\n    double area();\n}\n\nabstract class Shape implements IShape {\n    public abstract double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n    public Circle(double radius) { this.radius = radius; }\n    @Override\n    public double area() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        return 0.0;\n    }\n}\n\nclass AreaCalculator {\n    public void printArea(IShape shape) {\n        double calculatedArea = shape.area();\n        System.out.println(shape.getClass().getSimpleName() + \" Area: \" + calculatedArea);\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had a potential violation of the Single Responsibility Principle as the AreaCalculator class was responsible for both calculating and printing the area. The refactored code maintains this separation of concerns by ensuring that the AreaCalculator only handles the printing of the area, while the shape classes handle their own area calculations."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.io.File;\\n\\ninterface FileStatusProvider {\\n    String getStatus(String filePath);\\n}\\n\\ninterface FileProcessor {\\n    void processFile(String filePath);\\n}\\n\\nclass FileProcessorImpl implements FileProcessor {\\n    private final FileStatusProvider fileStatusProvider;\\n\\n    public FileProcessorImpl(FileStatusProvider fileStatusProvider) {\\n        this.fileStatusProvider = fileStatusProvider;\\n    }\\n\\n    @Override\\n    public void processFile(String filePath) {\\n        String status = fileStatusProvider.getStatus(filePath);\\n        if (status.contains(\\\"not found\\\")) {\\n            System.out.println(\\\"FileProcessor: Error - File not found.\\\");\\n            return;\\n        }\\n        System.out.println(\\\"FileProcessor: File processed successfully.\\\");\\n    }\\n}\\n\\nclass ReadOnlyFileStatusProvider implements FileStatusProvider {\\n    @Override\\n    public String getStatus(String filePath) {\\n        File file = new File(filePath);\\n        return file.exists() ? \\\"Available (Read-only)\\\" : \\\"File not found (Read-only)\\\";\\n    }\\n}\\n\\nclass RealFileStatusProvider implements FileStatusProvider {\\n    @Override\\n    public String getStatus(String filePath) {\\n        File file = new File(filePath);\\n        return file.exists() ? \\\"Ready for processing\\\" : \\\"File not found\\\";\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        FileStatusProvider readOnlyProvider = new ReadOnlyFileStatusProvider();\\n        FileProcessor readOnlyProcessor = new FileProcessorImpl(readOnlyProvider);\\n        readOnlyProcessor.processFile(\\\"path/to/read-only/file.txt\\\");\\n\\n        FileStatusProvider realProvider = new RealFileStatusProvider();\\n        FileProcessor realProcessor = new FileProcessorImpl(realProvider);\\n        realProcessor.processFile(\\\"path/to/real/file.txt\\\");\\n    }\\n}\",\"explanation\":\"The refactored code separates the concerns of file processing and file status retrieval, adhering to the Single Responsibility Principle (SRP). The FileProcessor interface no longer extends FileStatusProvider, which allows for better adherence to the Interface Segregation Principle (ISP). Additionally, the Dependency Inversion Principle (DIP) is respected by injecting the FileStatusProvider into the FileProcessorImpl class, allowing for more flexible and testable code. Each file status provider can now be used independently, promoting the Open/Closed Principle (OCP) as new providers can be added without modifying existing code.\"},\"violation_type\":\"Multiple violations of SOLID principles\",\"total_duration\":8053383125}",
            "output": "import java.io.File;\n\ninterface FileStatusProvider {\n    String getStatus(String filePath);\n}\n\ninterface FileProcessor {\n    void processFile(String filePath);\n}\n\nclass FileProcessorImpl implements FileProcessor {\n    private final FileStatusProvider fileStatusProvider;\n\n    public FileProcessorImpl(FileStatusProvider fileStatusProvider) {\n        this.fileStatusProvider = fileStatusProvider;\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        String status = fileStatusProvider.getStatus(filePath);\n        if (status.contains(\"not found\")) {\n            System.out.println(\"FileProcessor: Error - File not found.\");\n            return;\n        }\n        System.out.println(\"FileProcessor: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileStatusProvider implements FileStatusProvider {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n}\n\nclass RealFileStatusProvider implements FileStatusProvider {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileStatusProvider readOnlyProvider = new ReadOnlyFileStatusProvider();\n        FileProcessor readOnlyProcessor = new FileProcessorImpl(readOnlyProvider);\n        readOnlyProcessor.processFile(\"path/to/read-only/file.txt\");\n\n        FileStatusProvider realProvider = new RealFileStatusProvider();\n        FileProcessor realProcessor = new FileProcessorImpl(realProvider);\n        realProcessor.processFile(\"path/to/real/file.txt\");\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The refactored code separates the concerns of file processing and file status retrieval, adhering to the Single Responsibility Principle (SRP). The FileProcessor interface no longer extends FileStatusProvider, which allows for better adherence to the Interface Segregation Principle (ISP). Additionally, the Dependency Inversion Principle (DIP) is respected by injecting the FileStatusProvider into the FileProcessorImpl class, allowing for more flexible and testable code. Each file status provider can now be used independently, promoting the Open/Closed Principle (OCP) as new providers can be added without modifying existing code."
        },
        {
            "input": "interface SimpleLogger {\n    void log(String message);\n}\n\nclass CountingLogger implements SimpleLogger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        System.out.println(\"[COUNTING LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentLogger implements SimpleLogger {\n    @Override\n    public void log(String message) {\n        // This implementation simply does nothing, which is a valid behavior\n    }\n}\n\nclass LoggerFactory {\n    public static SimpleLogger createLogger(String type) {\n        if (type.equals(\"counting\")) {\n            return new CountingLogger();\n        } else if (type.equals(\"silent\")) {\n            return new SilentLogger();\n        }\n        throw new IllegalArgumentException(\"Unknown logger type: \" + type);\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2814503291,\"explanation\":\"The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.io.File;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n// Define interfaces for different capabilities\\ninterface DataLoader {\\n    boolean loadData(String source);\\n}\\n\\ninterface DataProcessor {\\n    boolean processData();\\n}\\n\\ninterface DataSaver {\\n    boolean saveResults(String destination);\\n}\\n\\n// A concrete implementation that can load, process, and save data\\nclass DataProcessorImpl implements DataLoader, DataProcessor, DataSaver {\\n    private Map<String, Object> data = null;\\n\\n    public DataProcessorImpl() {\\n        System.out.println(\\\"DataProcessorImpl created.\\\");\\n    }\\n\\n    @Override\\n    public boolean loadData(String source) {\\n        System.out.println(\\\"Loading data from \\\" + source + \\\"...\\\");\\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        if (\\\"valid_source\\\".equals(source)) {\\n            data = new HashMap<>();\\n            data.put(\\\"key1\\\", \\\"value1\\\");\\n            data.put(\\\"key2\\\", 42);\\n            System.out.println(\\\"Data loaded successfully.\\\");\\n            return true;\\n        } else {\\n            data = null;\\n            System.out.println(\\\"Failed to load data.\\\");\\n            return false;\\n        }\\n    }\\n\\n    @Override\\n    public boolean processData() {\\n        System.out.println(\\\"Processing data...\\\");\\n        if (data == null) {\\n            System.out.println(\\\"No data to process.\\\");\\n            return false;\\n        }\\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        data.put(\\\"processed\\\", true);\\n        System.out.println(\\\"Data processed.\\\");\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean saveResults(String destination) {\\n        System.out.println(\\\"Saving results to \\\" + destination + \\\"...\\\");\\n        if (data == null || !Boolean.TRUE.equals(data.get(\\\"processed\\\"))) {\\n            System.out.println(\\\"No processed data to save.\\\");\\n            return false;\\n        }\\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        System.out.println(\\\"Results saved to \\\" + destination + \\\".\\\");\\n        return true;\\n    }\\n}\\n\\n// A concrete implementation that can load and process data but not save\\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessor {\\n    private Map<String, Object> data = null;\\n\\n    public ReadOnlyDataProcessor() {\\n        System.out.println(\\\"ReadOnlyDataProcessor created.\\\");\\n    }\\n\\n    @Override\\n    public boolean loadData(String source) {\\n        System.out.println(\\\"Loading data from \\\" + source + \\\"...\\\");\\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        if (\\\"valid_source\\\".equals(source)) {\\n            data = new HashMap<>();\\n            data.put(\\\"key1\\\", \\\"value1\\\");\\n            data.put(\\\"key2\\\", 42);\\n            System.out.println(\\\"Data loaded successfully.\\\");\\n            return true;\\n        } else {\\n            data = null;\\n            System.out.println(\\\"Failed to load data.\\\");\\n            return false;\\n        }\\n    }\\n\\n    @Override\\n    public boolean processData() {\\n        System.out.println(\\\"Processing data (read-only simulation)...\\\");\\n        if (data == null) {\\n            System.out.println(\\\"No data to process.\\\");\\n            return false;\\n        }\\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        data.put(\\\"processed\\\", true);\\n        System.out.println(\\\"Data processed (read-only).\\\");\\n        return true;\\n    }\\n}\\n\\n// Example Usage\\npublic class ComplianceDemo {\\n    public static void saveProcessedData(DataSaver saver, String destination) {\\n        System.out.println(\\\"Attempting to save using a saver...\\\");\\n        saver.saveResults(destination);\\n    }\\n\\n    public static void processSomeData(DataProcessor processor) {\\n        System.out.println(\\\"Attempting to process using a processor...\\\");\\n        processor.processData();\\n    }\\n\\n    public static void loadSomeData(DataLoader loader) {\\n        System.out.println(\\\"Attempting to load using a loader...\\\");\\n        loader.loadData(\\\"valid_source\\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"--- Demonstrating Compliance ---\\\");\\n\\n        // Instantiate classes\\n        DataProcessorImpl fullProc = new DataProcessorImpl();\\n        ReadOnlyDataProcessor readOnlyProc = new ReadOnlyDataProcessor();\\n\\n        System.out.println(\\\"\\\\nUsing DataProcessorImpl where saver is needed:\\\");\\n        if (fullProc.loadData(\\\"valid_source\\\")) {\\n            if (fullProc.processData()) {\\n                saveProcessedData(fullProc, \\\"output_compliant.txt\\\");\\n            }\\n        }\\n\\n        System.out.println(\\\"\\\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\\\");\\n        // saveProcessedData(readOnlyProc, \\\"output_compliant.txt\\\"); // This line would cause a compile-time type error\\n        System.out.println(\\\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\\\");\\n\\n        System.out.println(\\\"\\\\nUsing DataProcessorImpl where processor is needed:\\\");\\n        if (fullProc.loadData(\\\"valid_source\\\")) {\\n            processSomeData(fullProc);\\n        }\\n\\n        System.out.println(\\\"\\\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\\\");\\n        if (readOnlyProc.loadData(\\\"valid_source\\\")) {\\n            processSomeData(readOnlyProc);\\n        }\\n\\n        System.out.println(\\\"\\\\nUsing DataProcessorImpl where loader is needed:\\\");\\n        loadSomeData(fullProc);\\n\\n        System.out.println(\\\"\\\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\\\");\\n        loadSomeData(readOnlyProc);\\n\\n        // Clean up\\n        File dummyFile = new File(\\\"output_compliant.txt\\\");\\n        if (dummyFile.exists()) dummyFile.delete();\\n    }\\n}\",\"explanation\":\"The refactored code separates the responsibilities more clearly by ensuring that each class adheres to the Single Responsibility Principle (SRP). The interfaces are kept distinct, and the classes implement only the interfaces they need. This avoids the violation of the Interface Segregation Principle (ISP) where classes were forced to implement methods they did not use. The refactored code also maintains compliance with the Liskov Substitution Principle (LSP) by ensuring that subclasses can be substituted without altering the correctness of the program. Overall, the refactoring improves the design by making it more modular and easier to maintain.\"}",
            "output": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Define interfaces for different capabilities\ninterface DataLoader {\n    boolean loadData(String source);\n}\n\ninterface DataProcessor {\n    boolean processData();\n}\n\ninterface DataSaver {\n    boolean saveResults(String destination);\n}\n\n// A concrete implementation that can load, process, and save data\nclass DataProcessorImpl implements DataLoader, DataProcessor, DataSaver {\n    private Map<String, Object> data = null;\n\n    public DataProcessorImpl() {\n        System.out.println(\"DataProcessorImpl created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Processing data...\");\n        if (data == null) {\n            System.out.println(\"No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Data processed.\");\n        return true;\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        System.out.println(\"Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\n// A concrete implementation that can load and process data but not save\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessor {\n    private Map<String, Object> data = null;\n\n    public ReadOnlyDataProcessor() {\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Processing data (read-only simulation)...\");\n        if (data == null) {\n            System.out.println(\"No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Data processed (read-only).\");\n        return true;\n    }\n}\n\n// Example Usage\npublic class ComplianceDemo {\n    public static void saveProcessedData(DataSaver saver, String destination) {\n        System.out.println(\"Attempting to save using a saver...\");\n        saver.saveResults(destination);\n    }\n\n    public static void processSomeData(DataProcessor processor) {\n        System.out.println(\"Attempting to process using a processor...\");\n        processor.processData();\n    }\n\n    public static void loadSomeData(DataLoader loader) {\n        System.out.println(\"Attempting to load using a loader...\");\n        loader.loadData(\"valid_source\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"--- Demonstrating Compliance ---\");\n\n        // Instantiate classes\n        DataProcessorImpl fullProc = new DataProcessorImpl();\n        ReadOnlyDataProcessor readOnlyProc = new ReadOnlyDataProcessor();\n\n        System.out.println(\"\\nUsing DataProcessorImpl where saver is needed:\");\n        if (fullProc.loadData(\"valid_source\")) {\n            if (fullProc.processData()) {\n                saveProcessedData(fullProc, \"output_compliant.txt\");\n            }\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\");\n        // saveProcessedData(readOnlyProc, \"output_compliant.txt\"); // This line would cause a compile-time type error\n        System.out.println(\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\");\n\n        System.out.println(\"\\nUsing DataProcessorImpl where processor is needed:\");\n        if (fullProc.loadData(\"valid_source\")) {\n            processSomeData(fullProc);\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\");\n        if (readOnlyProc.loadData(\"valid_source\")) {\n            processSomeData(readOnlyProc);\n        }\n\n        System.out.println(\"\\nUsing DataProcessorImpl where loader is needed:\");\n        loadSomeData(fullProc);\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\");\n        loadSomeData(readOnlyProc);\n\n        // Clean up\n        File dummyFile = new File(\"output_compliant.txt\");\n        if (dummyFile.exists()) dummyFile.delete();\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The refactored code separates the responsibilities more clearly by ensuring that each class adheres to the Single Responsibility Principle (SRP). The interfaces are kept distinct, and the classes implement only the interfaces they need. This avoids the violation of the Interface Segregation Principle (ISP) where classes were forced to implement methods they did not use. The refactored code also maintains compliance with the Liskov Substitution Principle (LSP) by ensuring that subclasses can be substituted without altering the correctness of the program. Overall, the refactoring improves the design by making it more modular and easier to maintain."
        },
        {
            "input": "class Bird:\n    def move(self):\n        raise NotImplementedError(\"Subclasses should implement this!\")\n\nclass FlyingBird(Bird):\n    def move(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def move(self):\n        print('Running')\n\nclass Sparrow(FlyingBird):\n    def move(self):\n        print('Flying high')\n",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":4429818792,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility."
        },
        {
            "input": "class Shape:\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    def area(self):\n        return self.width  self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side  self.side\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    def area(self):\n        import math\n        return math.pi  (self.radius  2)\n\nshapes = [Rectangle(3, 4), Square(5), Circle(2)]\nfor shape in shapes:\n    print(f'Area: {shape.area()}')",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3083127042,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Shape` class is not responsible for calculating the area of different shapes. Each shape class now has a single responsibility: to calculate its own area.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `Shape` class is not responsible for calculating the area of different shapes. Each shape class now has a single responsibility: to calculate its own area."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def move(self):\n        pass\n\nclass Fish(Animal):\n    def move(self):\n        print('Swimming')\n\nclass Bird(Animal):\n    def move(self):\n        print('Flying')\n\nclass Mammal(Animal):\n    def move(self):\n        print('Running')\n\n# Example usage\nanimals = [Fish(), Bird(), Mammal()]\nfor animal in animals:\n    animal.move()",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2700943333,\"explanation\":\"This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals."
        },
        {
            "input": "class FileReader:\n    def read(self):\n        print('Reading file')\n\nclass FileWriter:\n    def write(self):\n        print('Writing to file')\n\nclass FileHandler:\n    def __init__(self, reader: FileReader, writer: FileWriter):\n        self.reader = reader\n        self.writer = writer\n\n    def read_file(self):\n        self.reader.read()\n\n    def write_file(self):\n        self.writer.write()",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2469172542,\"explanation\":\"The original code violates the Single Responsibility Principle because the `FileHandler` class is responsible for both reading and writing files, which are two distinct responsibilities. By separating the reading and writing functionalities into their own classes, we adhere to SRP.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `FileHandler` class is responsible for both reading and writing files, which are two distinct responsibilities. By separating the reading and writing functionalities into their own classes, we adhere to SRP."
        },
        {
            "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor:\n    def process_payment(self):\n        print('Processed free payment')\n\nclass Payment:\n    def __init__(self, amount=0):\n        self.amount = amount\n\nclass PaymentFactory:\n    @staticmethod\n    def create_payment(payment_type, amount=0):\n        if payment_type == 'free':\n            return FreePaymentProcessor()\n        else:\n            return PaymentProcessor()",
            "output": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor:\n    def process_payment(self):\n        print('Processed free payment')\n\nclass Payment:\n    def __init__(self, amount=0):\n        self.amount = amount\n\nclass PaymentFactory:\n    @staticmethod\n    def create_payment(payment_type, amount=0):\n        if payment_type == 'free':\n            return FreePaymentProcessor()\n        else:\n            return PaymentProcessor()",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The Payment class is responsible for holding payment data, while the PaymentProcessor and FreePaymentProcessor classes handle payment processing. This separation of concerns adheres to the Single Responsibility Principle, ensuring that each class has one reason to change."
        },
        {
            "input": "class Document:\n    def show(self):\n        print('Showing document')\n\nclass SecureDocument(Document):\n    def show(self):\n        print('Showing secure document')\n\nclass DocumentViewer:\n    def display(self, document: Document):\n        document.show()\n\n# Example usage\nif __name__ == '__main__':\n    doc = Document()\n    secure_doc = SecureDocument()\n    viewer = DocumentViewer()\n    viewer.display(doc)\n    viewer.display(secure_doc)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1733431500,\"explanation\":\"This code violates the Single Responsibility Principle because the `Document` and `SecureDocument` classes are responsible for both the content and the display logic, which should be separated.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This code violates the Single Responsibility Principle because the `Document` and `SecureDocument` classes are responsible for both the content and the display logic, which should be separated."
        },
        {
            "input": "class Vehicle:\n    def move(self):\n        raise NotImplementedError(\"Subclasses should implement this method\")\n\nclass Bicycle(Vehicle):\n    def move(self):\n        print('Bicycle is moving')\n\nclass Car(Vehicle):\n    def move(self):\n        print('Car is moving')\n\nclass VehicleMover:\n    def move_vehicle(self, vehicle: Vehicle):\n        vehicle.move()",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2088939583,\"explanation\":\"The original code violates the Single Responsibility Principle because the `VehicleMover` class is responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `VehicleMover` class is responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility."
        },
        {
            "input": "class EmailSender:\n    def __init__(self, logger):\n        self.logger = logger\n\n    def send_email(self, address):\n        self.logger.log(f'Sending email to {address}')\n\nclass Logger:\n    def log(self, message):\n        print(message)\n\n# Example usage\nlogger = Logger()\nemail_sender = EmailSender(logger)\nemail_sender.send_email('example@example.com')",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1522838416,\"explanation\":\"This class violates the Single Responsibility Principle because it handles both user information and email sending, which are two distinct responsibilities.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This class violates the Single Responsibility Principle because it handles both user information and email sending, which are two distinct responsibilities."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import abc\\nimport os\\nimport time\\n\\n# Define ABCs for different capabilities\\nclass DataLoader(abc.ABC):\\n    @abc.abstractmethod\\n    def load_data(self, source):\\n        pass\\n\\nclass DataProcessor(abc.ABC):\\n    @abc.abstractmethod\\n    def process_data(self):\\n        pass\\n\\nclass DataSaver(abc.ABC):\\n    @abc.abstractmethod\\n    def save_results(self, destination):\\n        pass\\n\\n# A concrete implementation that can do all three\\nclass FullDataProcessor(DataLoader, DataProcessor, DataSaver):\\n    def __init__(self):\\n        self._data = None\\n        print(\\\"FullDataProcessor created.\\\")\\n\\n    def load_data(self, source):\\n        print(f\\\"Full: Loading data from {source}...\\\")\\n        time.sleep(0.1)\\n        if source == \\\"valid_source\\\":\\n            self._data = {\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": 42}\\n            print(\\\"Full: Data loaded successfully.\\\")\\n        else:\\n            self._data = None\\n            print(\\\"Full: Failed to load data.\\\")\\n        return self._data is not None\\n\\n    def process_data(self):\\n        print(\\\"Full: Processing data...\\\")\\n        if self._data is None:\\n            print(\\\"Full: No data to process.\\\")\\n            return False\\n        time.sleep(0.2)\\n        # Simulate processing\\n        self._data[\\\"processed\\\"] = True\\n        print(\\\"Full: Data processed.\\\")\\n        return True\\n\\n    def save_results(self, destination):\\n        print(f\\\"Full: Saving results to {destination}...\\\")\\n        if self._data is None or not self._data.get(\\\"processed\\\"):\\n            print(\\\"Full: No processed data to save.\\\")\\n            return False\\n        time.sleep(0.3)\\n        # Simulate saving\\n        print(f\\\"Full: Results saved to {destination}.\\\")\\n        return True\\n\\n# A concrete implementation that can load and process (read-only concept)\\nclass ReadOnlyDataProcessor(DataLoader, DataProcessor):\\n    def __init__(self):\\n        self._data = None # Manage its own state\\n        print(\\\"ReadOnlyDataProcessor created.\\\")\\n\\n    def load_data(self, source):\\n        print(f\\\"ReadOnly: Loading data from {source}...\\\")\\n        time.sleep(0.1)\\n        if source == \\\"valid_source\\\":\\n            self._data = {\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": 42}\\n            print(\\\"ReadOnly: Data loaded successfully.\\\")\\n        else:\\n            self._data = None\\n            print(\\\"ReadOnly: Failed to load data.\\\")\\n        return self._data is not None\\n\\n    def process_data(self):\\n        print(\\\"ReadOnly: Processing data (read-only simulation)...\\\")\\n        if self._data is None:\\n            print(\\\"ReadOnly: No data to process.\\\")\\n            return False\\n        time.sleep(0.2)\\n        # Simulate processing without making it 'savable'\\n        print(\\\"ReadOnly: Data processed (read-only).\\\")\\n        return True\\n\\n# Example Usage (LSP Compliant - requires specific capabilities):\\ndef demonstrate_compliance():\\n    print(\\\"--- Demonstrating Compliance ---\\\")\\n\\n    # A function requiring saving capability MUST ask for DataSaver (or FullDataProcessor)\\n    def save_processed_data(saver: DataSaver, destination):\\n         # This function knows it can save\\n         print(\\\"Attempting to save using a saver...\\\")\\n         saver.save_results(destination) # This call is guaranteed to exist (though might fail for other reasons like disk full)\\n\\n    # A function requiring only processing capability can ask for DataProcessor\\n    def process_some_data(processor: DataProcessor):\\n         # This function knows it can process\\n         print(\\\"Attempting to process using a processor...\\\")\\n         processor.process_data() # This call is guaranteed to exist\\n\\n    # A function requiring only loading capability can ask for DataLoader\\n    def load_some_data(loader: DataLoader):\\n         # This function knows it can load\\n         print(\\\"Attempting to load using a loader...\\\")\\n         loader.load_data(\\\"valid_source\\\") # This call is guaranteed to exist\\n\\n    # Instantiate classes\\n    full_proc = FullDataProcessor()\\n    read_only_proc = ReadOnlyDataProcessor()\\n\\n    print(\\\"\\\\nUsing FullDataProcessor where saver is needed:\\\")\\n    # Need to load/process first if save logic requires state\\n    if full_proc.load_data(\\\"valid_source\\\"): full_proc.process_data()\\n    save_processed_data(full_proc, \\\"output_compliant.txt\\\") # Works (FullDataProcessor implements DataSaver)\\n\\n    print(\\\"\\\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\\\")\\n    # save_processed_data(read_only_proc, \\\"output_compliant.txt\\\") # This line would cause a TypeError\\n    print(\\\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\\\")\\n\\n    print(\\\"\\\\nUsing FullDataProcessor where processor is needed:\\\")\\n    # Need to load first if process logic requires state\\n    if full_proc.load_data(\\\"valid_source\\\"): process_some_data(full_proc) # Works (FullDataProcessor implements DataProcessor)\\n\\n    print(\\\"\\\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\\\")\\n    # Need to load first if process logic requires state\\n    if read_only_proc.load_data(\\\"valid_source\\\"): process_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataProcessor)\\n\\n    print(\\\"\\\\nUsing FullDataProcessor where loader is needed:\\\")\\n    load_some_data(full_proc) # Works (FullDataProcessor implements DataLoader)\\n\\n    print(\\\"\\\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\\\")\\n    load_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataLoader)\\n\\n    # Clean up\\n    if os.path.exists(\\\"output_compliant.txt\\\"): os.remove(\\\"output_compliant.txt\\\")\\n\\ndemonstrate_compliance()\",\"explanation\":\"The refactored code separates the concerns of data loading, processing, and saving into distinct interfaces, ensuring that classes only implement the methods they need. This adheres to the Interface Segregation Principle (ISP) by preventing classes from being forced to implement methods they do not use. The original code had a violation of ISP because the ReadOnlyDataProcessor class was forced to implement the save_results method, which it did not need. The refactored code maintains the same functionality while improving adherence to SOLID principles.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":23593955750}",
            "output": "import abc\nimport os\nimport time\n\n# Define ABCs for different capabilities\nclass DataLoader(abc.ABC):\n    @abc.abstractmethod\n    def load_data(self, source):\n        pass\n\nclass DataProcessor(abc.ABC):\n    @abc.abstractmethod\n    def process_data(self):\n        pass\n\nclass DataSaver(abc.ABC):\n    @abc.abstractmethod\n    def save_results(self, destination):\n        pass\n\n# A concrete implementation that can do all three\nclass FullDataProcessor(DataLoader, DataProcessor, DataSaver):\n    def __init__(self):\n        self._data = None\n        print(\"FullDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"Full: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Full: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Full: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"Full: Processing data...\")\n        if self._data is None:\n            print(\"Full: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing\n        self._data[\"processed\"] = True\n        print(\"Full: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        print(f\"Full: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Full: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        # Simulate saving\n        print(f\"Full: Results saved to {destination}.\")\n        return True\n\n# A concrete implementation that can load and process (read-only concept)\nclass ReadOnlyDataProcessor(DataLoader, DataProcessor):\n    def __init__(self):\n        self._data = None # Manage its own state\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"ReadOnly: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"ReadOnly: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"ReadOnly: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"ReadOnly: Processing data (read-only simulation)...\")\n        if self._data is None:\n            print(\"ReadOnly: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing without making it 'savable'\n        print(\"ReadOnly: Data processed (read-only).\")\n        return True\n\n# Example Usage (LSP Compliant - requires specific capabilities):\ndef demonstrate_compliance():\n    print(\"--- Demonstrating Compliance ---\")\n\n    # A function requiring saving capability MUST ask for DataSaver (or FullDataProcessor)\n    def save_processed_data(saver: DataSaver, destination):\n         # This function knows it can save\n         print(\"Attempting to save using a saver...\")\n         saver.save_results(destination) # This call is guaranteed to exist (though might fail for other reasons like disk full)\n\n    # A function requiring only processing capability can ask for DataProcessor\n    def process_some_data(processor: DataProcessor):\n         # This function knows it can process\n         print(\"Attempting to process using a processor...\")\n         processor.process_data() # This call is guaranteed to exist\n\n    # A function requiring only loading capability can ask for DataLoader\n    def load_some_data(loader: DataLoader):\n         # This function knows it can load\n         print(\"Attempting to load using a loader...\")\n         loader.load_data(\"valid_source\") # This call is guaranteed to exist\n\n    # Instantiate classes\n    full_proc = FullDataProcessor()\n    read_only_proc = ReadOnlyDataProcessor()\n\n    print(\"\\nUsing FullDataProcessor where saver is needed:\")\n    # Need to load/process first if save logic requires state\n    if full_proc.load_data(\"valid_source\"): full_proc.process_data()\n    save_processed_data(full_proc, \"output_compliant.txt\") # Works (FullDataProcessor implements DataSaver)\n\n    print(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\")\n    # save_processed_data(read_only_proc, \"output_compliant.txt\") # This line would cause a TypeError\n    print(\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\")\n\n    print(\"\\nUsing FullDataProcessor where processor is needed:\")\n    # Need to load first if process logic requires state\n    if full_proc.load_data(\"valid_source\"): process_some_data(full_proc) # Works (FullDataProcessor implements DataProcessor)\n\n    print(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\")\n    # Need to load first if process logic requires state\n    if read_only_proc.load_data(\"valid_source\"): process_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataProcessor)\n\n    print(\"\\nUsing FullDataProcessor where loader is needed:\")\n    load_some_data(full_proc) # Works (FullDataProcessor implements DataLoader)\n\n    print(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\")\n    load_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataLoader)\n\n    # Clean up\n    if os.path.exists(\"output_compliant.txt\"): os.remove(\"output_compliant.txt\")\n\ndemonstrate_compliance()",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The refactored code separates the concerns of data loading, processing, and saving into distinct interfaces, ensuring that classes only implement the methods they need. This adheres to the Interface Segregation Principle (ISP) by preventing classes from being forced to implement methods they do not use. The original code had a violation of ISP because the ReadOnlyDataProcessor class was forced to implement the save_results method, which it did not need. The refactored code maintains the same functionality while improving adherence to SOLID principles."
        },
        {
            "input": "import abc\n\n# Define an ABC for the core logging capability\nclass SimpleLogger(abc.ABC):\n    @abc.abstractmethod\n    def log(self, message):\n        pass\n\n# Define an ABC for loggers that can provide a count\nclass CountableLogger(SimpleLogger):\n    @abc.abstractmethod\n    def get_messages_logged_count(self):\n        pass\n\n# An implementation that logs and also tracks a count\nclass CountingLogger(CountableLogger):\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[COUNTING LOG] {message}\")\n        self._messages_logged += 1\n\n# An implementation that simply logs (or does nothing)\nclass SilentLogger(SimpleLogger):\n    def log(self, message):\n        # This implementation simply does nothing, which is a valid behavior\n        # for a SimpleLogger if the contract doesn't guarantee visible output.\n        pass\n",
            "output": "import abc\n\n# Define an ABC for the core logging capability\nclass SimpleLogger(abc.ABC):\n    @abc.abstractmethod\n    def log(self, message):\n        pass\n\n# An implementation that logs and also tracks a count\nclass CountingLogger(SimpleLogger):\n    def __init__(self):\n        self._messages_logged = 0\n\n    def log(self, message):\n        print(f\"[COUNTING LOG] {message}\")\n        self._messages_logged += 1\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n# An implementation that simply logs (or does nothing)\nclass SilentLogger(SimpleLogger):\n    def log(self, message):\n        pass",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "Interface Bloat",
            "explanation": "The original code had an unnecessary interface (CountableLogger) that added complexity without providing significant value. By removing this interface and integrating the counting functionality directly into the CountingLogger, we adhere to the Interface Segregation Principle, reducing the bloat and keeping the interfaces focused."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import abc\\nimport os\\n\\n# Represents a component that can provide the status of a file\\nclass FileStatusProvider(abc.ABC):\\n    @abc.abstractmethod\\n    def get_status(self, file_path):\\n        pass\\n\\n# Represents a component that can process files\\nclass FileProcessor(abc.ABC):\\n    @abc.abstractmethod\\n    def process_file(self, file_path):\\n        pass\\n\\n# A concrete implementation of a processor\\nclass RealFileProcessor(FileProcessor, FileStatusProvider):\\n    def get_status(self, file_path):\\n        file_exists = os.path.exists(file_path)\\n        status = \\\"Ready for processing\\\" if file_exists else \\\"File not found\\\"\\n        print(f\\\"RealProcessor: Checking status for {file_path} - {status}.\\\")\\n        return status\\n\\n    def process_file(self, file_path):\\n        print(f\\\"RealProcessor: Processing file {file_path}...\\\")\\n        if not os.path.exists(file_path):\\n            print(f\\\"RealProcessor: Error - File {file_path} not found for processing.\\\")\\n            return\\n        # Simulate processing...\\n        print(f\\\"RealProcessor: File {file_path} processed successfully.\\\")\\n\\n# Represents a component that can only check file status (read-only)\\nclass ReadOnlyFileStatusProvider(FileStatusProvider):\\n    def get_status(self, file_path):\\n        file_exists = os.path.exists(file_path)\\n        status = \\\"Available (Read-only)\\\" if file_exists else \\\"File not found (Read-only)\\\"\\n        print(f\\\"ReadOnlyStatusProvider: Checking status for {file_path} - {status}.\\\")\\n        return status\\n\\n# Example Usage:\\n# import os\\n\\ntest_file_path = \\\"dummy_refactored.txt\\\"\\nwith open(test_file_path, \\\"w\\\") as f: f.write(\\\"Some content\\\") # Create a dummy file\\n\\n# When you need processing capability, you must use FileProcessor:\\nprocessor: FileProcessor = RealFileProcessor() # Substitutes for FileProcessor\\nprint(processor.get_status(test_file_path)) # RealProcessor: ... Ready.\\nprocessor.process_file(test_file_path)     # RealProcessor: ... processed successfully.\\n\\nprint(\\\"---\\\")\\n\\n# When you only need status capability, you can use FileStatusProvider:\\nstatus_provider1: FileStatusProvider = RealFileProcessor() # Substitutes for FileStatusProvider\\nprint(status_provider1.get_status(test_file_path)) # RealProcessor: ... Ready.\\n\\nstatus_provider2: FileStatusProvider = ReadOnlyFileStatusProvider() # LSP compliant substitution\\nprint(status_provider2.get_status(test_file_path)) # ReadOnlyStatusProvider: ... Available (Read-only)\\n\\nif os.path.exists(test_file_path): os.remove(test_file_path) # Clean up dummy file\",\"explanation\":\"The refactored code separates the concerns of file processing and status checking more clearly by ensuring that both functionalities are encapsulated in their respective classes. The `FileProcessor` class no longer inherits from `FileStatusProvider`, which allows for a clearer distinction between processing and status checking. This change improves adherence to the Single Responsibility Principle (SRP) and the Interface Segregation Principle (ISP). The `RealFileProcessor` class now implements both interfaces, allowing it to be used interchangeably where either functionality is required.\"},\"violation_type\":\"LSP\",\"total_duration\":10944176708}",
            "output": "import abc\nimport os\n\n# Represents a component that can provide the status of a file\nclass FileStatusProvider(abc.ABC):\n    @abc.abstractmethod\n    def get_status(self, file_path):\n        pass\n\n# Represents a component that can process files\nclass FileProcessor(abc.ABC):\n    @abc.abstractmethod\n    def process_file(self, file_path):\n        pass\n\n# A concrete implementation of a processor\nclass RealFileProcessor(FileProcessor):\n    def process_file(self, file_path):\n        print(f\"RealProcessor: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"RealProcessor: Error - File {file_path} not found for processing.\")\n            return\n        # Simulate processing...\n        print(f\"RealProcessor: File {file_path} processed successfully.\")\n\n# A concrete implementation of a status provider\nclass RealFileStatusProvider(FileStatusProvider):\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Ready for processing\" if file_exists else \"File not found\"\n        print(f\"RealStatusProvider: Checking status for {file_path} - {status}.\")\n        return status\n\n# Represents a component that can only check file status (read-only)\nclass ReadOnlyFileStatusProvider(FileStatusProvider):\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Available (Read-only)\" if file_exists else \"File not found (Read-only)\"\n        print(f\"ReadOnlyStatusProvider: Checking status for {file_path} - {status}.\")\n        return status\n\n# Example Usage:\n# import os\n\ntest_file_path = \"dummy_refactored.txt\"\nwith open(test_file_path, \"w\") as f: f.write(\"Some content\") # Create a dummy file\n\n# When you need processing capability, you must use FileProcessor:\nprocessor: FileProcessor = RealFileProcessor() # Substitutes for FileProcessor\nprocessor.process_file(test_file_path)     # RealProcessor: ... processed successfully.\n\nprint(\"---\")\n\n# When you only need status capability, you can use FileStatusProvider:\nstatus_provider1: FileStatusProvider = RealFileStatusProvider() # Substitutes for FileStatusProvider\nprint(status_provider1.get_status(test_file_path)) # RealStatusProvider: ... Ready.\n\nstatus_provider2: FileStatusProvider = ReadOnlyFileStatusProvider() # LSP compliant substitution\nprint(status_provider2.get_status(test_file_path)) # ReadOnlyStatusProvider: ... Available (Read-only)\n\nif os.path.exists(test_file_path): os.remove(test_file_path) # Clean up dummy file",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactored code separates the concerns of file processing and status checking more clearly by ensuring that both functionalities are encapsulated in their respective classes. The `RealFileProcessor` class now only implements the `FileProcessor` interface, while the `RealFileStatusProvider` class implements the `FileStatusProvider` interface. This change improves adherence to the Liskov Substitution Principle (LSP) by ensuring that subclasses can be substituted without altering the desirable properties of the program."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import abc\\nimport math\\n\\n# Define an ABC for shapes that can provide an area.\\nclass IShape(abc.ABC):\\n    @abc.abstractmethod\\n    def area(self) -> float:\\n        pass\\n\\n# A standard shape implementation (like a circle)\\nclass Circle(IShape):\\n    def __init__(self, radius: float):\\n        self.radius = radius\\n\\n    def area(self) -> float:\\n        calculated_area = math.pi  self.radius  self.radius\\n        return calculated_area\\n\\n# An implementation representing a shape with no area (the \\\"null\\\" concept).\\nclass NullShape(IShape):\\n    def area(self) -> float:\\n        return 0.0\\n\\n# A new class for Rectangle to demonstrate OCP compliance\\nclass Rectangle(IShape):\\n    def __init__(self, width: float, height: float):\\n        self.width = width\\n        self.height = height\\n\\n    def area(self) -> float:\\n        return self.width  self.height\\n\\n# Example Usage:\\nshapes = [Circle(5.0), NullShape(), Rectangle(4.0, 6.0)]\\n\\nfor shape in shapes:\\n    print(f\\\"Area: {shape.area()}\\\")\\n\\n# Downstream code works correctly:\\ntotal_area = sum(shape.area() for shape in shapes)\\nprint(f\\\"Total Area: {total_area}\\\")\\n\\nif total_area >= 0.0:\\n    print(\\\"Total area is non-negative (check passes)\\\")\\nelse:\\n    print(\\\"Total area is negative or NaN\\\")\",\"explanation\":\"The refactored code introduces a new shape class, Rectangle, to demonstrate adherence to the Open/Closed Principle (OCP). This allows for the addition of new shapes without modifying existing code. The Single Responsibility Principle (SRP) is maintained as each class has a single responsibility. The Liskov Substitution Principle (LSP) is upheld as all shapes can be used interchangeably without affecting the correctness of the program. The Interface Segregation Principle (ISP) and Dependency Inversion Principle (DIP) are not directly violated in the original code, but the refactoring maintains their compliance by ensuring that interfaces are not bloated and that high-level modules do not depend on low-level modules.\"},\"total_duration\":15391190709}",
            "output": "import abc\nimport math\n\n# Define an ABC for shapes that can provide an area.\nclass IShape(abc.ABC):\n    @abc.abstractmethod\n    def area(self) -> float:\n        pass\n\n# A standard shape implementation (like a circle)\nclass Circle(IShape):\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    def area(self) -> float:\n        calculated_area = math.pi  self.radius  self.radius\n        return calculated_area\n\n# An implementation representing a shape with no area (the \"null\" concept).\nclass NullShape(IShape):\n    def area(self) -> float:\n        return 0.0\n\n# A new class for Rectangle to demonstrate OCP compliance\nclass Rectangle(IShape):\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n    def area(self) -> float:\n        return self.width  self.height\n\n# Example Usage:\nshapes = [Circle(5.0), NullShape(), Rectangle(4.0, 6.0)]\n\nfor shape in shapes:\n    print(f\"Area: {shape.area()}\")\n\n# Downstream code works correctly:\ntotal_area = sum(shape.area() for shape in shapes)\nprint(f\"Total Area: {total_area}\")\n\nif total_area >= 0.0:\n    print(\"Total area is non-negative (check passes)\")\nelse:\n    print(\"Total area is negative or NaN\")",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The refactored code introduces a new shape class, Rectangle, to demonstrate adherence to the Open/Closed Principle (OCP). This allows for the addition of new shapes without modifying existing code. The Single Responsibility Principle (SRP) is maintained as each class has a single responsibility. The Liskov Substitution Principle (LSP) is upheld as all shapes can be used interchangeably without affecting the correctness of the program. The Interface Segregation Principle (ISP) and Dependency Inversion Principle (DIP) are not directly violated in the original code, but the refactoring maintains their compliance by ensuring that interfaces are not bloated and that high-level modules do not depend on low-level modules."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"open class Bird {\\n    open fun move() {}\\n}\\n\\ninterface Movable {\\n    fun move()\\n}\\n\\nclass Ostrich : Bird(), Movable {\\n    override fun move() {\\n        // Ostrich runs\\n    }\\n}\\n\\nclass Sparrow : Bird(), Movable {\\n    override fun move() {\\n        // Sparrow flies\\n    }\\n}\\n\\nfun makeBirdMove(movable: Movable) {\\n    movable.move()\\n}\\n\\nfun main() {\\n    val ostrich = Ostrich()\\n    makeBirdMove(ostrich)\\n    val sparrow = Sparrow()\\n    makeBirdMove(sparrow)\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the Bird class forces all derived classes to implement the move method, even if they don't need to. By introducing a Movable interface, we allow classes to implement only the functionality they require. This also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions (Movable) rather than concrete implementations (Bird). The refactored code maintains the same functionality while improving adherence to SOLID principles.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":4968191000}",
            "output": "open class Bird {\n    open fun move() {}\n}\n\ninterface Movable {\n    fun move()\n}\n\nclass Ostrich : Movable {\n    override fun move() {\n        // Ostrich runs\n    }\n}\n\nclass Sparrow : Movable {\n    override fun move() {\n        // Sparrow flies\n    }\n}\n\nfun makeBirdMove(movable: Movable) {\n    movable.move()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdMove(ostrich)\n    val sparrow = Sparrow()\n    makeBirdMove(sparrow)\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the Bird class forces all derived classes to implement the move method, even if they don't need to. By introducing a Movable interface, we allow classes to implement only the functionality they require. This also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions (Movable) rather than concrete implementations (Bird). The refactored code maintains the same functionality while improving adherence to SOLID principles."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"open class Shape {\\n    open fun area(): Int = 0\\n}\\n\\ninterface AreaCalculable {\\n    fun area(): Int\\n}\\n\\nclass Rectangle(var width: Int, var height: Int) : Shape(), AreaCalculable {\\n    override fun area(): Int = width  height\\n}\\n\\nclass Square(size: Int) : Shape(), AreaCalculable {\\n    private val side = size\\n    override fun area(): Int = side  side\\n}\\n\\nfun printArea(shape: AreaCalculable) {\\n    println(shape.area())\\n}\\n\\nfun main() {\\n    val square = Square(5)\\n    printArea(square)\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `Shape` class is not an interface and does not provide a clear contract for area calculation. By introducing an `AreaCalculable` interface, we ensure that only classes that need to calculate an area implement this interface, adhering to the ISP. This change also maintains the functionality of the original code while improving its design.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":4348858125}",
            "output": "open class Shape {\n    open fun area(): Int = 0\n}\n\ninterface AreaCalculable {\n    fun area(): Int\n}\n\nclass Rectangle(var width: Int, var height: Int) : Shape(), AreaCalculable {\n    override fun area(): Int = width  height\n}\n\nclass Square(size: Int) : Shape(), AreaCalculable {\n    private val side = size\n    override fun area(): Int = side  side\n}\n\nfun printArea(shape: AreaCalculable) {\n    println(shape.area())\n}\n\nfun main() {\n    val square = Square(5)\n    printArea(square)\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the `Shape` class is not an interface and does not provide a clear contract for area calculation. By introducing an `AreaCalculable` interface, we ensure that only classes that need to calculate an area implement this interface, adhering to the ISP. This change also maintains the functionality of the original code while improving its design."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"open class Animal {\\n    open fun move() {}\\n}\\n\\ninterface Movable {\\n    fun move()\\n}\\n\\nclass Dog : Animal(), Movable {\\n    override fun move() {\\n        println(\\\"Dog runs\\\")\\n    }\\n}\\n\\nclass Fish : Animal(), Movable {\\n    override fun move() {\\n        println(\\\"Fish swims\\\")\\n    }\\n}\\n\\nfun animalMove(movable: Movable) {\\n    movable.move()\\n}\\n\\nfun main() {\\n    val fish = Fish()\\n    animalMove(fish)\\n    val dog = Dog()\\n    animalMove(dog)\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `Animal` class is not designed to be an interface for movement. By introducing a `Movable` interface, we ensure that only classes that need to implement movement behavior do so, adhering to the ISP. Additionally, this refactoring allows for better extensibility and separation of concerns.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":3885656292}",
            "output": "open class Animal {\n    open fun move() {}\n}\n\ninterface Movable {\n    fun move()\n}\n\nclass Dog : Movable {\n    override fun move() {\n        println(\"Dog runs\")\n    }\n}\n\nclass Fish : Movable {\n    override fun move() {\n        println(\"Fish swims\")\n    }\n}\n\nfun animalMove(movable: Movable) {\n    movable.move()\n}\n\nfun main() {\n    val fish = Fish()\n    animalMove(fish)\n    val dog = Dog()\n    animalMove(dog)\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the `Animal` class is not designed to be an interface for movement. By introducing a `Movable` interface, we ensure that only classes that need to implement movement behavior do so, adhering to the ISP. Additionally, this refactoring allows for better extensibility and separation of concerns."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"interface Payment {\\n    fun pay(amount: Double)\\n}\\n\\nclass CashPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount by credit card\\\")\\n    }\\n}\\n\\nclass PaymentProcessor {\\n    fun processPayment(payment: Payment, amount: Double) {\\n        payment.pay(amount)\\n    }\\n}\\n\\nfun main() {\\n    val credit = CreditPayment()\\n    val paymentProcessor = PaymentProcessor()\\n    paymentProcessor.processPayment(credit, 100.0)\\n}\",\"explanation\":\"The refactored code introduces a `PaymentProcessor` class that encapsulates the payment processing logic, adhering to the Single Responsibility Principle (SRP) by separating the payment processing from the payment methods. This change also enhances the Open/Closed Principle (OCP) by allowing new payment methods to be added without modifying the existing processing logic. The overall structure remains intact, ensuring that the code is still compilable and functional.\"},\"violation_type\":\"SRP\"}",
            "output": "{\"violation_type\":\"SRP\",\"refactored_code\":\"class PaymentProcessor {\\n    private val payments: List<Payment> = listOf(CashPayment(), CreditPayment())\\n\\n    fun processPayment(paymentType: String, amount: Double) {\\n        val payment = payments.find { it.javaClass.simpleName == paymentType }\\n        payment?.pay(amount) ?: throw IllegalArgumentException(\\\"Invalid payment type\\\")\\n    }\\n}\\n\\ninterface Payment {\\n    fun pay(amount: Double)\\n}\\n\\nclass CashPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount by credit card\\\")\\n    }\\n}\\n\\nfun main() {\\n    val paymentProcessor = PaymentProcessor()\\n    paymentProcessor.processPayment(\\\"CreditPayment\\\", 100.0)\\n}\",\"explanation\":\"The refactored code consolidates the payment processing logic into the `PaymentProcessor` class, which now handles the selection of payment methods based on a string identifier. This adheres to the Single Responsibility Principle (SRP) by ensuring that the `PaymentProcessor` is solely responsible for processing payments, while the individual payment classes handle their specific payment logic. This change also allows for easier extension of payment types without modifying the existing code.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"kotlin\\ninterface Writer {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ConsoleWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to console: \\$data\\\")\\n    }\\n}\\n\\nfun save(writer: Writer, data: String) {\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val fileWriter = FileWriter()\\n    save(fileWriter, \\\"Hello\\\")\\n    val consoleWriter = ConsoleWriter()\\n    save(consoleWriter, \\\"Hello World\\\")\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code adheres to the SOLID principles fairly well, but it can be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. In the original code, if we wanted to add a new type of writer (e.g., ConsoleWriter), we would need to modify the existing code. By introducing a new class for ConsoleWriter, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP.\"},\"violation_type\":\"OCP\"}",
            "output": "{\"violation_type\":\"OCP\",\"refactored_code\":\"\\\"\\\"\\\"kotlin\\ninterface Writer {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ConsoleWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to console: \\$data\\\")\\n    }\\n}\\n\\nfun save(writer: Writer, data: String) {\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val writers: List<Writer> = listOf(FileWriter(), ConsoleWriter())\\n    writers.forEach { writer -> save(writer, \\\"Hello World\\\") }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code adheres to the SOLID principles fairly well, but it can be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. In the original code, if we wanted to add a new type of writer (e.g., ConsoleWriter), we would need to modify the existing code. By introducing a new class for ConsoleWriter and using a list to handle multiple writers, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "interface Movable {\n    fun move()\n}\n\nclass Car : Movable {\n    override fun move() {\n        println(\"Car drives\")\n    }\n}\n\nclass Bicycle : Movable {\n    override fun move() {\n        println(\"Bicycle pedals\")\n    }\n}\n\nclass Vehicle(private val movable: Movable) {\n    fun start() {\n        movable.move()\n    }\n}\n\nfun main() {\n    val bike = Vehicle(Bicycle())\n    bike.start()\n    val car = Vehicle(Car())\n    car.start()\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2663912125,\"explanation\":\"The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present."
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"interface Notification {\\n    fun send(message: String)\\n}\\n\\nclass EmailNotification : Notification {\\n    override fun send(message: String) {\\n        println(\\\"Email: \\$message\\\")\\n    }\\n}\\n\\nclass SMSNotification : Notification {\\n    override fun send(message: String) {\\n        println(\\\"SMS: \\$message\\\")\\n    }\\n}\\n\\nclass NotificationService {\\n    fun notifyUser(notification: Notification, message: String) {\\n        notification.send(message)\\n    }\\n}\\n\\nfun main() {\\n    val email = EmailNotification()\\n    val sms = SMSNotification()\\n    val notificationService = NotificationService()\\n    notificationService.notifyUser(email, \\\"Hello via Email\\\")\\n    notificationService.notifyUser(sms, \\\"Hello via SMS\\\")\\n}\",\"explanation\":\"The original code adheres to most SOLID principles but can be improved in terms of the Single Responsibility Principle (SRP). The `notifyUser` function is responsible for both sending notifications and determining the type of notification to send. By introducing a `NotificationService` class, we separate the concerns of notification management from the notification types themselves. This allows for easier extension in the future, such as adding new notification types without modifying existing code.\"}",
            "output": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"class User(val name: String) {\\n    fun sendEmail(message: String) {\\n        println(\\\"Sending email to \\$name: \\$message\\\")\\n    }\\n\\n    fun sendSMS(message: String) {\\n        println(\\\"Sending SMS to \\$name: \\$message\\\")\\n    }\\n}\\n\\nfun main() {\\n    val user = User(\\\"John\\\")\\n    user.sendEmail(\\\"Hello via Email\\\")\\n    user.sendSMS(\\\"Hello via SMS\\\")\\n}\",\"explanation\":\"The original `User` class was responsible for both user data and sending notifications, violating the Single Responsibility Principle (SRP). By separating the notification methods into their own classes or services, we can ensure that the `User` class only handles user-related data and actions, making the code cleaner and more maintainable.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"interface Printer {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass LocalPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing locally: \\$document\\\")\\n    }\\n}\\n\\nclass PrintManager(private val printer: Printer) {\\n    fun print(document: String) {\\n        printer.printDocument(document)\\n    }\\n}\\n\\nfun main() {\\n    val networkPrinter = NetworkPrinter()\\n    val localPrinter = LocalPrinter()\\n    val printManager = PrintManager(networkPrinter)\\n    printManager.print(\\\"Test over network\\\")\\n    val localPrintManager = PrintManager(localPrinter)\\n    localPrintManager.print(\\\"Test locally\\\")\\n}\",\"explanation\":\"The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable.\"},\"violation_type\":\"Dependency Inversion Principle (DIP)\"}",
            "output": "{\"violation_type\":\"Dependency Inversion Principle (DIP)\",\"refactored_code\":\"interface Printer {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass LocalPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing locally: \\$document\\\")\\n    }\\n}\\n\\nclass PrintManager(private val printer: Printer) {\\n    fun print(document: String) {\\n        printer.printDocument(document)\\n    }\\n}\\n\\nfun main() {\\n    val networkPrinter = NetworkPrinter()\\n    val localPrinter = LocalPrinter()\\n    val printManager = PrintManager(networkPrinter)\\n    printManager.print(\\\"Test over network\\\")\\n    val localPrintManager = PrintManager(localPrinter)\\n    localPrintManager.print(\\\"Test locally\\\")\\n}\",\"explanation\":\"The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"interface Logger {\\n    fun log(message: String)\\n}\\n\\ninterface CountableLogger : Logger {\\n    fun getMessagesLoggedCount(): Int\\n}\\n\\nclass CountingLogger : CountableLogger {\\n    private var messagesLogged: Int = 0\\n\\n    override fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    override fun log(message: String) {\\n        println(\\\"[COUNTING LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\nclass SilentLogger : Logger {\\n    override fun log(message: String) {\\n        // No operation\\n    }\\n}\",\"explanation\":\"The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\"}}",
            "output": "{\"violation_type\":\"Interface Segregation Principle (ISP)\",\"refactored_code\":\"interface Logger {\\n    fun log(message: String)\\n}\\n\\ninterface CountableLogger : Logger {\\n    fun getMessagesLoggedCount(): Int\\n}\\n\\nclass CountingLogger : CountableLogger {\\n    private var messagesLogged: Int = 0\\n\\n    override fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    override fun log(message: String) {\\n        println(\\\"[COUNTING LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\nclass SilentLogger : Logger {\\n    override fun log(message: String) {\\n        // No operation\\n    }\\n}\",\"explanation\":\"The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\ninterface LogBuffer {\n    fun addLog(message: String)\n    fun getLogContents(): List<String>\n}\n\nclass ThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass LoggerImpl(private val logBuffer: LogBuffer) : Logger {\n    override fun log(message: String) {\n        logBuffer.addLog(message)\n        println(message)\n    }\n}\n\nfun main() {\n    val threadSafeLogger = LoggerImpl(ThreadSafeLogBuffer())\n    threadSafeLogger.log(\"This is a thread-safe log message.\")\n\n    val nonThreadSafeLogger = LoggerImpl(NonThreadSafeLogBuffer())\n    nonThreadSafeLogger.log(\"This is a non-thread-safe log message.\")\n}",
            "output": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\ninterface LogBuffer {\n    fun addLog(message: String)\n    fun getLogContents(): List<String>\n}\n\nclass ThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass LoggerImpl(private val logBuffer: LogBuffer) : Logger {\n    override fun log(message: String) {\n        logBuffer.addLog(message)\n        println(message)\n    }\n}\n\nfun main() {\n    val threadSafeLogger = LoggerImpl(ThreadSafeLogBuffer())\n    threadSafeLogger.log(\"This is a thread-safe log message.\")\n\n    val nonThreadSafeLogger = LoggerImpl(NonThreadSafeLogBuffer())\n    nonThreadSafeLogger.log(\"This is a non-thread-safe log message.\")\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The LoggerImpl class was responsible for both logging messages and managing the log buffer. By separating the log buffer into its own interface and implementation, we adhere to the Single Responsibility Principle, ensuring that each class has one reason to change."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"kotlin\\nimport kotlin.math.PI\\n\\ninterface IShape {\\n    fun area(): Double\\n}\\n\\nclass Circle(val radius: Double) : IShape {\\n    override fun area(): Double {\\n        val calculatedArea = PI  radius  radius\\n        return calculatedArea\\n    }\\n}\\n\\nclass NullShape : IShape {\\n    override fun area(): Double {\\n        return 0.0\\n    }\\n}\\n\\nclass ShapeAreaPrinter(private val shape: IShape) {\\n    fun printArea() {\\n        val area = shape.area()\\n        println(\\\"Area: \\$area\\\")\\n    }\\n}\\n\\nfun main() {\\n    val circle = Circle(5.0)\\n    val nullShape = NullShape()\\n    val circlePrinter = ShapeAreaPrinter(circle)\\n    val nullShapePrinter = ShapeAreaPrinter(nullShape)\\n    circlePrinter.printArea()\\n    nullShapePrinter.printArea()\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The refactored code adheres to the SOLID principles more closely. The Single Responsibility Principle (SRP) is respected by separating the area calculation from the printing logic, which is now handled by the `ShapeAreaPrinter` class. The Open/Closed Principle (OCP) is also respected, as new shapes can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since `NullShape` can be used interchangeably with other shapes without breaking functionality. The Interface Segregation Principle (ISP) is not directly applicable here as the interface is simple and specific. The Dependency Inversion Principle (DIP) is respected by depending on abstractions (the `IShape` interface) rather than concrete implementations.\"},\"violation_type\":\"Liskov Substitution Principle (LSP)\"}",
            "output": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"\\\"\\\"\\\"kotlin\\nimport kotlin.math.PI\\n\\ninterface IShape {\\n    fun area(): Double\\n}\\n\\nclass Circle(val radius: Double) : IShape {\\n    override fun area(): Double {\\n        return PI  radius  radius\\n    }\\n}\\n\\nclass NullShape : IShape {\\n    override fun area(): Double {\\n        return 0.0\\n    }\\n}\\n\\nclass ShapeAreaPrinter(private val shape: IShape) {\\n    fun printArea() {\\n        val area = shape.area()\\n        println(\\\"Area: \\$area\\\")\\n    }\\n}\\n\\nfun main() {\\n    val circle = Circle(5.0)\\n    val nullShape = NullShape()\\n    val circlePrinter = ShapeAreaPrinter(circle)\\n    val nullShapePrinter = ShapeAreaPrinter(nullShape)\\n    circlePrinter.printArea()\\n    nullShapePrinter.printArea()\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of `IShape` can be used interchangeably without affecting the correctness of the program. The `NullShape` class is a valid implementation of the `IShape` interface, allowing it to be used in the same context as other shapes without causing errors or unexpected behavior.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"import java.io.File\\n\\ninterface FileStatusProvider {\\n    fun getStatus(filePath: String): String\\n}\\n\\ninterface FileProcessor : FileStatusProvider {\\n    fun processFile(filePath: String)\\n}\\n\\nclass RealFileProcessor(private val fileStatusProvider: FileStatusProvider) : FileProcessor {\\n    override fun getStatus(filePath: String): String {\\n        return fileStatusProvider.getStatus(filePath)\\n    }\\n\\n    override fun processFile(filePath: String) {\\n        println(\\\"RealProcessor: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"RealProcessor: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"RealProcessor: File \\$filePath processed successfully.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileStatusProvider : FileStatusProvider {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"ReadOnlyStatusProvider: Checking status for \\$filePath - Read-only access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Available (Read-only)\\\"\\n        } else {\\n            \\\"File not found (Read-only)\\\"\\n        }\\n    }\\n}\\n\\nclass WritableFileStatusProvider : FileStatusProvider {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"WritableStatusProvider: Checking status for \\$filePath - Writable access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Ready for processing\\\"\\n        } else {\\n            \\\"File not found\\\"\\n        }\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `RealFileProcessor` class is responsible for both processing files and checking their status. This has been refactored by introducing separate status provider classes (`ReadOnlyFileStatusProvider` and `WritableFileStatusProvider`) that handle the status checking independently. The `RealFileProcessor` now only processes files and delegates the status checking to the provided `FileStatusProvider`. This separation of concerns improves maintainability and adheres to the SRP.\"}",
            "output": "class User {\n    private String name;\n    private String email;\n\n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n}\n\nclass UserService {\n    public void registerUser(User user) {\n        // Registration logic\n    }\n\n    public void sendEmail(User user) {\n        // Email sending logic\n    }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `UserService` class is responsible for both user registration and sending emails. This has been refactored by separating the responsibilities into distinct classes. The `User` class now only holds user data, while the `UserService` class handles user registration and email sending independently. This separation enhances clarity and maintainability."
        },
        {
            "input": "abstract class Bird { public abstract void Move(); } class Ostrich : Bird { public override void Move() { / Ostriches run instead of fly / } } class Sparrow : Bird { public override void Move() { / Sparrows fly / } }",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1921700750,\"explanation\":\"This refactoring separates the responsibilities of different bird types into their own classes, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of different bird types into their own classes, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"c#\\nusing System;\\n\\ninterface IShape\\n{\\n    int Area();\\n}\\n\\nclass Rectangle : IShape\\n{\\n    public int Width { get; set; }\\n    public int Height { get; set; }\\n    public int Area() => Width  Height;\\n}\\n\\nclass Square : IShape\\n{\\n    public int Side { get; set; }\\n    public int Area() => Side  Side;\\n}\\n\\nclass ShapeAreaCalculator\\n{\\n    public static int CalculateArea(IShape shape)\\n    {\\n        return shape.Area();\\n    }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code violates the Open/Closed Principle (OCP) because adding new shapes requires modifying the existing code. By introducing an interface (IShape), we allow for new shapes to be added without changing existing classes. This adheres to OCP as new implementations can be created without altering the existing codebase. Additionally, the code is now more flexible and adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes.\"},\"violation_type\":\"OCP\",\"total_duration\":4695350166}",
            "output": "```c#\nusing System;\n\ninterface IShape\n{\n    int Area();\n}\n\nclass Rectangle : IShape\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public int Area() => Width  Height;\n}\n\nclass Square : IShape\n{\n    public int Side { get; set; }\n    public int Area() => Side  Side;\n}\n\nclass ShapeAreaCalculator\n{\n    public static int CalculateArea(IShape shape)\n    {\n        return shape.Area();\n    }\n}\n```",
            "level": "EASY",
            "language": "C#",
            "violation": "OCP",
            "explanation": "The original code violates the Open/Closed Principle (OCP) because adding new shapes requires modifying the existing code. By introducing an interface (IShape), we allow for new shapes to be added without changing existing classes. This adheres to OCP as new implementations can be created without altering the existing codebase. Additionally, the code is now more flexible and adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes."
        },
        {
            "input": "abstract class Animal { public abstract void Move(); } class Fish : Animal { public override void Move() { Console.WriteLine(\"Fish swims\"); } } class Bird : Animal { public override void Move() { Console.WriteLine(\"Bird flies\"); } } class Dog : Animal { public override void Move() { Console.WriteLine(\"Dog runs\"); } }",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2338784000,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Animal` class is responsible for defining the movement behavior of different animals, which can lead to a lack of clarity and separation of concerns. Each animal type should have its own implementation of movement without being tightly coupled to a single class.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `Animal` class is responsible for defining the movement behavior of different animals, which can lead to a lack of clarity and separation of concerns. Each animal type should have its own implementation of movement without being tightly coupled to a single class."
        },
        {
            "input": "interface IPayment { void Pay(); } class PaidPayment : IPayment { public void Pay() { / Logic for paid payment / } } class FreePayment : IPayment { public void Pay() { / Logic for free payment / } } class PaymentProcessor { public void ProcessPayment(IPayment payment) { payment.Pay(); } }",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2623934541,\"explanation\":\"The original code violates the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments."
        },
        {
            "input": "interface IFileWriter { void Write(string data); } class FileWriter : IFileWriter { public void Write(string data) { / Implementation for writing to a file / } } class ReadOnlyFileWriter : IFileWriter { public void Write(string data) { throw new InvalidOperationException(\"Cannot write to a read-only file.\"); } } class FileReader { public string Read(string filePath) { / Implementation for reading from a file / return \"\"; } }",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2772351292,\"explanation\":\"The original code violates the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes are both implementing the `Write` method, which leads to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes are both implementing the `Write` method, which leads to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility."
        },
        {
            "input": "abstract class Vehicle { public abstract void Move(); } class Car : Vehicle { public override void Move() { / Implementation for Car movement / } } class Bicycle : Vehicle { public override void Move() { / Implementation for Bicycle movement / } } class VehicleMover { public void MoveVehicle(Vehicle vehicle) { vehicle.Move(); } }",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1805129084,\"explanation\":\"This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle."
        },
        {
            "input": "interface IDocument { void Print(); } class PaperDocument : IDocument { public void Print() { / Print logic for paper document / } } class DigitalDocument : IDocument { public void Print() { / Print logic for digital document / } } class DocumentPrinter { public void PrintDocument(IDocument document) { document.Print(); } }",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2149269709,\"explanation\":\"This code violates the Single Responsibility Principle because the `DocumentPrinter` class is responsible for printing documents, while the document classes themselves are responsible for their own print logic. By separating the responsibilities into distinct classes, we adhere to SRP.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "This code violates the Single Responsibility Principle because the `DocumentPrinter` class is responsible for printing documents, while the document classes themselves are responsible for their own print logic. By separating the responsibilities into distinct classes, we adhere to SRP."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"using System;using System.Collections.Generic;interface ITimer { void Start(); void Stop(); }abstract class TimerBase : ITimer { public abstract void Start(); public abstract void Stop(); }class RegularTimer : TimerBase { public override void Start() { Console.WriteLine(\\\"Regular Timer Started\\\"); } public override void Stop() { Console.WriteLine(\\\"Regular Timer Stopped\\\"); }}class OneShotTimer : TimerBase { public override void Start() { Console.WriteLine(\\\"One Shot Timer Started\\\"); } public override void Stop() { Console.WriteLine(\\\"One Shot Timer Stopped\\\"); }}class TimerManager { private List<ITimer> timers = new List<ITimer>(); public void AddTimer(ITimer timer) { timers.Add(timer); } public void StartAll() { foreach (var timer in timers) { timer.Start(); } } public void StopAll() { foreach (var timer in timers) { timer.Stop(); } }}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the ITimer interface does not encapsulate a single responsibility; it allows for different types of timers to be implemented without a clear distinction of their behaviors. The Open/Closed Principle (OCP) is also violated since adding new timer types requires modifying existing code. The refactored code introduces an abstract class TimerBase that provides a common base for all timers, allowing for extensibility without modifying existing code. This adheres to OCP. The refactored code also maintains the Liskov Substitution Principle (LSP) as all derived classes can be used interchangeably without altering the correctness of the program. The Interface Segregation Principle (ISP) is respected as the ITimer interface remains focused on timer functionalities. The Dependency Inversion Principle (DIP) is also respected as higher-level modules (like TimerManager) depend on abstractions (ITimer) rather than concrete implementations. Overall, the refactored code is more maintainable and adheres to SOLID principles better than the original.\"},\"violation_type\":\"Multiple SOLID Violations\",\"total_duration\":7991389750}",
            "output": "using System;using System.Collections.Generic;interface ITimer { void Start(); void Stop(); }abstract class TimerBase : ITimer { public abstract void Start(); public abstract void Stop(); }class RegularTimer : TimerBase { public override void Start() { Console.WriteLine(\"Regular Timer Started\"); } public override void Stop() { Console.WriteLine(\"Regular Timer Stopped\"); }}class OneShotTimer : TimerBase { public override void Start() { Console.WriteLine(\"One Shot Timer Started\"); } public override void Stop() { Console.WriteLine(\"One Shot Timer Stopped\"); }}class TimerManager { private List<ITimer> timers = new List<ITimer>(); public void AddTimer(ITimer timer) { timers.Add(timer); } public void StartAll() { foreach (var timer in timers) { timer.Start(); } } public void StopAll() { foreach (var timer in timers) { timer.Stop(); } }}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "Multiple SOLID Violations",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the ITimer interface does not encapsulate a single responsibility; it allows for different types of timers to be implemented without a clear distinction of their behaviors. The Open/Closed Principle (OCP) is also violated since adding new timer types requires modifying existing code. The refactored code introduces an abstract class TimerBase that provides a common base for all timers, allowing for extensibility without modifying existing code. This adheres to OCP. The refactored code also maintains the Liskov Substitution Principle (LSP) as all derived classes can be used interchangeably without altering the correctness of the program. The Interface Segregation Principle (ISP) is respected as the ITimer interface remains focused on timer functionalities. The Dependency Inversion Principle (DIP) is also respected as higher-level modules (like TimerManager) depend on abstractions (ITimer) rather than concrete implementations. Overall, the refactored code is more maintainable and adheres to SOLID principles better than the original."
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"using System;\\nusing System.IO;\\n\\ninterface IFileStatusProvider\\n{\\n    string GetStatus(string filePath);\\n}\\n\\nclass FileStatusProvider : IFileStatusProvider\\n{\\n    public virtual string GetStatus(string filePath)\\n    {\\n        if (File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Found.\");\\n            return \\\"Ready for status check\\\";\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Not Found.\");\\n            return \\\"File not found\\\";\\n        }\\n    }\\n}\\n\\nclass ReadOnlyFileStatusProvider : IFileStatusProvider\\n{\\n    public string GetStatus(string filePath)\\n    {\\n        Console.WriteLine($\"ReadOnlyStatus: Checking status for {filePath} - Read-only access.\");\\n        if (File.Exists(filePath))\\n        {\\n            return \\\"Available (Read-only)\\\";\\n        }\\n        else\\n        {\\n            return \\\"File not found (Read-only)\\\";\\n        }\\n    }\\n}\\n\\nclass FileProcessor\\n{\\n    private readonly IFileStatusProvider _fileStatusProvider;\\n\\n    public FileProcessor(IFileStatusProvider fileStatusProvider)\\n    {\\n        _fileStatusProvider = fileStatusProvider;\\n    }\\n\\n    public void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"Processor: Processing file {filePath}...\");\\n        if (!File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Processor: Error - File {filePath} not found for processing.\");\\n            return;\\n        }\\n        Console.WriteLine($\"Processor: File {filePath} processed successfully.\");\\n    }\\n\\n    public string GetStatus(string filePath)\\n    {\\n        string baseStatus = _fileStatusProvider.GetStatus(filePath);\\n        if (baseStatus == \\\"Ready for status check\\\") return \\\"Ready for processing\\\";\\n        return baseStatus;\\n    }\\n}\",\"explanation\":\"The refactored code separates the concerns of file status checking and file processing, adhering to the Single Responsibility Principle (SRP). The FileProcessor class now depends on an interface (IFileStatusProvider) rather than a concrete class, which adheres to the Dependency Inversion Principle (DIP). The Open/Closed Principle (OCP) is respected as new status providers can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since all implementations of IFileStatusProvider can be used interchangeably. The Interface Segregation Principle (ISP) is also respected as the interface is focused on a single responsibility.\"}}",
            "output": "using System;\nusing System.IO;\n\ninterface IFileStatusProvider\n{\n    string GetStatus(string filePath);\n}\n\nclass FileStatusProvider : IFileStatusProvider\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Found.\");\n            return \"Ready for status check\";\n        }\n        else\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n}\n\nclass ReadOnlyFileStatusProvider : IFileStatusProvider\n{\n    public string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnlyStatus: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n}\n\nclass FileProcessor\n{\n    private readonly IFileStatusProvider _fileStatusProvider;\n\n    public FileProcessor(IFileStatusProvider fileStatusProvider)\n    {\n        _fileStatusProvider = fileStatusProvider;\n    }\n\n    public void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Processor: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Processor: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Processor: File {filePath} processed successfully.\");\n    }\n\n    public string GetStatus(string filePath)\n    {\n        string baseStatus = _fileStatusProvider.GetStatus(filePath);\n        if (baseStatus == \"Ready for status check\") return \"Ready for processing\";\n        return baseStatus;\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The refactored code separates the concerns of file status checking and file processing, adhering to the Single Responsibility Principle (SRP). The FileProcessor class now depends on an interface (IFileStatusProvider) rather than a concrete class, which adheres to the Dependency Inversion Principle (DIP). The Open/Closed Principle (OCP) is respected as new status providers can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since all implementations of IFileStatusProvider can be used interchangeably. The Interface Segregation Principle (ISP) is also respected as the interface is focused on a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\n\\ninterface IAccount\\n{\\n    void Withdraw(decimal amount);\\n    decimal GetBalance();\\n}\\n\\nabstract class AccountBase : IAccount\\n{\\n    protected decimal _balance;\\n\\n    public decimal GetBalance()\\n    {\\n        return _balance;\\n    }\\n}\\n\\nclass ActiveAccount : AccountBase\\n{\\n    public ActiveAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Active\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Active\\\");\\n        }\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds. Cannot withdraw {amount}. Balance: {_balance}\");\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : AccountBase\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public LimitedWithdrawalAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount > MaxWithdrawalLimit)\\n        {\\n            LogExceedsLimit(amount, MaxWithdrawalLimit, \\\"Limited\\\");\\n        }\\n        else if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Limited\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Limited\\\");\\n        }\\n    }\\n\\n    private void LogExceedsLimit(decimal amount, decimal limit, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Withdrawal request ({amount}) exceeds per-transaction limit ({limit}). No action taken. Balance remains: {_balance}\");\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds for withdrawal ({amount}). Balance: {_balance}\");\\n    }\\n}\",\"explanation\":\"The refactored code addresses the Single Responsibility Principle (SRP) violation by creating an abstract base class `AccountBase` that handles the common functionality of getting the balance. Each account type now only focuses on its specific withdrawal logic. Additionally, logging methods have been extracted to avoid code duplication and improve maintainability.\"}",
            "output": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\n\\ninterface IAccount\\n{\\n    void Withdraw(decimal amount);\\n    decimal GetBalance();\\n}\\n\\nabstract class AccountBase : IAccount\\n{\\n    protected decimal _balance;\\n\\n    public decimal GetBalance()\\n    {\\n        return _balance;\\n    }\\n}\\n\\nclass ActiveAccount : AccountBase\\n{\\n    public ActiveAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Active\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Active\\\");\\n        }\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds. Cannot withdraw {amount}. Balance: {_balance}\");\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : AccountBase\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public LimitedWithdrawalAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount > MaxWithdrawalLimit)\\n        {\\n            LogExceedsLimit(amount, MaxWithdrawalLimit, \\\"Limited\\\");\\n        }\\n        else if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Limited\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Limited\\\");\\n        }\\n    }\\n\\n    private void LogExceedsLimit(decimal amount, decimal limit, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Withdrawal request ({amount}) exceeds per-transaction limit ({limit}). No action taken. Balance remains: {_balance}\");\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds for withdrawal ({amount}). Balance: {_balance}\");\\n    }\\n}\",\"explanation\":\"The refactored code addresses the Single Responsibility Principle (SRP) violation by creating an abstract base class `AccountBase` that handles the common functionality of getting the balance. Each account type now only focuses on its specific withdrawal logic. Additionally, logging methods have been extracted to avoid code duplication and improve maintainability.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"using System;\\n\\ninterface ILogger\\n{\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger\\n{\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass LoggerWithIncorrectTimestamp : ILogger\\n{\\n    private readonly ILogger _logger;\\n    private readonly DateTime _creationTime = DateTime.Now;\\n\\n    public LoggerWithIncorrectTimestamp(ILogger logger)\\n    {\\n        _logger = logger;\\n    }\\n\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        _logger.Log(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the Logger class is responsible for both logging messages and formatting them with timestamps. It also violates the Dependency Inversion Principle (DIP) because the Logger class is tightly coupled to the Console output. The refactored code introduces an ILogger interface to decouple the logging functionality from the implementation, allowing for better adherence to SOLID principles. The ConsoleLogger class handles the actual logging to the console, while LoggerWithIncorrectTimestamp uses an ILogger instance to log messages with a fixed timestamp.\"},\"violation_type\":\"SRP, DIP\"}",
            "output": "{\"violation_type\":\"SRP, DIP\",\"refactored_code\":\"using System;\\n\\ninterface ILogger\\n{\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger\\n{\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass TimestampLogger : ILogger\\n{\\n    private readonly ILogger _logger;\\n    private readonly DateTime _creationTime;\\n\\n    public TimestampLogger(ILogger logger)\\n    {\\n        _logger = logger;\\n        _creationTime = DateTime.Now;\\n    }\\n\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        _logger.Log(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the Logger class is responsible for both logging messages and formatting them with timestamps. It also violates the Dependency Inversion Principle (DIP) because the Logger class is tightly coupled to the Console output. The refactored code introduces an ILogger interface to decouple the logging functionality from the implementation, allowing for better adherence to SOLID principles. The ConsoleLogger class handles the actual logging to the console, while TimestampLogger uses an ILogger instance to log messages with a fixed timestamp.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic interface ICollectionProcessor\\n{\\n    void ProcessCollection(IEnumerable<string> data);\\n}\\n\\npublic class StandardCollectionProcessor : ICollectionProcessor\\n{\\n    public void ProcessCollection(IEnumerable<string> data)\\n    {\\n        Console.WriteLine(\\\"[StandardProcessor] Starting processing...\\\");\\n        foreach (var item in data.ToList())\\n        {\\n            ProcessItem(item);\\n        }\\n        Console.WriteLine(\\\"[StandardProcessor] Processing finished.\\\");\\n    }\\n\\n    private void ProcessItem(string item)\\n    {\\n        Console.WriteLine($\"[StandardProcessor] Processing item: {item}\");\\n        System.Threading.Thread.Sleep(10);\\n    }\\n}\\n\\npublic class LoggingCollectionProcessor : ICollectionProcessor\\n{\\n    private readonly ICollectionProcessor _innerProcessor;\\n\\n    public LoggingCollectionProcessor(ICollectionProcessor innerProcessor)\\n    {\\n        _innerProcessor = innerProcessor;\\n    }\\n\\n    public void ProcessCollection(IEnumerable<string> data)\\n    {\\n        Console.WriteLine(\\\"[LoggingProcessor] Starting logging...\\\");\\n        _innerProcessor.ProcessCollection(data);\\n        Console.WriteLine(\\\"[LoggingProcessor] Finished logging.\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `StandardCollectionProcessor` class is responsible for both processing the collection and logging the processing steps. In the refactored code, I separated the logging functionality into a new class called `LoggingCollectionProcessor`, which wraps around the original processor. This way, each class has a single responsibility: `StandardCollectionProcessor` focuses on processing the collection, while `LoggingCollectionProcessor` handles logging. This adheres to the SRP and makes the code more maintainable and extensible.\"}",
            "output": "public class User {\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n\npublic class UserService {\n    public void RegisterUser(User user) {\n        // Registration logic\n    }\n}\n\npublic class UserNotificationService {\n    public void NotifyUser(User user) {\n        // Notification logic\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `User` class was responsible for both user data and user notifications. In the refactored code, I separated the responsibilities into distinct classes: `User` for user data, `UserService` for user registration, and `UserNotificationService` for user notifications. This adheres to the SRP, making the code cleaner and easier to maintain."
        }
    ]
}