{
    "code_examples": [
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":3038600959,\"explanation\":\"The original code had a potential LSP violation because the `Bird` class was not defined as abstract, which could lead to instances of `Bird` being created directly, violating the expected behavior of subclasses. By making `Bird` an abstract class, we ensure that it cannot be instantiated directly, thus adhering to LSP.\"}",
            "output": "abstract class Bird {\n    public abstract void fly();\n}\n\nclass Sparrow extends Bird {\n    @Override\n    public void fly() {\n        // Implementation for Sparrow flying\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Ostriches cannot fly\");\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code had a potential LSP violation because the `Bird` class was not defined as abstract, which could lead to instances of `Bird` being created directly, violating the expected behavior of subclasses. By making `Bird` an abstract class, we ensure that it cannot be instantiated directly, thus adhering to LSP."
        },
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":3036255167,\"explanation\":\"The original implementation of `Square` violated LSP because it had a separate implementation for `getArea()`, which could lead to unexpected behavior when using polymorphism. The refactored code makes `Square` extend `Rectangle`, ensuring that it adheres to the expected behavior of the `Shape` interface.\"}",
            "output": "class Shape {\n    public double getArea();\n}\n\nclass Rectangle implements Shape {\n    private double width;\n    private double height;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    public double getArea() {\n        return width  height;\n    }\n}\n\nclass Square extends Rectangle {\n    public Square(double side) {\n        super(side, side);\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original implementation of `Square` violated LSP because it had a separate implementation for `getArea()`, which could lead to unexpected behavior when using polymorphism. The refactored code makes `Square` extend `Rectangle`, ensuring that it adheres to the expected behavior of the `Shape` interface."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2454655125,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely.\"}",
            "output": "interface SoundMaker {\n    void makeSound();\n}\n\nclass Dog implements SoundMaker {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\nclass Cat implements SoundMaker {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n\nclass Animal {\n    private SoundMaker soundMaker;\n\n    public Animal(SoundMaker soundMaker) {\n        this.soundMaker = soundMaker;\n    }\n\n    public void performSound() {\n        soundMaker.makeSound();\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely."
        },
        {
            "input": "NONE",
            "output": "",
            "level": "EASY",
            "language": "JAVA",
            "violation": "NONE",
            "explanation": "The provided code does not exhibit any violations of the SOLID principles."
        },
        {
            "input": "{\"violation_type\":\"NONE\",\"total_duration\":2278716750,\"explanation\":\"The code adheres to the SOLID principles, with no violations present. Each class has a single responsibility, and the use of interfaces and abstract classes promotes flexibility and extensibility.\"}",
            "output": "",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "NONE",
            "explanation": "The code adheres to the SOLID principles, with no violations present. Each class has a single responsibility, and the use of interfaces and abstract classes promotes flexibility and extensibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":4027409208,\"explanation\":\"The original code had a single `Main` class that was responsible for both user management and email sending, violating the Single Responsibility Principle (SRP). The refactored code separates concerns by keeping user management in `UserService` and email handling in `EmailService`, allowing each class to focus on a single responsibility.\"}",
            "output": "class UserService {\n    public void manageUser() {\n        // User management logic\n    }\n}\n\nclass EmailService {\n    public void sendEmail() {\n        // Email sending logic\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had a single `Main` class that was responsible for both user management and email sending, violating the Single Responsibility Principle (SRP). The refactored code separates concerns by keeping user management in `UserService` and email handling in `EmailService`, allowing each class to focus on a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":2136336916,\"explanation\":\"The `ReadOnlyWriter` class previously threw an exception when the `write` method was called, violating the Liskov Substitution Principle. Now, it implements the method without throwing an exception, allowing it to be used interchangeably with other `Writer` implementations without breaking the expected behavior.\"}",
            "output": "class Writer {\n    write(data) {\n        // implementation for writing data\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    write(data) {\n        // No operation, as this is a read-only writer\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The `ReadOnlyWriter` class previously threw an exception when the `write` method was called, violating the Liskov Substitution Principle. Now, it implements the method without throwing an exception, allowing it to be used interchangeably with other `Writer` implementations without breaking the expected behavior."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2528872542,\"explanation\":\"This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks.\"}",
            "output": "class BasicCalculator {\n    public double divide(double a, double b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Cannot divide by zero\");\n        }\n        return a / b;\n    }\n}\n\nclass SafeCalculator {\n    private BasicCalculator calculator;\n\n    public SafeCalculator() {\n        this.calculator = new BasicCalculator();\n    }\n\n    public double safeDivide(double a, double b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Cannot divide by zero\");\n        }\n        return calculator.divide(a, b);\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks."
        },
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":3646242584,\"explanation\":\"The `NullShape` class violates the Liskov Substitution Principle by returning an area of 0, which may not be a valid area for all shapes. The refactored code maintains the same behavior but ensures that the `NullShape` can be used interchangeably with other shapes without breaking the expected behavior.\"}",
            "output": "class Shape:\n    def area(self):\n        raise NotImplementedError(\"Subclasses should implement this method\")\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14  self.radius  self.radius\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side  self.side\n\nclass NullShape(Shape):\n    def area(self):\n        return None  # Indicating that this shape does not have a valid area\n",
            "level": "HARD",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The `NullShape` class was returning an area of 0, which could mislead users into thinking it is a valid area for a shape. By returning None instead, we indicate that this shape does not have a valid area, thus adhering to the Liskov Substitution Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":8379960542,\"explanation\":\"The `FileProcessorImpl` class was handling both file processing and status handling, violating the Single Responsibility Principle (SRP). The refactored code separates the status handling into its own method, allowing the class to focus solely on processing files.\"}",
            "output": "class FileProcessor {\n    public void processFile(String filePath) {\n        // Logic to process the file\n    }\n}\n\nclass StatusHandler {\n    public void updateStatus(String status) {\n        // Logic to update status\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `FileProcessor` class now only handles file processing, while the `StatusHandler` class is responsible for managing status updates. This separation of concerns adheres to the Single Responsibility Principle (SRP), ensuring that each class has a single reason to change."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1635729625,\"explanation\":\"The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility.\"}",
            "output": "class Logger {\n    log(message) {\n        console.log(message);\n    }\n}\n\nclass MessageCounter {\n    constructor() {\n        this.count = 0;\n    }\n\n    increment() {\n        this.count++;\n    }\n\n    getCount() {\n        return this.count;\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":12719321833,\"explanation\":\"The `DataProcessorImpl` class implements all three interfaces, which violates the Interface Segregation Principle (ISP) because it forces the class to implement methods that may not be relevant for all implementations. The refactoring separates the responsibilities into distinct interfaces, allowing classes to implement only the methods they need.\"}",
            "output": "interface DataReader {\n    void readData();\n}\n\ninterface DataWriter {\n    void writeData();\n}\n\ninterface DataProcessor {\n    void processData();\n}\n\nclass CsvDataReader implements DataReader {\n    public void readData() {\n        // Implementation for reading CSV data\n    }\n}\n\nclass CsvDataWriter implements DataWriter {\n    public void writeData() {\n        // Implementation for writing CSV data\n    }\n}\n\nclass DataProcessorImpl implements DataProcessor {\n    private DataReader dataReader;\n    private DataWriter dataWriter;\n\n    public DataProcessorImpl(DataReader dataReader, DataWriter dataWriter) {\n        this.dataReader = dataReader;\n        this.dataWriter = dataWriter;\n    }\n\n    public void processData() {\n        // Implementation for processing data\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The `DataProcessorImpl` class previously implemented multiple interfaces, which forced it to include methods that were not relevant to its functionality. By creating separate interfaces for reading and writing data, we adhere to the Interface Segregation Principle (ISP), allowing classes to implement only the methods they need."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1620889458,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility.\"}",
            "output": "class Bird {\n    public void fly() {\n        // code for flying\n    }\n}\n\nclass BirdSound {\n    public void makeSound() {\n        // code for making sound\n    }\n}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2544107500,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Shape` class was responsible for both defining a shape and calculating the area. Now, each shape class (e.g., `Circle`, `Rectangle`) has a single responsibility: to calculate its own area.\"}",
            "output": "class Shape {\n    // This class is now an abstract class or interface\n}\n\nclass Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    public double calculateArea() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass Rectangle extends Shape {\n    private double width;\n    private double height;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    public double calculateArea() {\n        return width  height;\n    }\n}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Shape` class was responsible for both defining a shape and calculating the area. Now, each shape class (e.g., `Circle`, `Rectangle`) has a single responsibility: to calculate its own area."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2135687875,\"explanation\":\"This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals.\"}",
            "output": "class Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    move() {\n        // Movement logic specific to the animal\n    }\n}\n\nclass AnimalMover {\n    constructor(animals) {\n        this.animals = animals;\n    }\n    moveAll() {\n        this.animals.forEach(animal => animal.move());\n    }\n}\n\nconst dog = new Animal('Dog');\nconst cat = new Animal('Cat');\nconst animalMover = new AnimalMover([dog, cat]);\nanimalMover.moveAll();",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2383244584,\"explanation\":\"The original `FileHandler` class was responsible for both reading and writing files, which are two distinct responsibilities. By separating these functionalities into `FileReader` and `FileWriter`, we adhere to the Single Responsibility Principle (SRP).\"}",
            "output": "class FileReader {\n    read(filePath) {\n        // Logic to read from a file\n    }\n}\n\nclass FileWriter {\n    write(filePath, data) {\n        // Logic to write to a file\n    }\n}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original `FileHandler` class was responsible for both reading and writing files, which are two distinct responsibilities. By separating these functionalities into `FileReader` and `FileWriter`, we adhere to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"total_duration\":2705308166,\"explanation\":\"The original code used `if-else` statements in the `PaymentFactory` to determine which payment processor to create, violating the Open/Closed Principle. The refactored code allows for new payment processors to be added without modifying the factory, adhering to OCP.\"}",
            "output": "class PaymentProcessor {\n    processPayment(amount) {\n        throw new Error('This method should be overridden');\n    }\n}\n\nclass PayPalProcessor extends PaymentProcessor {\n    processPayment(amount) {\n        console.log(`Processing payment of ${amount} through PayPal`);\n    }\n}\n\nclass StripeProcessor extends PaymentProcessor {\n    processPayment(amount) {\n        console.log(`Processing payment of ${amount} through Stripe`);\n    }\n}\n\nclass PaymentFactory {\n    static createProcessor(type) {\n        const processors = {\n            'paypal': PayPalProcessor,\n            'stripe': StripeProcessor\n        };\n        const Processor = processors[type];\n        if (!Processor) {\n            throw new Error('Payment processor not supported');\n        }\n        return new Processor();\n    }\n}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used `if-else` statements in the `PaymentFactory` to determine which payment processor to create, violating the Open/Closed Principle. The refactored code allows for new payment processors to be added without modifying the factory, adhering to OCP."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3167811125,\"explanation\":\"The refactoring separates the responsibilities of content management and display logic into different classes, adhering to the Single Responsibility Principle (SRP). The `Document` class now only handles content, while `DocumentDisplay` is responsible for displaying the content.\"}",
            "output": "class Document {\n    private String content;\n\n    public Document(String content) {\n        this.content = content;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}\n\nclass DocumentDisplay {\n    public void display(Document document) {\n        System.out.println(document.getContent());\n    }\n}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The refactoring separates the responsibilities of content management and display logic into different classes, adhering to the Single Responsibility Principle (SRP). The `Document` class now only handles content, while `DocumentDisplay` is responsible for displaying the content."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2272183416,\"explanation\":\"The original code violated the Single Responsibility Principle because the `VehicleMover` class was responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility.\"}",
            "output": "class Vehicle {\n    constructor(type) {\n        this.type = type;\n    }\n}\n\nclass VehicleMover {\n    move(vehicle) {\n        console.log(`Moving a ${vehicle.type}`);\n    }\n}\n\nclass Car extends Vehicle {\n    constructor() {\n        super('Car');\n    }\n}\n\nclass Truck extends Vehicle {\n    constructor() {\n        super('Truck');\n    }\n}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `VehicleMover` class was responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2617212666,\"explanation\":\"This refactoring separates the responsibilities of managing user information and sending emails into two distinct classes, adhering to the Single Responsibility Principle (SRP).\"}",
            "output": "class UserManager {\n    public void manageUserInfo(User user) {\n        // Logic to manage user information\n    }\n}\n\nclass EmailService {\n    public void sendEmail(User user, String message) {\n        // Logic to send email\n    }\n}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of managing user information and sending emails into two distinct classes, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":18996784583,\"explanation\":\"The `FullDataProcessor` class implements multiple interfaces (DataLoader, DataProcessor, DataSaver), which violates the Interface Segregation Principle (ISP) because it forces clients to depend on methods they do not use (like save_results in ReadOnlyDataProcessor). The refactoring separates the responsibilities into distinct classes, ensuring that clients only need to implement the methods they require.\"}",
            "output": "class DataLoader {\n    loadData(): void;\n}\n\nclass DataProcessor {\n    processData(data: any): any;\n}\n\nclass DataSaver {\n    saveResults(data: any): void;\n}\n\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessor {\n    loadData() {\n        // Implementation for loading data\n    }\n    processData(data: any) {\n        // Implementation for processing data\n    }\n}\n\nclass FullDataProcessor implements DataLoader, DataProcessor, DataSaver {\n    loadData() {\n        // Implementation for loading data\n    }\n    processData(data: any) {\n        // Implementation for processing data\n    }\n    saveResults(data: any) {\n        // Implementation for saving results\n    }\n}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The `FullDataProcessor` class implements multiple interfaces (DataLoader, DataProcessor, DataSaver), which violates the Interface Segregation Principle (ISP) because it forces clients to depend on methods they do not use (like save_results in ReadOnlyDataProcessor). The refactoring separates the responsibilities into distinct classes, ensuring that clients only need to implement the methods they require."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2783441208,\"explanation\":\"The `CountingLogger` class previously handled both logging and counting messages, violating the Single Responsibility Principle (SRP). Now, the logging functionality is separated into `SimpleMessageLogger`, allowing each class to have a single responsibility.\"}",
            "output": "class SimpleMessageLogger {\n    log(message) {\n        console.log(message);\n    }\n}\n\nclass CountingLogger {\n    constructor() {\n        this.count = 0;\n        this.logger = new SimpleMessageLogger();\n    }\n\n    log(message) {\n        this.count++;\n        this.logger.log(message);\n    }\n\n    getCount() {\n        return this.count;\n    }\n}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The `CountingLogger` class previously handled both logging and counting messages, violating the Single Responsibility Principle (SRP). Now, the logging functionality is separated into `SimpleMessageLogger`, allowing each class to have a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":9673972666,\"explanation\":\"The `FileStatusProvider` interface is too large as it forces all implementations to provide a `get_status` method, even if they may not need it. The refactoring separates the interfaces into more specific ones, allowing classes to implement only the methods they require, thus adhering to the Interface Segregation Principle (ISP).\"}",
            "output": "interface FileStatusProvider {\n    String getStatus();\n}\n\ninterface FileReader {\n    void readFile();\n}\n\nclass TextFileReader implements FileReader, FileStatusProvider {\n    @Override\n    public void readFile() {\n        // Implementation for reading a text file\n    }\n\n    @Override\n    public String getStatus() {\n        return \"Text file status\";\n    }\n}\n\nclass ImageFileReader implements FileReader {\n    @Override\n    public void readFile() {\n        // Implementation for reading an image file\n    }\n    // No need to implement getStatus()\n}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The `FileStatusProvider` interface was too large, forcing all implementations to provide a `get_status` method, even if they didn't need it. By separating the interfaces into `FileStatusProvider` and `FileReader`, classes can now implement only the methods they require, thus adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"total_duration\":7924119250,\"explanation\":\"The original code had a violation of the Open/Closed Principle (OCP) due to the use of a `NullShape` class that was not necessary for the area calculation. By refactoring, we ensured that all shape classes implement the `IShape` interface without needing to check for a null shape, thus allowing for easier extension of new shapes without modifying existing code.\"}",
            "output": "interface IShape {\n    double area();\n}\n\nclass Circle implements IShape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass Rectangle implements IShape {\n    private double width;\n    private double height;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double area() {\n        return width  height;\n    }\n}\n\nclass AreaCalculator {\n    public double totalArea(List<IShape> shapes) {\n        double total = 0;\n        for (IShape shape : shapes) {\n            total += shape.area();\n        }\n        return total;\n    }\n}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code had a violation of the Open/Closed Principle (OCP) due to the use of a `NullShape` class that was not necessary for the area calculation. By refactoring, we ensured that all shape classes implement the `IShape` interface without needing to check for a null shape, thus allowing for easier extension of new shapes without modifying existing code."
        },
        {
            "input": "NONE",
            "output": "",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "NONE",
            "explanation": "The provided code does not exhibit any violations of the SOLID principles."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"total_duration\":4600568208,\"explanation\":\"The original code had a single function `printArea` that was limited to printing the area of one shape at a time. The refactored code allows for multiple shapes to be processed in a list, adhering to the Open/Closed Principle by enabling the addition of new shapes without modifying existing code.\"}",
            "output": "class Shape {\n    public double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    public double area() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass Rectangle extends Shape {\n    private double width, height;\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    public double area() {\n        return width  height;\n    }\n}\n\nclass AreaPrinter {\n    public void printAreas(List<Shape> shapes) {\n        for (Shape shape : shapes) {\n            System.out.println(\"Area: \" + shape.area());\n        }\n    }\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code had a single function `printArea` that was limited to printing the area of one shape at a time. The refactored code allows for multiple shapes to be processed in a list, adhering to the Open/Closed Principle by enabling the addition of new shapes without modifying existing code."
        },
        {
            "input": "NONE",
            "output": "",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "NONE",
            "explanation": ""
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":8438853792,\"explanation\":\"The refactored code separates the responsibility of selecting payment types from the `PaymentProcessor` class. Now, the `processPayment` method directly accepts a `Payment` object, adhering to the Single Responsibility Principle (SRP) by ensuring that the `PaymentProcessor` is only responsible for processing payments, while the individual payment classes handle their specific payment logic. This change simplifies the code and enhances its extensibility.\"}",
            "output": "class Payment {\n    constructor(amount) {\n        this.amount = amount;\n    }\n}\n\nclass CreditCardPayment extends Payment {\n    process() {\n        // Logic for processing credit card payment\n    }\n}\n\nclass PayPalPayment extends Payment {\n    process() {\n        // Logic for processing PayPal payment\n    }\n}\n\nclass PaymentProcessor {\n    processPayment(payment) {\n        payment.process();\n    }\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The refactored code separates the responsibility of selecting payment types from the `PaymentProcessor` class. Now, the `processPayment` method directly accepts a `Payment` object, adhering to the Single Responsibility Principle (SRP) by ensuring that the `PaymentProcessor` is only responsible for processing payments, while the individual payment classes handle their specific payment logic. This change simplifies the code and enhances its extensibility."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"total_duration\":3403721208,\"explanation\":\"The original code adhered to the SOLID principles fairly well, but it could be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. By introducing a new class for ConsoleWriter and using a list to handle multiple writers, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP.\"}",
            "output": "class Writer {\n    write(data) {\n        throw new Error('Method not implemented');\n    }\n}\n\nclass FileWriter extends Writer {\n    write(data) {\n        // Logic to write data to a file\n    }\n}\n\nclass ConsoleWriter extends Writer {\n    write(data) {\n        console.log(data);\n    }\n}\n\nclass DataSaver {\n    constructor(writers) {\n        this.writers = writers;\n    }\n\n    save(data) {\n        this.writers.forEach(writer => writer.write(data));\n    }\n}\n\nconst fileWriter = new FileWriter();\nconst consoleWriter = new ConsoleWriter();\nconst dataSaver = new DataSaver([fileWriter, consoleWriter]);\n\ndataSaver.save('Hello, World!');",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code adhered to the SOLID principles fairly well, but it could be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. By introducing a new class for ConsoleWriter and using a list to handle multiple writers, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP."
        },
        {
            "input": "{\"violation_type\":\"NONE\",\"total_duration\":1304486583,\"explanation\":\"The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present.\"}",
            "output": "",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "NONE",
            "explanation": "The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2926287833,\"explanation\":\"The original `User` class was responsible for both user data and sending notifications, violating the Single Responsibility Principle (SRP). By introducing a `NotificationService` class, we ensure that the `User` class only handles user-related data, while the `NotificationService` manages the sending of notifications, improving code organization and maintainability.\"}",
            "output": "class User {\n    private String name;\n    private String email;\n\n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n}\n\nclass NotificationService {\n    public void sendNotification(User user, String message) {\n        // Logic to send notification to the user\n        System.out.println(\"Sending notification to \" + user.getEmail() + \": \" + message);\n    }\n}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original `User` class was responsible for both user data and sending notifications, violating the Single Responsibility Principle (SRP). By introducing a `NotificationService` class, we ensure that the `User` class only handles user-related data, while the `NotificationService` manages the sending of notifications, improving code organization and maintainability."
        },
        {
            "input": "{\"violation_type\":\"DIP\",\"total_duration\":5817301000,\"explanation\":\"The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable.\"}",
            "output": "",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "NONE",
            "explanation": "The provided explanation indicates that the code has been refactored to comply with the Dependency Inversion Principle (DIP) and also adheres to the other SOLID principles. Therefore, there are no violations present."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":4913716583,\"explanation\":\"The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality.\"}",
            "output": "interface Logger {\n    void log(String message);\n}\n\ninterface CountableLogger extends Logger {\n    int getMessageCount();\n}\n\nclass CountingLogger implements CountableLogger {\n    private int messageCount = 0;\n\n    @Override\n    public void log(String message) {\n        messageCount++;\n        // Log the message\n    }\n\n    @Override\n    public int getMessageCount() {\n        return messageCount;\n    }\n}\n\nclass SilentLogger implements Logger {\n    @Override\n    public void log(String message) {\n        // Do nothing\n    }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":5584676833,\"explanation\":\"The Logger interface is not violating ISP as it has a single method. However, the LogBuffer interface could be seen as violating ISP if a class only needs one of the methods. To refactor, we could split LogBuffer into two separate interfaces: AddableLog and ReadableLog, allowing classes to implement only what they need.\"}",
            "output": "interface AddableLog { void addLog(String log); }\ninterface ReadableLog { List<String> readLogs(); }\nclass LogManager implements AddableLog, ReadableLog {\n    private List<String> logs = new ArrayList<>();\n    public void addLog(String log) { logs.add(log); }\n    public List<String> readLogs() { return logs; }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original LogBuffer interface may force classes to implement methods they do not need, violating the Interface Segregation Principle (ISP). By splitting LogBuffer into two interfaces, AddableLog and ReadableLog, we allow classes to implement only the methods they require, thus adhering to ISP."
        },
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":4067302583,\"explanation\":\"The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of `IShape` can be used interchangeably without affecting the correctness of the program. The `NullShape` class is a valid implementation of the `IShape` interface, allowing it to be used in the same context as other shapes without causing errors or unexpected behavior.\"}",
            "output": "interface IShape {\n    double area();\n}\n\nclass Circle implements IShape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass Square implements IShape {\n    private double side;\n\n    public Square(double side) {\n        this.side = side;\n    }\n\n    @Override\n    public double area() {\n        return side  side;\n    }\n}\n\nclass NullShape implements IShape {\n    @Override\n    public double area() {\n        return 0;\n    }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of `IShape` can be used interchangeably without affecting the correctness of the program. The `NullShape` class is a valid implementation of the `IShape` interface, allowing it to be used in the same context as other shapes without causing errors or unexpected behavior."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1849126916,\"explanation\":\"The `UserService` class previously handled both user registration and email sending, violating the Single Responsibility Principle (SRP). The refactoring separates the email functionality into its own `EmailService` class, ensuring that each class has a single responsibility.\"}",
            "output": "class UserService {\n    private EmailService emailService;\n\n    public UserService(EmailService emailService) {\n        this.emailService = emailService;\n    }\n\n    public void registerUser(User user) {\n        // Registration logic\n        emailService.sendWelcomeEmail(user);\n    }\n}\n\nclass EmailService {\n    public void sendWelcomeEmail(User user) {\n        // Email sending logic\n    }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The `UserService` class previously handled both user registration and email sending, violating the Single Responsibility Principle (SRP). The refactoring separates the email functionality into its own `EmailService` class, ensuring that each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2780717917,\"explanation\":\"The original code had a single class handling multiple bird types with different flying capabilities, violating the Single Responsibility Principle. The refactoring separates the flying behavior into individual classes for each bird type, ensuring that each class has a single responsibility.\"}",
            "output": "class Bird {\n    private String name;\n\n    public Bird(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\ninterface FlyBehavior {\n    void fly();\n}\n\nclass Sparrow extends Bird implements FlyBehavior {\n    public Sparrow(String name) {\n        super(name);\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(getName() + \" is flying high!\");\n    }\n}\n\nclass Penguin extends Bird implements FlyBehavior {\n    public Penguin(String name) {\n        super(name);\n    }\n\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(getName() + \" cannot fly!\");\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had a single class handling multiple bird types with different flying capabilities, violating the Single Responsibility Principle. The refactoring separates the flying behavior into individual classes for each bird type, ensuring that each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":5083824792,\"explanation\":\"The original code had a potential Liskov Substitution Principle violation because the `Square` class, while implementing the `IShape` interface, could lead to unexpected behavior if a `Rectangle` is expected to behave like a `Square` due to their differing properties. The refactored code maintains the same functionality while ensuring that both shapes adhere to the expected behavior of the `IShape` interface.\"}",
            "output": "interface IShape {\n    double area();\n}\n\nclass Rectangle implements IShape {\n    private double width;\n    private double height;\n\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double area() {\n        return width  height;\n    }\n}\n\nclass Square implements IShape {\n    private double side;\n\n    public Square(double side) {\n        this.side = side;\n    }\n\n    @Override\n    public double area() {\n        return side  side;\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The original code had a potential Liskov Substitution Principle violation because the `Square` class, while implementing the `IShape` interface, could lead to unexpected behavior if a `Rectangle` is expected to behave like a `Square` due to their differing properties. The refactored code maintains the same functionality while ensuring that both shapes adhere to the expected behavior of the `IShape` interface."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2433099125,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the animal's characteristics and its movement behavior. The refactored code separates movement behavior into its own interface and classes, allowing each animal to have its own movement implementation without cluttering the `Animal` class.\"}",
            "output": "interface MovementBehavior {\n    void move();\n}\n\nclass Walk implements MovementBehavior {\n    public void move() {\n        System.out.println(\"Walking...\");\n    }\n}\n\nclass Fly implements MovementBehavior {\n    public void move() {\n        System.out.println(\"Flying...\");\n    }\n}\n\nclass Animal {\n    private MovementBehavior movementBehavior;\n\n    public Animal(MovementBehavior movementBehavior) {\n        this.movementBehavior = movementBehavior;\n    }\n\n    public void performMove() {\n        movementBehavior.move();\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the animal's characteristics and its movement behavior. The refactored code separates movement behavior into its own interface and classes, allowing each animal to have its own movement implementation without cluttering the `Animal` class."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2863712875,\"explanation\":\"The original code violated the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments.\"}",
            "output": "class PaymentProcessor {\n    public void processPayment(Payment payment) {\n        // Logic to process payment\n    }\n}\n\ninterface Payment {\n    void pay();\n}\n\nclass CreditCardPayment implements Payment {\n    public void pay() {\n        // Logic for credit card payment\n    }\n}\n\nclass PayPalPayment implements Payment {\n    public void pay() {\n        // Logic for PayPal payment\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2196349208,\"explanation\":\"The original code violated the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes were both implementing the `Write` method, leading to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility.\"}",
            "output": "class FileWriter {\n    public void write(String data) {\n        // logic to write data to a file\n    }\n}\n\nclass ReadOnlyFileWriter {\n    // This class does not need a write method\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes were both implementing the `Write` method, leading to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1546762084,\"explanation\":\"This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle.\"}",
            "output": "class Vehicle {\n    private String type;\n    private int speed;\n\n    public Vehicle(String type, int speed) {\n        this.type = type;\n        this.speed = speed;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public int getSpeed() {\n        return speed;\n    }\n}\n\nclass Car extends Vehicle {\n    private int numberOfDoors;\n\n    public Car(int speed, int numberOfDoors) {\n        super(\"Car\", speed);\n        this.numberOfDoors = numberOfDoors;\n    }\n\n    public int getNumberOfDoors() {\n        return numberOfDoors;\n    }\n}\n\nclass Bike extends Vehicle {\n    private boolean hasCarrier;\n\n    public Bike(int speed, boolean hasCarrier) {\n        super(\"Bike\", speed);\n        this.hasCarrier = hasCarrier;\n    }\n\n    public boolean hasCarrier() {\n        return hasCarrier;\n    }\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1751397250,\"explanation\":\"The `DocumentPrinter` class was previously responsible for both printing and managing document content. Now, the `Document` class solely handles the content, while `DocumentPrinter` is only responsible for printing, adhering to the Single Responsibility Principle.\"}",
            "output": "class Document {\n    private String content;\n\n    public Document(String content) {\n        this.content = content;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}\n\nclass DocumentPrinter {\n    public void print(Document document) {\n        System.out.println(document.getContent());\n    }\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The `DocumentPrinter` class was previously responsible for both printing and managing document content. Now, the `Document` class solely handles the content, while `DocumentPrinter` is only responsible for printing, adhering to the Single Responsibility Principle."
        },
        {
            "input": "NONE",
            "output": "",
            "level": "MODERATE",
            "language": "C#",
            "violation": "NONE",
            "explanation": "The provided code does not exhibit any violations of the SOLID principles."
        },
        {
            "input": "{\"violation_type\":\"LSP\",\"total_duration\":7660001209,\"explanation\":\"The `ReadOnlyFileStatusProvider` class was overriding the `GetStatus` method in a way that could lead to unexpected behavior when used polymorphically. By making it inherit from `FileStatusProvider` and overriding the method correctly, we ensure that it adheres to the Liskov Substitution Principle.\"}",
            "output": "class FileStatusProvider {\n    public virtual string GetStatus() {\n        return \"File status\";\n    }\n}\n\nclass ReadOnlyFileStatusProvider : FileStatusProvider {\n    public override string GetStatus() {\n        return \"Read-only file status\";\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The `ReadOnlyFileStatusProvider` class was overriding the `GetStatus` method in a way that could lead to unexpected behavior when used polymorphically. By making it inherit from `FileStatusProvider` and overriding the method correctly, we ensure that it adheres to the Liskov Substitution Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":8874405166,\"explanation\":\"The refactored code addresses the Single Responsibility Principle (SRP) violation by creating a separate `Logger` class that handles all logging responsibilities. This allows the `ActiveAccount` and `LimitedWithdrawalAccount` classes to focus solely on their withdrawal logic, improving maintainability and clarity.\"}",
            "output": "class Logger {\n    log(message) {\n        console.log(message);\n    }\n}\n\nclass ActiveAccount {\n    constructor(logger) {\n        this.logger = logger;\n    }\n\n    withdraw(amount) {\n        // withdrawal logic\n        this.logger.log(`Withdrew ${amount} from ActiveAccount`);\n    }\n}\n\nclass LimitedWithdrawalAccount {\n    constructor(logger) {\n        this.logger = logger;\n    }\n\n    withdraw(amount) {\n        // limited withdrawal logic\n        this.logger.log(`Withdrew ${amount} from LimitedWithdrawalAccount`);\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The refactored code addresses the Single Responsibility Principle (SRP) violation by creating a separate `Logger` class that handles all logging responsibilities. This allows the `ActiveAccount` and `LimitedWithdrawalAccount` classes to focus solely on their withdrawal logic, improving maintainability and clarity."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3207834792,\"explanation\":\"The original code violated the Single Responsibility Principle (SRP) because the Logger class was responsible for both logging messages and formatting them with timestamps. The refactored code separates these concerns by introducing an ILogger interface and creating distinct classes for logging to the console and for adding timestamps, ensuring each class has a single responsibility.\"}",
            "output": "{\"violation_type\":\"SRP\",\"refactored_code\":\"interface ILogger {\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger {\\n    public void Log(string message) {\\n        Console.WriteLine(message);\\n    }\\n}\\n\\nclass TimestampLogger : ILogger {\\n    private readonly ILogger _logger;\\n\\n    public TimestampLogger(ILogger logger) {\\n        _logger = logger;\\n    }\\n\\n    public void Log(string message) {\\n        string timestampedMessage = $\"{DateTime.Now}: {message}\";\\n        _logger.Log(timestampedMessage);\\n    }\\n}\",\"explanation\":\"The original code violated the Single Responsibility Principle (SRP) because the Logger class was responsible for both logging messages and formatting them with timestamps. The refactored code separates these concerns by introducing an ILogger interface and creating distinct classes for logging to the console and for adding timestamps, ensuring each class has a single responsibility.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3602770000,\"explanation\":\"The original code had a single class handling both user registration and notification, which violates the Single Responsibility Principle (SRP). The refactored code separates these concerns into distinct classes, ensuring that each class has one reason to change.\"}",
            "output": "class UserRegistration {\n    public void registerUser(User user) {\n        // Registration logic\n    }\n}\n\nclass NotificationService {\n    public void sendNotification(User user) {\n        // Notification logic\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had a single class handling both user registration and notification, which violates the Single Responsibility Principle (SRP). The refactored code separates these concerns into distinct classes, ensuring that each class has one reason to change."
        }
    ]
}