{
    "code_examples": [
        {
            "input": "public interface IPrint {\n\tvoid print(String document);\n}\n\npublic interface IScanner {\n\tvoid scan();\n}\n\npublic interface IFax {\n\tvoid fax(String recipient);\n}\n\npublic class BasicPrinter implements IPrint {\n\t@Override\n\tpublic void print(String document) {\n\t\tSystem.out.println(\"Printing: \" + document);\n\t}\n}\n\npublic class AdvancedPrinter implements IPrint, IScanner {\n\t@Override\n\tpublic void print(String document) {\n\t\tSystem.out.println(\"Printing: \" + document);\n\t}\n\t\n\t@Override\n\tpublic void scan() {\n\t\tSystem.out.println(\"Scanning document...\");\n\t}\n}\n\npublic class SmartPhone implements IPrint, IScanner {\n\t@Override\n\tpublic void print(String document) {\n\t\tSystem.out.println(\"Sending to cloud printer: \" + document);\n\t}\n\t\n\t@Override\n\tpublic void scan() {\n\t\tSystem.out.println(\"Scanning document with camera...\");\n\t}\n}\n\npublic class MultiFunctionPrinter implements IPrint, IScanner {\n\tprivate final IPrint printer;\n\tprivate final IScanner scanner;\n\t\n\tpublic MultiFunctionPrinter(IPrint printer, IScanner scanner) {\n\t\tthis.printer = printer;\n\t\tthis.scanner = scanner;\n\t}\n\t\n\t@Override\n\tpublic void print(String document) {\n\t\tprinter.print(document);\n\t}\n\t\n\t@Override\n\tpublic void scan() {\n\t\tscanner.scan();\n\t}\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":7368717791,\"explanation\":\"The interfaces IPrint, IScanner, and IFax are too large and force classes to implement methods they may not need. The refactoring maintains smaller, more focused interfaces, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The interfaces IPrint, IScanner, and IFax are too large and force classes to implement methods they may not need. The refactoring maintains smaller, more focused interfaces, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":2355290708,\"explanation\":\"The `IJobSeekerExtended` interface violates the Interface Segregation Principle by forcing classes that implement `IJobSeeker` to also implement methods that may not be relevant to them, such as `saveJob`. This can lead to unnecessary dependencies and bloated interfaces.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":2254247250,\"explanation\":\"The `IJobSeekerExtended` interface was too large, forcing implementations to include methods that were not relevant to all job seekers. By splitting it into smaller interfaces, we adhere to the Interface Segregation Principle, allowing classes to implement only the methods they need.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The `IJobSeekerExtended` interface was too large, forcing implementations to include methods that were not relevant to all job seekers. By splitting it into smaller interfaces, we adhere to the Interface Segregation Principle, allowing classes to implement only the methods they need."
        },
        {
            "input": "class IAnalogueOperations {\n    void play();\n    void pause();\n    void stop();\n}\n\nclass IDigitalOperations {\n    void skipTrack();\n    void eject();\n}\n\nclass CDPlayer implements IAnalogueOperations, IDigitalOperations {\n    @Override\n    public void play() {\n        System.out.println(\"CD is playing.\");\n    }\n    \n    @Override\n    public void pause() {\n        System.out.println(\"CD is paused.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"CD stopped.\");\n    }\n    \n    @Override\n    public void skipTrack() {\n        System.out.println(\"Skipping to next CD track.\");\n    }\n    \n    @Override\n    public void eject() {\n        System.out.println(\"CD ejected.\");\n    }\n}\n\nclass VinylPlayer implements IAnalogueOperations {\n    @Override\n    public void play() {\n        System.out.println(\"Vinyl record is playing.\");\n    }\n    \n    @Override\n    public void pause() {\n        System.out.println(\"Vinyl playback paused (lift the needle).);\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(\"Vinyl playback stopped.\");\n    }\n}\n\nclass DigitalVinylPlayer extends VinylPlayer implements IDigitalOperations {\n    @Override\n    public void skipTrack() {\n        System.out.println(\"Skipping to next vinyl track.\");\n    }\n    \n    @Override\n    public void eject() {\n        System.out.println(\"Vinyl ejected.\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5326001750,\"explanation\":\"The interfaces were too large, forcing classes to implement methods they do not use. Now, `IAnalogueOperations` and `IDigitalOperations` are separate interfaces, adhering to the ISP.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The interfaces were too large, forcing classes to implement methods they do not use. Now, `IAnalogueOperations` and `IDigitalOperations` are separate interfaces, adhering to the ISP."
        },
        {
            "input": "interface IVehicleEngine {\n    void start();\n    void stop();\n}\n\ninterface IDriveable {\n    void drive();\n}\n\ninterface IFlyable {\n    void fly();\n}\n\ninterface IDiveable {\n    void dive();\n}\n\nabstract class Vehicle implements IVehicleEngine {\n    @Override\n    public abstract void start();\n\n    @Override\n    public abstract void stop();\n}\n\nclass Car extends Vehicle implements IDriveable {\n    @Override\n    public void start() {\n        System.out.println(\"Car started.\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Car stopped.\");\n    }\n\n    @Override\n    public void drive() {\n        System.out.println(\"Car is driving on the road.\");\n    }\n}\n\nclass Plane extends Vehicle implements IFlyable {\n    @Override\n    public void start() {\n        System.out.println(\"Plane engine started.\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Plane engine stopped.\");\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(\"Plane is flying.\");\n    }\n}\n\nclass Submarine extends Vehicle implements IDiveable {\n    @Override\n    public void start() {\n        System.out.println(\"Submarine powered up.\");\n    }\n\n    @Override\n    public void stop() {\n        System.out.println(\"Submarine powered down.\");\n    }\n\n    @Override\n    public void dive() {\n        System.out.println(\"Submarine is diving.\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5426558958,\"explanation\":\"The interfaces are too large and force classes to implement methods that are not relevant to them. By separating the interfaces into smaller, more specific ones, we adhere to the Interface Segregation Principle (ISP).\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The interfaces are too large and force classes to implement methods that are not relevant to them. By separating the interfaces into smaller, more specific ones, we adhere to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":8705187583,\"explanation\":\"The code violates the Interface Segregation Principle (ISP) because the `AbstractAudioDevice` class inherits from `AbstractElectronicDevice`, which may not be relevant for all audio devices. This creates unnecessary dependencies. To refactor, we can separate the electronic control functionality from the audio functionality, allowing audio devices to implement only the necessary interfaces.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4197446000,\"explanation\":\"The refactoring separates the audio functionality from the electronic control functionality, allowing audio devices to implement only the necessary interfaces, thus adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The refactoring separates the audio functionality from the electronic control functionality, allowing audio devices to implement only the necessary interfaces, thus adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "package game;\n\ninterface MoveStrategy {\n    void move();\n}\n\ninterface AttackStrategy {\n    void attack();\n}\n\nclass WalkMovement implements MoveStrategy {\n    private String characterName;\n\n    public WalkMovement(String characterName) {\n        this.characterName = characterName;\n    }\n\n    public void move() {\n        System.out.println(characterName + \" walks on foot.\");\n    }\n}\n\nclass FlyMovement implements MoveStrategy {\n    private String characterName;\n\n    public FlyMovement(String characterName) {\n        this.characterName = characterName;\n    }\n\n    public void move() {\n        System.out.println(characterName + \" flies magically.\");\n    }\n}\n\nclass MeleeAttack implements AttackStrategy {\n    private String characterName;\n\n    public MeleeAttack(String characterName) {\n        this.characterName = characterName;\n    }\n\n    public void attack() {\n        System.out.println(characterName + \" performs a melee attack.\");\n    }\n}\n\nclass SpellAttack implements AttackStrategy {\n    private String characterName;\n\n    public SpellAttack(String characterName) {\n        this.characterName = characterName;\n    }\n\n    public void attack() {\n        System.out.println(characterName + \" casts a powerful spell.\");\n    }\n}\n\nabstract class Character {\n    protected MoveStrategy moveStrategy;\n    protected AttackStrategy attackStrategy;\n    protected String name;\n\n    public Character(String name, MoveStrategy moveStrategy, AttackStrategy attackStrategy) {\n        this.name = name;\n        this.moveStrategy = moveStrategy;\n        this.attackStrategy = attackStrategy;\n    }\n\n    public void performMove() {\n        moveStrategy.move();\n    }\n\n    public void performAttack() {\n        attackStrategy.attack();\n    }\n\n    public void displayRole() {\n        System.out.println(\"Current character: \" + name);\n    }\n}\n\nclass Mage extends Character {\n    public Mage() {\n        super(\"Mage\", new FlyMovement(\"Mage\"), new SpellAttack(\"Mage\"));\n    }\n}\n\nclass Fighter extends Character {\n    public Fighter() {\n        super(\"Fighter\", new WalkMovement(\"Fighter\"), new MeleeAttack(\"Fighter\"));\n    }\n}\n\nclass Ranger extends Character {\n    public Ranger() {\n        super(\"Ranger\", new WalkMovement(\"Ranger\"), new MeleeAttack(\"Ranger\"));\n    }\n}\n\nclass GameContext {\n    private Character character;\n\n    public GameContext(Character character) {\n        this.character = character;\n    }\n\n    public void setCharacter(Character newCharacter) {\n        this.character = newCharacter;\n    }\n\n    public void move() {\n        character.performMove();\n    }\n\n    public void attack() {\n        character.performAttack();\n    }\n\n    public void display() {\n        character.displayRole();\n    }\n}",
            "output": "{\"violation_type\":\"DIP\",\"total_duration\":10441006167,\"explanation\":\"The original code had the `Mage`, `Fighter`, and `Ranger` classes directly instantiating their movement and attack strategies, which created a tight coupling between high-level and low-level classes. The refactored code allows for the injection of `MoveStrategy` and `AttackStrategy` into the character classes, adhering to the Dependency Inversion Principle (DIP).\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "DIP",
            "explanation": "The original code had the `Mage`, `Fighter`, and `Ranger` classes directly instantiating their movement and attack strategies, which created a tight coupling between high-level and low-level classes. The refactored code allows for the injection of `MoveStrategy` and `AttackStrategy` into the character classes, adhering to the Dependency Inversion Principle (DIP)."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":5630768792,\"explanation\":\"The Chef class violates the Interface Segregation Principle because it implements multiple interfaces, forcing it to provide implementations for methods that may not be relevant to its primary responsibility. Refactoring could involve creating a separate class for BeverageService and DessertService, allowing the Chef to focus solely on cooking.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":2148660375,\"explanation\":\"The refactoring separates the responsibilities into distinct interfaces, allowing the Chef class to focus solely on cooking, thus adhering to the Interface Segregation Principle.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The refactoring separates the responsibilities into distinct interfaces, allowing the Chef class to focus solely on cooking, thus adhering to the Interface Segregation Principle."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":8598094875,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `IShape` interface forces classes to implement methods that are not relevant to their specific shape type. The refactored code separates the interfaces for 1D, 2D, and 3D shapes, ensuring that classes only implement the methods that are applicable to them.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":2763104084,\"explanation\":\"The original code violated the Interface Segregation Principle (ISP) because the `IShape` interface forced classes to implement methods that were not relevant to their specific shape type. The refactored code separates the interfaces for 1D, 2D, and 3D shapes, ensuring that classes only implement the methods that are applicable to them.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle (ISP) because the `IShape` interface forced classes to implement methods that were not relevant to their specific shape type. The refactored code separates the interfaces for 1D, 2D, and 3D shapes, ensuring that classes only implement the methods that are applicable to them."
        },
        {
            "input": "interface Device {\n    String getDeviceName();\n    void displayInfo();\n}\n\ninterface Connectable {\n    void connect();\n    void disconnect();\n}\n\ninterface DataTransferable {\n    void transferData(String data);\n}\n\ninterface Diagnosable {\n    void runDiagnostics();\n}\n\ninterface Updatable {\n    void updateFirmware(String version);\n}\n\ninterface MediaPlayable {\n    void play();\n    void stop();\n}\n\ninterface VolumeAdjustable {\n    void setVolume(int level);\n}\n\ninterface PowerControllable {\n    void powerOn();\n    void powerOff();\n}\n\ninterface ScreenResolutionAdjustable {\n    void setScreenResolution(String resolution);\n}\n\nabstract class AbstractDevice implements Device {\n    protected String name;\n    public AbstractDevice(String name) {\n        this.name = name;\n    }\n    @Override\n    public String getDeviceName() {\n        return name;\n    }\n}\n\nclass Router extends AbstractDevice implements Connectable, DataTransferable, Diagnosable, Updatable {\n    private String ipAddress;\n    \n    public Router(String name, String ipAddress) {\n        super(name);\n        this.ipAddress = ipAddress;\n    }\n    \n    @Override\n    public void connect() {\n        System.out.println(\"Router \" + name + \" established connection.\");\n    }\n    \n    @Override\n    public void disconnect() {\n        System.out.println(\"Router \" + name + \" disconnected.\");\n    }\n    \n    @Override\n    public void transferData(String data) {\n        System.out.println(\"Router transferring data: \" + data);\n    }\n    \n    @Override\n    public void runDiagnostics() {\n        System.out.println(\"Running diagnostics on router \" + name);\n    }\n    \n    @Override\n    public void updateFirmware(String version) {\n        System.out.println(\"Router firmware updated to version: \" + version);\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Router: \" + name + \", IP: \" + ipAddress);\n    }\n}\n\nclass NetworkSwitch extends AbstractDevice implements Connectable, DataTransferable, Diagnosable, Updatable {\n    private String ipAddress;\n    \n    public NetworkSwitch(String name, String ipAddress) {\n        super(name);\n        this.ipAddress = ipAddress;\n    }\n    \n    @Override\n    public void connect() {\n        System.out.println(\"Switch \" + name + \" established connection.\");\n    }\n    \n    @Override\n    public void disconnect() {\n        System.out.println(\"Switch \" + name + \" disconnected.\");\n    }\n    \n    @Override\n    public void transferData(String data) {\n        System.out.println(\"Switch transferring data: \" + data);\n    }\n    \n    @Override\n    public void runDiagnostics() {\n        System.out.println(\"Running diagnostics on switch \" + name);\n    }\n    \n    @Override\n    public void updateFirmware(String version) {\n        System.out.println(\"Switch firmware updated to version: \" + version);\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Network Switch: \" + name + \", IP: \" + ipAddress);\n    }\n}\n\nclass SmartTV extends AbstractDevice implements PowerControllable, MediaPlayable, VolumeAdjustable, ScreenResolutionAdjustable {\n    private String location;\n    \n    public SmartTV(String name, String location) {\n        super(name);\n        this.location = location;\n    }\n    \n    @Override\n    public void powerOn() {\n        System.out.println(name + \" TV powered on.\");\n    }\n    \n    @Override\n    public void powerOff() {\n        System.out.println(name + \" TV powered off.\");\n    }\n    \n    @Override\n    public void play() {\n        System.out.println(name + \" TV playing content.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(name + \" TV stopped playback.\");\n    }\n    \n    @Override\n    public void setVolume(int level) {\n        System.out.println(name + \" TV volume set to \" + level);\n    }\n    \n    @Override\n    public void setScreenResolution(String resolution) {\n        System.out.println(name + \" TV resolution set to \" + resolution);\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Smart TV: \" + name + \", Location: \" + location);\n    }\n}\n\nclass SmartSpeaker extends AbstractDevice implements PowerControllable, MediaPlayable, VolumeAdjustable {\n    private String location;\n    \n    public SmartSpeaker(String name, String location) {\n        super(name);\n        this.location = location;\n    }\n    \n    @Override\n    public void powerOn() {\n        System.out.println(name + \" speaker powered on.\");\n    }\n    \n    @Override\n    public void powerOff() {\n        System.out.println(name + \" speaker powered off.\");\n    }\n    \n    @Override\n    public void play() {\n        System.out.println(name + \" speaker playing audio.\");\n    }\n    \n    @Override\n    public void stop() {\n        System.out.println(name + \" speaker stopped playback.\");\n    }\n    \n    @Override\n    public void setVolume(int level) {\n        System.out.println(name + \" speaker volume set to \" + level);\n    }\n    \n    @Override\n    public void displayInfo() {\n        System.out.println(\"Smart Speaker: \" + name + \", Location: \" + location);\n    }\n}\n\nclass DeviceManager {\n    public void configureDevice(Device device) {\n        device.displayInfo();\n        if (device instanceof PowerControllable) {\n            ((PowerControllable) device).powerOn();\n        }\n        if (device instanceof Connectable) {\n            ((Connectable) device).connect();\n        }\n    }\n    \n    public void updateFirmware(Updatable device) {\n        System.out.println(\"Updating firmware for \" + device.getDeviceName());\n        device.updateFirmware(\"v2.4.1\");\n    }\n    \n    public void playMedia(MediaPlayable device) {\n        System.out.println(\"Playing media on \" + device.getDeviceName());\n        device.play();\n    }\n    \n    public void adjustVolume(VolumeAdjustable device, int level) {\n        System.out.println(\"Adjusting volume on \" + device.getDeviceName());\n        device.setVolume(level);\n    }\n    \n    public void adjustScreenResolution(ScreenResolutionAdjustable device, String resolution) {\n        System.out.println(\"Adjusting screen resolution on \" + device.getDeviceName());\n        device.setScreenResolution(resolution);\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":17509603875,\"explanation\":\"The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring maintains smaller, more focused interfaces that allow classes to implement only the methods they need.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring maintains smaller, more focused interfaces that allow classes to implement only the methods they need."
        },
        {
            "input": "import java.util.List;\nimport java.util.ArrayList;\n\ninterface UIElement {\n    void render();\n    void setVisible(boolean visible);\n}\n\ninterface Positionable {\n    void resize(int width, int height);\n}\n\ninterface Colorable {\n    void setBackground(String color);\n    void setForeground(String color);\n}\n\ninterface Clickable {\n    void onClick(int x, int y);\n}\n\ninterface Hoverable {\n    void onHover(int x, int y);\n}\n\ninterface KeyboardInteractive {\n    void onKeyPress(int keyCode);\n}\n\ninterface Focusable {\n    void onFocus();\n    void onBlur();\n}\n\ninterface Container {\n    void addChild(UIElement child);\n    void removeChild(UIElement child);\n    UIElement getParent();\n}\n\ninterface TextStyleable {\n    void setFont(String fontName, int size);\n    void setTextAlignment(String alignment);\n}\n\ninterface LayoutStyleable {\n    void setMargin(int top, int right, int bottom, int left);\n    void setPadding(int top, int right, int bottom, int left);\n}\n\ninterface Fadeable {\n    void fadeIn(int durationMs);\n    void fadeOut(int durationMs);\n}\n\nabstract class AbstractUIElement implements UIElement, Positionable {\n    protected int x, y, width, height;\n    protected boolean visible;\n\n    public AbstractUIElement(int x, int y, int width, int height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.visible = true;\n    }\n\n    @Override\n    public void setVisible(boolean visible) {\n        this.visible = visible;\n        System.out.println(getClass().getSimpleName() + \" visibility set to: \" + visible);\n    }\n\n    @Override\n    public void resize(int width, int height) {\n        this.width = width;\n        this.height = height;\n        System.out.println(getClass().getSimpleName() + \" resized to: \" + width + \"x\" + height);\n    }\n}\n\nclass Button extends AbstractUIElement implements Colorable, Clickable, Hoverable {\n    private String label;\n    private String backgroundColor;\n    private String foregroundColor;\n\n    public Button(String label, int x, int y, int width, int height) {\n        super(x, y, width, height);\n        this.label = label;\n        this.backgroundColor = \"#CCCCCC\";\n        this.foregroundColor = \"#000000\";\n    }\n\n    @Override\n    public void render() {\n        System.out.println(\"Rendering button: \" + label);\n    }\n\n    @Override\n    public void setBackground(String color) {\n        this.backgroundColor = color;\n        System.out.println(\"Button background set to: \" + color);\n    }\n\n    @Override\n    public void setForeground(String color) {\n        this.foregroundColor = color;\n        System.out.println(\"Button foreground set to: \" + color);\n    }\n\n    @Override\n    public void onClick(int x, int y) {\n        System.out.println(\"Button clicked: \" + label);\n    }\n\n    @Override\n    public void onHover(int x, int y) {\n        System.out.println(\"Hover over button: \" + label);\n    }\n}\n\nclass TextField extends AbstractUIElement implements KeyboardInteractive, Focusable, TextStyleable {\n    private String text;\n    private boolean focused;\n    private String fontName;\n    private int fontSize;\n    private String textAlignment;\n\n    public TextField(String initialText, int x, int y, int width, int height) {\n        super(x, y, width, height);\n        this.text = initialText;\n        this.focused = false;\n        this.fontName = \"Arial\";\n        this.fontSize = 12;\n        this.textAlignment = \"left\";\n    }\n\n    @Override\n    public void render() {\n        System.out.println(\"Rendering text field: \" + text);\n    }\n\n    @Override\n    public void onKeyPress(int keyCode) {\n        System.out.println(\"Key pressed in text field: \" + keyCode);\n        // Handle text input\n    }\n\n    @Override\n    public void onFocus() {\n        this.focused = true;\n        System.out.println(\"Text field focused\");\n    }\n\n    @Override\n    public void onBlur() {\n        this.focused = false;\n        System.out.println(\"Text field lost focus\");\n    }\n\n    @Override\n    public void setFont(String fontName, int size) {\n        this.fontName = fontName;\n        this.fontSize = size;\n        System.out.println(\"TextField font set to: \" + fontName + \", size: \" + size);\n    }\n\n    @Override\n    public void setTextAlignment(String alignment) {\n        this.textAlignment = alignment;\n        System.out.println(\"TextField alignment set to: \" + alignment);\n    }\n}\n\nclass Image extends AbstractUIElement implements Fadeable {\n    private String imagePath;\n\n    public Image(String imagePath, int x, int y, int width, int height) {\n        super(x, y, width, height);\n        this.imagePath = imagePath;\n    }\n\n    @Override\n    public void render() {\n        System.out.println(\"Rendering image from: \" + imagePath);\n    }\n\n    @Override\n    public void fadeIn(int durationMs) {\n        System.out.println(\"Fading in image over \" + durationMs + \"ms\");\n    }\n\n    @Override\n    public void fadeOut(int durationMs) {\n        System.out.println(\"Fading out image over \" + durationMs + \"ms\");\n    }\n}\n\nclass Panel extends AbstractUIElement implements Container, LayoutStyleable {\n    private List<UIElement> children = new ArrayList<>();\n    private UIElement parent;\n    private int[] margins = {0, 0, 0, 0};\n    private int[] paddings = {0, 0, 0, 0};\n\n    public Panel(int x, int y, int width, int height) {\n        super(x, y, width, height);\n    }\n\n    @Override\n    public void render() {\n        System.out.println(\"Rendering panel\");\n        for (UIElement child : children) {\n            child.render();\n        }\n    }\n\n    @Override\n    public void addChild(UIElement child) {\n        children.add(child);\n        System.out.println(\"Child added to panel\");\n    }\n\n    @Override\n    public void removeChild(UIElement child) {\n        children.remove(child);\n        System.out.println(\"Child removed from panel\");\n    }\n\n    @Override\n    public UIElement getParent() {\n        return parent;\n    }\n\n    @Override\n    public void setMargin(int top, int right, int bottom, int left) {\n        this.margins = new int[]{top, right, bottom, left};\n        System.out.println(\"Panel margins set\");\n    }\n\n    @Override\n    public void setPadding(int top, int right, int bottom, int left) {\n        this.paddings = new int[]{top, right, bottom, left};\n        System.out.println(\"Panel padding set\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":24165998542,\"explanation\":\"The interfaces are too large and force classes to implement methods that may not be relevant to them, violating the Interface Segregation Principle (ISP). The refactoring separates the interfaces into smaller, more specific ones, allowing classes to implement only the methods they need.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The interfaces are too large and force classes to implement methods that may not be relevant to them, violating the Interface Segregation Principle (ISP). The refactoring separates the interfaces into smaller, more specific ones, allowing classes to implement only the methods they need."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":6449805667,\"explanation\":\"The original code violates the Interface Segregation Principle because the `SlackService` and `PushNotificationService` classes implement both `MessageSender` and `MessageReceiver` interfaces, which may not be necessary for all implementations. The refactored code separates the interfaces to ensure that classes only implement the methods they actually use.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":3583601959,\"explanation\":\"The original code violated the Interface Segregation Principle because the `SlackService` and `PushNotificationService` classes implemented both `MessageSender` and `MessageReceiver` interfaces, which may not be necessary for all implementations. The refactored code separates the interfaces to ensure that classes only implement the methods they actually use.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle because the `SlackService` and `PushNotificationService` classes implemented both `MessageSender` and `MessageReceiver` interfaces, which may not be necessary for all implementations. The refactored code separates the interfaces to ensure that classes only implement the methods they actually use."
        },
        {
            "input": "import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\ninterface FlightSearchable {\n    List<Flight> searchAvailableFlights(String origin, String destination, LocalDateTime date);\n}\n\ninterface FlightManageable {\n    void addFlight(Flight flight);\n    void updateFlightStatus(String flightNumber, FlightStatus status);\n}\n\ninterface BookingCreator {\n    Booking createBooking(String passengerId, String flightNumber);\n    void cancelBooking(String bookingId);\n    Booking getBookingDetails(String bookingId);\n}\n\ninterface PaymentProcessor {\n    boolean processPayment(String bookingId, PaymentMethod method, double amount);\n    boolean refundPayment(String bookingId);\n}\n\ninterface EmailNotifier {\n    void sendBookingConfirmation(String bookingId, String email);\n    void sendCancellationNotice(String bookingId, String email);\n}\n\ninterface ReportGenerator {\n    byte[] generateBookingReport(String bookingId);\n    Map<String, Integer> getBookingStatistics(LocalDateTime start, LocalDateTime end);\n}\n\nclass CustomerBookingSystem implements FlightSearchable, BookingCreator, PaymentProcessor {\n    private Map<String, Flight> flights = new HashMap<>();\n    private Map<String, Booking> bookings = new HashMap<>();\n    private EmailNotifier emailNotifier;\n\n    public CustomerBookingSystem(EmailNotifier emailNotifier) {\n        this.emailNotifier = emailNotifier;\n    }\n\n    public void setFlightsForDemo(Flight... flightsToAdd) {\n        for (Flight flight : flightsToAdd) {\n            flights.put(flight.getFlightNumber(), flight);\n        }\n    }\n\n    @Override\n    public List<Flight> searchAvailableFlights(String origin, String destination, LocalDateTime date) {\n        List<Flight> availableFlights = new ArrayList<>();\n        for (Flight flight : flights.values()) {\n            if (flight.getOrigin().equals(origin) && \n                flight.getDestination().equals(destination) &&\n                flight.getDepartureTime().toLocalDate().equals(date.toLocalDate())) {\n                availableFlights.add(flight);\n            }\n        }\n        return availableFlights;\n    }\n\n    @Override\n    public Booking createBooking(String passengerId, String flightNumber) {\n        Flight flight = flights.get(flightNumber);\n        if (flight != null) {\n            String bookingId = \"B\" + System.currentTimeMillis();\n            Booking booking = new Booking(bookingId, passengerId, flightNumber);\n            bookings.put(bookingId, booking);\n            emailNotifier.sendBookingConfirmation(bookingId, passengerId);\n            return booking;\n        }\n        return null;\n    }\n\n    @Override\n    public void cancelBooking(String bookingId) {\n        bookings.remove(bookingId);\n        emailNotifier.sendCancellationNotice(bookingId, \"passenger@example.com\");\n    }\n\n    @Override\n    public Booking getBookingDetails(String bookingId) {\n        return bookings.get(bookingId);\n    }\n\n    @Override\n    public boolean processPayment(String bookingId, PaymentMethod method, double amount) {\n        System.out.println(\"Processing payment of $\" + amount + \" for booking \" + bookingId);\n        return true;\n    }\n\n    @Override\n    public boolean refundPayment(String bookingId) {\n        System.out.println(\"Refunding payment for booking \" + bookingId);\n        return true;\n    }\n}\n\nclass AdminFlightSystem implements FlightManageable, FlightSearchable {\n    private Map<String, Flight> flights = new HashMap<>();\n\n    @Override\n    public void addFlight(Flight flight) {\n        flights.put(flight.getFlightNumber(), flight);\n    }\n\n    @Override\n    public void updateFlightStatus(String flightNumber, FlightStatus status) {\n        Flight flight = flights.get(flightNumber);\n        if (flight != null) {\n            flight.setStatus(status);\n        }\n    }\n\n    @Override\n    public List<Flight> searchAvailableFlights(String origin, String destination, LocalDateTime date) {\n        List<Flight> availableFlights = new ArrayList<>();\n        for (Flight flight : flights.values()) {\n            if (flight.getOrigin().equals(origin) && \n                flight.getDestination().equals(destination) &&\n                flight.getDepartureTime().toLocalDate().equals(date.toLocalDate())) {\n                availableFlights.add(flight);\n            }\n        }\n        return availableFlights;\n    }\n}\n\nclass EmailNotificationService implements EmailNotifier {\n    @Override\n    public void sendBookingConfirmation(String bookingId, String email) {\n        System.out.println(\"Sending booking confirmation email for \" + bookingId + \" to \" + email);\n    }\n    \n    @Override\n    public void sendCancellationNotice(String bookingId, String email) {\n        System.out.println(\"Sending cancellation notice for \" + bookingId + \" to \" + email);\n    }\n}\n\nclass ReportingService implements ReportGenerator {\n    @Override\n    public byte[] generateBookingReport(String bookingId) {\n        System.out.println(\"Generating booking report for \" + bookingId);\n        return new byte[512];\n    }\n    \n    @Override\n    public Map<String, Integer> getBookingStatistics(LocalDateTime start, LocalDateTime end) {\n        System.out.println(\"Generating booking statistics from \" + start + \" to \" + end);\n        Map<String, Integer> stats = new HashMap<>();\n        stats.put(\"totalBookings\", 120);\n        stats.put(\"cancelledBookings\", 15);\n        return stats;\n    }\n}\n\nenum FlightStatus {\n    SCHEDULED, BOARDING, DEPARTED, LANDED, CANCELLED, DELAYED\n}\n\nenum PaymentMethod {\n    CREDIT_CARD, DEBIT_CARD, PAYPAL\n}\n\nclass Flight {\n    private String flightNumber;\n    private String origin;\n    private String destination;\n    private LocalDateTime departureTime;\n    private LocalDateTime arrivalTime;\n    private FlightStatus status;\n    \n    public Flight(String flightNumber, String origin, String destination, \n                 LocalDateTime departureTime, LocalDateTime arrivalTime) {\n        this.flightNumber = flightNumber;\n        this.origin = origin;\n        this.destination = destination;\n        this.departureTime = departureTime;\n        this.arrivalTime = arrivalTime;\n        this.status = FlightStatus.SCHEDULED;\n    }\n    \n    public String getFlightNumber() { return flightNumber; }\n    public String getOrigin() { return origin; }\n    public String getDestination() { return destination; }\n    public LocalDateTime getDepartureTime() { return departureTime; }\n    public LocalDateTime getArrivalTime() { return arrivalTime; }\n    public FlightStatus getStatus() { return status; }\n    \n    public void setStatus(FlightStatus status) { this.status = status; }\n}\n\nclass Booking {\n    private String bookingId;\n    private String passengerId;\n    private String flightNumber;\n    private LocalDateTime bookingTime;\n    \n    public Booking(String bookingId, String passengerId, String flightNumber) {\n        this.bookingId = bookingId;\n        this.passengerId = passengerId;\n        this.flightNumber = flightNumber;\n        this.bookingTime = LocalDateTime.now();\n    }\n    \n    public String getBookingId() { return bookingId; }\n    public String getPassengerId() { return passengerId; }\n    public String getFlightNumber() { return flightNumber; }\n    public LocalDateTime getBookingTime() { return bookingTime; }\n    \n    @Override\n    public String toString() {\n        return \"Booking{\" +\n               \"bookingId='\" + bookingId + '\\'' +\n               \", passengerId='\" + passengerId + '\\'' +\n               \", flightNumber='\" + flightNumber + '\\'' +\n               \", bookingTime=\" + bookingTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME) +\n               '}';\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":25393164000,\"explanation\":\"The `CustomerBookingSystem` class previously implemented multiple interfaces, including `EmailNotifier`, which led to it having too many responsibilities. Now, the email notification methods are included in the `CustomerBookingSystem`, ensuring that the class adheres to the Interface Segregation Principle (ISP) by not forcing it to implement methods that are not relevant to its core functionality.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The `CustomerBookingSystem` class previously implemented multiple interfaces, including `EmailNotifier`, which led to it having too many responsibilities. Now, the email notification methods are included in the `CustomerBookingSystem`, ensuring that the class adheres to the Interface Segregation Principle (ISP) by not forcing it to implement methods that are not relevant to its core functionality."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass IPrint(ABC):\n    @abstractmethod\n    def print(self, document):\n        pass\n\nclass IScanner(ABC):\n    @abstractmethod\n    def scan(self):\n        pass\n\nclass IFax(ABC):\n    @abstractmethod\n    def fax(self, recipient):\n        pass\n\nclass BasicPrinter(IPrint):\n    def print(self, document):\n        print(f\"Printing: {document}\")\n\nclass AdvancedPrinter(IPrint, IScanner):\n    def print(self, document):\n        print(f\"Printing: {document}\")\n\n    def scan(self):\n        print(\"Scanning document...\")\n\nclass MultiFunctionDevice(IPrint, IScanner, IFax):\n    def print(self, document):\n        print(f\"Printing: {document}\")\n\n    def scan(self):\n        print(\"Scanning document...\")\n\n    def fax(self, recipient):\n        print(f\"Sending fax to {recipient}\")\n\n",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5733239750,\"explanation\":\"The original `MultiFunctionDevice` class implemented all methods from the interfaces, violating the Interface Segregation Principle (ISP) by forcing it to implement methods that may not be relevant for all devices. The refactored code separates the functionalities into distinct classes (`Scanner` and `Fax`) and composes them in `MultiFunctionDevice`, allowing for more flexible and specific implementations.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The original `MultiFunctionDevice` class implemented all methods from the interfaces, violating the Interface Segregation Principle (ISP) by forcing it to implement methods that may not be relevant for all devices. The refactored code separates the functionalities into distinct classes (`Scanner` and `Fax`) and composes them in `MultiFunctionDevice`, allowing for more flexible and specific implementations."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass Resume:\n    def __init__(self, content):\n        self.content = content\n\nclass IJobSeeker(ABC):\n    @abstractmethod\n    def search_jobs(self):\n        pass\n\nclass IJobApplication(ABC):\n    @abstractmethod\n    def apply_for_job(self, resume: Resume):\n        pass\n\nclass IRecruiter(ABC):\n    @abstractmethod\n    def post_job(self, job_description: str):\n        pass\n\nclass IApplicantReview(ABC):\n    @abstractmethod\n    def review_applicants(self):\n        pass\n\nclass JobSeeker(IJobSeeker, IJobApplication):\n    def search_jobs(self):\n        print(\"Searching for jobs...\")\n\n    def apply_for_job(self, resume: Resume):\n        print(f\"Applied with resume: {resume.content}\")\n\nclass Recruiter(IRecruiter, IApplicantReview):\n    def post_job(self, job_description: str):\n        print(f\"Job posted: {job_description}\")\n\n    def review_applicants(self):\n        print(\"Reviewing applicants...\")\n\nclass SiteSettings:\n    def __init__(self, settings):\n        self.settings = settings\n\n    def manage(self):\n        print(\"Managing site settings...\")\n",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5117643708,\"explanation\":\"The interfaces `IJobSeeker`, `IJobApplication`, `IRecruiter`, and `IApplicantReview` are too large as they force classes to implement methods that may not be relevant to them. By separating the responsibilities into more focused interfaces, we adhere to the Interface Segregation Principle (ISP).\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The interfaces `IJobSeeker`, `IJobApplication`, `IRecruiter`, and `IApplicantReview` are too large as they force classes to implement methods that may not be relevant to them. By separating the responsibilities into more focused interfaces, we adhere to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass IPlayer(ABC):\n    @abstractmethod\n    def play(self):\n        pass\n\n    @abstractmethod\n    def pause(self):\n        pass\n\n    @abstractmethod\n    def stop(self):\n        pass\n\nclass IDigitalOperations(ABC):\n    @abstractmethod\n    def skip_track(self):\n        pass\n\n    @abstractmethod\n    def eject(self):\n        pass\n\nclass CDPlayer(IPlayer, IDigitalOperations):\n    def play(self):\n        print(\"CD is playing.\")\n\n    def pause(self):\n        print(\"CD is paused.\")\n\n    def stop(self):\n        print(\"CD stopped.\")\n\n    def skip_track(self):\n        print(\"Skipping to next CD track.\")\n\n    def eject(self):\n        print(\"CD ejected.\")\n\nclass VinylPlayer(IPlayer):\n    def play(self):\n        print(\"Vinyl record is playing.\")\n\n    def pause(self):\n        print(\"Vinyl playback paused (lift the needle).\")\n\n    def stop(self):\n        print(\"Vinyl playback stopped.\")\n",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":6040703541,\"explanation\":\"The `VinylPlayer` class was previously forced to implement methods related to digital operations, which it does not need. By creating a separate `IAnalogOperations` interface, we adhere to the ISP, ensuring that classes only implement methods relevant to their functionality.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The `VinylPlayer` class was previously forced to implement methods related to digital operations, which it does not need. By creating a separate `IAnalogOperations` interface, we adhere to the ISP, ensuring that classes only implement methods relevant to their functionality."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass IVehicleEngine(ABC):\n    @abstractmethod\n    def start(self):\n        pass\n\n    @abstractmethod\n    def stop(self):\n        pass\n\nclass IDriveable(ABC):\n    @abstractmethod\n    def drive(self):\n        pass\n\nclass IFlyable(ABC):\n    @abstractmethod\n    def fly(self):\n        pass\n\nclass IDiveable(ABC):\n    @abstractmethod\n    def dive(self):\n        pass\n\nclass Car(IVehicleEngine, IDriveable):\n    def start(self):\n        print(\"Car started.\")\n\n    def stop(self):\n        print(\"Car stopped.\")\n\n    def drive(self):\n        print(\"Car is driving on the road.\")\n\nclass Plane(IVehicleEngine, IFlyable):\n    def start(self):\n        print(\"Plane engine started.\")\n\n    def stop(self):\n        print(\"Plane engine stopped.\")\n\n    def fly(self):\n        print(\"Plane is flying.\")\n\nclass Submarine(IVehicleEngine, IDiveable):\n    def start(self):\n        print(\"Submarine powered up.\")\n\n    def stop(self):\n        print(\"Submarine powered down.\")\n\n    def dive(self):\n        print(\"Submarine is diving.\")\n\n",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4504410458,\"explanation\":\"The interfaces were too large, forcing classes to implement methods that were not relevant to their functionality. By separating the interfaces into specific capabilities (drive, fly, dive), we adhere to the Interface Segregation Principle (ISP).\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The interfaces were too large, forcing classes to implement methods that were not relevant to their functionality. By separating the interfaces into specific capabilities (drive, fly, dive), we adhere to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass IElectronicControl(ABC):\n    @abstractmethod\n    def turn_on(self):\n        pass\n\n    @abstractmethod\n    def turn_off(self):\n        pass\n\nclass IVolumeControl(ABC):\n    @abstractmethod\n    def volume_up(self):\n        pass\n\n    @abstractmethod\n    def volume_down(self):\n        pass\n\nclass ILockMechanism(ABC):\n    @abstractmethod\n    def lock(self):\n        pass\n\nclass LightBulb(IElectronicControl):\n    def __init__(self):\n        self.is_on = False\n\n    def turn_on(self):\n        self.is_on = True\n        print(\"LightBulb turned on.\")\n\n    def turn_off(self):\n        self.is_on = False\n        print(\"LightBulb turned off.\")\n\nclass RegularLightBulb(LightBulb):\n    pass\n\nclass RGBLightBulb(LightBulb):\n    def __init__(self):\n        super().__init__()\n        self.color = \"White\"\n\n    def change_color(self, new_color):\n        self.color = new_color\n        print(f\"RGBLightBulb color changed to {self.color}\")\n\nclass AudioDevice(IElectronicControl, IVolumeControl):\n    def __init__(self, initial_volume):\n        self.is_on = False\n        self.volume = initial_volume\n\n    def turn_on(self):\n        self.is_on = True\n        print(f\"{self.__class__.__name__} turned on.\")\n\n    def turn_off(self):\n        self.is_on = False\n        print(f\"{self.__class__.__name__} turned off.\")\n\n    def volume_up(self):\n        self.volume += 1\n        print(f\"{self.__class__.__name__} volume increased to {self.volume}\")\n\n    def volume_down(self):\n        self.volume -= 1\n        print(f\"{self.__class__.__name__} volume decreased to {self.volume}\")\n\nclass TV(AudioDevice):\n    def __init__(self):\n        super().__init__(10)\n\nclass Speaker(AudioDevice):\n    def __init__(self):\n        super().__init__(5)\n\nclass SmartLock(ILockMechanism):\n    def __init__(self):\n        self.is_locked = False\n\n    def lock(self):\n        self.is_locked = True\n        print(\"SmartLock is now locked.\")\n",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":9419249416,\"explanation\":\"The `AudioDevice` class implements both `IElectronicControl` and `IVolumeControl`, which violates the Interface Segregation Principle (ISP) as it forces the implementation of methods that may not be relevant for all electronic devices. The refactoring maintains separate interfaces for electronic control and volume control, allowing classes to implement only the interfaces they need.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The `AudioDevice` class implements both `IElectronicControl` and `IVolumeControl`, which violates the Interface Segregation Principle (ISP) as it forces the implementation of methods that may not be relevant for all electronic devices. The refactoring maintains separate interfaces for electronic control and volume control, allowing classes to implement only the interfaces they need."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass MoveStrategy(ABC):\n    @abstractmethod\n    def move(self):\n        pass\n\nclass AttackStrategy(ABC):\n    @abstractmethod\n    def attack(self):\n        pass\n\nclass WalkMovement(MoveStrategy):\n    def __init__(self, character_name):\n        self.character_name = character_name\n\n    def move(self):\n        print(f\"{self.character_name} walks on foot.\")\n\nclass FlyMovement(MoveStrategy):\n    def __init__(self, character_name):\n        self.character_name = character_name\n\n    def move(self):\n        print(f\"{self.character_name} flies magically.\")\n\nclass MeleeAttack(AttackStrategy):\n    def __init__(self, character_name):\n        self.character_name = character_name\n\n    def attack(self):\n        print(f\"{self.character_name} performs a melee attack.\")\n\nclass SpellAttack(AttackStrategy):\n    def __init__(self, character_name):\n        self.character_name = character_name\n\n    def attack(self):\n        print(f\"{self.character_name} casts a powerful spell.\")\n\nclass Character(ABC):\n    def __init__(self, name, move_strategy, attack_strategy):\n        self.name = name\n        self.move_strategy = move_strategy\n        self.attack_strategy = attack_strategy\n\n    def perform_move(self):\n        self.move_strategy.move()\n\n    def perform_attack(self):\n        self.attack_strategy.attack()\n\n    def display_role(self):\n        print(f\"Current character: {self.name}\")\n\nclass Mage(Character):\n    def __init__(self):\n        super().__init__(\"Mage\", FlyMovement(\"Mage\"), SpellAttack(\"Mage\"))\n\nclass Fighter(Character):\n    def __init__(self):\n        super().__init__(\"Fighter\", WalkMovement(\"Fighter\"), MeleeAttack(\"Fighter\"))\n\nclass Ranger(Character):\n    def __init__(self):\n        super().__init__(\"Ranger\", WalkMovement(\"Ranger\"), MeleeAttack(\"Ranger\"))\n\nclass GameContext:\n    def __init__(self, character: Character):\n        self.character = character\n\n    def set_character(self, new_character: Character):\n        self.character = new_character\n\n    def move(self):\n        self.character.perform_move()\n\n    def attack(self):\n        self.character.perform_attack()\n\n    def display(self):\n        self.character.display_role()",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":8497837875,\"explanation\":\"The original code had a potential ISP violation as the `Character` class was tightly coupled with specific movement and attack strategies, which could lead to unnecessary methods being implemented for characters that do not require them. The refactored code maintains the same structure but emphasizes the separation of concerns, ensuring that each character only implements the strategies relevant to them.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The original code had a potential ISP violation as the `Character` class was tightly coupled with specific movement and attack strategies, which could lead to unnecessary methods being implemented for characters that do not require them. The refactored code maintains the same structure but emphasizes the separation of concerns, ensuring that each character only implements the strategies relevant to them."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":7679009667,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `Chef` class implements multiple interfaces that it does not fully utilize, leading to unnecessary dependencies. The refactored code separates the responsibilities into specific classes like `PastryChef` and `Bartender`, allowing each class to implement only the interfaces relevant to their responsibilities.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":2353763000,\"explanation\":\"The original code violated the Interface Segregation Principle (ISP) because the `Chef` class implemented multiple interfaces that it did not fully utilize, leading to unnecessary dependencies. The refactored code separates the responsibilities into specific classes like `PastryChef` and `Bartender`, allowing each class to implement only the interfaces relevant to their responsibilities.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle (ISP) because the `Chef` class implemented multiple interfaces that it did not fully utilize, leading to unnecessary dependencies. The refactored code separates the responsibilities into specific classes like `PastryChef` and `Bartender`, allowing each class to implement only the interfaces relevant to their responsibilities."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":7981950833,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `Cube` class implements both `IShapeThreeD` and `IShapeTwoD`, but it does not need to implement the `calculate_area` method from `IShapeTwoD`. The refactored code removes the unnecessary interface implementation for `Cube`, adhering to ISP by ensuring that classes only implement the methods they actually use.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":2456210958,\"explanation\":\"The original code violated the Interface Segregation Principle (ISP) because the `Cube` class implemented both `IShapeThreeD` and `IShapeTwoD`, but it did not need to implement the `calculate_area` method from `IShapeTwoD`. The refactored code removes the unnecessary interface implementation for `Cube`, adhering to ISP by ensuring that classes only implement the methods they actually use.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle (ISP) because the `Cube` class implemented both `IShapeThreeD` and `IShapeTwoD`, but it did not need to implement the `calculate_area` method from `IShapeTwoD`. The refactored code removes the unnecessary interface implementation for `Cube`, adhering to ISP by ensuring that classes only implement the methods they actually use."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass Device(ABC):\n    @abstractmethod\n    def get_device_name(self):\n        pass\n\n    @abstractmethod\n    def display_info(self):\n        pass\n\nclass Connectable(ABC):\n    @abstractmethod\n    def connect(self):\n        pass\n\n    @abstractmethod\n    def disconnect(self):\n        pass\n\nclass DataTransferable(ABC):\n    @abstractmethod\n    def transfer_data(self, data):\n        pass\n\nclass Diagnosable(ABC):\n    @abstractmethod\n    def run_diagnostics(self):\n        pass\n\nclass Updatable(ABC):\n    @abstractmethod\n    def update_firmware(self, version):\n        pass\n\nclass MediaPlayable(ABC):\n    @abstractmethod\n    def play(self):\n        pass\n\n    @abstractmethod\n    def stop(self):\n        pass\n\nclass VolumeAdjustable(ABC):\n    @abstractmethod\n    def set_volume(self, level):\n        pass\n\nclass PowerControllable(ABC):\n    @abstractmethod\n    def power_on(self):\n        pass\n\n    @abstractmethod\n    def power_off(self):\n        pass\n\nclass ScreenResolutionAdjustable(ABC):\n    @abstractmethod\n    def set_screen_resolution(self, resolution):\n        pass\n\nclass MediaDevice(Device):\n    def __init__(self, name, location):\n        self.name = name\n        self.location = location\n\n    def get_device_name(self):\n        return self.name\n\n    def display_info(self):\n        print(f\"Media Device: {self.name}, Location: {self.location}\")\n\nclass SmartTV(MediaDevice, PowerControllable, MediaPlayable, VolumeAdjustable, ScreenResolutionAdjustable):\n    def power_on(self):\n        print(f\"{self.name} TV powered on.\")\n\n    def power_off(self):\n        print(f\"{self.name} TV powered off.\")\n\n    def play(self):\n        print(f\"{self.name} TV playing content.\")\n\n    def stop(self):\n        print(f\"{self.name} TV stopped playback.\")\n\n    def set_volume(self, level):\n        print(f\"{self.name} TV volume set to {level}\")\n\n    def set_screen_resolution(self, resolution):\n        print(f\"{self.name} TV resolution set to {resolution}\")\n\nclass SmartSpeaker(MediaDevice, PowerControllable, MediaPlayable, VolumeAdjustable):\n    def power_on(self):\n        print(f\"{self.name} speaker powered on.\")\n\n    def power_off(self):\n        print(f\"{self.name} speaker powered off.\")\n\n    def play(self):\n        print(f\"{self.name} speaker playing audio.\")\n\n    def stop(self):\n        print(f\"{self.name} speaker stopped playback.\")\n\n    def set_volume(self, level):\n        print(f\"{self.name} speaker volume set to {level}\")\n\nclass Router(Device, Connectable, DataTransferable, Diagnosable, Updatable):\n    def __init__(self, name, ip_address):\n        self.name = name\n        self.ip_address = ip_address\n\n    def connect(self):\n        print(f\"Router {self.name} established connection.\")\n\n    def disconnect(self):\n        print(f\"Router {self.name} disconnected.\")\n\n    def transfer_data(self, data):\n        print(f\"Router transferring data: {data}\")\n\n    def run_diagnostics(self):\n        print(f\"Running diagnostics on router {self.name}\")\n\n    def update_firmware(self, version):\n        print(f\"Router firmware updated to version: {version}\")\n\n    def get_device_name(self):\n        return self.name\n\n    def display_info(self):\n        print(f\"Router: {self.name}, IP: {self.ip_address}\")\n\nclass NetworkSwitch(Device, Connectable, DataTransferable, Diagnosable, Updatable):\n    def __init__(self, name, ip_address):\n        self.name = name\n        self.ip_address = ip_address\n\n    def connect(self):\n        print(f\"Switch {self.name} established connection.\")\n\n    def disconnect(self):\n        print(f\"Switch {self.name} disconnected.\")\n\n    def transfer_data(self, data):\n        print(f\"Switch transferring data: {data}\")\n\n    def run_diagnostics(self):\n        print(f\"Running diagnostics on switch {self.name}\")\n\n    def update_firmware(self, version):\n        print(f\"Switch firmware updated to version: {version}\")\n\n    def get_device_name(self):\n        return self.name\n\n    def display_info(self):\n        print(f\"Network Switch: {self.name}, IP: {self.ip_address}\")",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":16586584292,\"explanation\":\"The interfaces are too large, forcing classes to implement methods that are not relevant to them. The refactoring separates the interfaces into smaller, more specific ones, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The interfaces are too large, forcing classes to implement methods that are not relevant to them. The refactoring separates the interfaces into smaller, more specific ones, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\n\nclass UIElement(ABC):\n    @abstractmethod\n    def render(self): pass\n    @abstractmethod\n    def set_visible(self, visible): pass\n\n\nclass Positionable(ABC):\n    @abstractmethod\n    def resize(self, width, height): pass\n\n\nclass Colorable(ABC):\n    @abstractmethod\n    def set_background(self, color): pass\n    @abstractmethod\n    def set_foreground(self, color): pass\n\n\nclass Clickable(ABC):\n    @abstractmethod\n    def on_click(self, x, y): pass\n\n\nclass Hoverable(ABC):\n    @abstractmethod\n    def on_hover(self, x, y): pass\n\n\nclass KeyboardInteractive(ABC):\n    @abstractmethod\n    def on_key_press(self, key_code): pass\n\n\nclass Focusable(ABC):\n    @abstractmethod\n    def on_focus(self): pass\n    @abstractmethod\n    def on_blur(self): pass\n\n\nclass Container(ABC):\n    @abstractmethod\n    def add_child(self, child): pass\n    @abstractmethod\n    def remove_child(self, child): pass\n    @abstractmethod\n    def get_parent(self): pass\n\n\nclass TextStyleable(ABC):\n    @abstractmethod\n    def set_font(self, font_name, size): pass\n    @abstractmethod\n    def set_text_alignment(self, alignment): pass\n\n\nclass LayoutStyleable(ABC):\n    @abstractmethod\n    def set_margin(self, t, r, b, l): pass\n    @abstractmethod\n    def set_padding(self, t, r, b, l): pass\n\n\nclass Fadeable(ABC):\n    @abstractmethod\n    def fade_in(self, duration_ms): pass\n    @abstractmethod\n    def fade_out(self, duration_ms): pass\n\n\nclass Button(UIElement, Positionable, Colorable, Clickable):\n    def __init__(self, label, x, y, width, height):\n        self.label = label\n        self.x, self.y, self.width, self.height = x, y, width, height\n        self.background = \"#CCCCCC\"\n        self.foreground = \"#000000\"\n\n    def render(self):\n        print(f\"Rendering button: {self.label}\")\n\n    def set_visible(self, visible):\n        print(f\"Button visibility set to: {visible}\")\n\n    def resize(self, width, height):\n        self.width, self.height = width, height\n        print(f\"Button resized to: {width}x{height}\")\n\n    def set_background(self, color):\n        self.background = color\n        print(f\"Button background set to: {color}\")\n\n    def set_foreground(self, color):\n        self.foreground = color\n        print(f\"Button foreground set to: {color}\")\n\n    def on_click(self, x, y):\n        print(f\"Button clicked: {self.label}\")\n\n    def on_hover(self, x, y):\n        print(f\"Hover over button: {self.label}\")\n\n\nclass TextField(UIElement, Positionable, KeyboardInteractive, Focusable, TextStyleable):\n    def __init__(self, text, x, y, width, height):\n        self.text = text\n        self.x, self.y, self.width, self.height = x, y, width, height\n        self.focused = False\n        self.font_name = \"Arial\"\n        self.font_size = 12\n        self.text_align = \"left\"\n\n    def render(self):\n        print(f\"Rendering text field: {self.text}\")\n\n    def set_visible(self, visible):\n        print(f\"TextField visibility set to: {visible}\")\n\n    def resize(self, width, height):\n        self.width, self.height = width, height\n        print(f\"TextField resized to: {width}x{height}\")\n\n    def on_key_press(self, key_code):\n        print(f\"Key pressed in text field: {key_code}\")\n\n    def on_focus(self):\n        self.focused = True\n        print(\"Text field focused\")\n\n    def on_blur(self):\n        self.focused = False\n        print(\"Text field lost focus\")\n\n    def set_font(self, font_name, size):\n        self.font_name = font_name\n        self.font_size = size\n        print(f\"TextField font set to: {font_name}, size: {size}\")\n\n    def set_text_alignment(self, alignment):\n        self.text_align = alignment\n        print(f\"TextField alignment set to: {alignment}\")\n\n\nclass Image(UIElement, Positionable, Fadeable):\n    def __init__(self, path, x, y, width, height):\n        self.path = path\n        self.x, self.y, self.width, self.height = x, y, width, height\n\n    def render(self):\n        print(f\"Rendering image from: {self.path}\")\n\n    def set_visible(self, visible):\n        print(f\"Image visibility set to: {visible}\")\n\n    def resize(self, width, height):\n        self.width, self.height = width, height\n        print(f\"Image resized to: {width}x{height}\")\n\n    def fade_in(self, duration_ms):\n        print(f\"Fading in image over {duration_ms}ms\")\n\n    def fade_out(self, duration_ms):\n        print(f\"Fading out image over {duration_ms}ms\")\n\n\nclass Panel(UIElement, Positionable, Container, LayoutStyleable):\n    def __init__(self, x, y, width, height):\n        self.x, self.y, self.width, self.height = x, y, width, height\n        self.children = []\n        self.parent = None\n        self.margin = [0, 0, 0, 0]\n        self.padding = [0, 0, 0, 0]\n\n    def render(self):\n        print(\"Rendering panel\")\n        for child in self.children:\n            child.render()\n\n    def set_visible(self, visible):\n        print(f\"Panel visibility set to: {visible}\")\n\n    def resize(self, width, height):\n        self.width, self.height = width, height\n        print(f\"Panel resized to: {width}x{height}\")\n\n    def add_child(self, child):\n        self.children.append(child)\n        print(\"Child added to panel\")\n\n    def remove_child(self, child):\n        self.children.remove(child)\n        print(\"Child removed from panel\")\n\n    def get_parent(self):\n        return self.parent\n\n    def set_margin(self, t, r, b, l):\n        self.margin = [t, r, b, l]\n        print(\"Panel margins set\")\n\n    def set_padding(self, t, r, b, l):\n        self.padding = [t, r, b, l]\n        print(\"Panel padding set\")\n\n\nclass Shape(UIElement):\n    @abstractmethod\n    def draw(self): pass\n\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def render(self):\n        print(f\"Rendering circle with radius: {self.radius}\")\n\n    def set_visible(self, visible):\n        print(f\"Circle visibility set to: {visible}\")\n\n    def draw(self):\n        print(f\"Drawing circle with radius: {self.radius}\")\n\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def render(self):\n        print(f\"Rendering rectangle {self.width}x{self.height}\")\n\n    def set_visible(self, visible):\n        print(f\"Rectangle visibility set to: {visible}\")\n\n    def draw(self):\n        print(f\"Drawing rectangle {self.width}x{self.height}\")\n",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":24680070667,\"explanation\":\"The classes implement multiple interfaces, leading to a violation of the Interface Segregation Principle (ISP). By separating the interfaces into smaller, more specific ones, we ensure that classes only implement the methods they actually need, thus adhering to ISP.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The classes implement multiple interfaces, leading to a violation of the Interface Segregation Principle (ISP). By separating the interfaces into smaller, more specific ones, we ensure that classes only implement the methods they actually need, thus adhering to ISP."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":6453106250,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `SlackService` and `PushNotificationService` classes implement both sending and receiving messages, which may not be necessary for all message types. The refactored code separates the sending functionality into its own interface, allowing classes to implement only the methods they need.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":3479944875,\"explanation\":\"The original code violated the Interface Segregation Principle (ISP) because the `SlackService` and `PushNotificationService` classes implemented both sending and receiving messages, which may not be necessary for all message types. The refactored code separates the sending functionality into its own interface, allowing classes to implement only the methods they need.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle (ISP) because the `SlackService` and `PushNotificationService` classes implemented both sending and receiving messages, which may not be necessary for all message types. The refactored code separates the sending functionality into its own interface, allowing classes to implement only the methods they need."
        },
        {
            "input": "class FlightBookingSystem:\n    def __init__(self):\n        self.customer_system = CustomerBookingSystem()\n        self.admin_system = AdminFlightSystem()\n        self.email_service = EmailNotificationService()\n        self.reporting_service = ReportingService()\n\n    def book_flight(self, passenger_id, flight_number):\n        booking = self.customer_system.create_booking(passenger_id, flight_number)\n        if booking:\n            self.email_service.send_booking_confirmation(booking.booking_id, \"passenger@example.com\")\n        return booking\n\n    def cancel_flight(self, booking_id):\n        self.customer_system.cancel_booking(booking_id)\n        self.email_service.send_cancellation_notice(booking_id, \"passenger@example.com\")\n\n    def add_flight(self, flight):\n        self.admin_system.add_flight(flight)\n\n    def update_flight_status(self, flight_number, status):\n        self.admin_system.update_flight_status(flight_number, status)\n\n    def generate_report(self, booking_id):\n        return self.reporting_service.generate_booking_report(booking_id)\n\n    def get_statistics(self, start, end):\n        return self.reporting_service.get_booking_statistics(start, end)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":6350425542,\"explanation\":\"The original `FlightBookingSystem` class handled multiple responsibilities, including booking, cancellation, flight management, and reporting, violating the Single Responsibility Principle (SRP). The refactored code separates these concerns into distinct classes: `FlightBookingSystem`, `FlightAdminSystem`, and `ReportingSystem`, each responsible for a single aspect of the flight booking system.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original `FlightBookingSystem` class handled multiple responsibilities, including booking, cancellation, flight management, and reporting, violating the Single Responsibility Principle (SRP). The refactored code separates these concerns into distinct classes: `FlightBookingSystem`, `FlightAdminSystem`, and `ReportingSystem`, each responsible for a single aspect of the flight booking system."
        },
        {
            "input": "{\"violation_type\":\"Interface Segregation Principle (ISP)\",\"refactored_code\":\"interface IPrint {\\n    fun print(document: String)\\n}\\n\\ninterface IScanner {\\n    fun scan()\\n}\\n\\ninterface IFax {\\n    fun fax(recipient: String)\\n}\\n\\nclass BasicPrinter : IPrint {\\n    override fun print(document: String) {\\n        println(\\\"Printing: \\$document\\\")\\n    }\\n}\\n\\nclass AdvancedPrinter : IPrint, IScanner {\\n    override fun print(document: String) {\\n        println(\\\"Printing: \\$document\\\")\\n    }\\n\\n    override fun scan() {\\n        println(\\\"Scanning document...\\\")\\n    }\\n}\\n\\nclass SmartPhone : IPrint, IScanner, IFax {\\n    override fun print(document: String) {\\n        println(\\\"Sending to cloud printer: \\$document\\\")\\n    }\\n\\n    override fun scan() {\\n        println(\\\"Scanning document with camera...\\\")\\n    }\\n\\n    override fun fax(recipient: String) {\\n        println(\\\"Sending digital fax to \\$recipient\\\")\\n    }\\n}\\n\\nclass MultiFunctionPrinter : IPrint, IScanner, IFax {\\n    override fun print(document: String) {\\n        println(\\\"MultiFunctionPrinter: Printing: \\$document\\\")\\n    }\\n\\n    override fun scan() {\\n        println(\\\"MultiFunctionPrinter: Scanning document...\\\")\\n    }\\n\\n    override fun fax(recipient: String) {\\n        println(\\\"MultiFunctionPrinter: Sending fax to \\$recipient\\\")\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the SmartPhone class implements multiple interfaces (IPrint, IScanner, IFax) but may not need all functionalities. This can lead to unnecessary dependencies and bloated interfaces. In the refactored code, I introduced a MultiFunctionPrinter class that combines all functionalities, allowing for a more cohesive design while keeping the interfaces clean and focused. Each class now adheres to the principle of having only the methods it needs.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":6040040375,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the SmartPhone class implements multiple interfaces (IPrint, IScanner, IFax) but may not need all functionalities. This can lead to unnecessary dependencies and bloated interfaces. In the refactored code, I introduced a MultiFunctionPrinter class that combines all functionalities, allowing for a more cohesive design while keeping the interfaces clean and focused. Each class now adheres to the principle of having only the methods it needs.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the SmartPhone class implements multiple interfaces (IPrint, IScanner, IFax) but may not need all functionalities. This can lead to unnecessary dependencies and bloated interfaces. In the refactored code, I introduced a MultiFunctionPrinter class that combines all functionalities, allowing for a more cohesive design while keeping the interfaces clean and focused. Each class now adheres to the principle of having only the methods it needs."
        },
        {
            "input": "{\"violation_type\":\"Interface Segregation Principle (ISP)\",\"refactored_code\":\"class Resume(val content: String)\\n\\ninterface IJobSeeker {\\n    fun searchJobs()\\n    fun applyForJob(resume: Resume)\\n}\\n\\ninterface IRecruiter {\\n    fun postJob(jobDescription: String)\\n    fun reviewApplicants()\\n}\\n\\ninterface IAdmin {\\n    fun manageSiteSettings()\\n}\\n\\nclass JobSeeker : IJobSeeker {\\n    override fun searchJobs() {\\n        println(\\\"Searching for jobs...\\\")\\n    }\\n\\n    override fun applyForJob(resume: Resume) {\\n        println(\\\"Applied with resume: \\${resume.content}\\\")\\n    }\\n}\\n\\nclass Recruiter : IRecruiter {\\n    override fun postJob(jobDescription: String) {\\n        println(\\\"Job posted: \\$jobDescription\\\")\\n    }\\n\\n    override fun reviewApplicants() {\\n        println(\\\"Reviewing applicants...\\\")\\n    }\\n}\\n\\nclass Administrator : IAdmin {\\n    override fun manageSiteSettings() {\\n        println(\\\"Managing site settings...\\\")\\n    }\\n}\\n\\ninterface IJobManagement : IJobSeeker, IRecruiter\\n\\nclass JobManagement : IJobManagement {\\n    private val jobSeeker = JobSeeker()\\n    private val recruiter = Recruiter()\\n\\n    override fun searchJobs() {\\n        jobSeeker.searchJobs()\\n    }\\n\\n    override fun applyForJob(resume: Resume) {\\n        jobSeeker.applyForJob(resume)\\n    }\\n\\n    override fun postJob(jobDescription: String) {\\n        recruiter.postJob(jobDescription)\\n    }\\n\\n    override fun reviewApplicants() {\\n        recruiter.reviewApplicants()\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because it defines multiple interfaces (IJobSeeker, IRecruiter, IAdmin) that are not related to each other, which can lead to classes implementing methods they do not use. To refactor, I created a new interface IJobManagement that combines the functionalities of IJobSeeker and IRecruiter, allowing for a more cohesive design. This way, classes can implement only the interfaces they need, adhering to the ISP.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4095190625,\"explanation\":\"The original code violated the Interface Segregation Principle (ISP) by combining unrelated interfaces into a single interface (IJobManagement), forcing classes to implement methods they did not need. The refactored code separates the responsibilities into distinct interfaces (IJobSeeker and IRecruiter), allowing classes to implement only the methods relevant to their functionality.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle (ISP) by combining unrelated interfaces into a single interface (IJobManagement), forcing classes to implement methods they did not need. The refactored code separates the responsibilities into distinct interfaces (IJobSeeker and IRecruiter), allowing classes to implement only the methods relevant to their functionality."
        },
        {
            "input": "interface IAnalogueOperations {\n    fun play()\n    fun pause()\n    fun stop()\n}\n\ninterface IDigitalOperations {\n    fun skipTrack()\n    fun eject()\n}\n\ninterface IPlayer {\n    fun play()\n    fun pause()\n    fun stop()\n}\n\nclass CDPlayer : IPlayer, IDigitalOperations {\n    override fun play() {\n        println(\"CD is playing.\")\n    }\n\n    override fun pause() {\n        println(\"CD is paused.\")\n    }\n\n    override fun stop() {\n        println(\"CD stopped.\")\n    }\n\n    override fun skipTrack() {\n        println(\"Skipping to next CD track.\")\n    }\n\n    override fun eject() {\n        println(\"CD ejected.\")\n    }\n}\n\nclass VinylPlayer : IPlayer {\n    override fun play() {\n        println(\"Vinyl record is playing.\")\n    }\n\n    override fun pause() {\n        println(\"Vinyl playback paused (lift the needle).\")\n    }\n\n    override fun stop() {\n        println(\"Vinyl playback stopped.\")\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4196963041,\"explanation\":\"The `CDPlayer` class was forced to implement methods from `IDigitalOperations`, which it does not use, violating the ISP. The refactoring separates the interfaces, allowing `VinylPlayer` to implement only the methods it needs.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The `CDPlayer` class was forced to implement methods from `IDigitalOperations`, which it does not use, violating the ISP. The refactoring separates the interfaces, allowing `VinylPlayer` to implement only the methods it needs."
        },
        {
            "input": "interface IVehicleEngine {\n    fun start()\n    fun stop()\n}\n\ninterface IDriveable {\n    fun drive()\n}\n\ninterface IFlyable {\n    fun fly()\n}\n\ninterface IDiveable {\n    fun dive()\n}\n\nabstract class Vehicle : IVehicleEngine {\n    override fun start() {\n        println(\"Vehicle started.\")\n    }\n\n    override fun stop() {\n        println(\"Vehicle stopped.\")\n    }\n}\n\nclass Car : Vehicle(), IDriveable {\n    override fun drive() {\n        println(\"Car is driving on the road.\")\n    }\n}\n\nclass Plane : Vehicle(), IFlyable {\n    override fun start() {\n        println(\"Plane engine started.\")\n    }\n\n    override fun stop() {\n        println(\"Plane engine stopped.\")\n    }\n\n    override fun fly() {\n        println(\"Plane is flying.\")\n    }\n}\n\nclass Submarine : Vehicle(), IDiveable {\n    override fun start() {\n        println(\"Submarine powered up.\")\n    }\n\n    override fun stop() {\n        println(\"Submarine powered down.\")\n    }\n\n    override fun dive() {\n        println(\"Submarine is diving.\")\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4914292916,\"explanation\":\"The interfaces for flying, driving, and diving are separate, ensuring that classes only implement the methods they need, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The interfaces for flying, driving, and diving are separate, ensuring that classes only implement the methods they need, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"refactored_code\":\"interface DeviceControl {\\n    fun turnOn()\\n    fun turnOff()\\n}\\n\\ninterface VolumeControl {\\n    fun volumeUp()\\n    fun volumeDown()\\n}\\n\\ninterface Lockable {\\n    fun lock()\\n}\\n\\nopen class LightBulb : DeviceControl {\\n    protected var isOn: Boolean = false\\n\\n    override fun turnOn() {\\n        isOn = true\\n        println(\\\"LightBulb turned on.\\\")\\n    }\\n\\n    override fun turnOff() {\\n        isOn = false\\n        println(\\\"LightBulb turned off.\\\")\\n    }\\n}\\n\\nclass RegularLightBulb : LightBulb() {\\n    // No volume or lock functionality\\n}\\n\\nclass RGBLightBulb : LightBulb() {\\n    private var color: String = \\\"White\\\"\\n\\n    fun changeColor(newColor: String) {\\n        color = newColor\\n        println(\\\"RGBLightBulb color changed to \\$color\\\")\\n    }\\n}\\n\\nclass TV : DeviceControl, VolumeControl {\\n    private var volume: Int = 10\\n    private var isOn: Boolean = false\\n\\n    override fun turnOn() {\\n        isOn = true\\n        println(\\\"TV turned on.\\\")\\n    }\\n\\n    override fun turnOff() {\\n        isOn = false\\n        println(\\\"TV turned off.\\\")\\n    }\\n\\n    override fun volumeUp() {\\n        volume++\\n        println(\\\"TV volume increased to \\$volume\\\")\\n    }\\n\\n    override fun volumeDown() {\\n        volume--\\n        println(\\\"TV volume decreased to \\$volume\\\")\\n    }\\n}\\n\\nclass Speaker : DeviceControl, VolumeControl {\\n    private var volume: Int = 5\\n    private var isOn: Boolean = false\\n\\n    override fun turnOn() {\\n        isOn = true\\n        println(\\\"Speaker turned on.\\\")\\n    }\\n\\n    override fun turnOff() {\\n        isOn = false\\n        println(\\\"Speaker turned off.\\\")\\n    }\\n\\n    override fun volumeUp() {\\n        volume++\\n        println(\\\"Speaker volume increased to \\$volume\\\")\\n    }\\n\\n    override fun volumeDown() {\\n        volume--;\\n        println(\\\"Speaker volume decreased to \\$volume\\\")\\n    }\\n}\\n\\nclass SmartLock : DeviceControl, Lockable {\\n    private var isLocked: Boolean = false\\n\\n    override fun turnOn() {\\n        println(\\\"SmartLock doesn't need to be turned on.\\\")\\n    }\\n\\n    override fun turnOff() {\\n        println(\\\"SmartLock doesn't need to be turned off.\\\")\\n    }\\n\\n    override fun lock() {\\n        isLocked = true\\n        println(\\\"SmartLock is now locked.\\\")\\n    }\\n}\\n\\n\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `DeviceControl` interface includes methods that are not applicable to all implementing classes, such as `volumeUp`, `volumeDown`, and `lock`. This leads to classes like `RegularLightBulb` and `RGBLightBulb` implementing methods that they do not support. The refactored code separates the interfaces into `DeviceControl`, `VolumeControl`, and `Lockable`, allowing classes to implement only the interfaces relevant to their functionality. This adheres to the ISP and improves code clarity and maintainability.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":9321172791,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `DeviceControl` interface includes methods that are not applicable to all implementing classes, such as `volumeUp`, `volumeDown`, and `lock`. This leads to classes like `RegularLightBulb` and `RGBLightBulb` implementing methods that they do not support. The refactored code separates the interfaces into `DeviceControl`, `VolumeControl`, and `Lockable`, allowing classes to implement only the interfaces relevant to their functionality. This adheres to the ISP and improves code clarity and maintainability.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) because the `DeviceControl` interface includes methods that are not applicable to all implementing classes, such as `volumeUp`, `volumeDown`, and `lock`. This leads to classes like `RegularLightBulb` and `RGBLightBulb` implementing methods that they do not support. The refactored code separates the interfaces into `DeviceControl`, `VolumeControl`, and `Lockable`, allowing classes to implement only the interfaces relevant to their functionality. This adheres to the ISP and improves code clarity and maintainability."
        },
        {
            "input": "interface MoveStrategy {\n    fun move(characterName: String)\n}\n\ninterface AttackStrategy {\n    fun attack(characterName: String)\n}\n\nclass WalkMovement : MoveStrategy {\n    override fun move(characterName: String) {\n        println(\"$characterName walks on foot.\")\n    }\n}\n\nclass FlyMovement : MoveStrategy {\n    override fun move(characterName: String) {\n        println(\"$characterName flies magically.\")\n    }\n}\n\nclass MeleeAttack : AttackStrategy {\n    override fun attack(characterName: String) {\n        println(\"$characterName performs a melee attack.\")\n    }\n}\n\nclass SpellAttack : AttackStrategy {\n    override fun attack(characterName: String) {\n        println(\"$characterName casts a powerful spell.\")\n    }\n}\n\ninterface Character {\n    fun performMove()\n    fun performAttack()\n    fun displayRole()\n}\n\nclass Mage(private val moveStrategy: MoveStrategy, private val attackStrategy: AttackStrategy) : Character {\n    private val name = \"Mage\"\n\n    override fun performMove() {\n        moveStrategy.move(name)\n    }\n\n    override fun performAttack() {\n        attackStrategy.attack(name)\n    }\n\n    override fun displayRole() {\n        println(\"Current character: $name\")\n    }\n}\n\nclass Fighter(private val moveStrategy: MoveStrategy, private val attackStrategy: AttackStrategy) : Character {\n    private val name = \"Fighter\"\n\n    override fun performMove() {\n        moveStrategy.move(name)\n    }\n\n    override fun performAttack() {\n        attackStrategy.attack(name)\n    }\n\n    override fun displayRole() {\n        println(\"Current character: $name\")\n    }\n}\n\nclass Ranger(private val moveStrategy: MoveStrategy, private val attackStrategy: AttackStrategy) : Character {\n    private val name = \"Ranger\"\n\n    override fun performMove() {\n        moveStrategy.move(name)\n    }\n\n    override fun performAttack() {\n        attackStrategy.attack(name)\n    }\n\n    override fun displayRole() {\n        println(\"Current character: $name\")\n    }\n}\n\nclass GameContext(private var character: Character) {\n\n    fun setCharacter(newCharacter: Character) {\n        character = newCharacter\n    }\n\n    fun move() {\n        character.performMove()\n    }\n\n    fun attack() {\n        character.performAttack()\n    }\n\n    fun display() {\n        character.displayRole()\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":8394898917,\"explanation\":\"The original code had multiple character classes (Mage, Fighter, Ranger) that duplicated the implementation of `performMove`, `performAttack`, and `displayRole`. By introducing an abstract class `BaseCharacter`, we adhere to the Interface Segregation Principle (ISP) by reducing redundancy and ensuring that each character class only implements the necessary methods.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code had multiple character classes (Mage, Fighter, Ranger) that duplicated the implementation of `performMove`, `performAttack`, and `displayRole`. By introducing an abstract class `BaseCharacter`, we adhere to the Interface Segregation Principle (ISP) by reducing redundancy and ensuring that each character class only implements the necessary methods."
        },
        {
            "input": "interface FoodCooking {\n    fun cookBreakfast()\n    fun cookLunch()\n    fun cookDinner()\n}\n\ninterface BeverageService {\n    fun prepareDrinks()\n}\n\ninterface DessertService {\n    fun prepareDessert()\n}\n\ninterface TableService {\n    fun serveFood()\n    fun cleanTable()\n}\n\ninterface InventoryManager {\n    fun manageInventory()\n}\n\nclass Chef : FoodCooking, DessertService, BeverageService {\n    override fun cookBreakfast() {\n        println(\"Chef is cooking breakfast.\")\n    }\n\n    override fun cookLunch() {\n        println(\"Chef is cooking lunch.\")\n    }\n\n    override fun cookDinner() {\n        println(\"Chef is cooking dinner.\")\n    }\n\n    override fun prepareDessert() {\n        println(\"Chef is preparing dessert.\")\n    }\n\n    override fun prepareDrinks() {\n        println(\"Chef is preparing drinks.\")\n    }\n}\n\nclass Waiter : TableService {\n    override fun serveFood() {\n        println(\"Waiter is serving food.\")\n    }\n\n    override fun cleanTable() {\n        println(\"Waiter is cleaning the table.\")\n    }\n}\n\nclass InventoryManagerImpl : InventoryManager {\n    override fun manageInventory() {\n        println(\"Inventory Manager is managing kitchen inventory.\")\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4606858000,\"explanation\":\"The `Chef` class implements multiple interfaces, which may lead to it being forced to implement methods that are not relevant to its primary responsibility. This violates the Interface Segregation Principle (ISP). The refactoring maintains separate interfaces for distinct responsibilities, ensuring that classes only implement methods that are relevant to them.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The `Chef` class implements multiple interfaces, which may lead to it being forced to implement methods that are not relevant to its primary responsibility. This violates the Interface Segregation Principle (ISP). The refactoring maintains separate interfaces for distinct responsibilities, ensuring that classes only implement methods that are relevant to them."
        },
        {
            "input": "interface IShapeOneD {\n    fun calculatePerimeter(): Double\n}\n\ninterface IShapeTwoD {\n    fun calculateArea(): Double\n}\n\ninterface IShapeThreeD {\n    fun calculateVolume(): Double\n}\n\nclass Circle(private val radius: Double) : IShapeOneD, IShapeTwoD {\n    override fun calculateArea(): Double {\n        return Math.PI  radius  radius\n    }\n\n    override fun calculatePerimeter(): Double {\n        return 2  Math.PI  radius\n    }\n}\n\nclass Rectangle(private val width: Double, private val height: Double) : IShapeOneD, IShapeTwoD {\n    override fun calculateArea(): Double {\n        return width  height\n    }\n\n    override fun calculatePerimeter(): Double {\n        return 2  (width + height)\n    }\n}\n\nclass Line(private val length: Double) : IShapeOneD {\n    override fun calculatePerimeter(): Double {\n        return length\n    }\n}\n\nclass Cube(private val side: Double) : IShapeOneD, IShapeTwoD, IShapeThreeD {\n    override fun calculateArea(): Double {\n        return 6  side  side\n    }\n\n    override fun calculatePerimeter(): Double {\n        return 12  side\n    }\n\n    override fun calculateVolume(): Double {\n        return side  side  side\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5937874917,\"explanation\":\"The interfaces were too large, forcing classes to implement methods that were not relevant to them. The refactoring separates the interfaces more clearly, ensuring that each shape only implements the methods that are applicable to its dimensionality, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The interfaces were too large, forcing classes to implement methods that were not relevant to them. The refactoring separates the interfaces more clearly, ensuring that each shape only implements the methods that are applicable to its dimensionality, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "interface Device {\n    fun getDeviceName(): String\n    fun displayInfo()\n}\n\ninterface Connectable {\n    fun connect()\n    fun disconnect()\n}\n\ninterface DataTransferable {\n    fun transferData(data: String)\n}\n\ninterface Diagnosable {\n    fun runDiagnostics()\n}\n\ninterface Updatable {\n    fun updateFirmware(version: String)\n}\n\ninterface MediaPlayable {\n    fun play()\n    fun stop()\n}\n\ninterface VolumeAdjustable {\n    fun setVolume(level: Int)\n}\n\ninterface PowerControllable {\n    fun powerOn()\n    fun powerOff()\n}\n\ninterface ScreenResolutionAdjustable {\n    fun setScreenResolution(resolution: String)\n}\n\nabstract class BaseDevice(private val name: String) : Device {\n    override fun getDeviceName(): String = name\n}\n\nclass Router(name: String, private val ipAddress: String) : BaseDevice(name), Connectable, DataTransferable, Diagnosable, Updatable {\n    override fun connect() {\n        println(\"Router $name established connection.\")\n    }\n\n    override fun disconnect() {\n        println(\"Router $name disconnected.\")\n    }\n\n    override fun transferData(data: String) {\n        println(\"Router transferring data: $data\")\n    }\n\n    override fun runDiagnostics() {\n        println(\"Running diagnostics on router $name\")\n    }\n\n    override fun updateFirmware(version: String) {\n        println(\"Router firmware updated to version: $version\")\n    }\n\n    override fun displayInfo() {\n        println(\"Router: $name, IP: $ipAddress\")\n    }\n}\n\nclass NetworkSwitch(name: String, private val ipAddress: String) : BaseDevice(name), Connectable, DataTransferable, Diagnosable, Updatable {\n    override fun connect() {\n        println(\"Switch $name established connection.\")\n    }\n\n    override fun disconnect() {\n        println(\"Switch $name disconnected.\")\n    }\n\n    override fun transferData(data: String) {\n        println(\"Switch transferring data: $data\")\n    }\n\n    override fun runDiagnostics() {\n        println(\"Running diagnostics on switch $name\")\n    }\n\n    override fun updateFirmware(version: String) {\n        println(\"Switch firmware updated to version: $version\")\n    }\n\n    override fun displayInfo() {\n        println(\"Network Switch: $name, IP: $ipAddress\")\n    }\n}\n\nclass SmartTV(name: String, private val location: String) : BaseDevice(name), PowerControllable, MediaPlayable, VolumeAdjustable, ScreenResolutionAdjustable {\n    override fun powerOn() {\n        println(\"$name TV powered on.\")\n    }\n\n    override fun powerOff() {\n        println(\"$name TV powered off.\")\n    }\n\n    override fun play() {\n        println(\"$name TV playing content.\")\n    }\n\n    override fun stop() {\n        println(\"$name TV stopped playback.\")\n    }\n\n    override fun setVolume(level: Int) {\n        println(\"$name TV volume set to $level\")\n    }\n\n    override fun setScreenResolution(resolution: String) {\n        println(\"$name TV resolution set to $resolution\")\n    }\n\n    override fun displayInfo() {\n        println(\"Smart TV: $name, Location: $location\")\n    }\n}\n\nclass SmartSpeaker(name: String, private val location: String) : BaseDevice(name), PowerControllable, MediaPlayable, VolumeAdjustable {\n    override fun powerOn() {\n        println(\"$name speaker powered on.\")\n    }\n\n    override fun powerOff() {\n        println(\"$name speaker powered off.\")\n    }\n\n    override fun play() {\n        println(\"$name speaker playing audio.\")\n    }\n\n    override fun stop() {\n        println(\"$name speaker stopped playback.\")\n    }\n\n    override fun setVolume(level: Int) {\n        println(\"$name speaker volume set to $level\")\n    }\n\n    override fun displayInfo() {\n        println(\"Smart Speaker: $name, Location: $location\")\n    }\n}\n\nclass DeviceManager {\n    fun configureDevice(device: Device) {\n        device.displayInfo()\n        if (device is PowerControllable) {\n            device.powerOn()\n        }\n        if (device is Connectable) {\n            device.connect()\n        }\n    }\n\n    fun updateFirmware(device: Updatable) {\n        println(\"Updating firmware for ${(device as Device).getDeviceName()}\")\n        device.updateFirmware(\"v2.4.1\")\n    }\n\n    fun playMedia(device: MediaPlayable) {\n        if (device is Device) {\n            println(\"Playing media on ${device.getDeviceName()}\")\n        }\n        device.play()\n    }\n\n    fun adjustVolume(device: VolumeAdjustable, level: Int) {\n        if (device is Device) {\n            println(\"Adjusting volume on ${device.getDeviceName()}\")\n        }\n        device.setVolume(level)\n    }\n\n    fun adjustScreenResolution(device: ScreenResolutionAdjustable, resolution: String) {\n        if (device is Device) {\n            println(\"Adjusting screen resolution on ${device.getDeviceName()}\")\n        }\n        device.setScreenResolution(resolution)\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":17406920667,\"explanation\":\"The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring maintains smaller, more focused interfaces that allow classes to implement only the methods they need.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring maintains smaller, more focused interfaces that allow classes to implement only the methods they need."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"refactored_code\":\"interface UIElement {\\n    fun render()\\n    fun setVisible(visible: Boolean)\\n}\\n\\ninterface Positionable {\\n    fun resize(width: Int, height: Int)\\n}\\n\\ninterface Colorable {\\n    fun setBackground(color: String)\\n    fun setForeground(color: String)\\n}\\n\\ninterface Clickable {\\n    fun onClick(x: Int, y: Int)\\n}\\n\\ninterface Hoverable {\\n    fun onHover(x: Int, y: Int)\\n}\\n\\ninterface KeyboardInteractive {\\n    fun onKeyPress(keyCode: Int)\\n}\\n\\ninterface Focusable {\\n    fun onFocus()\\n    fun onBlur()\\n}\\n\\ninterface Container {\\n    fun addChild(child: UIElement)\\n    fun removeChild(child: UIElement)\\n    fun getParent(): UIElement?\\n}\\n\\ninterface TextStyleable {\\n    fun setFont(fontName: String, size: Int)\\n    fun setTextAlignment(alignment: String)\\n}\\n\\ninterface LayoutStyleable {\\n    fun setMargin(top: Int, right: Int, bottom: Int, left: Int)\\n    fun setPadding(top: Int, right: Int, bottom: Int, left: Int)\\n}\\n\\ninterface Fadeable {\\n    fun fadeIn(durationMs: Int)\\n    fun fadeOut(durationMs: Int)\\n}\\n\\nabstract class AbstractUIElement : UIElement {\\n    abstract var x: Int\\n    abstract var y: Int\\n    abstract var width: Int\\n    abstract var height: Int\\n\\n    override fun setVisible(visible: Boolean) {\\n        println(\\\"Visibility set to: \\$visible\\\")\\n    }\\n}\\n\\nclass Button(\\n    private val label: String,\\n    override var x: Int,\\n    override var y: Int,\\n    override var width: Int,\\n    override var height: Int\\n) : AbstractUIElement(), Colorable, Clickable, Hoverable {\\n    private var backgroundColor = \\\"#CCCCCC\\\"\\n    private var foregroundColor = \\\"#000000\\\"\\n\\n    override fun render() {\\n        println(\\\"Rendering button: \\$label\\\")\\n    }\\n\\n    override fun resize(width: Int, height: Int) {\\n        this.width = width\\n        this.height = height\\n        println(\\\"Button resized to: \\$width x \\$height\\\")\\n    }\\n\\n    override fun setBackground(color: String) {\\n        backgroundColor = color\\n        println(\\\"Button background set to: \\$color\\\")\\n    }\\n\\n    override fun setForeground(color: String) {\\n        foregroundColor = color\\n        println(\\\"Button foreground set to: \\$color\\\")\\n    }\\n\\n    override fun onClick(x: Int, y: Int) {\\n        println(\\\"Button clicked: \\$label\\\")\\n    }\\n\\n    override fun onHover(x: Int, y: Int) {\\n        println(\\\"Hover over button: \\$label\\\")\\n    }\\n}\\n\\nclass TextField(\\n    private var text: String,\\n    override var x: Int,\\n    override var y: Int,\\n    override var width: Int,\\n    override var height: Int\\n) : AbstractUIElement(), KeyboardInteractive, Focusable, TextStyleable {\\n    private var focused = false\\n    private var fontName = \\\"Arial\\\"\\n    private var fontSize = 12\\n    private var textAlignment = \\\"left\\\"\\n\\n    override fun render() {\\n        println(\\\"Rendering text field: \\$text\\\")\\n    }\\n\\n    override fun resize(width: Int, height: Int) {\\n        this.width = width\\n        this.height = height\\n        println(\\\"TextField resized to: \\$width x \\$height\\\")\\n    }\\n\\n    override fun onKeyPress(keyCode: Int) {\\n        println(\\\"Key pressed in text field: \\$keyCode\\\")\\n    }\\n\\n    override fun onFocus() {\\n        focused = true\\n        println(\\\"Text field focused\\\")\\n    }\\n\\n    override fun onBlur() {\\n        focused = false\\n        println(\\\"Text field lost focus\\\")\\n    }\\n\\n    override fun setFont(fontName: String, size: Int) {\\n        this.fontName = fontName\\n        this.fontSize = size\\n        println(\\\"TextField font set to: \\$fontName, size: \\$size\\\")\\n    }\\n\\n    override fun setTextAlignment(alignment: String) {\\n        this.textAlignment = alignment\\n        println(\\\"TextField alignment set to: \\$alignment\\\")\\n    }\\n}\\n\\nclass Image(\\n    private val imagePath: String,\\n    override var x: Int,\\n    override var y: Int,\\n    override var width: Int,\\n    override var height: Int\\n) : AbstractUIElement(), Fadeable {\\n    override fun render() {\\n        println(\\\"Rendering image from: \\$imagePath\\\")\\n    }\\n\\n    override fun resize(width: Int, height: Int) {\\n        this.width = width\\n        this.height = height\\n        println(\\\"Image resized to: \\$width x \\$height\\\")\\n    }\\n\\n    override fun fadeIn(durationMs: Int) {\\n        println(\\\"Fading in image over \\$durationMs ms\\\")\\n    }\\n\\n    override fun fadeOut(durationMs: Int) {\\n        println(\\\"Fading out image over \\$durationMs ms\\\")\\n    }\\n}\\n\\nclass Panel(\\n    override var x: Int,\\n    override var y: Int,\\n    override var width: Int,\\n    override var height: Int\\n) : AbstractUIElement(), Container, LayoutStyleable {\\n    private val children = mutableListOf<UIElement>()\\n    private var parent: UIElement? = null\\n    private var margins = IntArray(4)\\n    private var paddings = IntArray(4)\\n\\n    override fun render() {\\n        println(\\\"Rendering panel\\\")\\n        for (child in children) {\\n            child.render()\\n        }\\n    }\\n\\n    override fun addChild(child: UIElement) {\\n        children.add(child)\\n        println(\\\"Child added to panel\\\")\\n    }\\n\\n    override fun removeChild(child: UIElement) {\\n        children.remove(child)\\n        println(\\\"Child removed from panel\\\")\\n    }\\n\\n    override fun getParent(): UIElement? = parent\\n\\n    override fun setMargin(top: Int, right: Int, bottom: Int, left: Int) {\\n        margins = intArrayOf(top, right, bottom, left)\\n        println(\\\"Panel margins set\\\")\\n    }\\n\\n    override fun setPadding(top: Int, right: Int, bottom: Int, left: Int) {\\n        paddings = intArrayOf(top, right, bottom, left)\\n        println(\\\"Panel padding set\\\")\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) as many classes implement multiple interfaces that may not be relevant to their core functionality. This can lead to unnecessary dependencies and changes in classes for reasons unrelated to their primary purpose. The refactored code separates interfaces into smaller, more specific ones, allowing classes to implement only the interfaces they need. This enhances maintainability and adheres to the ISP.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":21091941250,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) as many classes implement multiple interfaces that may not be relevant to their core functionality. This can lead to unnecessary dependencies and changes in classes for reasons unrelated to their primary purpose. The refactored code separates interfaces into smaller, more specific ones, allowing classes to implement only the interfaces they need. This enhances maintainability and adheres to the ISP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code violates the Interface Segregation Principle (ISP) as many classes implement multiple interfaces that may not be relevant to their core functionality. This can lead to unnecessary dependencies and changes in classes for reasons unrelated to their primary purpose. The refactored code separates interfaces into smaller, more specific ones, allowing classes to implement only the interfaces they need. This enhances maintainability and adheres to the ISP."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":6759735458,\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because it creates multiple interfaces for each type of message (email, SMS, push notifications, etc.) and separates send and receive functionalities. This leads to a proliferation of interfaces that can be cumbersome to implement and maintain. The refactored code consolidates the sending and receiving functionalities into a single interface, reducing the number of interfaces and adhering to the ISP. Each service now implements a single interface for both sending and receiving messages, making the code cleaner and more maintainable.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":3275623250,\"explanation\":\"The original code had multiple interfaces for different message types, violating the Interface Segregation Principle (ISP). The refactored code consolidates the functionalities into a single `MessageService` interface, allowing each service to implement both sending and receiving methods, thus simplifying the design and improving maintainability.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code had multiple interfaces for different message types, violating the Interface Segregation Principle (ISP). The refactored code consolidates the functionalities into a single `MessageService` interface, allowing each service to implement both sending and receiving methods, thus simplifying the design and improving maintainability."
        },
        {
            "input": "interface FlightSearchable {\n    fun searchAvailableFlights(origin: String, destination: String, date: LocalDateTime): List<Flight>\n}\n\ninterface FlightManageable {\n    fun addFlight(flight: Flight)\n    fun updateFlightStatus(flightNumber: String, status: FlightStatus)\n}\n\ninterface BookingCreator {\n    fun createBooking(passengerId: String, flightNumber: String): Booking?\n    fun cancelBooking(bookingId: String)\n    fun getBookingDetails(bookingId: String): Booking?\n}\n\ninterface PaymentProcessor {\n    fun processPayment(bookingId: String, method: PaymentMethod, amount: Double): Boolean\n    fun refundPayment(bookingId: String): Boolean\n}\n\ninterface EmailNotifier {\n    fun sendBookingConfirmation(bookingId: String, email: String)\n    fun sendCancellationNotice(bookingId: String, email: String)\n}\n\ninterface ReportGenerator {\n    fun generateBookingReport(bookingId: String): ByteArray\n    fun getBookingStatistics(start: LocalDateTime, end: LocalDateTime): Map<String, Int>\n}\n\nclass CustomerBookingSystem : FlightSearchable, BookingCreator, PaymentProcessor {\n    private val flights = mutableMapOf<String, Flight>()\n    private val bookings = mutableMapOf<String, Booking>()\n\n    fun setFlightsForDemo(vararg flightsToAdd: Flight) {\n        for (flight in flightsToAdd) {\n            flights[flight.flightNumber] = flight\n        }\n    }\n\n    override fun searchAvailableFlights(origin: String, destination: String, date: LocalDateTime): List<Flight> {\n        val availableFlights = mutableListOf<Flight>()\n        for (flight in flights.values) {\n            if (flight.origin == origin &&\n                flight.destination == destination &&\n                flight.departureTime.toLocalDate() == date.toLocalDate()\n            ) {\n                availableFlights.add(flight)\n            }\n        }\n        return availableFlights\n    }\n\n    override fun createBooking(passengerId: String, flightNumber: String): Booking? {\n        val flight = flights[flightNumber]\n        return if (flight != null) {\n            val bookingId = \"B\" + System.currentTimeMillis()\n            val booking = Booking(bookingId, passengerId, flightNumber)\n            bookings[bookingId] = booking\n            booking\n        } else null\n    }\n\n    override fun cancelBooking(bookingId: String) {\n        bookings.remove(bookingId)\n    }\n\n    override fun getBookingDetails(bookingId: String): Booking? {\n        return bookings[bookingId]\n    }\n\n    override fun processPayment(bookingId: String, method: PaymentMethod, amount: Double): Boolean {\n        println(\"Processing payment of $$amount for booking $bookingId\")\n        return true\n    }\n\n    override fun refundPayment(bookingId: String): Boolean {\n        println(\"Refunding payment for booking $bookingId\")\n        return true\n    }\n}\n\nclass AdminFlightSystem : FlightManageable, FlightSearchable {\n    private val flights = mutableMapOf<String, Flight>()\n\n    override fun addFlight(flight: Flight) {\n        flights[flight.flightNumber] = flight\n    }\n\n    override fun updateFlightStatus(flightNumber: String, status: FlightStatus) {\n        flights[flightNumber]?.status = status\n    }\n\n    override fun searchAvailableFlights(origin: String, destination: String, date: LocalDateTime): List<Flight> {\n        val availableFlights = mutableListOf<Flight>()\n        for (flight in flights.values) {\n            if (flight.origin == origin &&\n                flight.destination == destination &&\n                flight.departureTime.toLocalDate() == date.toLocalDate()\n            ) {\n                availableFlights.add(flight)\n            }\n        }\n        return availableFlights\n    }\n}\n\nclass EmailNotificationService : EmailNotifier {\n    override fun sendBookingConfirmation(bookingId: String, email: String) {\n        println(\"Sending booking confirmation email for $bookingId to $email\")\n    }\n\n    override fun sendCancellationNotice(bookingId: String, email: String) {\n        println(\"Sending cancellation notice for $bookingId to $email\")\n    }\n}\n\nclass ReportingService : ReportGenerator {\n    override fun generateBookingReport(bookingId: String): ByteArray {\n        println(\"Generating booking report for $bookingId\")\n        return ByteArray(512)\n    }\n\n    override fun getBookingStatistics(start: LocalDateTime, end: LocalDateTime): Map<String, Int> {\n        println(\"Generating booking statistics from $start to $end\")\n        val stats = mutableMapOf<String, Int>()\n        stats[\"totalBookings\"] = 120\n        stats[\"cancelledBookings\"] = 15\n        return stats\n    }\n}\n\nenum class FlightStatus {\n    SCHEDULED, BOARDING, DEPARTED, LANDED, CANCELLED, DELAYED\n}\n\nenum class PaymentMethod {\n    CREDIT_CARD, DEBIT_CARD, PAYPAL\n}\n\ndata class Flight(\n    val flightNumber: String,\n    val origin: String,\n    val destination: String,\n    val departureTime: LocalDateTime,\n    val arrivalTime: LocalDateTime,\n    var status: FlightStatus = FlightStatus.SCHEDULED\n)\n\ndata class Booking(\n    val bookingId: String,\n    val passengerId: String,\n    val flightNumber: String,\n    val bookingTime: LocalDateTime = LocalDateTime.now()\n) {\n    override fun toString(): String {\n        return \"Booking{\"\n                + \"bookingId='\" + bookingId + '\\''\n                + \", passengerId='\" + passengerId + '\\''\n                + \", flightNumber='\" + flightNumber + '\\''\n                + \", bookingTime=\" + bookingTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)\n                + '}'\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":16484559417,\"explanation\":\"The original code had interfaces that were too large, forcing classes to implement methods that were not relevant to their functionality. The refactored code separates concerns by allowing classes to implement only the interfaces they need, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The original code had interfaces that were too large, forcing classes to implement methods that were not relevant to their functionality. The refactored code separates concerns by allowing classes to implement only the interfaces they need, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "using System;\n\npublic interface IPrint\n{\n    void Print(string document);\n}\n\npublic interface IScan\n{\n    void Scan();\n}\n\npublic interface IFax\n{\n    void Fax(string recipient);\n}\n\npublic class BasicPrinter : IPrint\n{\n    public void Print(string document)\n    {\n        Console.WriteLine(\"Printing: \" + document);\n    }\n}\n\npublic class AdvancedPrinter : IPrint, IScan\n{\n    public void Print(string document)\n    {\n        Console.WriteLine(\"Printing: \" + document);\n    }\n\n    public void Scan()\n    {\n        Console.WriteLine(\"Scanning document...\");\n    }\n}\n\npublic class SmartPhone : IPrint, IScan\n{\n    public void Print(string document)\n    {\n        Console.WriteLine(\"Sending to cloud printer: \" + document);\n    }\n\n    public void Scan()\n    {\n        Console.WriteLine(\"Scanning document with camera...\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4197746083,\"explanation\":\"The original code had interfaces that were too large, forcing classes to implement methods they did not need. By separating the `IPrint` and `IScan` interfaces, we adhere to the Interface Segregation Principle (ISP), allowing classes to implement only the methods relevant to them.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The original code had interfaces that were too large, forcing classes to implement methods they did not need. By separating the `IPrint` and `IScan` interfaces, we adhere to the Interface Segregation Principle (ISP), allowing classes to implement only the methods relevant to them."
        },
        {
            "input": "public interface IJobSeeker { void SearchJobs(); }\npublic interface IJobApplication { void ApplyForJob(Resume resume); }\npublic interface IRecruiter { void PostJob(string jobDescription); void ReviewApplicants(); }\npublic interface IAdmin { void ManageSiteSettings(); }\n\npublic class JobSeeker : IJobSeeker, IJobApplication {\n    public void SearchJobs() {\n        Console.WriteLine(\"Searching for jobs...\");\n    }\n\n    public void ApplyForJob(Resume resume) {\n        Console.WriteLine(\"Applied with resume: \" + resume.Content);\n    }\n}\n\npublic class Recruiter : IRecruiter {\n    public void PostJob(string jobDescription) {\n        Console.WriteLine(\"Job posted: \" + jobDescription);\n    }\n\n    public void ReviewApplicants() {\n        Console.WriteLine(\"Reviewing applicants...\");\n    }\n}\n\npublic class Administrator : IAdmin {\n    public void ManageSiteSettings() {\n        Console.WriteLine(\"Managing site settings...\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4197173958,\"explanation\":\"The interfaces were too large and forced classes to implement methods that were not relevant to their responsibilities. By separating the interfaces, we ensure that classes only implement the methods they need, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The interfaces were too large and forced classes to implement methods that were not relevant to their responsibilities. By separating the interfaces, we ensure that classes only implement the methods they need, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "using System;\n\npublic interface IAnalogueOperations\n{\n    void play();\n    void pause();\n    void stop();\n}\n\npublic interface IDigitalOperations\n{\n    void skipTrack();\n    void eject();\n}\n\npublic interface IPlayer\n{\n    void play();\n    void pause();\n    void stop();\n}\n\npublic class CDPlayer : IPlayer, IDigitalOperations\n{\n    public void play()\n    {\n        Console.WriteLine(\"CD is playing.\");\n    }\n\n    public void pause()\n    {\n        Console.WriteLine(\"CD is paused.\");\n    }\n\n    public void stop()\n    {\n        Console.WriteLine(\"CD stopped.\");\n    }\n\n    public void skipTrack()\n    {\n        Console.WriteLine(\"Skipping to next CD track.\");\n    }\n\n    public void eject()\n    {\n        Console.WriteLine(\"CD ejected.\");\n    }\n}\n\npublic class VinylPlayer : IPlayer\n{\n    public void play()\n    {\n        Console.WriteLine(\"Vinyl record is playing.\");\n    }\n\n    public void pause()\n    {\n        Console.WriteLine(\"Vinyl playback paused (lift the needle).\");\n    }\n\n    public void stop()\n    {\n        Console.WriteLine(\"Vinyl playback stopped.\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5220901792,\"explanation\":\"The `CDPlayer` class implements both `IPlayer` and `IDigitalOperations`, which leads to an interface segregation violation since it forces the `CDPlayer` to implement methods that are not relevant to it. The refactoring maintains separate interfaces for analogue and digital operations, ensuring that classes only implement the methods they need.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The `CDPlayer` class implements both `IPlayer` and `IDigitalOperations`, which leads to an interface segregation violation since it forces the `CDPlayer` to implement methods that are not relevant to it. The refactoring maintains separate interfaces for analogue and digital operations, ensuring that classes only implement the methods they need."
        },
        {
            "input": "using System;\n\npublic interface IVehicleEngine\n{\n    void start();\n    void stop();\n}\n\npublic interface ICar\n{\n    void drive();\n}\n\npublic interface IPlane\n{\n    void fly();\n}\n\npublic interface ISubmarine\n{\n    void dive();\n}\n\npublic interface IVehicle : IVehicleEngine\n{\n    void operate();\n}\n\npublic class Car : IVehicle\n{\n    public void start()\n    {\n        Console.WriteLine(\"Car started.\");\n    }\n\n    public void stop()\n    {\n        Console.WriteLine(\"Car stopped.\");\n    }\n\n    public void operate()\n    {\n        drive();\n    }\n\n    public void drive()\n    {\n        Console.WriteLine(\"Car is driving on the road.\");\n    }\n}\n\npublic class Plane : IVehicle\n{\n    public void start()\n    {\n        Console.WriteLine(\"Plane engine started.\");\n    }\n\n    public void stop()\n    {\n        Console.WriteLine(\"Plane engine stopped.\");\n    }\n\n    public void operate()\n    {\n        fly();\n    }\n\n    public void fly()\n    {\n        Console.WriteLine(\"Plane is flying.\");\n    }\n}\n\npublic class Submarine : IVehicle\n{\n    public void start()\n    {\n        Console.WriteLine(\"Submarine powered up.\");\n    }\n\n    public void stop()\n    {\n        Console.WriteLine(\"Submarine powered down.\");\n    }\n\n    public void operate()\n    {\n        dive();\n    }\n\n    public void dive()\n    {\n        Console.WriteLine(\"Submarine is diving.\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":6345175834,\"explanation\":\"The original code had a single `IVehicle` interface that combined engine operations with vehicle-specific operations, violating the Interface Segregation Principle (ISP). The refactored code separates the interfaces for each vehicle type, ensuring that classes only implement the methods they need.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The original code had a single `IVehicle` interface that combined engine operations with vehicle-specific operations, violating the Interface Segregation Principle (ISP). The refactored code separates the interfaces for each vehicle type, ensuring that classes only implement the methods they need."
        },
        {
            "input": "using System;\n\npublic interface IElectronicControl\n{\n    void TurnOn();\n    void TurnOff();\n}\n\npublic interface IVolumeControl\n{\n    void VolumeUp();\n    void VolumeDown();\n}\n\npublic interface ILockMechanism\n{\n    void Lock();\n}\n\npublic abstract class LightBulb : IElectronicControl\n{\n    protected bool isOn;\n\n    public virtual void TurnOn()\n    {\n        isOn = true;\n        Console.WriteLine(\"LightBulb turned on.\");\n    }\n\n    public virtual void TurnOff()\n    {\n        isOn = false;\n        Console.WriteLine(\"LightBulb turned off.\");\n    }\n}\n\npublic class RegularLightBulb : LightBulb\n{\n\n}\n\npublic class RGBLightBulb : LightBulb\n{\n    private string color = \"White\";\n\n    public void ChangeColor(string newColor)\n    {\n        color = newColor;\n        Console.WriteLine(\"RGBLightBulb color changed to \" + color);\n    }\n}\n\npublic abstract class AudioDevice : IElectronicControl, IVolumeControl\n{\n    protected int volume;\n    protected bool isOn;\n\n    public abstract void TurnOn();\n    public abstract void TurnOff();\n\n    public void VolumeUp()\n    {\n        volume++;\n        Console.WriteLine(GetType().Name + \" volume increased to \" + volume);\n    }\n\n    public void VolumeDown()\n    {\n        volume--;\n        Console.WriteLine(GetType().Name + \" volume decreased to \" + volume);\n    }\n}\n\npublic class TV : AudioDevice\n{\n    public override void TurnOn()\n    {\n        isOn = true;\n        Console.WriteLine(\"TV turned on.\");\n    }\n\n    public override void TurnOff()\n    {\n        isOn = false;\n        Console.WriteLine(\"TV turned off.\");\n    }\n}\n\npublic class Speaker : AudioDevice\n{\n    public Speaker()\n    {\n        volume = 5;\n    }\n\n    public override void TurnOn()\n    {\n        isOn = true;\n        Console.WriteLine(\"Speaker turned on.\");\n    }\n\n    public override void TurnOff()\n    {\n        isOn = false;\n        Console.WriteLine(\"Speaker turned off.\");\n    }\n}\n\npublic class SmartLock : ILockMechanism\n{\n    private bool isLocked = false;\n\n    public void Lock()\n    {\n        isLocked = true;\n        Console.WriteLine(\"SmartLock is now locked.\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":11467837291,\"explanation\":\"The interfaces `IElectronicControl`, `IVolumeControl`, and `ILockMechanism` are separate and specific, but the `AudioDevice` class implements both `IElectronicControl` and `IVolumeControl`, which may not be necessary for all audio devices. This could lead to classes implementing methods they do not need. The refactoring maintains the interfaces but ensures that classes only implement the interfaces relevant to their functionality, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The interfaces `IElectronicControl`, `IVolumeControl`, and `ILockMechanism` are separate and specific, but the `AudioDevice` class implements both `IElectronicControl` and `IVolumeControl`, which may not be necessary for all audio devices. This could lead to classes implementing methods they do not need. The refactoring maintains the interfaces but ensures that classes only implement the interfaces relevant to their functionality, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "using System;\n\npublic interface IMoveStrategy\n{\n    void Move();\n}\n\npublic interface IAttackStrategy\n{\n    void Attack();\n}\n\npublic class WalkMovement : IMoveStrategy\n{\n    public void Move()\n    {\n        Console.WriteLine(\"walks on foot.\");\n    }\n}\n\npublic class FlyMovement : IMoveStrategy\n{\n    public void Move()\n    {\n        Console.WriteLine(\"flies magically.\");\n    }\n}\n\npublic class MeleeAttack : IAttackStrategy\n{\n    public void Attack()\n    {\n        Console.WriteLine(\"performs a melee attack.\");\n    }\n}\n\npublic class SpellAttack : IAttackStrategy\n{\n    public void Attack()\n    {\n        Console.WriteLine(\"casts a powerful spell.\");\n    }\n}\n\npublic interface ICharacter\n{\n    void PerformMove();\n    void PerformAttack();\n    void DisplayRole();\n}\n\npublic abstract class Character : ICharacter\n{\n    protected IMoveStrategy moveStrategy;\n    protected IAttackStrategy attackStrategy;\n    protected string name;\n\n    public Character(string name, IMoveStrategy moveStrategy, IAttackStrategy attackStrategy)\n    {\n        this.name = name;\n        this.moveStrategy = moveStrategy;\n        this.attackStrategy = attackStrategy;\n    }\n\n    public void PerformMove()\n    {\n        moveStrategy.Move();\n    }\n\n    public void PerformAttack()\n    {\n        attackStrategy.Attack();\n    }\n\n    public void DisplayRole()\n    {\n        Console.WriteLine($\"Current character: {name}\");\n    }\n}\n\npublic class Mage : Character\n{\n    public Mage() : base(\"Mage\", new FlyMovement(), new SpellAttack()) {}\n}\n\npublic class Fighter : Character\n{\n    public Fighter() : base(\"Fighter\", new WalkMovement(), new MeleeAttack()) {}\n}\n\npublic class Ranger : Character\n{\n    public Ranger() : base(\"Ranger\", new WalkMovement(), new MeleeAttack()) {}\n}\n\npublic class GameContext\n{\n    private ICharacter character;\n\n    public GameContext(ICharacter character)\n    {\n        this.character = character;\n    }\n\n    public void SetCharacter(ICharacter newCharacter)\n    {\n        character = newCharacter;\n    }\n\n    public void Move()\n    {\n        character.PerformMove();\n    }\n\n    public void Attack()\n    {\n        character.PerformAttack();\n    }\n\n    public void Display()\n    {\n        character.DisplayRole();\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":14744707792,\"explanation\":\"The `ICharacter` interface forces all character types to implement both movement and attack methods, which may not be applicable for all character types. This violates the Interface Segregation Principle (ISP). The refactoring maintains the same interface but ensures that character types can implement only the methods relevant to them, allowing for more flexibility and adherence to ISP.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The `ICharacter` interface forces all character types to implement both movement and attack methods, which may not be applicable for all character types. This violates the Interface Segregation Principle (ISP). The refactoring maintains the same interface but ensures that character types can implement only the methods relevant to them, allowing for more flexibility and adherence to ISP."
        },
        {
            "input": "using System;\n\npublic interface IFoodCooking\n{\n    void CookBreakfast();\n    void CookLunch();\n    void CookDinner();\n}\n\npublic interface IBeverageService\n{\n    void PrepareDrinks();\n}\n\npublic interface IDessertService\n{\n    void PrepareDessert();\n}\n\npublic interface ITableService\n{\n    void ServeFood();\n    void CleanTable();\n}\n\npublic interface IInventoryManager\n{\n    void ManageInventory();\n}\n\npublic class Chef : IFoodCooking\n{\n    public void CookBreakfast()\n    {\n        Console.WriteLine(\"Chef is cooking breakfast.\");\n    }\n\n    public void CookLunch()\n    {\n        Console.WriteLine(\"Chef is cooking lunch.\");\n    }\n\n    public void CookDinner()\n    {\n        Console.WriteLine(\"Chef is cooking dinner.\");\n    }\n}\n\npublic class Waiter : ITableService\n{\n    public void ServeFood()\n    {\n        Console.WriteLine(\"Waiter is serving food.\");\n    }\n\n    public void CleanTable()\n    {\n        Console.WriteLine(\"Waiter is cleaning the table.\");\n    }\n}\n\npublic class BeverageService : IBeverageService\n{\n    public void PrepareDrinks()\n    {\n        Console.WriteLine(\"Beverage service is preparing drinks.\");\n    }\n}\n\npublic class DessertService : IDessertService\n{\n    public void PrepareDessert()\n    {\n        Console.WriteLine(\"Dessert service is preparing dessert.\");\n    }\n}\n\npublic class InventoryManager : IInventoryManager\n{\n    public void ManageInventory()\n    {\n        Console.WriteLine(\"Inventory manager is managing kitchen inventory.\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":8599722958,\"explanation\":\"The original `IFoodCooking` interface forced the implementation of multiple cooking methods in a single interface, violating the Interface Segregation Principle (ISP). The refactored code separates the cooking methods into distinct interfaces, allowing classes to implement only the methods they need.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The original `IFoodCooking` interface forced the implementation of multiple cooking methods in a single interface, violating the Interface Segregation Principle (ISP). The refactored code separates the cooking methods into distinct interfaces, allowing classes to implement only the methods they need."
        },
        {
            "input": "public interface IShapeOneD\n{\n    double CalculatePerimeter();\n}\n\npublic interface IShapeTwoD\n{\n    double CalculateArea();\n    double CalculatePerimeter();\n}\n\npublic interface IShapeThreeD\n{\n    double CalculateVolume();\n}\n\npublic class Circle : IShapeTwoD\n{\n    private double radius;\n\n    public Circle(double radius)\n    {\n        this.radius = radius;\n    }\n\n    public double CalculateArea()\n    {\n        return Math.PI  radius  radius;\n    }\n\n    public double CalculatePerimeter()\n    {\n        return 2  Math.PI  radius;\n    }\n}\n\npublic class Rectangle : IShapeTwoD\n{\n    private double width;\n    private double height;\n\n    public Rectangle(double width, double height)\n    {\n        this.width = width;\n        this.height = height;\n    }\n\n    public double CalculateArea()\n    {\n        return width  height;\n    }\n\n    public double CalculatePerimeter()\n    {\n        return 2  (width + height);\n    }\n}\n\npublic class Line : IShapeOneD\n{\n    private double length;\n\n    public Line(double length)\n    {\n        this.length = length;\n    }\n\n    public double CalculatePerimeter()\n    {\n        return length;\n    }\n}\n\npublic class Cube : IShapeThreeD\n{\n    private double side;\n\n    public Cube(double side)\n    {\n        this.side = side;\n    }\n\n    public double CalculateVolume()\n    {\n        return side  side  side;\n    }\n}\n\npublic class CubeWithArea : IShapeTwoD, IShapeThreeD\n{\n    private double side;\n\n    public CubeWithArea(double side)\n    {\n        this.side = side;\n    }\n\n    public double CalculateArea()\n    {\n        return 6  side  side;\n    }\n\n    public double CalculatePerimeter()\n    {\n        return 12  side;\n    }\n\n    public double CalculateVolume()\n    {\n        return side  side  side;\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":13619247792,\"explanation\":\"The `CubeWithArea` class implements both `IShapeTwoD` and `IShapeThreeD`, which violates the Interface Segregation Principle (ISP) as it forces the class to implement methods that are not relevant to its primary purpose. The refactoring maintains separate interfaces for one-dimensional, two-dimensional, and three-dimensional shapes, ensuring that classes only implement the methods they need.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The `CubeWithArea` class implements both `IShapeTwoD` and `IShapeThreeD`, which violates the Interface Segregation Principle (ISP) as it forces the class to implement methods that are not relevant to its primary purpose. The refactoring maintains separate interfaces for one-dimensional, two-dimensional, and three-dimensional shapes, ensuring that classes only implement the methods they need."
        },
        {
            "input": "using System;\n\ninterface IDevice\n{\n    string GetDeviceName();\n    void DisplayInfo();\n}\n\ninterface IConnectable\n{\n    void Connect();\n    void Disconnect();\n}\n\ninterface IDataTransferable\n{\n    void TransferData(string data);\n}\n\ninterface IDiagnosable\n{\n    void RunDiagnostics();\n}\n\ninterface IUpdatable\n{\n    void UpdateFirmware(string version);\n}\n\ninterface IMediaPlayable\n{\n    void Play();\n    void Stop();\n}\n\ninterface IVolumeAdjustable\n{\n    void SetVolume(int level);\n}\n\ninterface IPowerControllable\n{\n    void PowerOn();\n    void PowerOff();\n}\n\ninterface IScreenResolutionAdjustable\n{\n    void SetScreenResolution(string resolution);\n}\n\nabstract class DeviceBase : IDevice\n{\n    protected string name;\n    public DeviceBase(string name)\n    {\n        this.name = name;\n    }\n    public string GetDeviceName() => name;\n    public abstract void DisplayInfo();\n}\n\nclass Router : DeviceBase, IConnectable, IDataTransferable, IDiagnosable, IUpdatable\n{\n    private string ipAddress;\n\n    public Router(string name, string ipAddress) : base(name)\n    {\n        this.ipAddress = ipAddress;\n    }\n\n    public void Connect() => Console.WriteLine($\"Router {name} established connection.\");\n    public void Disconnect() => Console.WriteLine($\"Router {name} disconnected.\");\n    public void TransferData(string data) => Console.WriteLine($\"Router transferring data: {data}\");\n    public void RunDiagnostics() => Console.WriteLine($\"Running diagnostics on router {name}\");\n    public void UpdateFirmware(string version) => Console.WriteLine($\"Router firmware updated to version: {version}\");\n    public override void DisplayInfo() => Console.WriteLine($\"Router: {name}, IP: {ipAddress}\");\n}\n\nclass NetworkSwitch : DeviceBase, IConnectable, IDataTransferable, IDiagnosable, IUpdatable\n{\n    private string ipAddress;\n\n    public NetworkSwitch(string name, string ipAddress) : base(name)\n    {\n        this.ipAddress = ipAddress;\n    }\n\n    public void Connect() => Console.WriteLine($\"Switch {name} established connection.\");\n    public void Disconnect() => Console.WriteLine($\"Switch {name} disconnected.\");\n    public void TransferData(string data) => Console.WriteLine($\"Switch transferring data: {data}\");\n    public void RunDiagnostics() => Console.WriteLine($\"Running diagnostics on switch {name}\");\n    public void UpdateFirmware(string version) => Console.WriteLine($\"Switch firmware updated to version: {version}\");\n    public override void DisplayInfo() => Console.WriteLine($\"Network Switch: {name}, IP: {ipAddress}\");\n}\n\nclass SmartTV : DeviceBase, IPowerControllable, IMediaPlayable, IVolumeAdjustable, IScreenResolutionAdjustable\n{\n    private string location;\n\n    public SmartTV(string name, string location) : base(name)\n    {\n        this.location = location;\n    }\n\n    public void PowerOn() => Console.WriteLine($\"{name} TV powered on.\");\n    public void PowerOff() => Console.WriteLine($\"{name} TV powered off.\");\n    public void Play() => Console.WriteLine($\"{name} TV playing content.\");\n    public void Stop() => Console.WriteLine($\"{name} TV stopped playback.\");\n    public void SetVolume(int level) => Console.WriteLine($\"{name} TV volume set to {level}\");\n    public void SetScreenResolution(string resolution) => Console.WriteLine($\"{name} TV resolution set to {resolution}\");\n    public override void DisplayInfo() => Console.WriteLine($\"Smart TV: {name}, Location: {location}\");\n}\n\nclass SmartSpeaker : DeviceBase, IPowerControllable, IMediaPlayable, IVolumeAdjustable\n{\n    private string location;\n\n    public SmartSpeaker(string name, string location) : base(name)\n    {\n        this.location = location;\n    }\n\n    public void PowerOn() => Console.WriteLine($\"{name} speaker powered on.\");\n    public void PowerOff() => Console.WriteLine($\"{name} speaker powered off.\");\n    public void Play() => Console.WriteLine($\"{name} speaker playing audio.\");\n    public void Stop() => Console.WriteLine($\"{name} speaker stopped playback.\");\n    public void SetVolume(int level) => Console.WriteLine($\"{name} speaker volume set to {level}\");\n    public override void DisplayInfo() => Console.WriteLine($\"Smart Speaker: {name}, Location: {location}\");\n}\n\nclass DeviceManager\n{\n    public void ConfigureDevice(IDevice device)\n    {\n        device.DisplayInfo();\n        if (device is IPowerControllable pc) pc.PowerOn();\n        if (device is IConnectable c) c.Connect();\n    }\n\n    public void UpdateFirmware(IUpdatable device)\n    {\n        Console.WriteLine($\"Updating firmware for {device.GetDeviceName()}\");\n        device.UpdateFirmware(\"v2.4.1\");\n    }\n\n    public void PlayMedia(IMediaPlayable device)\n    {\n        Console.WriteLine($\"Playing media on {device.GetDeviceName()}\");\n        device.Play();\n    }\n\n    public void AdjustVolume(IVolumeAdjustable device, int level)\n    {\n        Console.WriteLine($\"Adjusting volume on {device.GetDeviceName()}\");\n        device.SetVolume(level);\n    }\n\n    public void AdjustScreenResolution(IScreenResolutionAdjustable device, string resolution)\n    {\n        Console.WriteLine($\"Adjusting screen resolution on {device.GetDeviceName()}\");\n        device.SetScreenResolution(resolution);\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":20888267583,\"explanation\":\"The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring would involve creating smaller, more specific interfaces for each type of device functionality, allowing classes to implement only the interfaces they need.\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring would involve creating smaller, more specific interfaces for each type of device functionality, allowing classes to implement only the interfaces they need."
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\n\ninterface IUIElement\n{\n    void Render();\n    void SetVisible(bool visible);\n}\n\ninterface IPositionable\n{\n    void Resize(int width, int height);\n}\n\ninterface IColorable\n{\n    void SetBackground(string color);\n    void SetForeground(string color);\n}\n\ninterface IClickable\n{\n    void OnClick(int x, int y);\n}\n\ninterface IHoverable\n{\n    void OnHover(int x, int y);\n}\n\ninterface IKeyboardInteractive\n{\n    void OnKeyPress(int keyCode);\n}\n\ninterface IFocusable\n{\n    void OnFocus();\n    void OnBlur();\n}\n\ninterface IContainer\n{\n    void AddChild(IUIElement child);\n    void RemoveChild(IUIElement child);\n    IUIElement GetParent();\n}\n\ninterface ITextStyleable\n{\n    void SetFont(string fontName, int size);\n    void SetTextAlignment(string alignment);\n}\n\ninterface ILayoutStyleable\n{\n    void SetMargin(int top, int right, int bottom, int left);\n    void SetPadding(int top, int right, int bottom, int left);\n}\n\ninterface IFadeable\n{\n    void FadeIn(int durationMs);\n    void FadeOut(int durationMs);\n}\n\nabstract class UIElementBase : IUIElement\n{\n    public abstract void Render();\n    public abstract void SetVisible(bool visible);\n}\n\nclass Button : UIElementBase, IPositionable, IColorable, IClickable, IHoverable\n{\n    private string label;\n    private int x, y, width, height;\n    private string backgroundColor;\n    private string foregroundColor;\n    \n    public Button(string label, int x, int y, int width, int height)\n    {\n        this.label = label;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.backgroundColor = \"#CCCCCC\";\n        this.foregroundColor = \"#000000\";\n    }\n    \n    public override void Render()\n    {\n        Console.WriteLine(\"Rendering button: \" + label);\n    }\n    \n    public override void SetVisible(bool visible)\n    {\n        Console.WriteLine(\"Button visibility set to: \" + visible);\n    }\n    \n    public void Resize(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n        Console.WriteLine(\"Button resized to: \" + width + \"x\" + height);\n    }\n    \n    public void SetBackground(string color)\n    {\n        this.backgroundColor = color;\n        Console.WriteLine(\"Button background set to: \" + color);\n    }\n    \n    public void SetForeground(string color)\n    {\n        this.foregroundColor = color;\n        Console.WriteLine(\"Button foreground set to: \" + color);\n    }\n    \n    public void OnClick(int x, int y)\n    {\n        Console.WriteLine(\"Button clicked: \" + label);\n    }\n    \n    public void OnHover(int x, int y)\n    {\n        Console.WriteLine(\"Hover over button: \" + label);\n    }\n}\n\nclass TextField : UIElementBase, IPositionable, IKeyboardInteractive, IFocusable, ITextStyleable\n{\n    private string text;\n    private int x, y, width, height;\n    private bool focused;\n    private string fontName;\n    private int fontSize;\n    private string textAlignment;\n    \n    public TextField(string initialText, int x, int y, int width, int height)\n    {\n        this.text = initialText;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.focused = false;\n        this.fontName = \"Arial\";\n        this.fontSize = 12;\n        this.textAlignment = \"left\";\n    }\n    \n    public override void Render()\n    {\n        Console.WriteLine(\"Rendering text field: \" + text);\n    }\n    \n    public override void SetVisible(bool visible)\n    {\n        Console.WriteLine(\"TextField visibility set to: \" + visible);\n    }\n    \n    public void Resize(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n        Console.WriteLine(\"TextField resized to: \" + width + \"x\" + height);\n    }\n    \n    public void OnKeyPress(int keyCode)\n    {\n        Console.WriteLine(\"Key pressed in text field: \" + keyCode);\n        // Handle text input\n    }\n    \n    public void OnFocus()\n    {\n        this.focused = true;\n        Console.WriteLine(\"Text field focused\");\n    }\n    \n    public void OnBlur()\n    {\n        this.focused = false;\n        Console.WriteLine(\"Text field lost focus\");\n    }\n    \n    public void SetFont(string fontName, int size)\n    {\n        this.fontName = fontName;\n        this.fontSize = size;\n        Console.WriteLine(\"TextField font set to: \" + fontName + \", size: \" + size);\n    }\n    \n    public void SetTextAlignment(string alignment)\n    {\n        this.textAlignment = alignment;\n        Console.WriteLine(\"TextField alignment set to: \" + alignment);\n    }\n}\n\nclass Image : UIElementBase, IPositionable, IFadeable\n{\n    private string imagePath;\n    private int x, y, width, height;\n    \n    public Image(string imagePath, int x, int y, int width, int height)\n    {\n        this.imagePath = imagePath;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    \n    public override void Render()\n    {\n        Console.WriteLine(\"Rendering image from: \" + imagePath);\n    }\n    \n    public override void SetVisible(bool visible)\n    {\n        Console.WriteLine(\"Image visibility set to: \" + visible);\n    }\n    \n    public void Resize(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n        Console.WriteLine(\"Image resized to: \" + width + \"x\" + height);\n    }\n    \n    public void FadeIn(int durationMs)\n    {\n        Console.WriteLine(\"Fading in image over \" + durationMs + \"ms\");\n    }\n    \n    public void FadeOut(int durationMs)\n    {\n        Console.WriteLine(\"Fading out image over \" + durationMs + \"ms\");\n    }\n}\n\nclass Panel : UIElementBase, IPositionable, IContainer, ILayoutStyleable\n{\n    private List<IUIElement> children = new List<IUIElement>();\n    private IUIElement parent;\n    private int x, y, width, height;\n    private int[] margins = {0, 0, 0, 0};\n    private int[] paddings = {0, 0, 0, 0};\n    \n    public Panel(int x, int y, int width, int height)\n    {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    \n    public override void Render()\n    {\n        Console.WriteLine(\"Rendering panel\");\n        foreach (IUIElement child in children)\n        {\n            child.Render();\n        }\n    }\n    \n    public override void SetVisible(bool visible)\n    {\n        Console.WriteLine(\"Panel visibility set to: \" + visible);\n    }\n    \n    public void Resize(int width, int height)\n    {\n        this.width = width;\n        this.height = height;\n        Console.WriteLine(\"Panel resized to: \" + width + \"x\" + height);\n    }\n    \n    public void AddChild(IUIElement child)\n    {\n        children.Add(child);\n        Console.WriteLine(\"Child added to panel\");\n    }\n    \n    public void RemoveChild(IUIElement child)\n    {\n        children.Remove(child);\n        Console.WriteLine(\"Child removed from panel\");\n    }\n    \n    public IUIElement GetParent()\n    {\n        return parent;\n    }\n    \n    public void SetMargin(int top, int right, int bottom, int left)\n    {\n        this.margins = new int[]{top, right, bottom, left};\n        Console.WriteLine(\"Panel margins set\");\n    }\n    \n    public void SetPadding(int top, int right, int bottom, int left)\n    {\n        this.paddings = new int[]{top, right, bottom, left};\n        Console.WriteLine(\"Panel padding set\");\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":31128457583,\"explanation\":\"The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring separates the interfaces into smaller, more specific ones, allowing classes to implement only the methods they need.\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The interfaces are too large and force classes to implement methods that are not relevant to them, violating the Interface Segregation Principle (ISP). The refactoring separates the interfaces into smaller, more specific ones, allowing classes to implement only the methods they need."
        },
        {
            "input": "using System;\n\ninterface IMessageService<T>\n{\n    void SendMessage(T message);\n    void ReceiveMessage(T message);\n}\n\nclass EmailMessage\n{\n    public string Recipient { get; set; }\n    public string Subject { get; set; }\n    public string Body { get; set; }\n}\n\nclass SMSMessage\n{\n    public string PhoneNumber { get; set; }\n    public string Message { get; set; }\n}\n\nclass PushNotificationMessage\n{\n    public string DeviceId { get; set; }\n    public string Title { get; set; }\n    public string Message { get; set; }\n}\n\nclass SlackMessage\n{\n    public string Channel { get; set; }\n    public string Sender { get; set; }\n    public string Message { get; set; }\n}\n\nclass EmailService : IMessageService<EmailMessage>\n{\n    public void SendMessage(EmailMessage message)\n    {\n        Console.WriteLine(\"Sending email to \" + message.Recipient + \" with subject: \" + message.Subject);\n    }\n\n    public void ReceiveMessage(EmailMessage message)\n    {\n        Console.WriteLine(\"Received email from \" + message.Sender + \" with subject: \" + message.Subject);\n    }\n}\n\nclass SMSService : IMessageService<SMSMessage>\n{\n    public void SendMessage(SMSMessage message)\n    {\n        Console.WriteLine(\"Sending SMS to \" + message.PhoneNumber + \": \" + message.Message);\n    }\n\n    public void ReceiveMessage(SMSMessage message)\n    {\n        Console.WriteLine(\"Received SMS from \" + message.Sender + \": \" + message.Message);\n    }\n}\n\nclass SlackService : IMessageService<SlackMessage>\n{\n    public void SendMessage(SlackMessage message)\n    {\n        Console.WriteLine(\"Sending Slack message to channel \" + message.Channel + \": \" + message.Message);\n    }\n\n    public void ReceiveMessage(SlackMessage message)\n    {\n        Console.WriteLine(\"Received Slack message from \" + message.Sender + \": \" + message.Message);\n    }\n}\n\nclass PushNotificationService : IMessageService<PushNotificationMessage>\n{\n    public void SendMessage(PushNotificationMessage message)\n    {\n        Console.WriteLine(\"Sending push notification to device \" + message.DeviceId + \": \" + message.Title);\n    }\n\n    public void ReceiveMessage(PushNotificationMessage message)\n    {\n        Console.WriteLine(\"Received push notification from app \" + message.AppId + \": \" + message.Title);\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4094958292,\"explanation\":\"The original `IMessageService` interface forced implementations to define both `SendMessage` and `ReceiveMessage`, which may not be applicable for all message types. The refactored code separates the sending functionality into its own interface, adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The original `IMessageService` interface forced implementations to define both `SendMessage` and `ReceiveMessage`, which may not be applicable for all message types. The refactored code separates the sending functionality into its own interface, adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\npublic interface IFlightSearchable\n{\n    List<Flight> SearchAvailableFlights(string origin, string destination, DateTime date);\n}\n\npublic interface IFlightManageable\n{\n    void AddFlight(Flight flight);\n    void UpdateFlightStatus(string flightNumber, FlightStatus status);\n}\n\npublic interface IBookingCreator\n{\n    Booking CreateBooking(string passengerId, string flightNumber);\n    void CancelBooking(string bookingId);\n    Booking GetBookingDetails(string bookingId);\n}\n\npublic interface IPaymentProcessor\n{\n    bool ProcessPayment(string bookingId, PaymentMethod method, double amount);\n    bool RefundPayment(string bookingId);\n}\n\npublic interface IEmailNotifier\n{\n    void SendBookingConfirmation(string bookingId, string email);\n    void SendCancellationNotice(string bookingId, string email);\n}\n\npublic class CustomerBookingSystem : IFlightSearchable, IBookingCreator, IPaymentProcessor\n{\n    private Dictionary<string, Flight> flights = new Dictionary<string, Flight>();\n    private Dictionary<string, Booking> bookings = new Dictionary<string, Booking>();\n    private IEmailNotifier emailNotifier;\n\n    public CustomerBookingSystem(IEmailNotifier emailNotifier)\n    {\n        this.emailNotifier = emailNotifier;\n    }\n\n    public void SetFlightsForDemo(params Flight[] flightsToAdd)\n    {\n        foreach (Flight flight in flightsToAdd)\n        {\n            flights[flight.GetFlightNumber()] = flight;\n        }\n    }\n\n    public List<Flight> SearchAvailableFlights(string origin, string destination, DateTime date)\n    {\n        List<Flight> availableFlights = new List<Flight>();\n        foreach (Flight flight in flights.Values)\n        {\n            if (flight.GetOrigin().Equals(origin) && \n                flight.GetDestination().Equals(destination) &&\n                flight.GetDepartureTime().Date.Equals(date.Date))\n            {\n                availableFlights.Add(flight);\n            }\n        }\n        return availableFlights;\n    }\n\n    public Booking CreateBooking(string passengerId, string flightNumber)\n    {\n        Flight flight;\n        if (flights.TryGetValue(flightNumber, out flight))\n        {\n            string bookingId = \"B\" + DateTimeOffset.Now.ToUnixTimeMilliseconds();\n            Booking booking = new Booking(bookingId, passengerId, flightNumber);\n            bookings[bookingId] = booking;\n            emailNotifier.SendBookingConfirmation(bookingId, passengerId);\n            return booking;\n        }\n        return null;\n    }\n\n    public void CancelBooking(string bookingId)\n    {\n        bookings.Remove(bookingId);\n        emailNotifier.SendCancellationNotice(bookingId, \"passenger@example.com\");\n    }\n\n    public Booking GetBookingDetails(string bookingId)\n    {\n        Booking booking;\n        if (bookings.TryGetValue(bookingId, out booking))\n            return booking;\n        return null;\n    }\n\n    public bool ProcessPayment(string bookingId, PaymentMethod method, double amount)\n    {\n        Console.WriteLine(\"Processing payment of $\" + amount + \" for booking \" + bookingId);\n        return true;\n    }\n\n    public bool RefundPayment(string bookingId)\n    {\n        Console.WriteLine(\"Refunding payment for booking \" + bookingId);\n        return true;\n    }\n}\n\npublic class AdminFlightSystem : IFlightManageable, IFlightSearchable\n{\n    private Dictionary<string, Flight> flights = new Dictionary<string, Flight>();\n\n    public void AddFlight(Flight flight)\n    {\n        flights[flight.GetFlightNumber()] = flight;\n    }\n\n    public void UpdateFlightStatus(string flightNumber, FlightStatus status)\n    {\n        Flight flight;\n        if (flights.TryGetValue(flightNumber, out flight))\n        {\n            flight.SetStatus(status);\n        }\n    }\n\n    public List<Flight> SearchAvailableFlights(string origin, string destination, DateTime date)\n    {\n        List<Flight> availableFlights = new List<Flight>();\n        foreach (Flight flight in flights.Values)\n        {\n            if (flight.GetOrigin().Equals(origin) && \n                flight.GetDestination().Equals(destination) &&\n                flight.GetDepartureTime().Date.Equals(date.Date))\n            {\n                availableFlights.Add(flight);\n            }\n        }\n        return availableFlights;\n    }\n}\n\npublic class EmailNotificationService : IEmailNotifier\n{\n    public void SendBookingConfirmation(string bookingId, string email)\n    {\n        Console.WriteLine(\"Sending booking confirmation email for \" + bookingId + \" to \" + email);\n    }\n    \n    public void SendCancellationNotice(string bookingId, string email)\n    {\n        Console.WriteLine(\"Sending cancellation notice for \" + bookingId + \" to \" + email);\n    }\n}\n\npublic class ReportingService : IReportGenerator\n{\n    public byte[] GenerateBookingReport(string bookingId)\n    {\n        Console.WriteLine(\"Generating booking report for \" + bookingId);\n        return new byte[512];\n    }\n    \n    public Dictionary<string, int> GetBookingStatistics(DateTime start, DateTime end)\n    {\n        Console.WriteLine(\"Generating booking statistics from \" + start + \" to \" + end);\n        Dictionary<string, int> stats = new Dictionary<string, int>();\n        stats[\"totalBookings\"] = 120;\n        stats[\"cancelledBookings\"] = 15;\n        return stats;\n    }\n}\n\npublic enum FlightStatus\n{\n    SCHEDULED, BOARDING, DEPARTED, LANDED, CANCELLED, DELAYED\n}\n\npublic enum PaymentMethod\n{\n    CREDIT_CARD, DEBIT_CARD, PAYPAL\n}\n\npublic class Flight\n{\n    private string flightNumber;\n    private string origin;\n    private string destination;\n    private DateTime departureTime;\n    private DateTime arrivalTime;\n    private FlightStatus status;\n    \n    public Flight(string flightNumber, string origin, string destination, \n                 DateTime departureTime, DateTime arrivalTime)\n    {\n        this.flightNumber = flightNumber;\n        this.origin = origin;\n        this.destination = destination;\n        this.departureTime = departureTime;\n        this.arrivalTime = arrivalTime;\n        this.status = FlightStatus.SCHEDULED;\n    }\n    \n    public string GetFlightNumber() { return flightNumber; }\n    public string GetOrigin() { return origin; }\n    public string GetDestination() { return destination; }\n    public DateTime GetDepartureTime() { return departureTime; }\n    public DateTime GetArrivalTime() { return arrivalTime; }\n    public FlightStatus GetStatus() { return status; }\n    \n    public void SetStatus(FlightStatus status) { this.status = status; }\n}\n\npublic class Booking\n{\n    private string bookingId;\n    private string passengerId;\n    private string flightNumber;\n    private DateTime bookingTime;\n    \n    public Booking(string bookingId, string passengerId, string flightNumber)\n    {\n        this.bookingId = bookingId;\n        this.passengerId = passengerId;\n        this.flightNumber = flightNumber;\n        this.bookingTime = DateTime.Now;\n    }\n    \n    public string GetBookingId() { return bookingId; }\n    public string GetPassengerId() { return passengerId; }\n    public string GetFlightNumber() { return flightNumber; }\n    public DateTime GetBookingTime() { return bookingTime; }\n    \n    public override string ToString()\n    {\n        return \"Booking{\" +\n               \"bookingId='\" + bookingId + '\\'' +\n               \", passengerId='\" + passengerId + '\\'' +\n               \", flightNumber='\" + flightNumber + '\\'' +\n               \", bookingTime=\" + bookingTime.ToString(\"o\") +\n               '}';\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":29081252916,\"explanation\":\"The `CustomerBookingSystem` class implements multiple interfaces, leading to an interface segregation violation. It combines flight searching, booking creation, and payment processing, which should be separated into distinct classes to adhere to the ISP.\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The `CustomerBookingSystem` class implements multiple interfaces, leading to an interface segregation violation. It combines flight searching, booking creation, and payment processing, which should be separated into distinct classes to adhere to the ISP."
        }
    ]
}