{
    "code_examples": [
        {
            "input": "public interface Movable {\n    void move();\n}\n\npublic class Bird {\n    // Bird specific properties and methods\n}\n\nclass Ostrich extends Bird implements Movable {\n    @Override\n    public void move() {\n        System.out.println(\"Ostrich is running\");\n    }\n}\n\nclass Sparrow extends Bird implements Movable {\n    @Override\n    public void move() {\n        System.out.println(\"Sparrow is flying\");\n    }\n}\n\npublic class Main {\n    public static void makeBirdMove(Movable bird) {\n        bird.move();\n    }\n    public static void main(String[] args) {\n        makeBirdMove(new Ostrich());\n        makeBirdMove(new Sparrow());\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":3038600959,\"explanation\":\"The original code had a potential LSP violation because the `Bird` class was not defined as abstract, which could lead to instances of `Bird` being created directly, violating the expected behavior of subclasses. By making `Bird` an abstract class, we ensure that it cannot be instantiated directly, thus adhering to LSP.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code had a potential LSP violation because the `Bird` class was not defined as abstract, which could lead to instances of `Bird` being created directly, violating the expected behavior of subclasses. By making `Bird` an abstract class, we ensure that it cannot be instantiated directly, thus adhering to LSP."
        },
        {
            "input": "public interface Shape {\n    int getArea();\n}\n\nclass Rectangle implements Shape {\n    protected int width;\n    protected int height;\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    @Override\n    public int getArea() { return width  height; }\n}\n\nclass Square implements Shape {\n    protected int side;\n    public Square(int side) {\n        this.side = side;\n    }\n    @Override\n    public int getArea() { return side  side; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape s = new Square(5);\n        System.out.println(s.getArea());\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":3036255167,\"explanation\":\"The original implementation of `Square` violated LSP because it had a separate implementation for `getArea()`, which could lead to unexpected behavior when using polymorphism. The refactored code makes `Square` extend `Rectangle`, ensuring that it adheres to the expected behavior of the `Shape` interface.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original implementation of `Square` violated LSP because it had a separate implementation for `getArea()`, which could lead to unexpected behavior when using polymorphism. The refactored code makes `Square` extend `Rectangle`, ensuring that it adheres to the expected behavior of the `Shape` interface."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2370118917,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Animal` class is responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2454655125,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the sound and potentially handling other behaviors. By separating the sound-making functionality into an interface, we adhere to SRP more closely."
        },
        {
            "input": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface PaymentStrategy {\n    void pay();\n}\n\nclass PaidPayment implements PaymentStrategy {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment implements PaymentStrategy {\n    @Override\n    public void pay() {\n        System.out.println(\"No payment needed\");\n    }\n}\n\nclass PaymentProcessor {\n    private List<PaymentStrategy> payments = new ArrayList<>();\n\n    public void addPayment(PaymentStrategy payment) {\n        payments.add(payment);\n    }\n\n    public void processPayments() {\n        for (PaymentStrategy payment : payments) {\n            payment.pay();\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        PaymentProcessor processor = new PaymentProcessor();\n        processor.addPayment(new FreePayment());\n        processor.addPayment(new PaidPayment());\n        processor.processPayments();\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "\"\"\"java\ninterface Movable {\n    void move();\n}\n\nabstract class Vehicle implements Movable {\n    // Additional properties and methods can be added here\n}\n\nclass Car extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Car is moving\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Bicycle is moving\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Movable v = new Bicycle();\n        v.move();\n    }\n}\n\"\"\"",
            "output": "{\"violation_type\":\"NONE\",\"total_duration\":2278716750,\"explanation\":\"The code adheres to the SOLID principles, with no violations present. Each class has a single responsibility, and the use of interfaces and abstract classes promotes flexibility and extensibility.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "NONE",
            "explanation": "The code adheres to the SOLID principles, with no violations present. Each class has a single responsibility, and the use of interfaces and abstract classes promotes flexibility and extensibility."
        },
        {
            "input": "```java\npublic class User {\n    private String name;\n    private String email;\n\n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n}\n\npublic class UserService {\n    public void saveUser(User user) {\n        // Code to save user to database\n    }\n}\n\npublic class EmailService {\n    public void sendEmail(String email) {\n        // Code to send email\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"John Doe\", \"john@example.com\");\n        UserService userService = new UserService();\n        userService.saveUser(user);\n        EmailService emailService = new EmailService();\n        emailService.sendEmail(user.getEmail());\n    }\n}\n```",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":4027409208,\"explanation\":\"The original code had a single `Main` class that was responsible for both user management and email sending, violating the Single Responsibility Principle (SRP). The refactored code separates concerns by keeping user management in `UserService` and email handling in `EmailService`, allowing each class to focus on a single responsibility.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had a single `Main` class that was responsible for both user management and email sending, violating the Single Responsibility Principle (SRP). The refactored code separates concerns by keeping user management in `UserService` and email handling in `EmailService`, allowing each class to focus on a single responsibility."
        },
        {
            "input": "import java.util.ArrayList;\nimport java.util.List;\n\ninterface Writer {\n    void write(String data);\n}\n\nclass FileWriter implements Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter implements Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException(\"Cannot write: Read only\");\n    }\n}\n\nclass WriterManager {\n    private List<Writer> writers = new ArrayList<>();\n\n    public void addWriter(Writer writer) {\n        writers.add(writer);\n    }\n\n    public void writeAll(String data) {\n        for (Writer writer : writers) {\n            writer.write(data);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        WriterManager manager = new WriterManager();\n        manager.addWriter(new FileWriter());\n        manager.addWriter(new ReadOnlyWriter());\n        manager.writeAll(\"Hello\");\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":2136336916,\"explanation\":\"The `ReadOnlyWriter` class previously threw an exception when the `write` method was called, violating the Liskov Substitution Principle. Now, it implements the method without throwing an exception, allowing it to be used interchangeably with other `Writer` implementations without breaking the expected behavior.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The `ReadOnlyWriter` class previously threw an exception when the `write` method was called, violating the Liskov Substitution Principle. Now, it implements the method without throwing an exception, allowing it to be used interchangeably with other `Writer` implementations without breaking the expected behavior."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":4481721583,\"explanation\":\"This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2528872542,\"explanation\":\"This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of performing division and ensuring safety, adhering to the Single Responsibility Principle. The `BasicCalculator` now only handles the division logic, while the `SafeCalculator` manages the safety checks."
        },
        {
            "input": "import java.lang.Math;\n\ninterface IShape {\n    double area();\n}\n\nabstract class Shape implements IShape {\n    public abstract double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n    public Circle(double radius) { this.radius = radius; }\n    @Override\n    public double area() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        return 0.0;\n    }\n}\n\nclass AreaCalculator {\n    public void printArea(IShape shape) {\n        double calculatedArea = shape.area();\n        System.out.println(shape.getClass().getSimpleName() + \" Area: \" + calculatedArea);\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":3646242584,\"explanation\":\"The `NullShape` class violates the Liskov Substitution Principle by returning an area of 0, which may not be a valid area for all shapes. The refactored code maintains the same behavior but ensures that the `NullShape` can be used interchangeably with other shapes without breaking the expected behavior.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The `NullShape` class violates the Liskov Substitution Principle by returning an area of 0, which may not be a valid area for all shapes. The refactored code maintains the same behavior but ensures that the `NullShape` can be used interchangeably with other shapes without breaking the expected behavior."
        },
        {
            "input": "import java.io.File;\n\ninterface FileStatusProvider {\n    String getStatus(String filePath);\n}\n\ninterface FileProcessor {\n    void processFile(String filePath);\n}\n\nclass FileProcessorImpl implements FileProcessor {\n    private final FileStatusProvider fileStatusProvider;\n\n    public FileProcessorImpl(FileStatusProvider fileStatusProvider) {\n        this.fileStatusProvider = fileStatusProvider;\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        String status = fileStatusProvider.getStatus(filePath);\n        if (status.contains(\"not found\")) {\n            System.out.println(\"FileProcessor: Error - File not found.\");\n            return;\n        }\n        System.out.println(\"FileProcessor: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileStatusProvider implements FileStatusProvider {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n}\n\nclass RealFileStatusProvider implements FileStatusProvider {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileStatusProvider readOnlyProvider = new ReadOnlyFileStatusProvider();\n        FileProcessor readOnlyProcessor = new FileProcessorImpl(readOnlyProvider);\n        readOnlyProcessor.processFile(\"path/to/read-only/file.txt\");\n\n        FileStatusProvider realProvider = new RealFileStatusProvider();\n        FileProcessor realProcessor = new FileProcessorImpl(realProvider);\n        realProcessor.processFile(\"path/to/real/file.txt\");\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":8379960542,\"explanation\":\"The `FileProcessorImpl` class was handling both file processing and status handling, violating the Single Responsibility Principle (SRP). The refactored code separates the status handling into its own method, allowing the class to focus solely on processing files.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `FileProcessorImpl` class was handling both file processing and status handling, violating the Single Responsibility Principle (SRP). The refactored code separates the status handling into its own method, allowing the class to focus solely on processing files."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2814503291,\"explanation\":\"The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1635729625,\"explanation\":\"The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original Logger class violated the Single Responsibility Principle by combining logging functionality with message counting. The refactored code separates the counting functionality into its own class, allowing each class to have a single responsibility."
        },
        {
            "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Define interfaces for different capabilities\ninterface DataLoader {\n    boolean loadData(String source);\n}\n\ninterface DataProcessor {\n    boolean processData();\n}\n\ninterface DataSaver {\n    boolean saveResults(String destination);\n}\n\n// A concrete implementation that can load, process, and save data\nclass DataProcessorImpl implements DataLoader, DataProcessor, DataSaver {\n    private Map<String, Object> data = null;\n\n    public DataProcessorImpl() {\n        System.out.println(\"DataProcessorImpl created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Processing data...\");\n        if (data == null) {\n            System.out.println(\"No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Data processed.\");\n        return true;\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        System.out.println(\"Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\n// A concrete implementation that can load and process data but not save\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessor {\n    private Map<String, Object> data = null;\n\n    public ReadOnlyDataProcessor() {\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Processing data (read-only simulation)...\");\n        if (data == null) {\n            System.out.println(\"No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Data processed (read-only).\");\n        return true;\n    }\n}\n\n// Example Usage\npublic class ComplianceDemo {\n    public static void saveProcessedData(DataSaver saver, String destination) {\n        System.out.println(\"Attempting to save using a saver...\");\n        saver.saveResults(destination);\n    }\n\n    public static void processSomeData(DataProcessor processor) {\n        System.out.println(\"Attempting to process using a processor...\");\n        processor.processData();\n    }\n\n    public static void loadSomeData(DataLoader loader) {\n        System.out.println(\"Attempting to load using a loader...\");\n        loader.loadData(\"valid_source\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"--- Demonstrating Compliance ---\");\n\n        // Instantiate classes\n        DataProcessorImpl fullProc = new DataProcessorImpl();\n        ReadOnlyDataProcessor readOnlyProc = new ReadOnlyDataProcessor();\n\n        System.out.println(\"\\nUsing DataProcessorImpl where saver is needed:\");\n        if (fullProc.loadData(\"valid_source\")) {\n            if (fullProc.processData()) {\n                saveProcessedData(fullProc, \"output_compliant.txt\");\n            }\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\");\n        // saveProcessedData(readOnlyProc, \"output_compliant.txt\"); // This line would cause a compile-time type error\n        System.out.println(\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\");\n\n        System.out.println(\"\\nUsing DataProcessorImpl where processor is needed:\");\n        if (fullProc.loadData(\"valid_source\")) {\n            processSomeData(fullProc);\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\");\n        if (readOnlyProc.loadData(\"valid_source\")) {\n            processSomeData(readOnlyProc);\n        }\n\n        System.out.println(\"\\nUsing DataProcessorImpl where loader is needed:\");\n        loadSomeData(fullProc);\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\");\n        loadSomeData(readOnlyProc);\n\n        // Clean up\n        File dummyFile = new File(\"output_compliant.txt\");\n        if (dummyFile.exists()) dummyFile.delete();\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":12719321833,\"explanation\":\"The `DataProcessorImpl` class implements all three interfaces, which violates the Interface Segregation Principle (ISP) because it forces the class to implement methods that may not be relevant for all implementations. The refactoring separates the responsibilities into distinct interfaces, allowing classes to implement only the methods they need.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "ISP",
            "explanation": "The `DataProcessorImpl` class implements all three interfaces, which violates the Interface Segregation Principle (ISP) because it forces the class to implement methods that may not be relevant for all implementations. The refactoring separates the responsibilities into distinct interfaces, allowing classes to implement only the methods they need."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":4429818792,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1620889458,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `Bird` class is responsible for both movement and sound. The refactored code separates the responsibilities into distinct classes: `Bird` for movement and `BirdSound` for sound, ensuring each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3083127042,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Shape` class is not responsible for calculating the area of different shapes. Each shape class now has a single responsibility: to calculate its own area.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2544107500,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Shape` class was responsible for both defining a shape and calculating the area. Now, each shape class (e.g., `Circle`, `Rectangle`) has a single responsibility: to calculate its own area.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Shape` class was responsible for both defining a shape and calculating the area. Now, each shape class (e.g., `Circle`, `Rectangle`) has a single responsibility: to calculate its own area."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2700943333,\"explanation\":\"This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2135687875,\"explanation\":\"This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibility of moving animals into its own class, adhering to the Single Responsibility Principle. The `Animal` classes now only focus on their movement behavior, while the `AnimalMover` class handles the logic of moving multiple animals."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2469172542,\"explanation\":\"The original code violates the Single Responsibility Principle because the `FileHandler` class is responsible for both reading and writing files, which are two distinct responsibilities. By separating the reading and writing functionalities into their own classes, we adhere to SRP.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2383244584,\"explanation\":\"The original `FileHandler` class was responsible for both reading and writing files, which are two distinct responsibilities. By separating these functionalities into `FileReader` and `FileWriter`, we adhere to the Single Responsibility Principle (SRP).\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original `FileHandler` class was responsible for both reading and writing files, which are two distinct responsibilities. By separating these functionalities into `FileReader` and `FileWriter`, we adhere to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor:\n    def process_payment(self):\n        print('Processed free payment')\n\nclass Payment:\n    def __init__(self, amount=0):\n        self.amount = amount\n\nclass PaymentFactory:\n    @staticmethod\n    def create_payment(payment_type, amount=0):\n        if payment_type == 'free':\n            return FreePaymentProcessor()\n        else:\n            return PaymentProcessor()",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":2705308166,\"explanation\":\"The original code used `if-else` statements in the `PaymentFactory` to determine which payment processor to create, violating the Open/Closed Principle. The refactored code allows for new payment processors to be added without modifying the factory, adhering to OCP.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used `if-else` statements in the `PaymentFactory` to determine which payment processor to create, violating the Open/Closed Principle. The refactored code allows for new payment processors to be added without modifying the factory, adhering to OCP."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1733431500,\"explanation\":\"This code violates the Single Responsibility Principle because the `Document` and `SecureDocument` classes are responsible for both the content and the display logic, which should be separated.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3167811125,\"explanation\":\"The refactoring separates the responsibilities of content management and display logic into different classes, adhering to the Single Responsibility Principle (SRP). The `Document` class now only handles content, while `DocumentDisplay` is responsible for displaying the content.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The refactoring separates the responsibilities of content management and display logic into different classes, adhering to the Single Responsibility Principle (SRP). The `Document` class now only handles content, while `DocumentDisplay` is responsible for displaying the content."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2088939583,\"explanation\":\"The original code violates the Single Responsibility Principle because the `VehicleMover` class is responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2272183416,\"explanation\":\"The original code violated the Single Responsibility Principle because the `VehicleMover` class was responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `VehicleMover` class was responsible for both moving vehicles and defining vehicle types. By separating the vehicle types into their own classes, we ensure that each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1522838416,\"explanation\":\"This class violates the Single Responsibility Principle because it handles both user information and email sending, which are two distinct responsibilities.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2617212666,\"explanation\":\"This refactoring separates the responsibilities of managing user information and sending emails into two distinct classes, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of managing user information and sending emails into two distinct classes, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "import abc\nimport os\nimport time\n\n# Define ABCs for different capabilities\nclass DataLoader(abc.ABC):\n    @abc.abstractmethod\n    def load_data(self, source):\n        pass\n\nclass DataProcessor(abc.ABC):\n    @abc.abstractmethod\n    def process_data(self):\n        pass\n\nclass DataSaver(abc.ABC):\n    @abc.abstractmethod\n    def save_results(self, destination):\n        pass\n\n# A concrete implementation that can do all three\nclass FullDataProcessor(DataLoader, DataProcessor, DataSaver):\n    def __init__(self):\n        self._data = None\n        print(\"FullDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"Full: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Full: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Full: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"Full: Processing data...\")\n        if self._data is None:\n            print(\"Full: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing\n        self._data[\"processed\"] = True\n        print(\"Full: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        print(f\"Full: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Full: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        # Simulate saving\n        print(f\"Full: Results saved to {destination}.\")\n        return True\n\n# A concrete implementation that can load and process (read-only concept)\nclass ReadOnlyDataProcessor(DataLoader, DataProcessor):\n    def __init__(self):\n        self._data = None # Manage its own state\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"ReadOnly: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"ReadOnly: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"ReadOnly: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"ReadOnly: Processing data (read-only simulation)...\")\n        if self._data is None:\n            print(\"ReadOnly: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing without making it 'savable'\n        print(\"ReadOnly: Data processed (read-only).\")\n        return True\n\n# Example Usage (LSP Compliant - requires specific capabilities):\ndef demonstrate_compliance():\n    print(\"--- Demonstrating Compliance ---\")\n\n    # A function requiring saving capability MUST ask for DataSaver (or FullDataProcessor)\n    def save_processed_data(saver: DataSaver, destination):\n         # This function knows it can save\n         print(\"Attempting to save using a saver...\")\n         saver.save_results(destination) # This call is guaranteed to exist (though might fail for other reasons like disk full)\n\n    # A function requiring only processing capability can ask for DataProcessor\n    def process_some_data(processor: DataProcessor):\n         # This function knows it can process\n         print(\"Attempting to process using a processor...\")\n         processor.process_data() # This call is guaranteed to exist\n\n    # A function requiring only loading capability can ask for DataLoader\n    def load_some_data(loader: DataLoader):\n         # This function knows it can load\n         print(\"Attempting to load using a loader...\")\n         loader.load_data(\"valid_source\") # This call is guaranteed to exist\n\n    # Instantiate classes\n    full_proc = FullDataProcessor()\n    read_only_proc = ReadOnlyDataProcessor()\n\n    print(\"\\nUsing FullDataProcessor where saver is needed:\")\n    # Need to load/process first if save logic requires state\n    if full_proc.load_data(\"valid_source\"): full_proc.process_data()\n    save_processed_data(full_proc, \"output_compliant.txt\") # Works (FullDataProcessor implements DataSaver)\n\n    print(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\")\n    # save_processed_data(read_only_proc, \"output_compliant.txt\") # This line would cause a TypeError\n    print(\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\")\n\n    print(\"\\nUsing FullDataProcessor where processor is needed:\")\n    # Need to load first if process logic requires state\n    if full_proc.load_data(\"valid_source\"): process_some_data(full_proc) # Works (FullDataProcessor implements DataProcessor)\n\n    print(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\")\n    # Need to load first if process logic requires state\n    if read_only_proc.load_data(\"valid_source\"): process_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataProcessor)\n\n    print(\"\\nUsing FullDataProcessor where loader is needed:\")\n    load_some_data(full_proc) # Works (FullDataProcessor implements DataLoader)\n\n    print(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\")\n    load_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataLoader)\n\n    # Clean up\n    if os.path.exists(\"output_compliant.txt\"): os.remove(\"output_compliant.txt\")\n\ndemonstrate_compliance()",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":18996784583,\"explanation\":\"The `FullDataProcessor` class implements multiple interfaces (DataLoader, DataProcessor, DataSaver), which violates the Interface Segregation Principle (ISP) because it forces clients to depend on methods they do not use (like save_results in ReadOnlyDataProcessor). The refactoring separates the responsibilities into distinct classes, ensuring that clients only need to implement the methods they require.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The `FullDataProcessor` class implements multiple interfaces (DataLoader, DataProcessor, DataSaver), which violates the Interface Segregation Principle (ISP) because it forces clients to depend on methods they do not use (like save_results in ReadOnlyDataProcessor). The refactoring separates the responsibilities into distinct classes, ensuring that clients only need to implement the methods they require."
        },
        {
            "input": "import abc\n\n# Define an ABC for the core logging capability\nclass SimpleLogger(abc.ABC):\n    @abc.abstractmethod\n    def log(self, message):\n        pass\n\n# An implementation that logs and also tracks a count\nclass CountingLogger(SimpleLogger):\n    def __init__(self):\n        self._messages_logged = 0\n\n    def log(self, message):\n        print(f\"[COUNTING LOG] {message}\")\n        self._messages_logged += 1\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n# An implementation that simply logs (or does nothing)\nclass SilentLogger(SimpleLogger):\n    def log(self, message):\n        pass",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2783441208,\"explanation\":\"The `CountingLogger` class previously handled both logging and counting messages, violating the Single Responsibility Principle (SRP). Now, the logging functionality is separated into `SimpleMessageLogger`, allowing each class to have a single responsibility.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The `CountingLogger` class previously handled both logging and counting messages, violating the Single Responsibility Principle (SRP). Now, the logging functionality is separated into `SimpleMessageLogger`, allowing each class to have a single responsibility."
        },
        {
            "input": "import abc\nimport os\n\n# Represents a component that can provide the status of a file\nclass FileStatusProvider(abc.ABC):\n    @abc.abstractmethod\n    def get_status(self, file_path):\n        pass\n\n# Represents a component that can process files\nclass FileProcessor(abc.ABC):\n    @abc.abstractmethod\n    def process_file(self, file_path):\n        pass\n\n# A concrete implementation of a processor\nclass RealFileProcessor(FileProcessor):\n    def process_file(self, file_path):\n        print(f\"RealProcessor: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"RealProcessor: Error - File {file_path} not found for processing.\")\n            return\n        # Simulate processing...\n        print(f\"RealProcessor: File {file_path} processed successfully.\")\n\n# A concrete implementation of a status provider\nclass RealFileStatusProvider(FileStatusProvider):\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Ready for processing\" if file_exists else \"File not found\"\n        print(f\"RealStatusProvider: Checking status for {file_path} - {status}.\")\n        return status\n\n# Represents a component that can only check file status (read-only)\nclass ReadOnlyFileStatusProvider(FileStatusProvider):\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Available (Read-only)\" if file_exists else \"File not found (Read-only)\"\n        print(f\"ReadOnlyStatusProvider: Checking status for {file_path} - {status}.\")\n        return status\n\n# Example Usage:\n# import os\n\ntest_file_path = \"dummy_refactored.txt\"\nwith open(test_file_path, \"w\") as f: f.write(\"Some content\") # Create a dummy file\n\n# When you need processing capability, you must use FileProcessor:\nprocessor: FileProcessor = RealFileProcessor() # Substitutes for FileProcessor\nprocessor.process_file(test_file_path)     # RealProcessor: ... processed successfully.\n\nprint(\"---\")\n\n# When you only need status capability, you can use FileStatusProvider:\nstatus_provider1: FileStatusProvider = RealFileStatusProvider() # Substitutes for FileStatusProvider\nprint(status_provider1.get_status(test_file_path)) # RealStatusProvider: ... Ready.\n\nstatus_provider2: FileStatusProvider = ReadOnlyFileStatusProvider() # LSP compliant substitution\nprint(status_provider2.get_status(test_file_path)) # ReadOnlyStatusProvider: ... Available (Read-only)\n\nif os.path.exists(test_file_path): os.remove(test_file_path) # Clean up dummy file",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":9673972666,\"explanation\":\"The `FileStatusProvider` interface is too large as it forces all implementations to provide a `get_status` method, even if they may not need it. The refactoring separates the interfaces into more specific ones, allowing classes to implement only the methods they require, thus adhering to the Interface Segregation Principle (ISP).\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The `FileStatusProvider` interface is too large as it forces all implementations to provide a `get_status` method, even if they may not need it. The refactoring separates the interfaces into more specific ones, allowing classes to implement only the methods they require, thus adhering to the Interface Segregation Principle (ISP)."
        },
        {
            "input": "import abc\nimport math\n\n# Define an ABC for shapes that can provide an area.\nclass IShape(abc.ABC):\n    @abc.abstractmethod\n    def area(self) -> float:\n        pass\n\n# A standard shape implementation (like a circle)\nclass Circle(IShape):\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    def area(self) -> float:\n        calculated_area = math.pi  self.radius  self.radius\n        return calculated_area\n\n# An implementation representing a shape with no area (the \"null\" concept).\nclass NullShape(IShape):\n    def area(self) -> float:\n        return 0.0\n\n# A new class for Rectangle to demonstrate OCP compliance\nclass Rectangle(IShape):\n    def __init__(self, width: float, height: float):\n        self.width = width\n        self.height = height\n\n    def area(self) -> float:\n        return self.width  self.height\n\n# Example Usage:\nshapes = [Circle(5.0), NullShape(), Rectangle(4.0, 6.0)]\n\nfor shape in shapes:\n    print(f\"Area: {shape.area()}\")\n\n# Downstream code works correctly:\ntotal_area = sum(shape.area() for shape in shapes)\nprint(f\"Total Area: {total_area}\")\n\nif total_area >= 0.0:\n    print(\"Total area is non-negative (check passes)\")\nelse:\n    print(\"Total area is negative or NaN\")",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":7924119250,\"explanation\":\"The original code had a violation of the Open/Closed Principle (OCP) due to the use of a `NullShape` class that was not necessary for the area calculation. By refactoring, we ensured that all shape classes implement the `IShape` interface without needing to check for a null shape, thus allowing for easier extension of new shapes without modifying existing code.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code had a violation of the Open/Closed Principle (OCP) due to the use of a `NullShape` class that was not necessary for the area calculation. By refactoring, we ensured that all shape classes implement the `IShape` interface without needing to check for a null shape, thus allowing for easier extension of new shapes without modifying existing code."
        },
        {
            "input": "open class Bird {\n    open fun move() {}\n}\n\ninterface Movable {\n    fun move()\n}\n\nclass Ostrich : Movable {\n    override fun move() {\n        // Ostrich runs\n    }\n}\n\nclass Sparrow : Movable {\n    override fun move() {\n        // Sparrow flies\n    }\n}\n\nfun makeBirdMove(movable: Movable) {\n    movable.move()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdMove(ostrich)\n    val sparrow = Sparrow()\n    makeBirdMove(sparrow)\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Shape {\n    open fun area(): Int = 0\n}\n\ninterface AreaCalculable {\n    fun area(): Int\n}\n\nclass Rectangle(var width: Int, var height: Int) : Shape(), AreaCalculable {\n    override fun area(): Int = width  height\n}\n\nclass Square(size: Int) : Shape(), AreaCalculable {\n    private val side = size\n    override fun area(): Int = side  side\n}\n\nfun printArea(shape: AreaCalculable) {\n    println(shape.area())\n}\n\nfun main() {\n    val square = Square(5)\n    printArea(square)\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":4600568208,\"explanation\":\"The original code had a single function `printArea` that was limited to printing the area of one shape at a time. The refactored code allows for multiple shapes to be processed in a list, adhering to the Open/Closed Principle by enabling the addition of new shapes without modifying existing code.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code had a single function `printArea` that was limited to printing the area of one shape at a time. The refactored code allows for multiple shapes to be processed in a list, adhering to the Open/Closed Principle by enabling the addition of new shapes without modifying existing code."
        },
        {
            "input": "open class Animal {\n    open fun move() {}\n}\n\ninterface Movable {\n    fun move()\n}\n\nclass Dog : Movable {\n    override fun move() {\n        println(\"Dog runs\")\n    }\n}\n\nclass Fish : Movable {\n    override fun move() {\n        println(\"Fish swims\")\n    }\n}\n\nfun animalMove(movable: Movable) {\n    movable.move()\n}\n\nfun main() {\n    val fish = Fish()\n    animalMove(fish)\n    val dog = Dog()\n    animalMove(dog)\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"class PaymentProcessor {\\n    private val payments: List<Payment> = listOf(CashPayment(), CreditPayment())\\n\\n    fun processPayment(paymentType: String, amount: Double) {\\n        val payment = payments.find { it.javaClass.simpleName == paymentType }\\n        payment?.pay(amount) ?: throw IllegalArgumentException(\\\"Invalid payment type\\\")\\n    }\\n}\\n\\ninterface Payment {\\n    fun pay(amount: Double)\\n}\\n\\nclass CashPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount by credit card\\\")\\n    }\\n}\\n\\nfun main() {\\n    val paymentProcessor = PaymentProcessor()\\n    paymentProcessor.processPayment(\\\"CreditPayment\\\", 100.0)\\n}\",\"explanation\":\"The refactored code consolidates the payment processing logic into the `PaymentProcessor` class, which now handles the selection of payment methods based on a string identifier. This adheres to the Single Responsibility Principle (SRP) by ensuring that the `PaymentProcessor` is solely responsible for processing payments, while the individual payment classes handle their specific payment logic. This change also allows for easier extension of payment types without modifying the existing code.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":8438853792,\"explanation\":\"The refactored code separates the responsibility of selecting payment types from the `PaymentProcessor` class. Now, the `processPayment` method directly accepts a `Payment` object, adhering to the Single Responsibility Principle (SRP) by ensuring that the `PaymentProcessor` is only responsible for processing payments, while the individual payment classes handle their specific payment logic. This change simplifies the code and enhances its extensibility.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The refactored code separates the responsibility of selecting payment types from the `PaymentProcessor` class. Now, the `processPayment` method directly accepts a `Payment` object, adhering to the Single Responsibility Principle (SRP) by ensuring that the `PaymentProcessor` is only responsible for processing payments, while the individual payment classes handle their specific payment logic. This change simplifies the code and enhances its extensibility."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"refactored_code\":\"\\\"\\\"\\\"kotlin\\ninterface Writer {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ConsoleWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to console: \\$data\\\")\\n    }\\n}\\n\\nfun save(writer: Writer, data: String) {\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val writers: List<Writer> = listOf(FileWriter(), ConsoleWriter())\\n    writers.forEach { writer -> save(writer, \\\"Hello World\\\") }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code adheres to the SOLID principles fairly well, but it can be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. In the original code, if we wanted to add a new type of writer (e.g., ConsoleWriter), we would need to modify the existing code. By introducing a new class for ConsoleWriter and using a list to handle multiple writers, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP.\"}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":3403721208,\"explanation\":\"The original code adhered to the SOLID principles fairly well, but it could be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. By introducing a new class for ConsoleWriter and using a list to handle multiple writers, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code adhered to the SOLID principles fairly well, but it could be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. By introducing a new class for ConsoleWriter and using a list to handle multiple writers, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2663912125,\"explanation\":\"The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present.\"}",
            "output": "{\"violation_type\":\"NONE\",\"total_duration\":1304486583,\"explanation\":\"The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "NONE",
            "explanation": "The code adheres to the Single Responsibility Principle as each class has a single responsibility: `Car` and `Bicycle` handle their own movement, while `Vehicle` is responsible for starting the movement of any `Movable` object. There are no violations present."
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"class User(val name: String) {\\n    fun sendEmail(message: String) {\\n        println(\\\"Sending email to \\$name: \\$message\\\")\\n    }\\n\\n    fun sendSMS(message: String) {\\n        println(\\\"Sending SMS to \\$name: \\$message\\\")\\n    }\\n}\\n\\nfun main() {\\n    val user = User(\\\"John\\\")\\n    user.sendEmail(\\\"Hello via Email\\\")\\n    user.sendSMS(\\\"Hello via SMS\\\")\\n}\",\"explanation\":\"The original `User` class was responsible for both user data and sending notifications, violating the Single Responsibility Principle (SRP). By separating the notification methods into their own classes or services, we can ensure that the `User` class only handles user-related data and actions, making the code cleaner and more maintainable.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2926287833,\"explanation\":\"The original `User` class was responsible for both user data and sending notifications, violating the Single Responsibility Principle (SRP). By introducing a `NotificationService` class, we ensure that the `User` class only handles user-related data, while the `NotificationService` manages the sending of notifications, improving code organization and maintainability.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original `User` class was responsible for both user data and sending notifications, violating the Single Responsibility Principle (SRP). By introducing a `NotificationService` class, we ensure that the `User` class only handles user-related data, while the `NotificationService` manages the sending of notifications, improving code organization and maintainability."
        },
        {
            "input": "{\"violation_type\":\"Dependency Inversion Principle (DIP)\",\"refactored_code\":\"interface Printer {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass LocalPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing locally: \\$document\\\")\\n    }\\n}\\n\\nclass PrintManager(private val printer: Printer) {\\n    fun print(document: String) {\\n        printer.printDocument(document)\\n    }\\n}\\n\\nfun main() {\\n    val networkPrinter = NetworkPrinter()\\n    val localPrinter = LocalPrinter()\\n    val printManager = PrintManager(networkPrinter)\\n    printManager.print(\\\"Test over network\\\")\\n    val localPrintManager = PrintManager(localPrinter)\\n    localPrintManager.print(\\\"Test locally\\\")\\n}\",\"explanation\":\"The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable.\"}",
            "output": "{\"violation_type\":\"DIP\",\"total_duration\":5817301000,\"explanation\":\"The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "DIP",
            "explanation": "The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable."
        },
        {
            "input": "{\"violation_type\":\"Interface Segregation Principle (ISP)\",\"refactored_code\":\"interface Logger {\\n    fun log(message: String)\\n}\\n\\ninterface CountableLogger : Logger {\\n    fun getMessagesLoggedCount(): Int\\n}\\n\\nclass CountingLogger : CountableLogger {\\n    private var messagesLogged: Int = 0\\n\\n    override fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    override fun log(message: String) {\\n        println(\\\"[COUNTING LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\nclass SilentLogger : Logger {\\n    override fun log(message: String) {\\n        // No operation\\n    }\\n}\",\"explanation\":\"The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":4913716583,\"explanation\":\"The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality."
        },
        {
            "input": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\ninterface LogBuffer {\n    fun addLog(message: String)\n    fun getLogContents(): List<String>\n}\n\nclass ThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass LoggerImpl(private val logBuffer: LogBuffer) : Logger {\n    override fun log(message: String) {\n        logBuffer.addLog(message)\n        println(message)\n    }\n}\n\nfun main() {\n    val threadSafeLogger = LoggerImpl(ThreadSafeLogBuffer())\n    threadSafeLogger.log(\"This is a thread-safe log message.\")\n\n    val nonThreadSafeLogger = LoggerImpl(NonThreadSafeLogBuffer())\n    nonThreadSafeLogger.log(\"This is a non-thread-safe log message.\")\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":5584676833,\"explanation\":\"The Logger interface is not violating ISP as it has a single method. However, the LogBuffer interface could be seen as violating ISP if a class only needs one of the methods. To refactor, we could split LogBuffer into two separate interfaces: AddableLog and ReadableLog, allowing classes to implement only what they need.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "ISP",
            "explanation": "The Logger interface is not violating ISP as it has a single method. However, the LogBuffer interface could be seen as violating ISP if a class only needs one of the methods. To refactor, we could split LogBuffer into two separate interfaces: AddableLog and ReadableLog, allowing classes to implement only what they need."
        },
        {
            "input": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"\\\"\\\"\\\"kotlin\\nimport kotlin.math.PI\\n\\ninterface IShape {\\n    fun area(): Double\\n}\\n\\nclass Circle(val radius: Double) : IShape {\\n    override fun area(): Double {\\n        return PI  radius  radius\\n    }\\n}\\n\\nclass NullShape : IShape {\\n    override fun area(): Double {\\n        return 0.0\\n    }\\n}\\n\\nclass ShapeAreaPrinter(private val shape: IShape) {\\n    fun printArea() {\\n        val area = shape.area()\\n        println(\\\"Area: \\$area\\\")\\n    }\\n}\\n\\nfun main() {\\n    val circle = Circle(5.0)\\n    val nullShape = NullShape()\\n    val circlePrinter = ShapeAreaPrinter(circle)\\n    val nullShapePrinter = ShapeAreaPrinter(nullShape)\\n    circlePrinter.printArea()\\n    nullShapePrinter.printArea()\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of `IShape` can be used interchangeably without affecting the correctness of the program. The `NullShape` class is a valid implementation of the `IShape` interface, allowing it to be used in the same context as other shapes without causing errors or unexpected behavior.\"}",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":4067302583,\"explanation\":\"The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of `IShape` can be used interchangeably without affecting the correctness of the program. The `NullShape` class is a valid implementation of the `IShape` interface, allowing it to be used in the same context as other shapes without causing errors or unexpected behavior.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of `IShape` can be used interchangeably without affecting the correctness of the program. The `NullShape` class is a valid implementation of the `IShape` interface, allowing it to be used in the same context as other shapes without causing errors or unexpected behavior."
        },
        {
            "input": "class User {\n    private String name;\n    private String email;\n\n    public User(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n}\n\nclass UserService {\n    public void registerUser(User user) {\n        // Registration logic\n    }\n\n    public void sendEmail(User user) {\n        // Email sending logic\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1849126916,\"explanation\":\"The `UserService` class previously handled both user registration and email sending, violating the Single Responsibility Principle (SRP). The refactoring separates the email functionality into its own `EmailService` class, ensuring that each class has a single responsibility.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The `UserService` class previously handled both user registration and email sending, violating the Single Responsibility Principle (SRP). The refactoring separates the email functionality into its own `EmailService` class, ensuring that each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1921700750,\"explanation\":\"This refactoring separates the responsibilities of different bird types into their own classes, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2780717917,\"explanation\":\"The original code had a single class handling multiple bird types with different flying capabilities, violating the Single Responsibility Principle. The refactoring separates the flying behavior into individual classes for each bird type, ensuring that each class has a single responsibility.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had a single class handling multiple bird types with different flying capabilities, violating the Single Responsibility Principle. The refactoring separates the flying behavior into individual classes for each bird type, ensuring that each class has a single responsibility."
        },
        {
            "input": "```c#\nusing System;\n\ninterface IShape\n{\n    int Area();\n}\n\nclass Rectangle : IShape\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public int Area() => Width  Height;\n}\n\nclass Square : IShape\n{\n    public int Side { get; set; }\n    public int Area() => Side  Side;\n}\n\nclass ShapeAreaCalculator\n{\n    public static int CalculateArea(IShape shape)\n    {\n        return shape.Area();\n    }\n}\n```",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":5083824792,\"explanation\":\"The original code had a potential Liskov Substitution Principle violation because the `Square` class, while implementing the `IShape` interface, could lead to unexpected behavior if a `Rectangle` is expected to behave like a `Square` due to their differing properties. The refactored code maintains the same functionality while ensuring that both shapes adhere to the expected behavior of the `IShape` interface.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The original code had a potential Liskov Substitution Principle violation because the `Square` class, while implementing the `IShape` interface, could lead to unexpected behavior if a `Rectangle` is expected to behave like a `Square` due to their differing properties. The refactored code maintains the same functionality while ensuring that both shapes adhere to the expected behavior of the `IShape` interface."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2338784000,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Animal` class is responsible for defining the movement behavior of different animals, which can lead to a lack of clarity and separation of concerns. Each animal type should have its own implementation of movement without being tightly coupled to a single class.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2433099125,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the animal's characteristics and its movement behavior. The refactored code separates movement behavior into its own interface and classes, allowing each animal to have its own movement implementation without cluttering the `Animal` class.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Animal` class was responsible for both defining the animal's characteristics and its movement behavior. The refactored code separates movement behavior into its own interface and classes, allowing each animal to have its own movement implementation without cluttering the `Animal` class."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2623934541,\"explanation\":\"The original code violates the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2863712875,\"explanation\":\"The original code violated the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `PaymentProcessor` class was responsible for both processing payments and determining the type of payment. The refactored code separates the payment types into their own classes, allowing `PaymentProcessor` to focus solely on processing payments."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2772351292,\"explanation\":\"The original code violates the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes are both implementing the `Write` method, which leads to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2196349208,\"explanation\":\"The original code violated the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes were both implementing the `Write` method, leading to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `FileWriter` and `ReadOnlyFileWriter` classes were both implementing the `Write` method, leading to confusion about their responsibilities. By separating the writing functionality into distinct classes, each class now has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":1805129084,\"explanation\":\"This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1546762084,\"explanation\":\"This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of the Vehicle class and its subclasses, ensuring that each class has a single responsibility, thus adhering to the Single Responsibility Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2149269709,\"explanation\":\"This code violates the Single Responsibility Principle because the `DocumentPrinter` class is responsible for printing documents, while the document classes themselves are responsible for their own print logic. By separating the responsibilities into distinct classes, we adhere to SRP.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1751397250,\"explanation\":\"The `DocumentPrinter` class was previously responsible for both printing and managing document content. Now, the `Document` class solely handles the content, while `DocumentPrinter` is only responsible for printing, adhering to the Single Responsibility Principle.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The `DocumentPrinter` class was previously responsible for both printing and managing document content. Now, the `Document` class solely handles the content, while `DocumentPrinter` is only responsible for printing, adhering to the Single Responsibility Principle."
        },
        {
            "input": "using System;using System.Collections.Generic;interface ITimer { void Start(); void Stop(); }abstract class TimerBase : ITimer { public abstract void Start(); public abstract void Stop(); }class RegularTimer : TimerBase { public override void Start() { Console.WriteLine(\"Regular Timer Started\"); } public override void Stop() { Console.WriteLine(\"Regular Timer Stopped\"); }}class OneShotTimer : TimerBase { public override void Start() { Console.WriteLine(\"One Shot Timer Started\"); } public override void Stop() { Console.WriteLine(\"One Shot Timer Stopped\"); }}class TimerManager { private List<ITimer> timers = new List<ITimer>(); public void AddTimer(ITimer timer) { timers.Add(timer); } public void StartAll() { foreach (var timer in timers) { timer.Start(); } } public void StopAll() { foreach (var timer in timers) { timer.Stop(); } }}",
            "output": "NONE",
            "level": "MODERATE",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\nusing System.IO;\n\ninterface IFileStatusProvider\n{\n    string GetStatus(string filePath);\n}\n\nclass FileStatusProvider : IFileStatusProvider\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Found.\");\n            return \"Ready for status check\";\n        }\n        else\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n}\n\nclass ReadOnlyFileStatusProvider : IFileStatusProvider\n{\n    public string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnlyStatus: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n}\n\nclass FileProcessor\n{\n    private readonly IFileStatusProvider _fileStatusProvider;\n\n    public FileProcessor(IFileStatusProvider fileStatusProvider)\n    {\n        _fileStatusProvider = fileStatusProvider;\n    }\n\n    public void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Processor: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Processor: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Processor: File {filePath} processed successfully.\");\n    }\n\n    public string GetStatus(string filePath)\n    {\n        string baseStatus = _fileStatusProvider.GetStatus(filePath);\n        if (baseStatus == \"Ready for status check\") return \"Ready for processing\";\n        return baseStatus;\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"total_duration\":7660001209,\"explanation\":\"The `ReadOnlyFileStatusProvider` class was overriding the `GetStatus` method in a way that could lead to unexpected behavior when used polymorphically. By making it inherit from `FileStatusProvider` and overriding the method correctly, we ensure that it adheres to the Liskov Substitution Principle.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The `ReadOnlyFileStatusProvider` class was overriding the `GetStatus` method in a way that could lead to unexpected behavior when used polymorphically. By making it inherit from `FileStatusProvider` and overriding the method correctly, we ensure that it adheres to the Liskov Substitution Principle."
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\n\\ninterface IAccount\\n{\\n    void Withdraw(decimal amount);\\n    decimal GetBalance();\\n}\\n\\nabstract class AccountBase : IAccount\\n{\\n    protected decimal _balance;\\n\\n    public decimal GetBalance()\\n    {\\n        return _balance;\\n    }\\n}\\n\\nclass ActiveAccount : AccountBase\\n{\\n    public ActiveAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Active\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Active\\\");\\n        }\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds. Cannot withdraw {amount}. Balance: {_balance}\");\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : AccountBase\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public LimitedWithdrawalAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount > MaxWithdrawalLimit)\\n        {\\n            LogExceedsLimit(amount, MaxWithdrawalLimit, \\\"Limited\\\");\\n        }\\n        else if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Limited\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Limited\\\");\\n        }\\n    }\\n\\n    private void LogExceedsLimit(decimal amount, decimal limit, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Withdrawal request ({amount}) exceeds per-transaction limit ({limit}). No action taken. Balance remains: {_balance}\");\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds for withdrawal ({amount}). Balance: {_balance}\");\\n    }\\n}\",\"explanation\":\"The refactored code addresses the Single Responsibility Principle (SRP) violation by creating an abstract base class `AccountBase` that handles the common functionality of getting the balance. Each account type now only focuses on its specific withdrawal logic. Additionally, logging methods have been extracted to avoid code duplication and improve maintainability.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":8874405166,\"explanation\":\"The refactored code addresses the Single Responsibility Principle (SRP) violation by creating a separate `Logger` class that handles all logging responsibilities. This allows the `ActiveAccount` and `LimitedWithdrawalAccount` classes to focus solely on their withdrawal logic, improving maintainability and clarity.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The refactored code addresses the Single Responsibility Principle (SRP) violation by creating a separate `Logger` class that handles all logging responsibilities. This allows the `ActiveAccount` and `LimitedWithdrawalAccount` classes to focus solely on their withdrawal logic, improving maintainability and clarity."
        },
        {
            "input": "{\"violation_type\":\"SRP, DIP\",\"refactored_code\":\"using System;\\n\\ninterface ILogger\\n{\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger\\n{\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass TimestampLogger : ILogger\\n{\\n    private readonly ILogger _logger;\\n    private readonly DateTime _creationTime;\\n\\n    public TimestampLogger(ILogger logger)\\n    {\\n        _logger = logger;\\n        _creationTime = DateTime.Now;\\n    }\\n\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        _logger.Log(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the Logger class is responsible for both logging messages and formatting them with timestamps. It also violates the Dependency Inversion Principle (DIP) because the Logger class is tightly coupled to the Console output. The refactored code introduces an ILogger interface to decouple the logging functionality from the implementation, allowing for better adherence to SOLID principles. The ConsoleLogger class handles the actual logging to the console, while TimestampLogger uses an ILogger instance to log messages with a fixed timestamp.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3207834792,\"explanation\":\"The original code violated the Single Responsibility Principle (SRP) because the Logger class was responsible for both logging messages and formatting them with timestamps. The refactored code separates these concerns by introducing an ILogger interface and creating distinct classes for logging to the console and for adding timestamps, ensuring each class has a single responsibility.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle (SRP) because the Logger class was responsible for both logging messages and formatting them with timestamps. The refactored code separates these concerns by introducing an ILogger interface and creating distinct classes for logging to the console and for adding timestamps, ensuring each class has a single responsibility."
        },
        {
            "input": "public class User {\n    public string Name { get; set; }\n    public string Email { get; set; }\n}\n\npublic class UserService {\n    public void RegisterUser(User user) {\n        // Registration logic\n    }\n}\n\npublic class UserNotificationService {\n    public void NotifyUser(User user) {\n        // Notification logic\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3602770000,\"explanation\":\"The original code had a single class handling both user registration and notification, which violates the Single Responsibility Principle (SRP). The refactored code separates these concerns into distinct classes, ensuring that each class has one reason to change.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had a single class handling both user registration and notification, which violates the Single Responsibility Principle (SRP). The refactored code separates these concerns into distinct classes, ensuring that each class has one reason to change."
        }
    ]
}