{
    "code_examples": [
        {
            "input": "public interface Shape {\n    double calculateArea();\n}\n\npublic class Rectangle implements Shape {\n    private double width;\n    private double height;\n    \n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return width  height;\n    }\n}\n\npublic class Circle implements Shape {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI  radius  radius;\n    }\n}\n\npublic class AreaCalculator {\n    public double calculateArea(Shape shape) {\n        return shape.calculateArea();\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":3420435958,\"explanation\":\"The original code had a potential violation of the Open/Closed Principle (OCP) as it could lead to multiple `if-else` statements if new shapes were added. By ensuring that all shapes implement the `Shape` interface and calculating their area through polymorphism, the code is now open for extension but closed for modification.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "OCP",
            "explanation": "The original code had a potential violation of the Open/Closed Principle (OCP) as it could lead to multiple `if-else` statements if new shapes were added. By ensuring that all shapes implement the `Shape` interface and calculating their area through polymorphism, the code is now open for extension but closed for modification."
        },
        {
            "input": "public interface Damageable {\n    int calculateDamage();\n}\n\npublic class Warrior implements Damageable {\n    private int strength;\n    \n    public Warrior(int strength) {\n        this.strength = strength;\n    }\n    \n    @Override\n    public int calculateDamage() {\n        return strength  2;\n    }\n}\n\npublic class Mage implements Damageable {\n    private int mana;\n    \n    public Mage(int mana) {\n        this.mana = mana;\n    }\n    \n    @Override\n    public int calculateDamage() {\n        return mana  3;\n    }\n}\n\npublic class DamageCalculator {\n    public int calculateDamage(Damageable character) {\n        return character.calculateDamage();\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1698870375,\"explanation\":\"The original class handled both report generation and saving, violating the Single Responsibility Principle (SRP). The refactored code separates these concerns into two distinct classes: `ReportGenerator` for generating reports and `ReportSaver` for saving them.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original class handled both report generation and saving, violating the Single Responsibility Principle (SRP). The refactored code separates these concerns into two distinct classes: `ReportGenerator` for generating reports and `ReportSaver` for saving them."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2788300041,\"explanation\":\"The code violates the Single Responsibility Principle because the `SpeedCalculator` class is responsible for calculating the speed of different vehicle types, which could be separated into individual classes or methods for better clarity and responsibility management.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3500032292,\"explanation\":\"The `SpeedCalculator` class previously handled speed calculations for multiple vehicle types, violating the Single Responsibility Principle. Now, each vehicle type has its own dedicated class, improving clarity and responsibility management.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `SpeedCalculator` class previously handled speed calculations for multiple vehicle types, violating the Single Responsibility Principle. Now, each vehicle type has its own dedicated class, improving clarity and responsibility management."
        },
        {
            "input": "public interface PaymentMethod {\n    void processPayment(double amount);\n}\n\npublic class CreditCardPayment implements PaymentMethod {\n    @Override\n    public void processPayment(double amount) {\n        new CreditCardProcessor().process(amount);\n    }\n}\n\npublic class PaypalPayment implements PaymentMethod {\n    @Override\n    public void processPayment(double amount) {\n        new PaypalProcessor().process(amount);\n    }\n}\n\npublic class BankTransferPayment implements PaymentMethod {\n    @Override\n    public void processPayment(double amount) {\n        new BankTransferProcessor().process(amount);\n    }\n}\n\npublic class CreditCardProcessor {\n    public void process(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n        System.out.println(\"Validating credit card information\");\n        System.out.println(\"Charging credit card\");\n        System.out.println(\"Recording the credit card transaction\");\n    }\n}\n\npublic class PaypalProcessor {\n    public void process(double amount) {\n        System.out.println(\"Processing PayPal payment of $\" + amount);\n        System.out.println(\"Redirecting user to PayPal\");\n        System.out.println(\"Confirming PayPal payment\");\n        System.out.println(\"Recording the PayPal transaction\");\n    }\n}\n\npublic class BankTransferProcessor {\n    public void process(double amount) {\n        System.out.println(\"Processing bank transfer of $\" + amount);\n        System.out.println(\"Generating bank transfer instructions\");\n        System.out.println(\"Sending transfer confirmation email\");\n        System.out.println(\"Recording the bank transfer transaction\");\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":8438407250,\"explanation\":\"The original code had the `PaymentMethod` implementations directly instantiating their respective processor classes, which led to multiple responsibilities within the payment classes. The refactored code now injects the processor classes through the constructor, adhering to the Single Responsibility Principle (SRP) by separating the concerns of payment processing and payment method implementation.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had the `PaymentMethod` implementations directly instantiating their respective processor classes, which led to multiple responsibilities within the payment classes. The refactored code now injects the processor classes through the constructor, adhering to the Single Responsibility Principle (SRP) by separating the concerns of payment processing and payment method implementation."
        },
        {
            "input": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class CustomerService {\n    private CustomerRepository repository;\n    private EmailSender emailSender;\n    private Map<String, WelcomeEmailStrategy> emailStrategies;\n\n    public CustomerService(CustomerRepository repository, EmailSender emailSender) {\n        this.repository = repository;\n        this.emailSender = emailSender;\n        initializeEmailStrategies();\n    }\n\n    private void initializeEmailStrategies() {\n        emailStrategies = new HashMap<>();\n        emailStrategies.put(\"standard\", new StandardWelcomeEmailStrategy());\n        emailStrategies.put(\"premium\", new PremiumWelcomeEmailStrategy());\n        emailStrategies.put(\"trial\", new TrialWelcomeEmailStrategy());\n    }\n\n    public Customer registerCustomer(String name, String email, String customerType) {\n        validateCustomerData(name, email);\n\n        Customer customer = new Customer(name, email);\n        repository.save(customer);\n\n        // Send welcome email based on customer type\n        sendWelcomeEmail(customer, customerType);\n\n        return customer;\n    }\n\n    private void validateCustomerData(String name, String email) {\n        if (name == null || name.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Name cannot be empty\");\n        }\n\n        if (email == null || !email.matches(\"^[A-Za-z0-9+_.-]+@(.+)$\")) {\n            throw new IllegalArgumentException(\"Invalid email format\");\n        }\n\n        if (repository.findByEmail(email) != null) {\n            throw new IllegalArgumentException(\"Email already registered\");\n        }\n    }\n\n    private void sendWelcomeEmail(Customer customer, String customerType) {\n        WelcomeEmailStrategy strategy = emailStrategies.get(customerType);\n        if (strategy == null) {\n            throw new IllegalArgumentException(\"Unsupported customer type: \" + customerType);\n        }\n\n        String subject = \"Welcome to Our Service\";\n        String body = strategy.createEmailBody(customer);\n\n        emailSender.sendEmail(customer.getEmail(), subject, body);\n    }\n}\n\npublic class EmailSender {\n    private EmailService emailService;\n\n    public EmailSender(EmailService emailService) {\n        this.emailService = emailService;\n    }\n\n    public void sendEmail(String to, String subject, String body) {\n        emailService.sendEmail(to, subject, body);\n    }\n}\n\npublic interface WelcomeEmailStrategy {\n    String createEmailBody(Customer customer);\n}\n\npublic class StandardWelcomeEmailStrategy implements WelcomeEmailStrategy {\n    @Override\n    public String createEmailBody(Customer customer) {\n        return \"Dear \" + customer.getName() + \",\\n\\n\" +\n              \"Welcome to our service! We're excited to have you join us.\\n\\n\" +\n              \"Your account has been created successfully. You can now access all standard features.\\n\\n\" +\n              \"Best regards,\\n\" +\n              \"The Service Team\";\n    }\n}\n\npublic class PremiumWelcomeEmailStrategy implements WelcomeEmailStrategy {\n    @Override\n    public String createEmailBody(Customer customer) {\n        return \"Dear \" + customer.getName() + \",\\n\\n\" +\n              \"Welcome to our PREMIUM service! We're thrilled to have you as a premium member.\\n\\n\" +\n              \"Your premium account has been activated with all exclusive features.\\n\" +\n              \"Our premium support team is available 24/7 to assist you.\\n\\n\" +\n              \"Best regards,\\n\" +\n              \"The Premium Service Team\";\n    }\n}\n\npublic class TrialWelcomeEmailStrategy implements WelcomeEmailStrategy {\n    @Override\n    public String createEmailBody(Customer customer) {\n        return \"Dear \" + customer.getName() + \",\\n\\n\" +\n              \"Thank you for trying our service! Your 30-day trial has begun.\\n\\n\" +\n              \"Explore all the features we offer during your trial period.\\n\" +\n              \"We'll send you a reminder before your trial expires.\\n\\n\" +\n              \"Best regards,\\n\" +\n              \"The Service Team\";\n    }\n}\n\npublic class Customer {\n    private String name;\n    private String email;\n\n    public Customer(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n}\n\npublic interface CustomerRepository {\n    void save(Customer customer);\n    Customer findByEmail(String email);\n}\n\npublic interface EmailService {\n    void sendEmail(String to, String subject, String body);\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":15202248084,\"explanation\":\"The `CustomerService` class was handling multiple responsibilities: customer registration, validation, and sending emails. The refactoring maintains these responsibilities but keeps them focused, ensuring that each method has a single responsibility, thus adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `CustomerService` class was handling multiple responsibilities: customer registration, validation, and sending emails. The refactoring maintains these responsibilities but keeps them focused, ensuring that each method has a single responsibility, thus adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "import java.util.;\n\npublic class DocumentService {\n    private DocumentRepository repository;\n    private SecurityService securityService;\n    private Logger logger;\n    private NotificationService notificationService;\n\n    public DocumentService(DocumentRepository repository, SecurityService securityService, Logger logger, NotificationService notificationService) {\n        this.repository = repository;\n        this.securityService = securityService;\n        this.logger = logger;\n        this.notificationService = notificationService;\n    }\n\n    public Document createDocument(String title, String content, User creator) {\n        Document document = new Document(title, content, creator);\n        repository.save(document);\n        logger.log(\"Document created: \" + document.getId());\n        return document;\n    }\n\n    public void shareDocument(Document document, User recipient, User sharedBy) {\n        validateSharingPermissions(document, sharedBy);\n        document.addSharedUser(recipient);\n        repository.update(document);\n        logger.log(\"Document \" + document.getId() + \" shared with \" + recipient.getUsername());\n        notificationService.notifyUser(document, recipient, sharedBy);\n    }\n\n    private void validateSharingPermissions(Document document, User user) {\n        if (!securityService.canShareDocument(document, user)) {\n            throw new SecurityException(\"User does not have permission to share this document\");\n        }\n    }\n}\n\npublic class NotificationService {\n    private Map<String, NotificationStrategy> notificationStrategies;\n    private Logger logger;\n\n    public NotificationService(Logger logger) {\n        this.logger = logger;\n        initializeNotificationStrategies();\n    }\n\n    private void initializeNotificationStrategies() {\n        notificationStrategies = new HashMap<>();\n        notificationStrategies.put(\"email\", new EmailNotificationStrategy());\n        notificationStrategies.put(\"sms\", new SMSNotificationStrategy());\n        notificationStrategies.put(\"push\", new PushNotificationStrategy());\n        notificationStrategies.put(\"slack\", new SlackNotificationStrategy());\n    }\n\n    public void registerNotificationStrategy(String type, NotificationStrategy strategy) {\n        notificationStrategies.put(type, strategy);\n    }\n\n    public void notifyUser(Document document, User recipient, User sharedBy) {\n        String recipientContact = recipient.getContactInfo();\n        String message = \"Document '\" + document.getTitle() + \"' has been shared with you by \" + sharedBy.getUsername();\n        String contactType = recipient.getPreferredContactMethod();\n        NotificationStrategy strategy = notificationStrategies.get(contactType);\n\n        if (strategy != null) {\n            strategy.sendNotification(recipientContact, \"Document Shared\", message);\n        } else {\n            logger.log(\"Unknown contact method: \" + contactType);\n        }\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":8434127208,\"explanation\":\"The `DocumentService` class was handling multiple responsibilities: document creation, sharing, permission validation, and logging. The refactoring separates the notification logic into the `NotificationService`, adhering to the Single Responsibility Principle (SRP) by ensuring each class has one reason to change.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `DocumentService` class was handling multiple responsibilities: document creation, sharing, permission validation, and logging. The refactoring separates the notification logic into the `NotificationService`, adhering to the Single Responsibility Principle (SRP) by ensuring each class has one reason to change."
        },
        {
            "input": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class ReportExporter {\n    private DataSource dataSource;\n    private FileSystem fileSystem;\n    private Map<String, ExportFormatStrategy> exportStrategies;\n\n    public ReportExporter(DataSource dataSource, FileSystem fileSystem) {\n        this.dataSource = dataSource;\n        this.fileSystem = fileSystem;\n        this.exportStrategies = new HashMap<>();\n    }\n\n    public void registerExportStrategy(String format, ExportFormatStrategy strategy) {\n        exportStrategies.put(format, strategy);\n    }\n\n    public ExportResult exportReport(String reportId, String exportFormat, String destination) {\n        Report report = dataSource.getReport(reportId);\n\n        if (report == null) {\n            return new ExportResult(false, \"Report not found\", null);\n        }\n\n        byte[] reportData = generateReportData(report, exportFormat);\n        if (reportData == null) {\n            return new ExportResult(false, \"Failed to generate report\", null);\n        }\n\n        String fileName = report.getTitle() + getFileExtension(exportFormat);\n        fileSystem.writeFile(destination + \"/\" + fileName, reportData);\n        return new ExportResult(true, \"Report exported successfully\", destination + \"/\" + fileName);\n    }\n\n    private byte[] generateReportData(Report report, String exportFormat) {\n        try {\n            ReportData data = dataSource.getReportData(report.getId());\n            ExportFormatStrategy strategy = exportStrategies.get(exportFormat);\n\n            if (strategy != null) {\n                return strategy.generateReport(report, data);\n            }\n        } catch (Exception e) {\n            return null;\n        }\n        return null;\n    }\n\n    private String getFileExtension(String format) {\n        ExportFormatStrategy strategy = exportStrategies.get(format);\n        return strategy != null ? strategy.getFileExtension() : \".txt\";\n    }\n}\n\npublic interface ExportFormatStrategy {\n    byte[] generateReport(Report report, ReportData data) throws Exception;\n    String getFileExtension();\n}\n\npublic class PdfExportStrategy implements ExportFormatStrategy {\n    @Override\n    public byte[] generateReport(Report report, ReportData data) throws Exception {\n        PdfDocument document = new PdfDocument();\n        return document.generate();\n    }\n    \n    @Override\n    public String getFileExtension() {\n        return \".pdf\";\n    }\n}\n\npublic class ExcelExportStrategy implements ExportFormatStrategy {\n    @Override\n    public byte[] generateReport(Report report, ReportData data) throws Exception {\n        ExcelDocument document = new ExcelDocument();\n        return document.generate();\n    }\n    \n    @Override\n    public String getFileExtension() {\n        return \".xlsx\";\n    }\n}\n\npublic class HtmlExportStrategy implements ExportFormatStrategy {\n    @Override\n    public byte[] generateReport(Report report, ReportData data) throws Exception {\n        StringBuilder html = new StringBuilder();\n        return html.toString().getBytes();\n    }\n    \n    @Override\n    public String getFileExtension() {\n        return \".html\";\n    }\n}\n\npublic class CsvExportStrategy implements ExportFormatStrategy {\n    @Override\n    public byte[] generateReport(Report report, ReportData data) throws Exception {\n        StringBuilder csv = new StringBuilder();\n        return csv.toString().getBytes();\n    }\n    \n    @Override\n    public String getFileExtension() {\n        return \".csv\";\n    }\n}\n\npublic class ExportResult {\n    private boolean success;\n    private String message;\n    private String outputPath;\n    \n    public ExportResult(boolean success, String message, String outputPath) {\n        this.success = success;\n        this.message = message;\n        this.outputPath = outputPath;\n    }\n}\n\npublic interface DataSource {\n    Report getReport(String reportId);\n    ReportData getReportData(String reportId);\n}\n\npublic interface FileSystem {\n    boolean writeFile(String path, byte[] data);\n}\n\npublic class Report {\n    private String id;\n    private String title;\n    \n    public String getId() { return id; }\n    public String getTitle() { return title; }\n}\n\npublic class ReportData {\n}\n\npublic class PdfDocument {\n    public byte[] generate() { return new byte[0]; }\n}\n\npublic class ExcelDocument {\n    public byte[] generate() { return new byte[0]; }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":11884159042,\"explanation\":\"The `ReportExporter` class was handling multiple responsibilities: fetching report data, generating report data, and writing files. The refactoring separates the concerns by ensuring that the `generateReportData` method only focuses on generating report data using the appropriate strategy, thus adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `ReportExporter` class was handling multiple responsibilities: fetching report data, generating report data, and writing files. The refactoring separates the concerns by ensuring that the `generateReportData` method only focuses on generating report data using the appropriate strategy, thus adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "import java.text.SimpleDateFormat;\nimport java.util.;\n\npublic class SalesData {\n    private List<Sale> sales;\n    \n    public SalesData(List<Sale> sales) {\n        this.sales = sales;\n    }\n    \n    public List<Sale> getSales() {\n        return sales;\n    }\n}\n\npublic class Sale {\n    private String productName;\n    private double amount;\n    private Date date;\n    private String region;\n    \n    public Sale(String productName, double amount, Date date, String region) {\n        this.productName = productName;\n        this.amount = amount;\n        this.date = date;\n        this.region = region;\n    }\n    \n    public String getProductName() {\n        return productName;\n    }\n    \n    public double getAmount() {\n        return amount;\n    }\n    \n    public Date getDate() {\n        return date;\n    }\n    \n    public String getRegion() {\n        return region;\n    }\n}\n\npublic interface ReportStrategy {\n    String generateReport(SalesData data);\n}\n\npublic abstract class BaseReportStrategy implements ReportStrategy {\n    protected StringBuilder report;\n    protected Map<String, Double> salesData;\n    \n    public BaseReportStrategy() {\n        report = new StringBuilder();\n        salesData = new HashMap<>();\n    }\n    \n    protected void appendTotalSales() {\n        double total = salesData.values().stream().mapToDouble(Double::doubleValue).sum();\n        report.append(\"\\nTotal Sales: $\").append(total);\n    }\n    \n    protected void aggregateSales(SalesData data, Function<Sale, String> keyExtractor) {\n        for (Sale sale : data.getSales()) {\n            String key = keyExtractor.apply(sale);\n            salesData.put(key, salesData.getOrDefault(key, 0.0) + sale.getAmount());\n        }\n    }\n}\n\npublic class DailyReportStrategy extends BaseReportStrategy {\n    @Override\n    public String generateReport(SalesData data) {\n        report.append(\"DAILY SALES REPORT\\n\").append(\"===================\\n\\n\");\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n        \n        aggregateSales(data, sale -> dateFormat.format(sale.getDate()));\n        \n        for (Map.Entry<String, Double> entry : salesData.entrySet()) {\n            report.append(\"Date: \").append(entry.getKey()).append(\", Total: $\").append(entry.getValue()).append(\"\\n\");\n        }\n        \n        appendTotalSales();\n        return report.toString();\n    }\n}\n\npublic class ProductReportStrategy extends BaseReportStrategy {\n    @Override\n    public String generateReport(SalesData data) {\n        report.append(\"PRODUCT SALES REPORT\\n\").append(\"====================\\n\\n\");\n        \n        aggregateSales(data, Sale::getProductName);\n        \n        for (Map.Entry<String, Double> entry : salesData.entrySet()) {\n            report.append(\"Product: \").append(entry.getKey()).append(\", Total: $\").append(entry.getValue()).append(\"\\n\");\n        }\n        \n        appendTotalSales();\n        return report.toString();\n    }\n}\n\npublic class RegionalReportStrategy extends BaseReportStrategy {\n    @Override\n    public String generateReport(SalesData data) {\n        report.append(\"REGIONAL SALES REPORT\\n\").append(\"=====================\\n\\n\");\n        \n        aggregateSales(data, Sale::getRegion);\n        \n        for (Map.Entry<String, Double> entry : salesData.entrySet()) {\n            report.append(\"Region: \").append(entry.getKey()).append(\", Total: $\").append(entry.getValue()).append(\"\\n\");\n        }\n        \n        appendTotalSales();\n        return report.toString();\n    }\n}\n\npublic class ReportGenerator {\n    private ReportStrategy reportStrategy;\n    \n    public ReportGenerator(ReportStrategy reportStrategy) {\n        this.reportStrategy = reportStrategy;\n    }\n    \n    public void setReportStrategy(ReportStrategy reportStrategy) {\n        this.reportStrategy = reportStrategy;\n    }\n    \n    public String generateReport(SalesData data) {\n        return reportStrategy.generateReport(data);\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":12122974417,\"explanation\":\"The original code had a violation of the Single Responsibility Principle (SRP) as the `BaseReportStrategy` class was responsible for both report generation and data aggregation. The refactored code maintains the same structure but clarifies the responsibilities, ensuring that each class focuses on a single task related to report generation.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had a violation of the Single Responsibility Principle (SRP) as the `BaseReportStrategy` class was responsible for both report generation and data aggregation. The refactored code maintains the same structure but clarifies the responsibilities, ensuring that each class focuses on a single task related to report generation."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"total_duration\":6052598917,\"explanation\":\"The original code violates the Open/Closed Principle because the `TaxCalculator` class is not open for extension; adding a new tax strategy requires modifying the existing code. The refactored code allows for new tax strategies to be added without changing the `TaxCalculator` class, thus adhering to the OCP.\"}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":3104345459,\"explanation\":\"The original code violated the Open/Closed Principle because the `TaxCalculator` class was not open for extension; adding a new tax strategy required modifying the existing code. The refactored code introduces a `TaxStrategy` interface, allowing new tax strategies to be added without changing the `TaxCalculator` class, thus adhering to the OCP.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "OCP",
            "explanation": "The original code violated the Open/Closed Principle because the `TaxCalculator` class was not open for extension; adding a new tax strategy required modifying the existing code. The refactored code introduces a `TaxStrategy` interface, allowing new tax strategies to be added without changing the `TaxCalculator` class, thus adhering to the OCP."
        },
        {
            "input": "import java.util.;\n\npublic class Content {\n    private String text;\n    private String type;\n    private Map<String, String> metadata;\n    \n    public Content(String text, String type, Map<String, String> metadata) {\n        this.text = text;\n        this.type = type;\n        this.metadata = metadata;\n    }\n    \n    public String getText() {\n        return text;\n    }\n    \n    public String getType() {\n        return type;\n    }\n    \n    public Map<String, String> getMetadata() {\n        return metadata;\n    }\n}\n\npublic interface ContentFilterStrategy {\n    String filter(String text, Map<String, String> metadata);\n}\n\npublic abstract class AbstractContentFilter implements ContentFilterStrategy {\n    protected String applyCommonFilters(String text) {\n        text = text.replaceAll(\"(?i)badword1|badword2|badword3\", \"[INAPPROPRIATE]\");\n        text = text.replaceAll(\"\\d{3}-\\d{2}-\\d{4}\", \"[SSN]\");\n        text = text.replaceAll(\"\\d{16}\", \"[CREDIT_CARD]\");\n        return text;\n    }\n}\n\npublic class EmailContentFilter extends AbstractContentFilter {\n    @Override\n    public String filter(String text, Map<String, String> metadata) {\n        String audience = metadata.getOrDefault(\"audience\", \"general\");\n        \n        if (audience.equals(\"public\")) {\n            text = text.replaceAll(\"(?i)confidential:\", \"[REDACTED]\");\n            text = text.replaceAll(\"(?i)internal use only\", \"[INTERNAL]\");\n        }\n        \n        text = text.replaceAll(\"(?i)from:\\s.?\\n\", \"\");\n        text = text.replaceAll(\"(?i)to:\\s.?\\n\", \"\");\n        text = text.replaceAll(\"(?i)cc:\\s.?\\n\", \"\");\n        \n        return applyCommonFilters(text);\n    }\n}\n\npublic class SocialContentFilter extends AbstractContentFilter {\n    @Override\n    public String filter(String text, Map<String, String> metadata) {\n        String platform = metadata.getOrDefault(\"platform\", \"general\");\n        String audience = metadata.getOrDefault(\"audience\", \"general\");\n        \n        if (platform.equals(\"twitter\")) {\n            text = text.replaceAll(\"@([A-Za-z0-9_]+)\", \"[USERNAME]\");\n        } else if (platform.equals(\"facebook\")) {\n            text = text.replaceAll(\"@\\[[^\\]]+\\]\", \"[NAME]\");\n        }\n        \n        if (audience.equals(\"minor\")) {\n            text = text.replaceAll(\"(?i)alcohol|beer|wine\", \"[AGE-RESTRICTED]\");\n        }\n        \n        return applyCommonFilters(text);\n    }\n}\n\npublic class CommentContentFilter extends AbstractContentFilter {\n    @Override\n    public String filter(String text, Map<String, String> metadata) {\n        String context = metadata.getOrDefault(\"context\", \"general\");\n        \n        if (context.equals(\"news\")) {\n            text = text.replaceAll(\"(?i)allegedly|reportedly\", \"[STATEMENT]\");\n        } else if (context.equals(\"review\")) {\n            text = text.replaceAll(\"(?i)terrible|awful|worst ever\", \"not satisfactory\");\n        }\n        \n        return applyCommonFilters(text);\n    }\n}\n\npublic class ContentFilterChain {\n    private List<ContentFilterStrategy> filters = new ArrayList<>();\n    \n    public void addFilter(ContentFilterStrategy filter) {\n        filters.add(filter);\n    }\n    \n    public String applyFilters(String text, Map<String, String> metadata) {\n        String result = text;\n        for (ContentFilterStrategy filter : filters) {\n            result = filter.filter(result, metadata);\n        }\n        return result;\n    }\n}\n\npublic class ContentFilter {\n    private Map<String, ContentFilterChain> filterChains = new HashMap<>();\n    \n    public ContentFilter() {\n        ContentFilterChain commonChain = new ContentFilterChain();\n        commonChain.addFilter(new CommonContentFilter());\n        \n        ContentFilterChain emailChain = new ContentFilterChain();\n        emailChain.addFilter(new EmailContentFilter());\n        emailChain.addFilter(new CommonContentFilter());\n        \n        ContentFilterChain socialChain = new ContentFilterChain();\n        socialChain.addFilter(new SocialContentFilter());\n        socialChain.addFilter(new CommonContentFilter());\n        \n        ContentFilterChain commentChain = new ContentFilterChain();\n        commentChain.addFilter(new CommentContentFilter());\n        commentChain.addFilter(new CommonContentFilter());\n        \n        filterChains.put(\"default\", commonChain);\n        filterChains.put(\"email\", emailChain);\n        filterChains.put(\"social\", socialChain);\n        filterChains.put(\"comment\", commentChain);\n    }\n    \n    public void registerFilterChain(String contentType, ContentFilterChain chain) {\n        filterChains.put(contentType, chain);\n    }\n    \n    public String filterContent(Content content) {\n        String contentType = content.getType();\n        ContentFilterChain chain = filterChains.getOrDefault(contentType, filterChains.get(\"default\"));\n        return chain.applyFilters(content.getText(), content.getMetadata());\n    }\n}\n\npublic class CommonContentFilter extends AbstractContentFilter {\n    @Override\n    public String filter(String text, Map<String, String> metadata) {\n        return applyCommonFilters(text);\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":20610670583,\"explanation\":\"The original code used multiple `if-else` statements in the filter methods of the content filter classes, which violates the Open/Closed Principle (OCP). The refactored code removes unnecessary conditions by allowing each filter to handle its specific logic without branching, thus adhering to OCP by promoting extensibility through polymorphism.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements in the filter methods of the content filter classes, which violates the Open/Closed Principle (OCP). The refactored code removes unnecessary conditions by allowing each filter to handle its specific logic without branching, thus adhering to OCP by promoting extensibility through polymorphism."
        },
        {
            "input": "import java.util.;\n\npublic class ShippingService {\n    private OrderRepository orderRepository;\n    private InventoryService inventoryService;\n    private Logger logger;\n    private Map<String, ShippingStrategy> shippingStrategies;\n\n    public ShippingService(OrderRepository orderRepository, InventoryService inventoryService, Logger logger) {\n        this.orderRepository = orderRepository;\n        this.inventoryService = inventoryService;\n        this.logger = logger;\n        initializeShippingStrategies();\n    }\n\n    private void initializeShippingStrategies() {\n        shippingStrategies = new HashMap<>();\n        shippingStrategies.put(\"standard\", new StandardShippingStrategy());\n        shippingStrategies.put(\"express\", new ExpressShippingStrategy());\n        shippingStrategies.put(\"overnight\", new OvernightShippingStrategy());\n        shippingStrategies.put(\"international\", new InternationalShippingStrategy());\n    }\n\n    public void registerShippingStrategy(String method, ShippingStrategy strategy) {\n        shippingStrategies.put(method, strategy);\n    }\n\n    public ShipmentResult processShipment(String orderId) {\n        ShipmentProcessor processor = new ShipmentProcessor(orderId, orderRepository, inventoryService, logger, shippingStrategies);\n        return processor.process();\n    }\n}\n\nclass ShipmentProcessor {\n    private String orderId;\n    private OrderRepository orderRepository;\n    private InventoryService inventoryService;\n    private Logger logger;\n    private Map<String, ShippingStrategy> shippingStrategies;\n\n    public ShipmentProcessor(String orderId, OrderRepository orderRepository, InventoryService inventoryService, Logger logger, Map<String, ShippingStrategy> shippingStrategies) {\n        this.orderId = orderId;\n        this.orderRepository = orderRepository;\n        this.inventoryService = inventoryService;\n        this.logger = logger;\n        this.shippingStrategies = shippingStrategies;\n    }\n\n    public ShipmentResult process() {\n        Order order = orderRepository.findById(orderId);\n\n        if (order == null) {\n            throw new IllegalArgumentException(\"Order not found: \" + orderId);\n        }\n\n        if (order.getStatus() != OrderStatus.PAID) {\n            return new ShipmentResult(false, \"Order is not paid yet\", null);\n        }\n\n        for (OrderItem item : order.getItems()) {\n            if (!inventoryService.isInStock(item.getProductId(), item.getQuantity())) {\n                return new ShipmentResult(false, \"Product out of stock: \" + item.getProductId(), null);\n            }\n        }\n\n        Shipment shipment = new Shipment(orderId, new Date());\n        ShippingCost shippingCost = calculateShippingCost(order);\n        shipment.setCost(shippingCost.getCost());\n\n        // Reserve inventory items\n        for (OrderItem item : order.getItems()) {\n            inventoryService.reserve(item.getProductId(), item.getQuantity());\n        }\n\n        // Update order status\n        order.setStatus(OrderStatus.SHIPPED);\n        orderRepository.update(order);\n\n        logger.log(\"Order shipped: \" + orderId + \", cost: \" + shippingCost.getCost());\n        return new ShipmentResult(true, \"Order shipped successfully\", shipment);\n    }\n\n    private ShippingCost calculateShippingCost(Order order) {\n        String shippingMethod = order.getShippingMethod();\n        ShippingStrategy strategy = shippingStrategies.get(shippingMethod);\n\n        if (strategy == null) {\n            // Default strategy if method not recognized\n            return new ShippingCost(10.0);\n        }\n\n        double totalWeight = calculateOrderWeight(order);\n        Address destination = order.getShippingAddress();\n        double distance = calculateDistance(destination);\n\n        return strategy.calculateCost(order, totalWeight, distance);\n    }\n\n    private double calculateOrderWeight(Order order) {\n        double totalWeight = 0.0;\n        for (OrderItem item : order.getItems()) {\n            Product product = inventoryService.getProduct(item.getProductId());\n            totalWeight += product.getWeight()  item.getQuantity();\n        }\n        return totalWeight;\n    }\n\n    private double calculateDistance(Address destination) {\n        // Simplified distance calculation. In a real system, this would use\n        // geographic coordinates or a distance service.\n        Address warehouseAddress = new Address(\"Warehouse\", \"123 Main St\", \"City\", \"State\", \"Country\", \"12345\");\n\n        if (warehouseAddress.getCountry().equals(destination.getCountry())) {\n            if (warehouseAddress.getState().equals(destination.getState())) {\n                if (warehouseAddress.getCity().equals(destination.getCity())) {\n                    return 10.0; // Same city\n                }\n                return 50.0; // Same state, different city\n            }\n            return 200.0; // Same country, different state\n        }\n        return 1000.0; // International\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":16435226000,\"explanation\":\"The `ShippingService` and `ShipmentProcessor` classes were doing too many unrelated tasks, violating the Single Responsibility Principle (SRP). The refactored code separates the responsibilities of validating orders, checking inventory, creating shipments, reserving inventory, and updating order status into distinct methods within the `ShipmentProcessor` class. This enhances clarity and maintainability.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `ShippingService` and `ShipmentProcessor` classes were doing too many unrelated tasks, violating the Single Responsibility Principle (SRP). The refactored code separates the responsibilities of validating orders, checking inventory, creating shipments, reserving inventory, and updating order status into distinct methods within the `ShipmentProcessor` class. This enhances clarity and maintainability."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":4575035042,\"explanation\":\"The original code violates the Single Responsibility Principle because the `AreaCalculator` class is responsible for both validating the shape type and calculating the area, which can be separated into different responsibilities. The refactored code maintains the same functionality while adhering to SRP.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3043639833,\"explanation\":\"The original code violated the Single Responsibility Principle because the `AreaCalculator` class was responsible for both validating the shape type and calculating the area. The refactored code separates these concerns into two classes: `ShapeValidator` for validation and `AreaCalculator` for area calculation, adhering to SRP.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `AreaCalculator` class was responsible for both validating the shape type and calculating the area. The refactored code separates these concerns into two classes: `ShapeValidator` for validation and `AreaCalculator` for area calculation, adhering to SRP."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass Character(ABC):\n    @abstractmethod\n    def calculate_damage(self):\n        pass\n\nclass Warrior(Character):\n    def __init__(self, strength):\n        self.__strength = strength\n    \n    def calculate_damage(self):\n        return self.__strength  2\n\nclass Mage(Character):\n    def __init__(self, mana):\n        self.__mana = mana\n    \n    def calculate_damage(self):\n        return self.__mana  3\n\nclass DamageCalculator:\n    def calculate_damage(self, character: Character):\n        if not isinstance(character, Character):\n            raise ValueError(\"Invalid character type\")\n        return character.calculate_damage()",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":2859710333,\"explanation\":\"The original code used an `if` statement to check the type of character, which violates the Open/Closed Principle (OCP) by requiring modification to handle new character types. The refactored code removes the type check, allowing the `DamageCalculator` to work with any `Character` subclass without modification.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used an `if` statement to check the type of character, which violates the Open/Closed Principle (OCP) by requiring modification to handle new character types. The refactored code removes the type check, allowing the `DamageCalculator` to work with any `Character` subclass without modification."
        },
        {
            "input": "class Animal(ABC):\n    @abstractmethod\n    def make_sound(self):\n        pass\n\nclass Dog(Animal):\n    def make_sound(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def make_sound(self):\n        return \"Meow!\"\n\nclass SoundMaker:\n    def make_sound(self, animal: Animal):\n        if not isinstance(animal, Animal):\n            raise ValueError(\"Invalid animal type\")\n        return animal.make_sound()",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":2467507250,\"explanation\":\"The original `SoundMaker` class used an `if` statement to check the type of the animal, which violates the Open/Closed Principle. The refactored code removes the type check, allowing the `SoundMaker` to work with any subclass of `Animal` without modification, thus adhering to OCP.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original `SoundMaker` class used an `if` statement to check the type of the animal, which violates the Open/Closed Principle. The refactored code removes the type check, allowing the `SoundMaker` to work with any subclass of `Animal` without modification, thus adhering to OCP."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":4037809500,\"explanation\":\"The original code violates the Single Responsibility Principle because the `VehicleFactory` class was responsible for creating specific types of vehicles, which can lead to a bloated interface. The refactored code consolidates vehicle creation into a single method that handles different vehicle types, improving clarity and responsibility separation.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2507849084,\"explanation\":\"The original code violated the Single Responsibility Principle because the `VehicleFactory` class was responsible for creating specific types of vehicles, which can lead to a bloated interface. The refactored code consolidates vehicle creation into a single method that handles different vehicle types, improving clarity and responsibility separation.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `VehicleFactory` class was responsible for creating specific types of vehicles, which can lead to a bloated interface. The refactored code consolidates vehicle creation into a single method that handles different vehicle types, improving clarity and responsibility separation."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass PaymentMethod(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n\nclass CreditCardPayment(PaymentMethod):\n    def process_payment(self, amount):\n        self.validate_credit_card()\n        self.charge_credit_card(amount)\n        self.record_transaction(amount, 'Credit Card')\n\n    def validate_credit_card(self):\n        print(\"Validating credit card information\")\n\n    def charge_credit_card(self, amount):\n        print(f\"Charging credit card: ${amount}\")\n\n    def record_transaction(self, amount, method):\n        print(f\"Recording the {method} transaction of ${amount}\")\n\nclass PaypalPayment(PaymentMethod):\n    def process_payment(self, amount):\n        self.redirect_to_paypal()\n        self.confirm_paypal_payment()\n        self.record_transaction(amount, 'PayPal')\n\n    def redirect_to_paypal(self):\n        print(\"Redirecting user to PayPal\")\n\n    def confirm_paypal_payment(self):\n        print(\"Confirming PayPal payment\")\n\n    def record_transaction(self, amount, method):\n        print(f\"Recording the {method} transaction of ${amount}\")\n\nclass BankTransferPayment(PaymentMethod):\n    def process_payment(self, amount):\n        self.generate_transfer_instructions()\n        self.send_confirmation_email()\n        self.record_transaction(amount, 'Bank Transfer')\n\n    def generate_transfer_instructions(self):\n        print(\"Generating bank transfer instructions\")\n\n    def send_confirmation_email(self):\n        print(\"Sending transfer confirmation email\")\n\n    def record_transaction(self, amount, method):\n        print(f\"Recording the {method} transaction of ${amount}\")\n\nclass PaymentProcessor:\n    def process_payment(self, payment_method, amount):\n        payment_method.process_payment(amount)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":5619501625,\"explanation\":\"The original code had the `record_transaction` method implemented in each payment method class, which violated the Single Responsibility Principle (SRP) by mixing transaction recording with payment processing. The refactored code introduces a separate `TransactionRecorder` class to handle transaction recording, thus adhering to SRP.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code had the `record_transaction` method implemented in each payment method class, which violated the Single Responsibility Principle (SRP) by mixing transaction recording with payment processing. The refactored code introduces a separate `TransactionRecorder` class to handle transaction recording, thus adhering to SRP."
        },
        {
            "input": "from abc import ABC, abstractmethod\nimport re\nfrom typing import Dict\n\nclass Customer:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\n    def get_name(self):\n        return self.name\n\n    def get_email(self):\n        return self.email\n\nclass CustomerRepository:\n    def save(self, customer):\n        pass\n\n    def find_by_email(self, email):\n        pass\n\nclass EmailService:\n    def send_email(self, to, subject, body):\n        pass\n\nclass WelcomeEmailStrategy(ABC):\n    @abstractmethod\n    def create_email_body(self, customer):\n        pass\n\nclass StandardWelcomeEmailStrategy(WelcomeEmailStrategy):\n    def create_email_body(self, customer):\n        return f\"Dear {customer.get_name()},\\n\\n\" \\\n               f\"Welcome to our service! We're excited to have you join us.\\n\\n\" \\\n               f\"Your account has been created successfully. You can now access all standard features.\\n\\n\" \\\n               f\"Best regards,\\n\" \\\n               f\"The Service Team\"\n\nclass PremiumWelcomeEmailStrategy(WelcomeEmailStrategy):\n    def create_email_body(self, customer):\n        return f\"Dear {customer.get_name()},\\n\\n\" \\\n               f\"Welcome to our PREMIUM service! We're thrilled to have you as a premium member.\\n\\n\" \\\n               f\"Your premium account has been activated with all exclusive features.\\n\" \\\n               f\"Our premium support team is available 24/7 to assist you.\\n\\n\" \\\n               f\"Best regards,\\n\" \\\n               f\"The Premium Service Team\"\n\nclass TrialWelcomeEmailStrategy(WelcomeEmailStrategy):\n    def create_email_body(self, customer):\n        return f\"Dear {customer.get_name()},\\n\\n\" \\\n               f\"Thank you for trying our service! Your 30-day trial has begun.\\n\\n\" \\\n               f\"Explore all the features we offer during your trial period.\\n\" \\\n               f\"We'll send you a reminder before your trial expires.\\n\\n\" \\\n               f\"Best regards,\\n\" \\\n               f\"The Service Team\"\n\nclass CustomerService:\n    def __init__(self, repository: CustomerRepository, email_service: EmailService):\n        self.repository = repository\n        self.email_service = email_service\n        self.email_strategies: Dict[str, WelcomeEmailStrategy] = {}\n        self.initialize_email_strategies()\n\n    def initialize_email_strategies(self):\n        self.email_strategies = {\n            \"standard\": StandardWelcomeEmailStrategy(),\n            \"premium\": PremiumWelcomeEmailStrategy(),\n            \"trial\": TrialWelcomeEmailStrategy()\n        }\n\n    def register_email_strategy(self, customer_type: str, strategy: WelcomeEmailStrategy):\n        self.email_strategies[customer_type] = strategy\n\n    def register_customer(self, name: str, email: str, customer_type: str):\n        self.validate_customer_data(name, email)\n\n        customer = Customer(name, email)\n        self.repository.save(customer)\n\n        # Send welcome email based on customer type\n        self.send_welcome_email(customer, customer_type)\n\n        return customer\n\n    def validate_customer_data(self, name: str, email: str):\n        if name is None or name.strip() == \"\":\n            raise ValueError(\"Name cannot be empty\")\n\n        if email is None or not re.match(r'^[A-Za-z0-9+_.-]+@(.+)$', email):\n            raise ValueError(\"Invalid email format\")\n\n        if self.repository.find_by_email(email) is not None:\n            raise ValueError(\"Email already registered\")\n\n    def send_welcome_email(self, customer: Customer, customer_type: str):\n        strategy = self.email_strategies.get(customer_type)\n        if strategy is None:\n            raise ValueError(f\"Unsupported customer type: {customer_type}\")\n\n        subject = \"Welcome to Our Service\"\n        body = strategy.create_email_body(customer)\n\n        self.email_service.send_email(customer.get_email(), subject, body)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":17837318125,\"explanation\":\"The `CustomerService` class was previously responsible for both customer registration and validation, violating the Single Responsibility Principle (SRP). The validation logic has been extracted into a new `CustomerValidator` class, allowing `CustomerService` to focus solely on customer registration and email sending.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The `CustomerService` class was previously responsible for both customer registration and validation, violating the Single Responsibility Principle (SRP). The validation logic has been extracted into a new `CustomerValidator` class, allowing `CustomerService` to focus solely on customer registration and email sending."
        },
        {
            "input": "import uuid\nfrom typing import Set, Dict, Protocol\nfrom abc import ABC, abstractmethod\n\nclass Document:\n    def __init__(self, title, content, creator):\n        self.id = str(uuid.uuid4())\n        self.title = title\n        self.content = content\n        self.creator = creator\n        self.shared_users = set()\n    \n    def get_id(self):\n        return self.id\n    \n    def get_title(self):\n        return self.title\n    \n    def get_content(self):\n        return self.content\n    \n    def get_creator(self):\n        return self.creator\n    \n    def get_shared_users(self):\n        return self.shared_users\n    \n    def add_shared_user(self, user):\n        self.shared_users.add(user)\n\nclass User:\n    def __init__(self, username, contact_info, preferred_contact_method):\n        self.id = str(uuid.uuid4())\n        self.username = username\n        self.contact_info = contact_info\n        self.preferred_contact_method = preferred_contact_method\n    \n    def get_id(self):\n        return self.id\n    \n    def get_username(self):\n        return self.username\n    \n    def get_contact_info(self):\n        return self.contact_info\n    \n    def get_preferred_contact_method(self):\n        return self.preferred_contact_method\n\nclass DocumentRepository:\n    def save(self, document):\n        pass\n    \n    def update(self, document):\n        pass\n    \n    def find_by_id(self, id):\n        pass\n\nclass SecurityService:\n    def can_share_document(self, document, user):\n        pass\n\nclass Logger:\n    def log(self, message):\n        pass\n\nclass NotificationStrategy(Protocol):\n    def send_notification(self, contact_info: str, subject: str, message: str) -> None:\n        ...\n\nclass EmailNotificationStrategy:\n    def send_notification(self, email: str, subject: str, message: str):\n        print(f\"Sending email to {email}\")\n        print(f\"Subject: {subject}\")\n        print(f\"Message: {message}\")\n\nclass SMSNotificationStrategy:\n    def send_notification(self, phone_number: str, subject: str, message: str):\n        print(f\"Sending SMS to {phone_number}\")\n        print(f\"Message: {message}\")\n\nclass PushNotificationStrategy:\n    def send_notification(self, device_id: str, subject: str, message: str):\n        print(f\"Sending push notification to device {device_id}\")\n        print(f\"Title: {subject}\")\n        print(f\"Message: {message}\")\n\nclass SlackNotificationStrategy:\n    def send_notification(self, slack_user_id: str, subject: str, message: str):\n        print(f\"Sending Slack message to {slack_user_id}\")\n        print(f\"Message: {message}\")\n\nclass DocumentService:\n    def __init__(self, repository: DocumentRepository, security_service: SecurityService, logger: Logger):\n        self.repository = repository\n        self.security_service = security_service\n        self.logger = logger\n        self.notification_strategies: Dict[str, NotificationStrategy] = {}\n        self.initialize_notification_strategies()\n    \n    def initialize_notification_strategies(self):\n        self.notification_strategies = {\n            \"email\": EmailNotificationStrategy(),\n            \"sms\": SMSNotificationStrategy(),\n            \"push\": PushNotificationStrategy(),\n            \"slack\": SlackNotificationStrategy()\n        }\n    \n    def register_notification_strategy(self, type: str, strategy: NotificationStrategy):\n        self.notification_strategies[type] = strategy\n    \n    def create_document(self, title: str, content: str, creator: User):\n        document = Document(title, content, creator)\n        self.repository.save(document)\n        self.logger.log(f\"Document created: {document.get_id()}\")\n        return document\n    \n    def share_document(self, document: Document, recipient: User, shared_by: User):\n        self.validate_sharing_permissions(document, shared_by)\n        document.add_shared_user(recipient)\n        self.repository.update(document)\n        self.logger.log(f\"Document {document.get_id()} shared with {recipient.get_username()}\")\n        self.notify_user(document, recipient, shared_by)\n    \n    def validate_sharing_permissions(self, document: Document, user: User):\n        if not self.security_service.can_share_document(document, user):\n            raise SecurityError(\"User does not have permission to share this document\")\n    \n    def notify_user(self, document: Document, recipient: User, shared_by: User):\n        recipient_contact = recipient.get_contact_info()\n        message = f\"Document '{document.get_title()}' has been shared with you by {shared_by.get_username()}\"\n        \n        # Notification logic based on recipient's preferred contact method\n        contact_type = recipient.get_preferred_contact_method()\n        strategy = self.notification_strategies.get(contact_type)\n        \n        if strategy:\n            strategy.send_notification(recipient_contact, \"Document Shared\", message)\n        else:\n            self.logger.log(f\"Unknown contact method: {contact_type}\")\n\nclass SecurityError(Exception):\n    pass",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":22395394250,\"explanation\":\"The `DocumentService` class was previously responsible for both document management and user notification, violating the Single Responsibility Principle (SRP). The notification logic has been extracted into a new `NotificationService` class, allowing `DocumentService` to focus solely on document-related tasks.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The `DocumentService` class was previously responsible for both document management and user notification, violating the Single Responsibility Principle (SRP). The notification logic has been extracted into a new `NotificationService` class, allowing `DocumentService` to focus solely on document-related tasks."
        },
        {
            "input": "from abc import ABC, abstractmethod\nfrom typing import Dict\n\nclass Report:\n    def __init__(self, id, title):\n        self.id = id\n        self.title = title\n    \n    def get_id(self):\n        return self.id\n    \n    def get_title(self):\n        return self.title\n\nclass ReportData:\n    pass\n\nclass Document(ABC):\n    @abstractmethod\n    def generate(self):\n        pass\n\nclass PdfDocument(Document):\n    def generate(self):\n        return bytes()\n\nclass ExcelDocument(Document):\n    def generate(self):\n        return bytes()\n\nclass ExportResult:\n    def __init__(self, success, message, output_path):\n        self.success = success\n        self.message = message\n        self.output_path = output_path\n\nclass DataSource:\n    def get_report(self, report_id):\n        pass\n    \n    def get_report_data(self, report_id):\n        pass\n\nclass FileSystem:\n    def write_file(self, path, data):\n        pass\n\nclass ExportFormatStrategy(ABC):\n    @abstractmethod\n    def generate_report(self, report, data):\n        pass\n    \n    @abstractmethod\n    def get_file_extension(self):\n        pass\n\nclass PdfExportStrategy(ExportFormatStrategy):\n    def generate_report(self, report, data):\n        document = PdfDocument()\n        return document.generate()\n    \n    def get_file_extension(self):\n        return \".pdf\"\n\nclass ExcelExportStrategy(ExportFormatStrategy):\n    def generate_report(self, report, data):\n        document = ExcelDocument()\n        return document.generate()\n    \n    def get_file_extension(self):\n        return \".xlsx\"\n\nclass HtmlExportStrategy(ExportFormatStrategy):\n    def generate_report(self, report, data):\n        html = \"\"\n        return html.encode()\n    \n    def get_file_extension(self):\n        return \".html\"\n\nclass CsvExportStrategy(ExportFormatStrategy):\n    def generate_report(self, report, data):\n        csv = \"\"\n        return csv.encode()\n    \n    def get_file_extension(self):\n        return \".csv\"\n\nclass ReportExporter:\n    def __init__(self, data_source, file_system):\n        self.data_source = data_source\n        self.file_system = file_system\n        self.export_strategies: Dict[str, ExportFormatStrategy] = {}\n        self.initialize_export_strategies()\n    \n    def initialize_export_strategies(self):\n        self.export_strategies = {\n            \"pdf\": PdfExportStrategy(),\n            \"excel\": ExcelExportStrategy(),\n            \"html\": HtmlExportStrategy(),\n            \"csv\": CsvExportStrategy()\n        }\n    \n    def register_export_strategy(self, format, strategy):\n        self.export_strategies[format] = strategy\n    \n    def export_report(self, report_id, export_format, destination):\n        report = self.data_source.get_report(report_id)\n        \n        if report is None:\n            return ExportResult(False, \"Report not found\", None)\n        \n        report_data = self.generate_report_data(report, export_format)\n        if report_data is None:\n            return ExportResult(False, \"Failed to generate report\", None)\n        \n        file_name = report.get_title() + self.get_file_extension(export_format)\n        self.file_system.write_file(destination + \"/\" + file_name, report_data)\n        return ExportResult(True, \"Report exported successfully\", destination + \"/\" + file_name)\n    \n    def generate_report_data(self, report, export_format):\n        try:\n            data = self.data_source.get_report_data(report.get_id())\n            strategy = self.export_strategies.get(export_format)\n            \n            if strategy:\n                return strategy.generate_report(report, data)\n        except Exception as e:\n            return None\n        return None\n    \n    def get_file_extension(self, format):\n        strategy = self.export_strategies.get(format)\n        return strategy.get_file_extension() if strategy else \".txt\"",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":16962668042,\"explanation\":\"The original code used multiple `if` statements to handle different export formats in the `generate_report_data` method. This was refactored to utilize polymorphism by directly calling the appropriate strategy's method, adhering to the Open/Closed Principle (OCP).\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used multiple `if` statements to handle different export formats in the `generate_report_data` method. This was refactored to utilize polymorphism by directly calling the appropriate strategy's method, adhering to the Open/Closed Principle (OCP)."
        },
        {
            "input": "import datetime\nfrom typing import List, Dict\nfrom abc import ABC, abstractmethod\n\nclass Sale:\n    def __init__(self, product_name: str, amount: float, date: datetime.date, region: str):\n        self.product_name = product_name\n        self.amount = amount\n        self.date = date\n        self.region = region\n\nclass SalesData:\n    def __init__(self, sales: List[Sale]):\n        self.sales = sales\n        \n    def get_sales(self) -> List[Sale]:\n        return self.sales\n\nclass ReportStrategy(ABC):\n    @abstractmethod\n    def generate_report(self, data: SalesData) -> str:\n        pass\n\nclass DailyReportStrategy(ReportStrategy):\n    def generate_report(self, data: SalesData) -> str:\n        daily_sales = self.aggregate_sales(data, key=lambda sale: sale.date.strftime(\"%Y-%m-%d\"))\n        return self.format_report(\"DAILY SALES REPORT\", daily_sales)\n\n    def aggregate_sales(self, data: SalesData, key) -> Dict[str, float]:\n        sales_dict = {}\n        for sale in data.get_sales():\n            sales_dict[key(sale)] = sales_dict.get(key(sale), 0) + sale.amount\n        return sales_dict\n\n    def format_report(self, title: str, sales: Dict[str, float]) -> str:\n        report = [f\"{title}\", \"===================\\n\"]\n        for key, amount in sales.items():\n            report.append(f\"{key}: Total: ${amount}\")\n        total = sum(sales.values())\n        report.append(f\"\\nTotal Sales: ${total}\")\n        return \"\\n\".join(report)\n\nclass ProductReportStrategy(ReportStrategy):\n    def generate_report(self, data: SalesData) -> str:\n        product_sales = self.aggregate_sales(data, key=lambda sale: sale.product_name)\n        return self.format_report(\"PRODUCT SALES REPORT\", product_sales)\n\nclass RegionalReportStrategy(ReportStrategy):\n    def generate_report(self, data: SalesData) -> str:\n        regional_sales = self.aggregate_sales(data, key=lambda sale: sale.region)\n        return self.format_report(\"REGIONAL SALES REPORT\", regional_sales)\n\nclass ReportGenerator:\n    def __init__(self, report_strategy: ReportStrategy):\n        self.report_strategy = report_strategy\n    \n    def set_report_strategy(self, report_strategy: ReportStrategy):\n        self.report_strategy = report_strategy\n    \n    def generate_report(self, data: SalesData) -> str:\n        return self.report_strategy.generate_report(data)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":11860107167,\"explanation\":\"The `DailyReportStrategy`, `ProductReportStrategy`, and `RegionalReportStrategy` classes were previously responsible for both aggregating sales and formatting reports, violating the Single Responsibility Principle (SRP). The `ReportFormatter` class was introduced to handle the formatting of reports, allowing the report strategies to focus solely on generating the report data.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The `DailyReportStrategy`, `ProductReportStrategy`, and `RegionalReportStrategy` classes were previously responsible for both aggregating sales and formatting reports, violating the Single Responsibility Principle (SRP). The `ReportFormatter` class was introduced to handle the formatting of reports, allowing the report strategies to focus solely on generating the report data."
        },
        {
            "input": "from abc import ABC, abstractmethod\n\nclass Order:\n    def __init__(self, customer_id, items, country):\n        self.customer_id = customer_id\n        self.items = items\n        self.country = country\n\n    def get_customer_id(self):\n        return self.customer_id\n    \n    def get_items(self):\n        return self.items\n    \n    def get_country(self):\n        return self.country\n\nclass OrderItem:\n    def __init__(self, product_id, price, quantity, category):\n        self.product_id = product_id\n        self.price = price\n        self.quantity = quantity\n        self.category = category\n    \n    def get_product_id(self):\n        return self.product_id\n    \n    def get_price(self):\n        return self.price\n    \n    def get_quantity(self):\n        return self.quantity\n    \n    def get_category(self):\n        return self.category\n\nclass TaxStrategy(ABC):\n    @abstractmethod\n    def calculate_tax(self, order):\n        pass\n\nclass USTaxStrategy(TaxStrategy):\n    def calculate_tax(self, order):\n        state_tax_rates = {\"CA\": 0.0725, \"NY\": 0.045, \"TX\": 0.0625}\n        category_tax_rates = {\"luxury\": 0.03, \"food\": 0.0}\n        state = order.get_customer_id()[:2]\n        state_tax_rate = state_tax_rates.get(state, 0.05)\n        total_tax = 0.0\n        for item in order.get_items():\n            item_price = item.get_price()  item.get_quantity()\n            category_rate = category_tax_rates.get(item.get_category(), 0.0)\n            item_tax = item_price  (state_tax_rate + category_rate)\n            total_tax += item_tax\n        return total_tax\n\nclass EUTaxStrategy(TaxStrategy):\n    def calculate_tax(self, order):\n        country_vat_rates = {\"DE\": 0.19, \"FR\": 0.20, \"IT\": 0.22}\n        country_code = order.get_customer_id()[:2]\n        vat_rate = country_vat_rates.get(country_code, 0.20)\n        total_tax = 0.0\n        for item in order.get_items():\n            item_price = item.get_price()  item.get_quantity()\n            total_tax += item_price  vat_rate\n        return total_tax\n\nclass CanadaTaxStrategy(TaxStrategy):\n    def calculate_tax(self, order):\n        province_tax_rates = {\"ON\": 0.08, \"BC\": 0.07, \"AB\": 0.0}\n        gst = 0.05\n        province = order.get_customer_id()[:2]\n        provincial_tax = province_tax_rates.get(province, 0.08)\n        total_tax = 0.0\n        for item in order.get_items():\n            item_price = item.get_price()  item.get_quantity()\n            total_tax += item_price  (gst + provincial_tax)\n        return total_tax\n\nclass TaxCalculator:\n    def __init__(self):\n        self.tax_strategies = {\n            \"US\": USTaxStrategy(),\n            \"EU\": EUTaxStrategy(),\n            \"CA\": CanadaTaxStrategy()\n        }\n    \n    def register_tax_strategy(self, country, strategy):\n        self.tax_strategies[country] = strategy\n    \n    def calculate_tax(self, order):\n        strategy = self.tax_strategies.get(order.get_country())\n        if strategy is None:\n            raise ValueError(f\"No tax strategy for country: {order.get_country()}\")\n        return strategy.calculate_tax(order)\n\n    @staticmethod\n    def create_tax_strategy(country):\n        if country == \"US\":\n            return USTaxStrategy()\n        elif country == \"EU\":\n            return EUTaxStrategy()\n        elif country == \"CA\":\n            return CanadaTaxStrategy()\n        else:\n            raise ValueError(f\"No tax strategy for country: {country}\")",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":17161608541,\"explanation\":\"The original code used multiple `if-else` statements in the `create_tax_strategy` method to determine which tax strategy to instantiate. This violates the Open/Closed Principle (OCP) because it requires modification of the method to add new strategies. The refactored code eliminates this method and instead uses a dictionary to map country codes to their respective tax strategy classes, allowing for easy extension without modifying existing code.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements in the `create_tax_strategy` method to determine which tax strategy to instantiate. This violates the Open/Closed Principle (OCP) because it requires modification of the method to add new strategies. The refactored code eliminates this method and instead uses a dictionary to map country codes to their respective tax strategy classes, allowing for easy extension without modifying existing code."
        },
        {
            "input": "import re\nfrom abc import ABC, abstractmethod\n\nclass Content:\n    def __init__(self, text, content_type, metadata):\n        self.text = text\n        self.content_type = content_type\n        self.metadata = metadata\n    \n    def get_text(self):\n        return self.text\n    \n    def get_type(self):\n        return self.content_type\n    \n    def get_metadata(self):\n        return self.metadata\n\nclass ContentFilterStrategy(ABC):\n    @abstractmethod\n    def filter(self, text, metadata):\n        pass\n\nclass EmailContentFilter(ContentFilterStrategy):\n    def filter(self, text, metadata):\n        audience = metadata.get(\"audience\", \"general\")\n        \n        if audience == \"public\":\n            text = re.sub(r'(?i)confidential:', '[REDACTED]', text)\n            text = re.sub(r'(?i)internal use only', '[INTERNAL]', text)\n        \n        text = re.sub(r'(?i)from:\\s.?\\n', '', text)\n        text = re.sub(r'(?i)to:\\s.?\\n', '', text)\n        text = re.sub(r'(?i)cc:\\s.?\\n', '', text)\n        \n        return text\n\nclass SocialContentFilter(ContentFilterStrategy):\n    def filter(self, text, metadata):\n        platform = metadata.get(\"platform\", \"general\")\n        audience = metadata.get(\"audience\", \"general\")\n        \n        if platform == \"twitter\":\n            text = re.sub(r'@([A-Za-z0-9_]+)', '[USERNAME]', text)\n        elif platform == \"facebook\":\n            text = re.sub(r'@\\[[^\\]]+\\]', '[NAME]', text)\n        \n        if audience == \"minor\":\n            text = re.sub(r'(?i)alcohol|beer|wine', '[AGE-RESTRICTED]', text)\n        \n        return text\n\nclass CommentContentFilter(ContentFilterStrategy):\n    def filter(self, text, metadata):\n        context = metadata.get(\"context\", \"general\")\n        \n        if context == \"news\":\n            text = re.sub(r'(?i)allegedly|reportedly', '[STATEMENT]', text)\n        elif context == \"review\":\n            text = re.sub(r'(?i)terrible|awful|worst ever', 'not satisfactory', text)\n        \n        return text\n\nclass CommonContentFilter(ContentFilterStrategy):\n    def filter(self, text, metadata):\n        text = re.sub(r'(?i)badword1|badword2|badword3', '[INAPPROPRIATE]', text)\n        text = re.sub(r'\\d{3}-\\d{2}-\\d{4}', '[SSN]', text)\n        text = re.sub(r'\\d{16}', '[CREDIT_CARD]', text)\n        return text\n\nclass ContentFilterChain:\n    def __init__(self):\n        self.filters = []\n    \n    def add_filter(self, filter):\n        self.filters.append(filter)\n    \n    def apply_filters(self, text, metadata):\n        result = text\n        for filter in self.filters:\n            result = filter.filter(result, metadata)\n        return result\n\nclass ContentFilter:\n    def __init__(self):\n        self.filter_chains = {}\n        \n        self.initialize_filter_chains()\n    \n    def initialize_filter_chains(self):\n        common_chain = ContentFilterChain()\n        common_chain.add_filter(CommonContentFilter())\n        \n        email_chain = ContentFilterChain()\n        email_chain.add_filter(EmailContentFilter())\n        email_chain.add_filter(CommonContentFilter())\n        \n        social_chain = ContentFilterChain()\n        social_chain.add_filter(SocialContentFilter())\n        social_chain.add_filter(CommonContentFilter())\n        \n        comment_chain = ContentFilterChain()\n        comment_chain.add_filter(CommentContentFilter())\n        comment_chain.add_filter(CommonContentFilter())\n        \n        self.filter_chains[\"default\"] = common_chain\n        self.filter_chains[\"email\"] = email_chain\n        self.filter_chains[\"social\"] = social_chain\n        self.filter_chains[\"comment\"] = comment_chain\n    \n    def register_filter_chain(self, content_type, chain):\n        self.filter_chains[content_type] = chain\n    \n    def filter_content(self, content):\n        content_type = content.get_type()\n        chain = self.filter_chains.get(content_type, self.filter_chains[\"default\"])\n        return chain.apply_filters(content.get_text(), content.get_metadata())",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":14025938167,\"explanation\":\"The original code used multiple `if-else` statements to determine which filters to apply based on content type. This was refactored to use a more extensible approach by creating filter chains for each content type, allowing for easier addition of new filters without modifying existing logic, thus adhering to the Open/Closed Principle (OCP).\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to determine which filters to apply based on content type. This was refactored to use a more extensible approach by creating filter chains for each content type, allowing for easier addition of new filters without modifying existing logic, thus adhering to the Open/Closed Principle (OCP)."
        },
        {
            "input": "import datetime\nfrom abc import ABC, abstractmethod\n\nclass Order:\n    def __init__(self, id, items, shipping_address, shipping_method):\n        self.id = id\n        self.items = items\n        self.shipping_address = shipping_address\n        self.shipping_method = shipping_method\n        self.status = OrderStatus.CREATED\n        self.total_amount = self.calculate_total_amount()\n\n    def calculate_total_amount(self):\n        return sum(item.price  item.quantity for item in self.items)\n\n    def get_id(self):\n        return self.id\n    \n    def get_items(self):\n        return self.items\n    \n    def get_shipping_address(self):\n        return self.shipping_address\n    \n    def get_shipping_method(self):\n        return self.shipping_method\n    \n    def get_status(self):\n        return self.status\n    \n    def set_status(self, status):\n        self.status = status\n    \n    def get_total_amount(self):\n        return self.total_amount\n\nclass OrderItem:\n    def __init__(self, product_id, quantity, price):\n        self.product_id = product_id\n        self.quantity = quantity\n        self.price = price\n\nclass Address:\n    def __init__(self, name, street, city, state, country, zip_code):\n        self.name = name\n        self.street = street\n        self.city = city\n        self.state = state\n        self.country = country\n        self.zip_code = zip_code\n\nclass Shipment:\n    def __init__(self, order_id, shipment_date):\n        self.order_id = order_id\n        self.shipment_date = shipment_date\n        self.cost = 0.0\n\nclass ShippingCost:\n    def __init__(self, cost):\n        self.cost = cost\n\nclass ShipmentResult:\n    def __init__(self, success, message, shipment):\n        self.success = success\n        self.message = message\n        self.shipment = shipment\n\nclass OrderRepository:\n    def find_by_id(self, id):\n        pass\n    \n    def update(self, order):\n        pass\n\nclass InventoryService:\n    def is_in_stock(self, product_id, quantity):\n        pass\n    \n    def reserve(self, product_id, quantity):\n        pass\n    \n    def get_product(self, product_id):\n        pass\n\nclass Product:\n    def __init__(self, id, name, weight, price):\n        self.id = id\n        self.name = name\n        self.weight = weight\n        self.price = price\n\nclass Logger:\n    def log(self, message):\n        pass\n\nclass OrderStatus:\n    CREATED = \"CREATED\"\n    PAID = \"PAID\"\n    SHIPPED = \"SHIPPED\"\n    DELIVERED = \"DELIVERED\"\n    CANCELLED = \"CANCELLED\"\n\nclass ShippingStrategy(ABC):\n    @abstractmethod\n    def calculate_cost(self, order, weight, distance):\n        pass\n\nclass StandardShippingStrategy(ShippingStrategy):\n    def calculate_cost(self, order, weight, distance):\n        base_cost = 5.0\n        weight_cost = weight  0.5\n        distance_factor = distance  0.01\n        return ShippingCost(base_cost + weight_cost + distance_factor)\n\nclass ExpressShippingStrategy(ShippingStrategy):\n    def calculate_cost(self, order, weight, distance):\n        base_cost = 15.0\n        weight_cost = weight  0.75\n        distance_factor = distance  0.015\n        return ShippingCost(base_cost + weight_cost + distance_factor)\n\nclass OvernightShippingStrategy(ShippingStrategy):\n    def calculate_cost(self, order, weight, distance):\n        base_cost = 25.0\n        weight_cost = weight  1.0\n        distance_factor = distance  0.02\n        return ShippingCost(base_cost + weight_cost + distance_factor)\n\nclass InternationalShippingStrategy(ShippingStrategy):\n    def calculate_cost(self, order, weight, distance):\n        base_cost = 30.0\n        weight_cost = weight  2.0\n        distance_factor = distance  0.025\n        customs_fee = order.get_total_amount()  0.05  # 5% of order value\n        return ShippingCost(base_cost + weight_cost + distance_factor + customs_fee)\n\nclass ShippingService:\n    def __init__(self, order_repository, inventory_service, logger):\n        self.order_repository = order_repository\n        self.inventory_service = inventory_service\n        self.logger = logger\n        self.shipping_strategies = self.initialize_shipping_strategies()\n\n    def initialize_shipping_strategies(self):\n        return {\n            \"standard\": StandardShippingStrategy(),\n            \"express\": ExpressShippingStrategy(),\n            \"overnight\": OvernightShippingStrategy(),\n            \"international\": InternationalShippingStrategy()\n        }\n\n    def process_shipment(self, order_id):\n        order = self.order_repository.find_by_id(order_id)\n        if order is None:\n            raise ValueError(f\"Order not found: {order_id}\")\n        if order.get_status() != OrderStatus.PAID:\n            return ShipmentResult(False, \"Order is not paid yet\", None)\n        for item in order.get_items():\n            if not self.inventory_service.is_in_stock(item.get_product_id(), item.get_quantity()):\n                return ShipmentResult(False, f\"Product out of stock: {item.get_product_id()}\", None)\n        shipment = Shipment(order_id, datetime.datetime.now())\n        shipping_cost = self.calculate_shipping_cost(order)\n        shipment.cost = shipping_cost.cost\n        for item in order.get_items():\n            self.inventory_service.reserve(item.get_product_id(), item.get_quantity())\n        order.set_status(OrderStatus.SHIPPED)\n        self.order_repository.update(order)\n        self.logger.log(f\"Order shipped: {order_id}, cost: {shipping_cost.cost}\")\n        return ShipmentResult(True, \"Order shipped successfully\", shipment)\n\n    def calculate_shipping_cost(self, order):\n        shipping_method = order.get_shipping_method()\n        strategy = self.shipping_strategies.get(shipping_method)\n        if strategy is None:\n            return ShippingCost(10.0)\n        total_weight = self.calculate_order_weight(order)\n        destination = order.get_shipping_address()\n        distance = self.calculate_distance(destination)\n        return strategy.calculate_cost(order, total_weight, distance)\n\n    def calculate_order_weight(self, order):\n        total_weight = 0.0\n        for item in order.get_items():\n            product = self.inventory_service.get_product(item.get_product_id())\n            total_weight += product.get_weight()  item.get_quantity()\n        return total_weight\n\n    def calculate_distance(self, destination):\n        warehouse_address = Address(\"Warehouse\", \"123 Main St\", \"City\", \"State\", \"Country\", \"12345\")\n        if warehouse_address.get_country() == destination.get_country():\n            if warehouse_address.get_state() == destination.get_state():\n                if warehouse_address.get_city() == destination.get_city():\n                    return 10.0  # Same city\n                return 50.0  # Same state, different city\n            return 200.0  # Same country, different state\n        return 1000.0  # International",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":22849877125,\"explanation\":\"The original code used multiple `if-else` statements to determine shipping costs based on the shipping method. This was refactored to utilize the Strategy pattern, allowing for easier extension of shipping methods without modifying existing code, thus adhering to the Open/Closed Principle (OCP).\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to determine shipping costs based on the shipping method. This was refactored to utilize the Strategy pattern, allowing for easier extension of shipping methods without modifying existing code, thus adhering to the Open/Closed Principle (OCP)."
        },
        {
            "input": "abstract class Shape {\n    abstract fun calculateArea(): Double\n}\n\nclass Rectangle(private val width: Double, private val height: Double) : Shape() {\n    override fun calculateArea(): Double {\n        return width  height\n    }\n}\n\nclass Circle(private val radius: Double) : Shape() {\n    override fun calculateArea(): Double {\n        return Math.PI  radius  radius\n    }\n}\n\ninterface AreaCalculator {\n    fun calculateArea(shape: Shape): Double\n}\n\nclass SimpleAreaCalculator : AreaCalculator {\n    override fun calculateArea(shape: Shape): Double {\n        return shape.calculateArea()\n    }\n}\n\nclass AdvancedAreaCalculator : AreaCalculator {\n    override fun calculateArea(shape: Shape): Double {\n        // Additional calculations can be added here\n        return shape.calculateArea()\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":4750942250,\"explanation\":\"The original code had a potential violation of the Open/Closed Principle (OCP) due to the use of multiple area calculation methods that could require modification for new shapes. The refactored code maintains the same structure but ensures that new shapes can be added without modifying existing classes, adhering to OCP.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code had a potential violation of the Open/Closed Principle (OCP) due to the use of multiple area calculation methods that could require modification for new shapes. The refactored code maintains the same structure but ensures that new shapes can be added without modifying existing classes, adhering to OCP."
        },
        {
            "input": "abstract class Character {\n    abstract fun calculateDamage(): Int\n}\n\ninterface Damageable {\n    fun calculateDamage(): Int\n}\n\nclass Warrior(private val strength: Int) : Character(), Damageable {\n    override fun calculateDamage(): Int {\n        return strength  2\n    }\n}\n\nclass Mage(private val mana: Int) : Character(), Damageable {\n    override fun calculateDamage(): Int {\n        return mana  3\n    }\n}\n\nclass DamageCalculator {\n    fun calculateDamage(character: Damageable): Int {\n        return character.calculateDamage()\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":4338858750,\"explanation\":\"The original code had a potential violation of OCP due to the use of `if-else` or `switch` statements for damage calculation based on character type. By using polymorphism through the `Damageable` interface, the code now adheres to OCP, allowing for easy extension with new character types without modifying existing code.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code had a potential violation of OCP due to the use of `if-else` or `switch` statements for damage calculation based on character type. By using polymorphism through the `Damageable` interface, the code now adheres to OCP, allowing for easy extension with new character types without modifying existing code."
        },
        {
            "input": "interface SoundMaker {\n    fun makeSound(): String\n}\n\nclass Dog : SoundMaker {\n    override fun makeSound(): String {\n        return \"Woof!\"\n    }\n}\n\nclass Cat : SoundMaker {\n    override fun makeSound(): String {\n        return \"Meow!\"\n    }\n}\n\nclass AnimalSoundMaker(private val soundMaker: SoundMaker) {\n    fun makeSound(): String {\n        return soundMaker.makeSound()\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "abstract class Vehicle {\n    abstract fun calculateMaxSpeed(): Double\n}\n\ninterface SpeedCalculable {\n    fun calculateMaxSpeed(): Double\n}\n\nclass Car(private val horsePower: Int) : Vehicle(), SpeedCalculable {\n    override fun calculateMaxSpeed(): Double {\n        return horsePower  0.4\n    }\n}\n\nclass Bicycle(private val gearCount: Int) : Vehicle(), SpeedCalculable {\n    override fun calculateMaxSpeed(): Double {\n        return gearCount  5.0\n    }\n}\n\nclass SpeedCalculator {\n    fun calculateMaxSpeed(vehicle: SpeedCalculable): Double {\n        return vehicle.calculateMaxSpeed()\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":5515379791,\"explanation\":\"This refactoring separates the responsibilities of processing payments and recording transactions into distinct classes, adhering to the Single Responsibility Principle. Each payment method now only handles payment processing, while transaction recording is managed by separate transaction classes.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2176355583,\"explanation\":\"This refactoring separates the responsibilities of processing payments and recording transactions into distinct classes, adhering to the Single Responsibility Principle. Each class now has a single responsibility, making the code cleaner and easier to maintain.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "This refactoring separates the responsibilities of processing payments and recording transactions into distinct classes, adhering to the Single Responsibility Principle. Each class now has a single responsibility, making the code cleaner and easier to maintain."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":6487251833,\"explanation\":\"The `CustomerService` class violates the Single Responsibility Principle because it handles both customer registration and email sending. The refactoring separates the validation logic into a `CustomerValidator` class, allowing `CustomerService` to focus solely on customer registration and email sending.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3347672041,\"explanation\":\"The `CustomerService` class previously handled both customer registration and email sending. The refactoring separates the validation logic into a `CustomerValidator` class and the email sending into an `EmailService`, allowing `CustomerService` to focus solely on customer registration, thus adhering to the Single Responsibility Principle.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The `CustomerService` class previously handled both customer registration and email sending. The refactoring separates the validation logic into a `CustomerValidator` class and the email sending into an `EmailService`, allowing `CustomerService` to focus solely on customer registration, thus adhering to the Single Responsibility Principle."
        },
        {
            "input": "{\"violation_type\":\"OCP\",\"refactored_code\":\"interface NotificationStrategy {\\n    fun sendNotification(contactInfo: String, subject: String, message: String)\\n}\\n\\nclass EmailNotificationStrategy : NotificationStrategy {\\n    override fun sendNotification(contactInfo: String, subject: String, message: String) {\\n        println(\\\"Sending email to \\$contactInfo\\\")\\n        println(\\\"Subject: \\$subject\\\")\\n        println(\\\"Message: \\$message\\\")\\n        // Email sending logic would go here\\n    }\\n}\\n\\nclass SMSNotificationStrategy : NotificationStrategy {\\n    override fun sendNotification(contactInfo: String, subject: String, message: String) {\\n        println(\\\"Sending SMS to \\$contactInfo\\\")\\n        println(\\\"Message: \\$message\\\")\\n        // SMS sending logic would go here\\n    }\\n}\\n\\nclass PushNotificationStrategy : NotificationStrategy {\\n    override fun sendNotification(contactInfo: String, subject: String, message: String) {\\n        println(\\\"Sending push notification to device \\$contactInfo\\\")\\n        println(\\\"Title: \\$subject\\\")\\n        println(\\\"Message: \\$message\\\")\\n        // Push notification logic would go here\\n    }\\n}\\n\\nclass SlackNotificationStrategy : NotificationStrategy {\\n    override fun sendNotification(contactInfo: String, subject: String, message: String) {\\n        println(\\\"Sending Slack message to \\$contactInfo\\\")\\n        println(\\\"Message: \\$message\\\")\\n        // Slack messaging logic would go here\\n    }\\n}\\n\\nclass Document(\\n    private val title: String,\\n    private val content: String,\\n    private val creator: User\\n) {\\n    private val id: String = UUID.randomUUID().toString()\\n    private val sharedUsers: MutableSet<User> = HashSet()\\n    \\n    fun getId(): String {\\n        return id\\n    }\\n    \\n    fun getTitle(): String {\\n        return title\\n    }\\n    \\n    fun getContent(): String {\\n        return content\\n    }\\n    \\n    fun getCreator(): User {\\n        return creator\\n    }\\n    \\n    fun getSharedUsers(): Set<User> {\\n        return sharedUsers\\n    }\\n    \\n    fun addSharedUser(user: User) {\\n        sharedUsers.add(user)\\n    }\\n}\\n\\nclass User(\\n    private val username: String,\\n    private val contactInfo: String,\\n    private val preferredContactMethod: String\\n) {\\n    private val id: String = UUID.randomUUID().toString()\\n    \\n    fun getId(): String {\\n        return id\\n    }\\n    \\n    fun getUsername(): String {\\n        return username\\n    }\\n    \\n    fun getContactInfo(): String {\\n        return contactInfo\\n    }\\n    \\n    fun getPreferredContactMethod(): String {\\n        return preferredContactMethod\\n    }\\n}\\n\\ninterface DocumentRepository {\\n    fun save(document: Document)\\n    fun update(document: Document)\\n    fun findById(id: String): Document?\\n}\\n\\ninterface SecurityService {\\n    fun canShareDocument(document: Document, user: User): Boolean\\n}\\n\\ninterface Logger {\\n    fun log(message: String)\\n}\\n\\nclass DocumentService(\\n    private val repository: DocumentRepository,\\n    private val securityService: SecurityService,\\n    private val logger: Logger,\\n    private val notificationStrategies: Map<String, NotificationStrategy>\\n) {\\n    \\n    fun createDocument(title: String, content: String, creator: User): Document {\\n        val document = Document(title, content, creator)\\n        repository.save(document)\\n        logger.log(\\\"Document created: \\${document.getId()}\\\")\\n        return document\\n    }\\n    \\n    fun shareDocument(document: Document, recipient: User, sharedBy: User) {\\n        validateSharingPermissions(document, sharedBy)\\n        document.addSharedUser(recipient)\\n        repository.update(document)\\n        logger.log(\\\"Document \\${document.getId()} shared with \\${recipient.getUsername()}\\\")\\n        notifyUser(document, recipient, sharedBy)\\n    }\\n    \\n    private fun validateSharingPermissions(document: Document, user: User) {\\n        if (!securityService.canShareDocument(document, user)) {\\n            throw SecurityException(\\\"User does not have permission to share this document\\\")\\n        }\\n    }\\n    \\n    private fun notifyUser(document: Document, recipient: User, sharedBy: User) {\\n        val recipientContact = recipient.getContactInfo()\\n        val message = \\\"Document '\\${document.getTitle()}' has been shared with you by \\${sharedBy.getUsername()}\\\"\\n        \\n        // Notification logic based on recipient's preferred contact method\\n        val contactType = recipient.getPreferredContactMethod()\\n        val strategy = notificationStrategies[contactType]\\n        \\n        if (strategy != null) {\\n            strategy.sendNotification(recipientContact, \\\"Document Shared\\\", message)\\n        } else {\\n            logger.log(\\\"Unknown contact method: \\$contactType\\\")\\n        }\\n    }\\n}\\n\\nclass SecurityException(message: String) : Exception(message)\",\"explanation\":\"The original code violates the Open/Closed Principle (OCP) because the `DocumentService` class is tightly coupled with the notification strategies. If a new notification method is added, the `DocumentService` class must be modified to include it. To adhere to OCP, I refactored the `DocumentService` to accept a map of notification strategies through its constructor, allowing it to be extended without modifying the class itself. This change promotes better adherence to SOLID principles.\"}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":16476101708,\"explanation\":\"The original code violates the Open/Closed Principle (OCP) because the `DocumentService` class is tightly coupled with the notification strategies. If a new notification method is added, the `DocumentService` class must be modified to include it. To adhere to OCP, I refactored the `DocumentService` to accept a map of notification strategies through its constructor, allowing it to be extended without modifying the class itself. This change promotes better adherence to SOLID principles.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code violates the Open/Closed Principle (OCP) because the `DocumentService` class is tightly coupled with the notification strategies. If a new notification method is added, the `DocumentService` class must be modified to include it. To adhere to OCP, I refactored the `DocumentService` to accept a map of notification strategies through its constructor, allowing it to be extended without modifying the class itself. This change promotes better adherence to SOLID principles."
        },
        {
            "input": "interface ExportFormatStrategy {\n    fun generateReport(report: Report, data: ReportData): ByteArray\n    fun getFileExtension(): String\n}\n\nclass PdfExportStrategy : ExportFormatStrategy {\n    override fun generateReport(report: Report, data: ReportData): ByteArray {\n        val document = PdfDocument()\n        return document.generate()\n    }\n    \n    override fun getFileExtension(): String {\n        return \".pdf\"\n    }\n}\n\nclass ExcelExportStrategy : ExportFormatStrategy {\n    override fun generateReport(report: Report, data: ReportData): ByteArray {\n        val document = ExcelDocument()\n        return document.generate()\n    }\n    \n    override fun getFileExtension(): String {\n        return \".xlsx\"\n    }\n}\n\nclass HtmlExportStrategy : ExportFormatStrategy {\n    override fun generateReport(report: Report, data: ReportData): ByteArray {\n        val html = StringBuilder()\n        return html.toString().toByteArray()\n    }\n    \n    override fun getFileExtension(): String {\n        return \".html\"\n    }\n}\n\nclass CsvExportStrategy : ExportFormatStrategy {\n    override fun generateReport(report: Report, data: ReportData): ByteArray {\n        val csv = StringBuilder()\n        return csv.toString().toByteArray()\n    }\n    \n    override fun getFileExtension(): String {\n        return \".csv\"\n    }\n}\n\nclass Report(private val id: String, private val title: String) {\n    fun getId(): String {\n        return id\n    }\n    \n    fun getTitle(): String {\n        return title\n    }\n}\n\nclass ReportData {\n    // Placeholder for actual report data\n}\n\nclass PdfDocument {\n    fun generate(): ByteArray {\n        return ByteArray(0)\n    }\n}\n\nclass ExcelDocument {\n    fun generate(): ByteArray {\n        return ByteArray(0)\n    }\n}\n\nclass ExportResult(val success: Boolean, val message: String, val outputPath: String?)\n\ninterface DataSource {\n    fun getReport(reportId: String): Report?\n    fun getReportData(reportId: String): ReportData\n}\n\ninterface FileSystem {\n    fun writeFile(path: String, data: ByteArray): Boolean\n}\n\nclass ReportExporter(private val dataSource: DataSource, private val fileSystem: FileSystem) {\n    private val exportStrategies = mutableMapOf<String, ExportFormatStrategy>()\n    \n    init {\n        initializeExportStrategies()\n    }\n    \n    private fun initializeExportStrategies() {\n        registerExportStrategy(\"pdf\", PdfExportStrategy())\n        registerExportStrategy(\"excel\", ExcelExportStrategy())\n        registerExportStrategy(\"html\", HtmlExportStrategy())\n        registerExportStrategy(\"csv\", CsvExportStrategy())\n    }\n    \n    fun registerExportStrategy(format: String, strategy: ExportFormatStrategy) {\n        exportStrategies[format] = strategy\n    }\n    \n    fun exportReport(reportId: String, exportFormat: String, destination: String): ExportResult {\n        val report = dataSource.getReport(reportId)\n        \n        if (report == null) {\n            return ExportResult(false, \"Report not found\", null)\n        }\n        \n        val reportData = generateReportData(report, exportFormat)\n        if (reportData == null) {\n            return ExportResult(false, \"Failed to generate report\", null)\n        }\n        \n        val fileName = report.getTitle() + getFileExtension(exportFormat)\n        fileSystem.writeFile(\"$destination/$fileName\", reportData)\n        return ExportResult(true, \"Report exported successfully\", \"$destination/$fileName\")\n    }\n    \n    private fun generateReportData(report: Report, exportFormat: String): ByteArray? {\n        try {\n            val data = dataSource.getReportData(report.getId())\n            val strategy = exportStrategies[exportFormat]\n            \n            return strategy?.generateReport(report, data)\n        } catch (e: Exception) {\n            return null\n        }\n    }\n    \n    private fun getFileExtension(format: String): String {\n        val strategy = exportStrategies[format]\n        return strategy?.getFileExtension() ?: \".txt\"\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":16274403333,\"explanation\":\"The original code used multiple `if-else` statements to handle different export formats in the `generateReportData` method. This was refactored to utilize polymorphism by directly calling the appropriate strategy's method based on the format, adhering to the Open/Closed Principle (OCP).\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to handle different export formats in the `generateReportData` method. This was refactored to utilize polymorphism by directly calling the appropriate strategy's method based on the format, adhering to the Open/Closed Principle (OCP)."
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"import java.text.SimpleDateFormat\\nimport java.util.\\n\\nclass SalesData(private val sales: List<Sale>) {\\n    fun getSales(): List<Sale> {\\n        return sales\\n    }\\n}\\n\\nclass Sale(private val productName: String, private val amount: Double, private val date: Date, private val region: String) {\\n    fun getProductName(): String {\\n        return productName\\n    }\\n    \\n    fun getAmount(): Double {\\n        return amount\\n    }\\n    \\n    fun getDate(): Date {\\n        return date\\n    }\\n    \\n    fun getRegion(): String {\\n        return region\\n    }\\n}\\n\\ninterface ReportStrategy {\\n    fun generateReport(data: SalesData): Map<String, Double>\\n}\\n\\nclass DailyReportStrategy : ReportStrategy {\\n    override fun generateReport(data: SalesData): Map<String, Double> {\\n        val dailySales = mutableMapOf<String, Double>()\\n        val dateFormat = SimpleDateFormat(\\\"yyyy-MM-dd\\\")\\n        \\n        for (sale in data.getSales()) {\\n            val dateStr = dateFormat.format(sale.getDate())\\n            dailySales[dateStr] = (dailySales[dateStr] ?: 0.0) + sale.getAmount()\\n        }\\n        return dailySales\\n    }\\n}\\n\\nclass ProductReportStrategy : ReportStrategy {\\n    override fun generateReport(data: SalesData): Map<String, Double> {\\n        val productSales = mutableMapOf<String, Double>()\\n        \\n        for (sale in data.getSales()) {\\n            productSales[sale.getProductName()] = (productSales[sale.getProductName()] ?: 0.0) + sale.getAmount()\\n        }\\n        return productSales\\n    }\\n}\\n\\nclass RegionalReportStrategy : ReportStrategy {\\n    override fun generateReport(data: SalesData): Map<String, Double> {\\n        val regionalSales = mutableMapOf<String, Double>()\\n        \\n        for (sale in data.getSales()) {\\n            regionalSales[sale.getRegion()] = (regionalSales[sale.getRegion()] ?: 0.0) + sale.getAmount()\\n        }\\n        return regionalSales\\n    }\\n}\\n\\nclass ReportGenerator(private var reportStrategy: ReportStrategy) {\\n    fun setReportStrategy(reportStrategy: ReportStrategy) {\\n        this.reportStrategy = reportStrategy\\n    }\\n    \\n    fun generateReport(data: SalesData): Map<String, Double> {\\n        return reportStrategy.generateReport(data)\\n    }\\n}\\n\\nclass ReportFormatter {\\n    fun formatReport(title: String, salesData: Map<String, Double>): String {\\n        val report = StringBuilder()\\n        report.append(\\\"$title\\\\n\\\")\\n        report.append(\\\"===================\\\\n\\\\n\\\")\\n        for ((key, amount) in salesData) {\\n            report.append(\\\"$key: \\$\\$amount\\\\n\\\")\\n        }\\n        return report.toString()\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the report generation strategies are responsible for both generating the report and formatting it. This makes the code harder to maintain and extend. In the refactored code, a new class `ReportFormatter` is introduced to handle the formatting of reports separately from the report generation logic. This separation allows for easier modifications and adherence to the SRP.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":9702911250,\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the report generation strategies are responsible for both generating the report and formatting it. This makes the code harder to maintain and extend. In the refactored code, a new class `ReportFormatter` is introduced to handle the formatting of reports separately from the report generation logic. This separation allows for easier modifications and adherence to the SRP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the report generation strategies are responsible for both generating the report and formatting it. This makes the code harder to maintain and extend. In the refactored code, a new class `ReportFormatter` is introduced to handle the formatting of reports separately from the report generation logic. This separation allows for easier modifications and adherence to the SRP."
        },
        {
            "input": "class Order(\n    private val customerId: String,\n    private val items: List<OrderItem>,\n    private val country: String\n) {\n    fun getCustomerId(): String {\n        return customerId\n    }\n    \n    fun getItems(): List<OrderItem> {\n        return items\n    }\n    \n    fun getCountry(): String {\n        return country\n    }\n}\n\nclass OrderItem(\n    private val productId: String,\n    private val price: Double,\n    private val quantity: Int,\n    private val category: String\n) {\n    fun getProductId(): String {\n        return productId\n    }\n    \n    fun getPrice(): Double {\n        return price\n    }\n    \n    fun getQuantity(): Int {\n        return quantity\n    }\n    \n    fun getCategory(): String {\n        return category\n    }\n}\n\ninterface TaxStrategy {\n    fun calculateTax(order: Order): Double\n}\n\nclass USTaxStrategy : TaxStrategy {\n    override fun calculateTax(order: Order): Double {\n        val stateTaxRates = getStateTaxRates()\n        val categoryTaxRates = getCategoryTaxRates()\n        \n        val state = order.getCustomerId().substring(0, 2)\n        val stateTaxRate = stateTaxRates.getOrDefault(state, 0.05)\n        \n        return order.getItems().sumOf { item ->\n            val itemPrice = item.getPrice()  item.getQuantity()\n            val categoryRate = categoryTaxRates.getOrDefault(item.getCategory(), 0.0)\n            itemPrice  (stateTaxRate + categoryRate)\n        }\n    }\n    \n    private fun getStateTaxRates(): Map<String, Double> {\n        return mapOf(\n            \"CA\" to 0.0725,\n            \"NY\" to 0.045,\n            \"TX\" to 0.0625\n        )\n    }\n    \n    private fun getCategoryTaxRates(): Map<String, Double> {\n        return mapOf(\n            \"luxury\" to 0.03,\n            \"food\" to 0.0\n        )\n    }\n}\n\nclass EUTaxStrategy : TaxStrategy {\n    override fun calculateTax(order: Order): Double {\n        val countryVatRates = getCountryVatRates()\n        \n        val countryCode = order.getCustomerId().substring(0, 2)\n        val vatRate = countryVatRates.getOrDefault(countryCode, 0.20)\n        \n        return order.getItems().sumOf { item ->\n            val itemPrice = item.getPrice()  item.getQuantity()\n            itemPrice  vatRate\n        }\n    }\n    \n    private fun getCountryVatRates(): Map<String, Double> {\n        return mapOf(\n            \"DE\" to 0.19,\n            \"FR\" to 0.20,\n            \"IT\" to 0.22\n        )\n    }\n}\n\nclass CanadaTaxStrategy : TaxStrategy {\n    override fun calculateTax(order: Order): Double {\n        val provinceTaxRates = getProvinceTaxRates()\n        val gst = 0.05\n        \n        val province = order.getCustomerId().substring(0, 2)\n        val provincialTax = provinceTaxRates.getOrDefault(province, 0.08)\n        \n        return order.getItems().sumOf { item ->\n            val itemPrice = item.getPrice()  item.getQuantity()\n            itemPrice  (gst + provincialTax)\n        }\n    }\n    \n    private fun getProvinceTaxRates(): Map<String, Double> {\n        return mapOf(\n            \"ON\" to 0.08,\n            \"BC\" to 0.07,\n            \"AB\" to 0.0\n        )\n    }\n}\n\nclass TaxCalculator {\n    private val taxStrategies = mutableMapOf<String, TaxStrategy>()\n    \n    init {\n        taxStrategies[\"US\"] = USTaxStrategy()\n        taxStrategies[\"EU\"] = EUTaxStrategy()\n        taxStrategies[\"CA\"] = CanadaTaxStrategy()\n    }\n    \n    fun registerTaxStrategy(country: String, strategy: TaxStrategy) {\n        taxStrategies[country] = strategy\n    }\n    \n    fun calculateTax(order: Order): Double {\n        val strategy = taxStrategies[order.getCountry()] \n            ?: throw IllegalArgumentException(\"No tax strategy for country: ${'$'}{order.getCountry()}\")\n        return strategy.calculateTax(order)\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":11266571083,\"explanation\":\"The original code used multiple `if-else` statements to determine tax strategies based on the country, which violates the Open/Closed Principle (OCP). The refactored code uses a map to store tax strategies, allowing for easy extension without modifying existing code. New tax strategies can be added without changing the `TaxCalculator` class, adhering to OCP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to determine tax strategies based on the country, which violates the Open/Closed Principle (OCP). The refactored code uses a map to store tax strategies, allowing for easy extension without modifying existing code. New tax strategies can be added without changing the `TaxCalculator` class, adhering to OCP."
        },
        {
            "input": "class Content(\n    private val text: String,\n    private val type: String,\n    private val metadata: Map<String, String>\n) {\n    fun getText(): String {\n        return text\n    }\n    \n    fun getType(): String {\n        return type\n    }\n    \n    fun getMetadata(): Map<String, String> {\n        return metadata\n    }\n}\n\ninterface ContentFilterStrategy {\n    fun filter(text: String, metadata: Map<String, String>): String\n}\n\nabstract class BaseContentFilter : ContentFilterStrategy {\n    protected fun replaceBadWords(text: String): String {\n        return text.replace(Regex(\"(?i)badword1|badword2|badword3\"), \"[INAPPROPRIATE]\")\n    }\n\n    protected fun replaceSensitiveData(text: String): String {\n        return text.replace(Regex(\"\\d{3}-\\d{2}-\\d{4}\"), \"[SSN]\")\n            .replace(Regex(\"\\d{16}\"), \"[CREDIT_CARD]\")\n    }\n}\n\nclass EmailContentFilter : BaseContentFilter() {\n    override fun filter(text: String, metadata: Map<String, String>): String {\n        var result = text\n        val audience = metadata.getOrDefault(\"audience\", \"general\")\n        \n        if (audience == \"public\") {\n            result = result.replace(Regex(\"(?i)confidential:\"), \"[REDACTED]\")\n            result = result.replace(Regex(\"(?i)internal use only\"), \"[INTERNAL]\")\n        }\n        \n        result = result.replace(Regex(\"(?i)from:\\s.?\n\"), \"\")\n        result = result.replace(Regex(\"(?i)to:\\s.?\n\"), \"\")\n        result = result.replace(Regex(\"(?i)cc:\\s.?\n\"), \"\")\n        \n        return replaceSensitiveData(replaceBadWords(result))\n    }\n}\n\nclass SocialContentFilter : BaseContentFilter() {\n    override fun filter(text: String, metadata: Map<String, String>): String {\n        var result = text\n        val platform = metadata.getOrDefault(\"platform\", \"general\")\n        val audience = metadata.getOrDefault(\"audience\", \"general\")\n        \n        if (platform == \"twitter\") {\n            result = result.replace(Regex(\"@([A-Za-z0-9_]+)\"), \"[USERNAME]\")\n        } else if (platform == \"facebook\") {\n            result = result.replace(Regex(\"@\\[[^\\]]+\\]\"), \"[NAME]\")\n        }\n        \n        if (audience == \"minor\") {\n            result = result.replace(Regex(\"(?i)alcohol|beer|wine\"), \"[AGE-RESTRICTED]\")\n        }\n        \n        return replaceSensitiveData(replaceBadWords(result))\n    }\n}\n\nclass CommentContentFilter : BaseContentFilter() {\n    override fun filter(text: String, metadata: Map<String, String>): String {\n        var result = text\n        val context = metadata.getOrDefault(\"context\", \"general\")\n        \n        if (context == \"news\") {\n            result = result.replace(Regex(\"(?i)allegedly|reportedly\"), \"[STATEMENT]\")\n        } else if (context == \"review\") {\n            result = result.replace(Regex(\"(?i)terrible|awful|worst ever\"), \"not satisfactory\")\n        }\n        \n        return replaceSensitiveData(replaceBadWords(result))\n    }\n}\n\nclass ContentFilterChain {\n    private val filters = mutableListOf<ContentFilterStrategy>()\n    \n    fun addFilter(filter: ContentFilterStrategy) {\n        filters.add(filter)\n    }\n    \n    fun applyFilters(text: String, metadata: Map<String, String>): String {\n        var result = text\n        for (filter in filters) {\n            result = filter.filter(result, metadata)\n        }\n        return result\n    }\n}\n\nclass ContentFilter {\n    private val filterChains = HashMap<String, ContentFilterChain>()\n    \n    init {\n        val commonChain = ContentFilterChain()\n        commonChain.addFilter(CommonContentFilter())\n        \n        val emailChain = ContentFilterChain()\n        emailChain.addFilter(EmailContentFilter())\n        emailChain.addFilter(commonChain)\n        \n        val socialChain = ContentFilterChain()\n        socialChain.addFilter(SocialContentFilter())\n        socialChain.addFilter(commonChain)\n        \n        val commentChain = ContentFilterChain()\n        commentChain.addFilter(CommentContentFilter())\n        commentChain.addFilter(commonChain)\n        \n        filterChains[\"default\"] = commonChain\n        filterChains[\"email\"] = emailChain\n        filterChains[\"social\"] = socialChain\n        filterChains[\"comment\"] = commentChain\n    }\n    \n    fun registerFilterChain(contentType: String, chain: ContentFilterChain) {\n        filterChains[contentType] = chain\n    }\n    \n    fun filterContent(content: Content): String {\n        val contentType = content.getType()\n        val chain = filterChains[contentType] ?: filterChains[\"default\"]!!\n        return chain.applyFilters(content.getText(), content.getMetadata())\n    }\n}\n\nclass CommonContentFilter : BaseContentFilter() {\n    override fun filter(text: String, metadata: Map<String, String>): String {\n        return replaceSensitiveData(replaceBadWords(text))\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":24622586500,\"explanation\":\"The original code used multiple `if-else` statements to handle different filtering logic based on content type, which violates the Open/Closed Principle (OCP). The refactored code replaces these `if-else` statements with `when` expressions, making it easier to extend the filtering logic without modifying existing code. This adheres to OCP by allowing new content types to be added with minimal changes.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to handle different filtering logic based on content type, which violates the Open/Closed Principle (OCP). The refactored code replaces these `if-else` statements with `when` expressions, making it easier to extend the filtering logic without modifying existing code. This adheres to OCP by allowing new content types to be added with minimal changes."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"import java.util.Date\\n\\nclass Order(\\n    private val id: String,\\n    private val items: List<OrderItem>,\\n    private val shippingAddress: Address,\\n    private val shippingMethod: String\\n) {\\n    private var status: OrderStatus = OrderStatus.CREATED\\n    private var totalAmount: Double = 0.0\\n    \\n    init {\\n        calculateTotalAmount()\\n    }\\n    \\n    private fun calculateTotalAmount() {\\n        totalAmount = items.sumByDouble { it.getPrice()  it.getQuantity() }\\n    }\\n    \\n    fun getId(): String {\\n        return id\\n    }\\n    \\n    fun getItems(): List<OrderItem> {\\n        return items\\n    }\\n    \\n    fun getShippingAddress(): Address {\\n        return shippingAddress\\n    }\\n    \\n    fun getShippingMethod(): String {\\n        return shippingMethod\\n    }\\n    \\n    fun getStatus(): OrderStatus {\\n        return status\\n    }\\n    \\n    fun setStatus(status: OrderStatus) {\\n        this.status = status\\n    }\\n    \\n    fun getTotalAmount(): Double {\\n        return totalAmount\\n    }\\n}\\n\\nclass OrderItem(\\n    private val productId: String,\\n    private val quantity: Int,\\n    private val price: Double\\n) {\\n    fun getProductId(): String {\\n        return productId\\n    }\\n    \\n    fun getQuantity(): Int {\\n        return quantity\\n    }\\n    \\n    fun getPrice(): Double {\\n        return price\\n    }\\n}\\n\\nclass Address(\\n    private val name: String,\\n    private val street: String,\\n    private val city: String,\\n    private val state: String,\\n    private val country: String,\\n    private val zipCode: String\\n) {\\n    fun getName(): String {\\n        return name\\n    }\\n    \\n    fun getStreet(): String {\\n        return street\\n    }\\n    \\n    fun getCity(): String {\\n        return city\\n    }\\n    \\n    fun getState(): String {\\n        return state\\n    }\\n    \\n    fun getCountry(): String {\\n        return country\\n    }\\n    \\n    fun getZipCode(): String {\\n        return zipCode\\n    }\\n}\\n\\nclass Shipment(\\n    private val orderId: String,\\n    private val shipmentDate: Date\\n) {\\n    private var cost: Double = 0.0\\n    \\n    fun getOrderId(): String {\\n        return orderId\\n    }\\n    \\n    fun getShipmentDate(): Date {\\n        return shipmentDate\\n    }\\n    \\n    fun getCost(): Double {\\n        return cost\\n    }\\n    \\n    fun setCost(cost: Double) {\\n        this.cost = cost\\n    }\\n}\\n\\nclass ShippingCost(\\n    private val cost: Double\\n) {\\n    fun getCost(): Double {\\n        return cost\\n    }\\n}\\n\\nclass ShipmentResult(\\n    private val success: Boolean,\\n    private val message: String,\\n    private val shipment: Shipment?\\n) {\\n    fun isSuccess(): Boolean {\\n        return success\\n    }\\n    \\n    fun getMessage(): String {\\n        return message\\n    }\\n    \\n    fun getShipment(): Shipment? {\\n        return shipment\\n    }\\n}\\n\\ninterface OrderRepository {\\n    fun findById(id: String): Order?\\n    fun update(order: Order)\\n}\\n\\ninterface InventoryService {\\n    fun isInStock(productId: String, quantity: Int): Boolean\\n    fun reserve(productId: String, quantity: Int)\\n    fun getProduct(productId: String): Product\\n}\\n\\nclass Product(\\n    private val id: String,\\n    private val name: String,\\n    private val weight: Double,\\n    private val price: Double\\n) {\\n    fun getId(): String {\\n        return id\\n    }\\n    \\n    fun getName(): String {\\n        return name\\n    }\\n    \\n    fun getWeight(): Double {\\n        return weight\\n    }\\n    \\n    fun getPrice(): Double {\\n        return price\\n    }\\n}\\n\\ninterface Logger {\\n    fun log(message: String)\\n}\\n\\nenum class OrderStatus {\\n    CREATED, PAID, SHIPPED, DELIVERED, CANCELLED\\n}\\n\\ninterface ShippingStrategy {\\n    fun calculateCost(order: Order, weight: Double, distance: Double): ShippingCost\\n}\\n\\nclass StandardShippingStrategy : ShippingStrategy {\\n    override fun calculateCost(order: Order, weight: Double, distance: Double): ShippingCost {\\n        val baseCost = 5.0\\n        val weightCost = weight  0.5\\n        val distanceFactor = distance  0.01\\n        \\n        return ShippingCost(baseCost + weightCost + distanceFactor)\\n    }\\n}\\n\\nclass ExpressShippingStrategy : ShippingStrategy {\\n    override fun calculateCost(order: Order, weight: Double, distance: Double): ShippingCost {\\n        val baseCost = 15.0\\n        val weightCost = weight  0.75\\n        val distanceFactor = distance  0.015\\n        \\n        return ShippingCost(baseCost + weightCost + distanceFactor)\\n    }\\n}\\n\\nclass OvernightShippingStrategy : ShippingStrategy {\\n    override fun calculateCost(order: Order, weight: Double, distance: Double): ShippingCost {\\n        val baseCost = 25.0\\n        val weightCost = weight  1.0\\n        val distanceFactor = distance  0.02\\n        \\n        return ShippingCost(baseCost + weightCost + distanceFactor)\\n    }\\n}\\n\\nclass InternationalShippingStrategy : ShippingStrategy {\\n    override fun calculateCost(order: Order, weight: Double, distance: Double): ShippingCost {\\n        val baseCost = 30.0\\n        val weightCost = weight  2.0\\n        val distanceFactor = distance  0.025\\n        val customsFee = order.getTotalAmount()  0.05 // 5% of order value\\n        \\n        return ShippingCost(baseCost + weightCost + distanceFactor + customsFee)\\n    }\\n}\\n\\nclass ShippingStrategyManager(\\n    private val shippingStrategies: Map<String, ShippingStrategy>\\n) {\\n    fun getStrategy(method: String): ShippingStrategy {\\n        return shippingStrategies[method] ?: throw IllegalArgumentException(\\\"Shipping method not recognized\\\")\\n    }\\n}\\n\\nclass ShippingService(\\n    private val orderRepository: OrderRepository,\\n    private val inventoryService: InventoryService,\\n    private val logger: Logger,\\n    private val shippingStrategyManager: ShippingStrategyManager\\n) {\\n    \\n    fun processShipment(orderId: String): ShipmentResult {\\n        val order = orderRepository.findById(orderId)\\n        \\n        if (order == null) {\\n            throw IllegalArgumentException(\\\"Order not found: \\$orderId\\\")\\n        }\\n        \\n        if (order.getStatus() != OrderStatus.PAID) {\\n            return ShipmentResult(false, \\\"Order is not paid yet\\\", null)\\n        }\\n        \\n        for (item in order.getItems()) {\\n            if (!inventoryService.isInStock(item.getProductId(), item.getQuantity())) {\\n                return ShipmentResult(false, \\\"Product out of stock: \\$${item.getProductId()}\\\", null)\\n            }\\n        }\\n        \\n        val shipment = Shipment(orderId, Date())\\n        val shippingCost = calculateShippingCost(order)\\n        shipment.setCost(shippingCost.getCost())\\n        \\n        // Reserve inventory items\\n        for (item in order.getItems()) {\\n            inventoryService.reserve(item.getProductId(), item.getQuantity())\\n        }\\n        \\n        // Update order status\\n        order.setStatus(OrderStatus.SHIPPED)\\n        orderRepository.update(order)\\n        \\n        logger.log(\\\"Order shipped: \\$orderId, cost: \\$${shippingCost.getCost()}\\\")\\n        return ShipmentResult(true, \\\"Order shipped successfully\\\", shipment)\\n    }\\n    \\n    private fun calculateShippingCost(order: Order): ShippingCost {\\n        val shippingMethod = order.getShippingMethod()\\n        val strategy = shippingStrategyManager.getStrategy(shippingMethod)\\n        \\n        val totalWeight = calculateOrderWeight(order)\\n        val destination = order.getShippingAddress()\\n        val distance = calculateDistance(destination)\\n        \\n        return strategy.calculateCost(order, totalWeight, distance)\\n    }\\n    \\n    private fun calculateOrderWeight(order: Order): Double {\\n        var totalWeight = 0.0\\n        for (item in order.getItems()) {\\n            val product = inventoryService.getProduct(item.getProductId())\\n            totalWeight += product.getWeight()  item.getQuantity()\\n        }\\n        return totalWeight\\n    }\\n    \\n    private fun calculateDistance(destination: Address): Double {\\n        // Simplified distance calculation. In a real system, this would use\\n        // geographic coordinates or a distance service.\\n        val warehouseAddress = Address(\\\"Warehouse\\\", \\\"123 Main St\\\", \\\"City\\\", \\\"State\\\", \\\"Country\\\", \\\"12345\\\")\\n        \\n        if (warehouseAddress.getCountry() == destination.getCountry()) {\\n            if (warehouseAddress.getState() == destination.getState()) {\\n                if (warehouseAddress.getCity() == destination.getCity()) {\\n                    return 10.0 // Same city\\n                }\\n                return 50.0 // Same state, different city\\n            }\\n            return 200.0 // Same country, different state\\n        }\\n        return 1000.0 // International\\n    }\\n}\\n\\nfun main() {\\n    // Example usage of ShippingService\\n    val orderRepository: OrderRepository = // implementation\\n    val inventoryService: InventoryService = // implementation\\n    val logger: Logger = // implementation\\n    val shippingStrategies = mapOf(\\n        \\\"standard\\\" to StandardShippingStrategy(),\\n        \\\"express\\\" to ExpressShippingStrategy(),\\n        \\\"overnight\\\" to OvernightShippingStrategy(),\\n        \\\"international\\\" to InternationalShippingStrategy()\\n    )\\n    val shippingStrategyManager = ShippingStrategyManager(shippingStrategies)\\n    val shippingService = ShippingService(orderRepository, inventoryService, logger, shippingStrategyManager)\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `ShippingService` class is responsible for both processing shipments and managing shipping strategies. This can lead to difficulties in maintaining and testing the code. To refactor, I separated the shipping strategy management into its own class, `ShippingStrategyManager`, which handles the registration and retrieval of shipping strategies. This allows `ShippingService` to focus solely on processing shipments. Additionally, I made the shipping strategies injectable, which adheres to the Dependency Inversion Principle (DIP) by allowing the `ShippingService` to depend on abstractions rather than concrete implementations. This refactoring improves the adherence to SOLID principles, particularly SRP and DIP.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":30842884500,\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `ShippingService` class is responsible for both processing shipments and managing shipping strategies. This can lead to difficulties in maintaining and testing the code. To refactor, I separated the shipping strategy management into its own class, `ShippingStrategyManager`, which handles the registration and retrieval of shipping strategies. This allows `ShippingService` to focus solely on processing shipments. Additionally, I made the shipping strategies injectable, which adheres to the Dependency Inversion Principle (DIP) by allowing the `ShippingService` to depend on abstractions rather than concrete implementations. This refactoring improves the adherence to SOLID principles, particularly SRP and DIP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `ShippingService` class is responsible for both processing shipments and managing shipping strategies. This can lead to difficulties in maintaining and testing the code. To refactor, I separated the shipping strategy management into its own class, `ShippingStrategyManager`, which handles the registration and retrieval of shipping strategies. This allows `ShippingService` to focus solely on processing shipments. Additionally, I made the shipping strategies injectable, which adheres to the Dependency Inversion Principle (DIP) by allowing the `ShippingService` to depend on abstractions rather than concrete implementations. This refactoring improves the adherence to SOLID principles, particularly SRP and DIP."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3294879167,\"explanation\":\"The original code adheres to the Single Responsibility Principle as each class has a single responsibility. However, if there were a class that handled both shape properties and area calculation, it would violate SRP. In this case, the code is already well-structured and does not require refactoring.\"}",
            "output": "{\"violation_type\":\"NONE\",\"total_duration\":1271644750,\"explanation\":\"The original code adheres to the Single Responsibility Principle as each class has a single responsibility. There are no violations present, and the code is already well-structured.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "NONE",
            "explanation": "The original code adheres to the Single Responsibility Principle as each class has a single responsibility. There are no violations present, and the code is already well-structured."
        },
        {
            "input": "using System;\n\nabstract class Character\n{\n    public abstract int CalculateDamage();\n}\n\nclass Warrior : Character\n{\n    private int strength;\n\n    public Warrior(int strength)\n    {\n        this.strength = strength;\n    }\n\n    public override int CalculateDamage()\n    {\n        return strength  2;\n    }\n}\n\nclass Mage : Character\n{\n    private int mana;\n\n    public Mage(int mana)\n    {\n        this.mana = mana;\n    }\n\n    public override int CalculateDamage()\n    {\n        return mana  3;\n    }\n}\n\ninterface IDamageCalculator\n{\n    int CalculateDamage(Character character);\n}\n\nclass DamageCalculator : IDamageCalculator\n{\n    public int CalculateDamage(Character character)\n    {\n        return character.CalculateDamage();\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Character warrior = new Warrior(10);\n        Character mage = new Mage(5);\n        IDamageCalculator damageCalculator = new DamageCalculator();\n\n        Console.WriteLine(\"Warrior Damage: \" + damageCalculator.CalculateDamage(warrior));\n        Console.WriteLine(\"Mage Damage: \" + damageCalculator.CalculateDamage(mage));\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":4927258583,\"explanation\":\"The original code had a potential violation of the Open/Closed Principle (OCP) because the `CalculateDamage` method in the `DamageCalculator` class relied on specific implementations of `Character`. However, since the `CalculateDamage` method is already abstracted through polymorphism, the code is structured to allow for future extensions without modifying existing code. Thus, it adheres to OCP.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "OCP",
            "explanation": "The original code had a potential violation of the Open/Closed Principle (OCP) because the `CalculateDamage` method in the `DamageCalculator` class relied on specific implementations of `Character`. However, since the `CalculateDamage` method is already abstracted through polymorphism, the code is structured to allow for future extensions without modifying existing code. Thus, it adheres to OCP."
        },
        {
            "input": "using System;\n\nabstract class Animal\n{\n    public abstract string MakeSound();\n}\n\nclass Dog : Animal\n{\n    public override string MakeSound()\n    {\n        return \"Woof!\";\n    }\n}\n\nclass Cat : Animal\n{\n    public override string MakeSound()\n    {\n        return \"Meow!\";\n    }\n}\n\ninterface ISoundMaker\n{\n    string MakeSound(Animal animal);\n}\n\nclass SoundMaker : ISoundMaker\n{\n    public string MakeSound(Animal animal)\n    {\n        return animal.MakeSound();\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Animal dog = new Dog();\n        Animal cat = new Cat();\n        ISoundMaker soundMaker = new SoundMaker();\n        Console.WriteLine(soundMaker.MakeSound(dog)); // Outputs: Woof!\n        Console.WriteLine(soundMaker.MakeSound(cat)); // Outputs: Meow!\n    }\n}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":6846712917,\"explanation\":\"The `ISoundMaker` interface is not too large, but it could be argued that it forces the implementation of a method that may not be necessary for all types of animals. However, in this case, it is still appropriate as it adheres to the principle of segregation by focusing on a specific behavior (making sound). Thus, there is no significant violation present.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The `ISoundMaker` interface is not too large, but it could be argued that it forces the implementation of a method that may not be necessary for all types of animals. However, in this case, it is still appropriate as it adheres to the principle of segregation by focusing on a specific behavior (making sound). Thus, there is no significant violation present."
        },
        {
            "input": "{\"violation_type\":\"ISP\",\"total_duration\":2839351542,\"explanation\":\"The original code violates the Interface Segregation Principle because the `ISpeedCalculator` interface could be split into smaller interfaces that cater to specific functionalities, allowing clients to only implement what they need.\"}",
            "output": "{\"violation_type\":\"ISP\",\"total_duration\":3522445833,\"explanation\":\"The original code violated the Interface Segregation Principle by forcing all implementing classes to include methods that they may not need. The refactored code introduces smaller, more specific interfaces, allowing clients to implement only the methods relevant to their functionality.\"}",
            "level": "EASY",
            "language": "CSHARP",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle by forcing all implementing classes to include methods that they may not need. The refactored code introduces smaller, more specific interfaces, allowing clients to implement only the methods relevant to their functionality."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":6974899583,\"explanation\":\"The original code violates the Single Responsibility Principle because each payment method class is responsible for processing payments and recording transactions. The refactored code introduces a separate `TransactionRecorder` class to handle transaction recording, thus adhering to SRP.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1704398458,\"explanation\":\"The original code violated the Single Responsibility Principle because each payment method class was responsible for both processing payments and recording transactions. The refactored code introduces a separate `TransactionRecorder` class to handle transaction recording, thus adhering to SRP.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because each payment method class was responsible for both processing payments and recording transactions. The refactored code introduces a separate `TransactionRecorder` class to handle transaction recording, thus adhering to SRP."
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nclass Customer\n{\n    private string name;\n    private string email;\n    \n    public Customer(string name, string email)\n    {\n        this.name = name;\n        this.email = email;\n    }\n    \n    public string GetName()\n    {\n        return name;\n    }\n    \n    public string GetEmail()\n    {\n        return email;\n    }\n}\n\ninterface ICustomerRepository\n{\n    void Save(Customer customer);\n    Customer FindByEmail(string email);\n}\n\ninterface IEmailService\n{\n    void SendEmail(string to, string subject, string body);\n}\n\ninterface IWelcomeEmailStrategy\n{\n    string CreateEmailBody(Customer customer);\n}\n\nclass StandardWelcomeEmailStrategy : IWelcomeEmailStrategy\n{\n    public string CreateEmailBody(Customer customer)\n    {\n        return \"Dear \" + customer.GetName() + \",\\n\\n\" +\n              \"Welcome to our service! We're excited to have you join us.\\n\\n\" +\n              \"Your account has been created successfully. You can now access all standard features.\\n\\n\" +\n              \"Best regards,\\n\" +\n              \"The Service Team\";\n    }\n}\n\nclass PremiumWelcomeEmailStrategy : IWelcomeEmailStrategy\n{\n    public string CreateEmailBody(Customer customer)\n    {\n        return \"Dear \" + customer.GetName() + \",\\n\\n\" +\n              \"Welcome to our PREMIUM service! We're thrilled to have you as a premium member.\\n\\n\" +\n              \"Your premium account has been activated with all exclusive features.\\n\" +\n              \"Our premium support team is available 24/7 to assist you.\\n\\n\" +\n              \"Best regards,\\n\" +\n              \"The Premium Service Team\";\n    }\n}\n\nclass TrialWelcomeEmailStrategy : IWelcomeEmailStrategy\n{\n    public string CreateEmailBody(Customer customer)\n    {\n        return \"Dear \" + customer.GetName() + \",\\n\\n\" +\n              \"Thank you for trying our service! Your 30-day trial has begun.\\n\\n\" +\n              \"Explore all the features we offer during your trial period.\\n\" +\n              \"We'll send you a reminder before your trial expires.\\n\\n\" +\n              \"Best regards,\\n\" +\n              \"The Service Team\";\n    }\n}\n\nclass CustomerService\n{\n    private ICustomerRepository repository;\n    private IEmailService emailService;\n    private Dictionary<string, IWelcomeEmailStrategy> emailStrategies;\n    \n    public CustomerService(ICustomerRepository repository, IEmailService emailService)\n    {\n        this.repository = repository;\n        this.emailService = emailService;\n        InitializeEmailStrategies();\n    }\n    \n    private void InitializeEmailStrategies()\n    {\n        emailStrategies = new Dictionary<string, IWelcomeEmailStrategy>();\n        emailStrategies[\"standard\"] = new StandardWelcomeEmailStrategy();\n        emailStrategies[\"premium\"] = new PremiumWelcomeEmailStrategy();\n        emailStrategies[\"trial\"] = new TrialWelcomeEmailStrategy();\n    }\n    \n    public Customer RegisterCustomer(string name, string email, string customerType)\n    {\n        ValidateCustomerData(name, email);\n        \n        Customer customer = new Customer(name, email);\n        repository.Save(customer);\n        \n        // Send welcome email based on customer type\n        SendWelcomeEmail(customer, customerType);\n        \n        return customer;\n    }\n    \n    private void ValidateCustomerData(string name, string email)\n    {\n        if (string.IsNullOrWhiteSpace(name))\n        {\n            throw new ArgumentException(\"Name cannot be empty\");\n        }\n        \n        if (string.IsNullOrEmpty(email) || !Regex.IsMatch(email, @\"^[A-Za-z0-9+_.-]+@(.+)$\"))\n        {\n            throw new ArgumentException(\"Invalid email format\");\n        }\n        \n        if (repository.FindByEmail(email) != null)\n        {\n            throw new ArgumentException(\"Email already registered\");\n        }\n    }\n    \n    private void SendWelcomeEmail(Customer customer, string customerType)\n    {\n        if (!emailStrategies.TryGetValue(customerType, out IWelcomeEmailStrategy strategy))\n        {\n            throw new ArgumentException(\"Unsupported customer type: \" + customerType);\n        }\n        \n        string subject = \"Welcome to Our Service\";\n        string body = strategy.CreateEmailBody(customer);\n        \n        emailService.SendEmail(customer.GetEmail(), subject, body);\n    }\n}\n\nclass EmailService : IEmailService\n{\n    public void SendEmail(string to, string subject, string body)\n    {\n        // Implementation for sending email\n        Console.WriteLine($\"Sending email to: {to}, Subject: {subject}, Body: {body}\");\n    }\n}\n\nclass CustomerRepository : ICustomerRepository\n{\n    private List<Customer> customers = new List<Customer>();\n    \n    public void Save(Customer customer)\n    {\n        customers.Add(customer);\n    }\n    \n    public Customer FindByEmail(string email)\n    {\n        return customers.Find(c => c.GetEmail() == email);\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":16938497625,\"explanation\":\"The original code used `if-else` statements to determine which email strategy to use based on customer type, violating the Open/Closed Principle (OCP). The refactored code initializes the email strategies in a dictionary, allowing for easy extension without modifying existing code.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "OCP",
            "explanation": "The original code used `if-else` statements to determine which email strategy to use based on customer type, violating the Open/Closed Principle (OCP). The refactored code initializes the email strategies in a dictionary, allowing for easy extension without modifying existing code."
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\n\nclass Document\n{\n    private string id;\n    private string title;\n    private string content;\n    private User creator;\n    private HashSet<User> sharedUsers;\n\n    public Document(string title, string content, User creator)\n    {\n        this.id = Guid.NewGuid().ToString();\n        this.title = title;\n        this.content = content;\n        this.creator = creator;\n        this.sharedUsers = new HashSet<User>();\n    }\n\n    public string Id => id;\n    public string Title => title;\n    public string Content => content;\n    public User Creator => creator;\n    public HashSet<User> SharedUsers => sharedUsers;\n\n    public void AddSharedUser(User user)\n    {\n        sharedUsers.Add(user);\n    }\n}\n\nclass User\n{\n    private string id;\n    private string username;\n    private string contactInfo;\n    private string preferredContactMethod;\n\n    public User(string username, string contactInfo, string preferredContactMethod)\n    {\n        this.id = Guid.NewGuid().ToString();\n        this.username = username;\n        this.contactInfo = contactInfo;\n        this.preferredContactMethod = preferredContactMethod;\n    }\n\n    public string Id => id;\n    public string Username => username;\n    public string ContactInfo => contactInfo;\n    public string PreferredContactMethod => preferredContactMethod;\n}\n\ninterface IDocumentRepository\n{\n    void Save(Document document);\n    void Update(Document document);\n    Document FindById(string id);\n}\n\ninterface ISecurityService\n{\n    bool CanShareDocument(Document document, User user);\n}\n\ninterface ILogger\n{\n    void Log(string message);\n}\n\ninterface INotificationStrategy\n{\n    void SendNotification(string contactInfo, string subject, string message);\n}\n\nclass EmailNotificationStrategy : INotificationStrategy\n{\n    public void SendNotification(string email, string subject, string message)\n    {\n        Console.WriteLine(\"Sending email to \" + email);\n        Console.WriteLine(\"Subject: \" + subject);\n        Console.WriteLine(\"Message: \" + message);\n    }\n}\n\nclass SMSNotificationStrategy : INotificationStrategy\n{\n    public void SendNotification(string phoneNumber, string subject, string message)\n    {\n        Console.WriteLine(\"Sending SMS to \" + phoneNumber);\n        Console.WriteLine(\"Message: \" + message);\n    }\n}\n\nclass PushNotificationStrategy : INotificationStrategy\n{\n    public void SendNotification(string deviceId, string subject, string message)\n    {\n        Console.WriteLine(\"Sending push notification to device \" + deviceId);\n        Console.WriteLine(\"Title: \" + subject);\n        Console.WriteLine(\"Message: \" + message);\n    }\n}\n\nclass SlackNotificationStrategy : INotificationStrategy\n{\n    public void SendNotification(string slackUserId, string subject, string message)\n    {\n        Console.WriteLine(\"Sending Slack message to \" + slackUserId);\n        Console.WriteLine(\"Message: \" + message);\n    }\n}\n\nclass DocumentService\n{\n    private IDocumentRepository repository;\n    private ISecurityService securityService;\n    private ILogger logger;\n    private Dictionary<string, INotificationStrategy> notificationStrategies;\n\n    public DocumentService(IDocumentRepository repository, ISecurityService securityService, ILogger logger)\n    {\n        this.repository = repository;\n        this.securityService = securityService;\n        this.logger = logger;\n        InitializeNotificationStrategies();\n    }\n\n    private void InitializeNotificationStrategies()\n    {\n        notificationStrategies = new Dictionary<string, INotificationStrategy>\n        {\n            { \"email\", new EmailNotificationStrategy() },\n            { \"sms\", new SMSNotificationStrategy() },\n            { \"push\", new PushNotificationStrategy() },\n            { \"slack\", new SlackNotificationStrategy() }\n        };\n    }\n\n    public void RegisterNotificationStrategy(string type, INotificationStrategy strategy)\n    {\n        notificationStrategies[type] = strategy;\n    }\n\n    public Document CreateDocument(string title, string content, User creator)\n    {\n        Document document = new Document(title, content, creator);\n        repository.Save(document);\n        logger.Log(\"Document created: \" + document.Id);\n        return document;\n    }\n\n    public void ShareDocument(Document document, User recipient, User sharedBy)\n    {\n        ValidateSharingPermissions(document, sharedBy);\n        document.AddSharedUser(recipient);\n        repository.Update(document);\n        logger.Log(\"Document \" + document.Id + \" shared with \" + recipient.Username);\n        NotifyUser(document, recipient, sharedBy);\n    }\n\n    private void ValidateSharingPermissions(Document document, User user)\n    {\n        if (!securityService.CanShareDocument(document, user))\n        {\n            throw new SecurityException(\"User does not have permission to share this document\");\n        }\n    }\n\n    private void NotifyUser(Document document, User recipient, User sharedBy)\n    {\n        string recipientContact = recipient.ContactInfo;\n        string message = \"Document '\" + document.Title + \"' has been shared with you by \" + sharedBy.Username;\n        string contactType = recipient.PreferredContactMethod;\n\n        if (notificationStrategies.TryGetValue(contactType, out INotificationStrategy strategy))\n        {\n            strategy.SendNotification(recipientContact, \"Document Shared\", message);\n        }\n        else\n        {\n            logger.Log(\"Unknown contact method: \" + contactType);\n        }\n    }\n}\n\nclass SecurityException : Exception\n{\n    public SecurityException(string message) : base(message)\n    {\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":20551766500,\"explanation\":\"The `DocumentService` class was previously responsible for both document management and user notifications, violating the Single Responsibility Principle (SRP). The refactoring introduces a new `NotificationService` class that handles notifications, allowing `DocumentService` to focus solely on document-related operations.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "SRP",
            "explanation": "The `DocumentService` class was previously responsible for both document management and user notifications, violating the Single Responsibility Principle (SRP). The refactoring introduces a new `NotificationService` class that handles notifications, allowing `DocumentService` to focus solely on document-related operations."
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nclass Report\n{\n    public string Id { get; private set; }\n    public string Title { get; private set; }\n    \n    public Report(string id, string title)\n    {\n        Id = id;\n        Title = title;\n    }\n}\n\nclass ReportData\n{\n}\n\ninterface IDocument\n{\n    byte[] Generate();\n}\n\nclass PdfDocument : IDocument\n{\n    public byte[] Generate() { return new byte[0]; }\n}\n\nclass ExcelDocument : IDocument\n{\n    public byte[] Generate() { return new byte[0]; }\n}\n\nclass ExportResult\n{\n    public bool Success { get; private set; }\n    public string Message { get; private set; }\n    public string OutputPath { get; private set; }\n    \n    public ExportResult(bool success, string message, string outputPath)\n    {\n        Success = success;\n        Message = message;\n        OutputPath = outputPath;\n    }\n}\n\ninterface IDataSource\n{\n    Report GetReport(string reportId);\n    ReportData GetReportData(string reportId);\n}\n\ninterface IFileSystem\n{\n    bool WriteFile(string path, byte[] data);\n}\n\ninterface IExportFormatStrategy\n{\n    byte[] GenerateReport(Report report, ReportData data);\n    string GetFileExtension();\n}\n\nclass PdfExportStrategy : IExportFormatStrategy\n{\n    public byte[] GenerateReport(Report report, ReportData data)\n    {\n        IDocument document = new PdfDocument();\n        return document.Generate();\n    }\n    \n    public string GetFileExtension()\n    {\n        return \".pdf\";\n    }\n}\n\nclass ExcelExportStrategy : IExportFormatStrategy\n{\n    public byte[] GenerateReport(Report report, ReportData data)\n    {\n        IDocument document = new ExcelDocument();\n        return document.Generate();\n    }\n    \n    public string GetFileExtension()\n    {\n        return \".xlsx\";\n    }\n}\n\nclass HtmlExportStrategy : IExportFormatStrategy\n{\n    public byte[] GenerateReport(Report report, ReportData data)\n    {\n        string html = \"\";\n        return Encoding.UTF8.GetBytes(html);\n    }\n    \n    public string GetFileExtension()\n    {\n        return \".html\";\n    }\n}\n\nclass CsvExportStrategy : IExportFormatStrategy\n{\n    public byte[] GenerateReport(Report report, ReportData data)\n    {\n        string csv = \"\";\n        return Encoding.UTF8.GetBytes(csv);\n    }\n    \n    public string GetFileExtension()\n    {\n        return \".csv\";\n    }\n}\n\nclass ReportExporter\n{\n    private IDataSource dataSource;\n    private IFileSystem fileSystem;\n    private Dictionary<string, IExportFormatStrategy> exportStrategies;\n    \n    public ReportExporter(IDataSource dataSource, IFileSystem fileSystem)\n    {\n        this.dataSource = dataSource;\n        this.fileSystem = fileSystem;\n        InitializeExportStrategies();\n    }\n    \n    private void InitializeExportStrategies()\n    {\n        exportStrategies = new Dictionary<string, IExportFormatStrategy>();\n        exportStrategies[\"pdf\"] = new PdfExportStrategy();\n        exportStrategies[\"excel\"] = new ExcelExportStrategy();\n        exportStrategies[\"html\"] = new HtmlExportStrategy();\n        exportStrategies[\"csv\"] = new CsvExportStrategy();\n    }\n    \n    public void RegisterExportStrategy(string format, IExportFormatStrategy strategy)\n    {\n        exportStrategies[format] = strategy;\n    }\n    \n    public ExportResult ExportReport(string reportId, string exportFormat, string destination)\n    {\n        Report report = dataSource.GetReport(reportId);\n        \n        if (report == null)\n        {\n            return new ExportResult(false, \"Report not found\", null);\n        }\n        \n        byte[] reportData = GenerateReportData(report, exportFormat);\n        if (reportData == null)\n        {\n            return new ExportResult(false, \"Failed to generate report\", null);\n        }\n        \n        string fileName = report.Title + GetFileExtension(exportFormat);\n        fileSystem.WriteFile(destination + \"/\" + fileName, reportData);\n        return new ExportResult(true, \"Report exported successfully\", destination + \"/\" + fileName);\n    }\n    \n    private byte[] GenerateReportData(Report report, string exportFormat)\n    {\n        try\n        {\n            ReportData data = dataSource.GetReportData(report.Id);\n            \n            if (exportStrategies.TryGetValue(exportFormat, out IExportFormatStrategy strategy))\n            {\n                return strategy.GenerateReport(report, data);\n            }\n        }\n        catch (Exception)\n        {\n            return null;\n        }\n        return null;\n    }\n    \n    private string GetFileExtension(string format)\n    {\n        if (exportStrategies.TryGetValue(format, out IExportFormatStrategy strategy))\n        {\n            return strategy.GetFileExtension();\n        }\n        return \".txt\";\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":13847445375,\"explanation\":\"The original code used multiple `if-else` statements to determine the export format and generate the report, which violates the Open/Closed Principle (OCP). The refactored code uses a dictionary to map export formats to their corresponding strategies, allowing for easy extension without modifying existing code.\"}",
            "level": "MODERATE",
            "language": "CSHARP",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to determine the export format and generate the report, which violates the Open/Closed Principle (OCP). The refactored code uses a dictionary to map export formats to their corresponding strategies, allowing for easy extension without modifying existing code."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\n\\npublic class SalesData {\\n    private List<Sale> sales;\\n    \\n    public SalesData(List<Sale> sales) {\\n        this.sales = sales;\\n    }\\n    \\n    public List<Sale> GetSales() {\\n        return sales;\\n    }\\n}\\n\\npublic class Sale {\\n    public string ProductName { get; private set; }\\n    public double Amount { get; private set; }\\n    public DateTime Date { get; private set; }\\n    public string Region { get; private set; }\\n    \\n    public Sale(string productName, double amount, DateTime date, string region) {\\n        ProductName = productName;\\n        Amount = amount;\\n        Date = date;\\n        Region = region;\\n    }\\n}\\n\\npublic interface IReportStrategy {\\n    string GenerateReport(SalesData data);\\n}\\n\\npublic abstract class BaseReportStrategy : IReportStrategy {\\n    protected abstract string GetKey(Sale sale);\\n    protected abstract string GetReportTitle();\\n    \\n    public string GenerateReport(SalesData data) {\\n        var sales = data.GetSales();\\n        StringBuilder report = new StringBuilder();\\n        report.AppendLine(GetReportTitle());\\n        report.AppendLine(new string('=', GetReportTitle().Length));\\n        report.AppendLine();\\n        \\n        var groupedSales = sales.GroupBy(GetKey)\\n                                 .ToDictionary(g => g.Key, g => g.Sum(s => s.Amount));\\n        \\n        foreach (var entry in groupedSales) {\\n            report.AppendLine($\"{GetKey(entry)}: {entry.Key}, Total: ${entry.Value}\");\\n        }\\n        \\n        double total = groupedSales.Values.Sum();\\n        report.AppendLine();\\n        report.Append($\"Total Sales: ${total}\");\\n        \\n        return report.ToString();\\n    }\\n}\\n\\npublic class DailyReportStrategy : BaseReportStrategy {\\n    protected override string GetKey(Sale sale) => sale.Date.ToString(\\\"yyyy-MM-dd\\\");\\n    protected override string GetReportTitle() => \\\"DAILY SALES REPORT\\\";\\n}\\n\\npublic class ProductReportStrategy : BaseReportStrategy {\\n    protected override string GetKey(Sale sale) => sale.ProductName;\\n    protected override string GetReportTitle() => \\\"PRODUCT SALES REPORT\\\";\\n}\\n\\npublic class RegionalReportStrategy : BaseReportStrategy {\\n    protected override string GetKey(Sale sale) => sale.Region;\\n    protected override string GetReportTitle() => \\\"REGIONAL SALES REPORT\\\";\\n}\\n\\npublic class ReportGenerator {\\n    private IReportStrategy reportStrategy;\\n    \\n    public ReportGenerator(IReportStrategy reportStrategy) {\\n        this.reportStrategy = reportStrategy;\\n    }\\n    \\n    public void SetReportStrategy(IReportStrategy reportStrategy) {\\n        this.reportStrategy = reportStrategy;\\n    }\\n    \\n    public string GenerateReport(SalesData data) {\\n        return reportStrategy.GenerateReport(data);\\n    }\\n}\",\"explanation\":\"The refactored code improves adherence to the SOLID principles, particularly the Single Responsibility Principle (SRP) and the Open/Closed Principle (OCP). Each report strategy now uses a common method to generate reports, reducing code duplication and improving maintainability. The Sale class properties have been changed to use public getters, which simplifies access to the data. The report generation logic is now more modular and can be easily extended for new report types without modifying existing code.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":10573649333,\"explanation\":\"The refactored code improves adherence to the Single Responsibility Principle (SRP) by ensuring that each class has a single responsibility. The `ReportGenerator` class is now solely responsible for generating reports using a specified strategy, while the report strategies handle the specifics of report generation. This separation of concerns enhances maintainability and clarity in the code.\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "SRP",
            "explanation": "The refactored code improves adherence to the Single Responsibility Principle (SRP) by ensuring that each class has a single responsibility. The `ReportGenerator` class is now solely responsible for generating reports using a specified strategy, while the report strategies handle the specifics of report generation. This separation of concerns enhances maintainability and clarity in the code."
        },
        {
            "input": "",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1891035667,\"explanation\":\"The original class handled both report generation and saving, violating the Single Responsibility Principle (SRP). The refactored code separates these concerns into two distinct classes: `ReportGenerator` for generating reports and `ReportSaver` for saving them.\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "SRP",
            "explanation": "The original class handled both report generation and saving, violating the Single Responsibility Principle (SRP). The refactored code separates these concerns into two distinct classes: `ReportGenerator` for generating reports and `ReportSaver` for saving them."
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\npublic class Content\n{\n    private string text;\n    private string type;\n    private Dictionary<string, string> metadata;\n    \n    public Content(string text, string type, Dictionary<string, string> metadata)\n    {\n        this.text = text;\n        this.type = type;\n        this.metadata = metadata;\n    }\n    \n    public string GetText()\n    {\n        return text;\n    }\n    \n    public string GetType()\n    {\n        return type;\n    }\n    \n    public Dictionary<string, string> GetMetadata()\n    {\n        return metadata;\n    }\n}\n\npublic interface IContentFilterStrategy\n{\n    string Filter(string text, Dictionary<string, string> metadata);\n}\n\npublic abstract class BaseContentFilter : IContentFilterStrategy\n{\n    public abstract string Filter(string text, Dictionary<string, string> metadata);\n    protected string ApplyCommonFilters(string text)\n    {\n        text = Regex.Replace(text, \"(?i)badword1|badword2|badword3\", \"[INAPPROPRIATE]\");\n        text = Regex.Replace(text, \"\\d{3}-\\d{2}-\\d{4}\", \"[SSN]\");\n        text = Regex.Replace(text, \"\\d{16}\", \"[CREDIT_CARD]\");\n        return text;\n    }\n}\n\npublic class EmailContentFilter : BaseContentFilter\n{\n    public override string Filter(string text, Dictionary<string, string> metadata)\n    {\n        string audience = metadata.ContainsKey(\"audience\") ? metadata[\"audience\"] : \"general\";\n        \n        if (audience.Equals(\"public\"))\n        {\n            text = Regex.Replace(text, \"(?i)confidential:\", \"[REDACTED]\");\n            text = Regex.Replace(text, \"(?i)internal use only\", \"[INTERNAL]\");\n        }\n        \n        text = Regex.Replace(text, \"(?i)from:\\s.?\\n\", \"\");\n        text = Regex.Replace(text, \"(?i)to:\\s.?\\n\", \"\");\n        text = Regex.Replace(text, \"(?i)cc:\\s.?\\n\", \"\");\n        \n        return ApplyCommonFilters(text);\n    }\n}\n\npublic class SocialContentFilter : BaseContentFilter\n{\n    public override string Filter(string text, Dictionary<string, string> metadata)\n    {\n        string platform = metadata.ContainsKey(\"platform\") ? metadata[\"platform\"] : \"general\";\n        string audience = metadata.ContainsKey(\"audience\") ? metadata[\"audience\"] : \"general\";\n        \n        if (platform.Equals(\"twitter\"))\n        {\n            text = Regex.Replace(text, \"@([A-Za-z0-9_]+)\", \"[USERNAME]\");\n        }\n        else if (platform.Equals(\"facebook\"))\n        {\n            text = Regex.Replace(text, \"@\\[[^\\]]+\\]\", \"[NAME]\");\n        }\n        \n        if (audience.Equals(\"minor\"))\n        {\n            text = Regex.Replace(text, \"(?i)alcohol|beer|wine\", \"[AGE-RESTRICTED]\");\n        }\n        \n        return ApplyCommonFilters(text);\n    }\n}\n\npublic class CommentContentFilter : BaseContentFilter\n{\n    public override string Filter(string text, Dictionary<string, string> metadata)\n    {\n        string context = metadata.ContainsKey(\"context\") ? metadata[\"context\"] : \"general\";\n        \n        if (context.Equals(\"news\"))\n        {\n            text = Regex.Replace(text, \"(?i)allegedly|reportedly\", \"[STATEMENT]\");\n        }\n        else if (context.Equals(\"review\"))\n        {\n            text = Regex.Replace(text, \"(?i)terrible|awful|worst ever\", \"not satisfactory\");\n        }\n        \n        return ApplyCommonFilters(text);\n    }\n}\n\npublic class ContentFilterChain\n{\n    private List<IContentFilterStrategy> filters = new List<IContentFilterStrategy>();\n    \n    public void AddFilter(IContentFilterStrategy filter)\n    {\n        filters.Add(filter);\n    }\n    \n    public string ApplyFilters(string text, Dictionary<string, string> metadata)\n    {\n        string result = text;\n        foreach (var filter in filters)\n        {\n            result = filter.Filter(result, metadata);\n        }\n        return result;\n    }\n}\n\npublic class ContentFilter\n{\n    private Dictionary<string, ContentFilterChain> filterChains = new Dictionary<string, ContentFilterChain>();\n    \n    public ContentFilter()\n    {\n        ContentFilterChain commonChain = new ContentFilterChain();\n        commonChain.AddFilter(new CommonContentFilter());\n        \n        ContentFilterChain emailChain = new ContentFilterChain();\n        emailChain.AddFilter(new EmailContentFilter());\n        emailChain.AddFilter(new CommonContentFilter());\n        \n        ContentFilterChain socialChain = new ContentFilterChain();\n        socialChain.AddFilter(new SocialContentFilter());\n        socialChain.AddFilter(new CommonContentFilter());\n        \n        ContentFilterChain commentChain = new ContentFilterChain();\n        commentChain.AddFilter(new CommentContentFilter());\n        commentChain.AddFilter(new CommonContentFilter());\n        \n        filterChains[\"default\"] = commonChain;\n        filterChains[\"email\"] = emailChain;\n        filterChains[\"social\"] = socialChain;\n        filterChains[\"comment\"] = commentChain;\n    }\n    \n    public void RegisterFilterChain(string contentType, ContentFilterChain chain)\n    {\n        filterChains[contentType] = chain;\n    }\n    \n    public string FilterContent(Content content)\n    {\n        string contentType = content.GetType();\n        ContentFilterChain chain;\n        \n        if (filterChains.ContainsKey(contentType))\n        {\n            chain = filterChains[contentType];\n        }\n        else\n        {\n            chain = filterChains[\"default\"];\n        }\n        \n        return chain.ApplyFilters(content.GetText(), content.GetMetadata());\n    }\n}\n\npublic class CommonContentFilter : BaseContentFilter\n{\n    public override string Filter(string text, Dictionary<string, string> metadata)\n    {\n        return ApplyCommonFilters(text);\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":18390631208,\"explanation\":\"The `ContentFilter` class was handling the registration of filter chains and the filtering process, which violates the Single Responsibility Principle (SRP). The refactored code separates the concerns by ensuring that each class has a single responsibility, making the code easier to maintain and understand.\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "SRP",
            "explanation": "The `ContentFilter` class was handling the registration of filter chains and the filtering process, which violates the Single Responsibility Principle (SRP). The refactored code separates the concerns by ensuring that each class has a single responsibility, making the code easier to maintain and understand."
        },
        {
            "input": "public class ShippingService\n{\n    private IOrderRepository orderRepository;\n    private IInventoryService inventoryService;\n    private ILogger logger;\n    private Dictionary<string, IShippingStrategy> shippingStrategies;\n\n    public ShippingService(IOrderRepository orderRepository, IInventoryService inventoryService, ILogger logger)\n    {\n        this.orderRepository = orderRepository;\n        this.inventoryService = inventoryService;\n        this.logger = logger;\n        InitializeShippingStrategies();\n    }\n\n    private void InitializeShippingStrategies()\n    {\n        shippingStrategies = new Dictionary<string, IShippingStrategy>\n        {\n            { \"standard\", new StandardShippingStrategy() },\n            { \"express\", new ExpressShippingStrategy() },\n            { \"overnight\", new OvernightShippingStrategy() },\n            { \"international\", new InternationalShippingStrategy() }\n        };\n    }\n\n    public ShipmentResult ProcessShipment(string orderId)\n    {\n        Order order = orderRepository.FindById(orderId);\n\n        if (order == null)\n        {\n            throw new ArgumentException($\"Order not found: {orderId}\");\n        }\n\n        if (order.GetStatus() != OrderStatus.PAID)\n        {\n            return new ShipmentResult(false, \"Order is not paid yet\", null);\n        }\n\n        foreach (OrderItem item in order.GetItems())\n        {\n            if (!inventoryService.IsInStock(item.GetProductId(), item.GetQuantity()))\n            {\n                return new ShipmentResult(false, $\"Product out of stock: {item.GetProductId()}\", null);\n            }\n        }\n\n        Shipment shipment = new Shipment(orderId, DateTime.Now);\n        ShippingCost shippingCost = CalculateShippingCost(order);\n        shipment.SetCost(shippingCost.GetCost());\n\n        ReserveInventory(order);\n\n        order.SetStatus(OrderStatus.SHIPPED);\n        orderRepository.Update(order);\n\n        logger.Log($\"Order shipped: {orderId}, cost: {shippingCost.GetCost()}\");\n        return new ShipmentResult(true, \"Order shipped successfully\", shipment);\n    }\n\n    private void ReserveInventory(Order order)\n    {\n        foreach (OrderItem item in order.GetItems())\n        {\n            inventoryService.Reserve(item.GetProductId(), item.GetQuantity());\n        }\n    }\n\n    private ShippingCost CalculateShippingCost(Order order)\n    {\n        string shippingMethod = order.GetShippingMethod();\n        if (!shippingStrategies.TryGetValue(shippingMethod, out IShippingStrategy strategy))\n        {\n            return new ShippingCost(10.0);\n        }\n\n        double totalWeight = CalculateOrderWeight(order);\n        Address destination = order.GetShippingAddress();\n        double distance = CalculateDistance(destination);\n\n        return strategy.CalculateCost(order, totalWeight, distance);\n    }\n\n    private double CalculateOrderWeight(Order order)\n    {\n        double totalWeight = 0.0;\n        foreach (OrderItem item in order.GetItems())\n        {\n            Product product = inventoryService.GetProduct(item.GetProductId());\n            totalWeight += product.GetWeight()  item.GetQuantity();\n        }\n        return totalWeight;\n    }\n\n    private double CalculateDistance(Address destination)\n    {\n        Address warehouseAddress = new Address(\"Warehouse\", \"123 Main St\", \"City\", \"State\", \"Country\", \"12345\");\n\n        if (warehouseAddress.GetCountry().Equals(destination.GetCountry()))\n        {\n            if (warehouseAddress.GetState().Equals(destination.GetState()))\n            {\n                if (warehouseAddress.GetCity().Equals(destination.GetCity()))\n                {\n                    return 10.0;\n                }\n                return 50.0;\n            }\n            return 200.0;\n        }\n        return 1000.0;\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":13999255166,\"explanation\":\"The `ShippingService` class was handling multiple responsibilities: validating orders, creating shipments, reserving inventory, and calculating shipping costs. The refactoring separates the order validation and shipment creation into their own methods, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "HARD",
            "language": "CSHARP",
            "violation": "SRP",
            "explanation": "The `ShippingService` class was handling multiple responsibilities: validating orders, creating shipments, reserving inventory, and calculating shipping costs. The refactoring separates the order validation and shipment creation into their own methods, adhering to the Single Responsibility Principle (SRP)."
        }
    ]
}