{
  "code_examples": [
    {
      "input": "class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Bird bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Ostrich());\n    }\n}",
      "output": "",
      "level": "EASY",
      "language": "JAVA",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"interface Flyable {\\n    void fly();\\n}\\n\\nclass Bird {\\n    // Common bird properties and methods can be added here\\n}\\n\\nclass Sparrow extends Bird implements Flyable {\\n    @Override\\n    public void fly() {\\n        System.out.println(\\\"Sparrow is flying\\\");\\n    }\\n}\\n\\nclass Ostrich extends Bird {\\n    // Ostrich does not implement Flyable, as it cannot fly\\n}\\n\\npublic class Main {\\n    public static void makeBirdFly(Flyable bird) {\\n        bird.fly();\\n    }\\n    public static void main(String[] args) {\\n        makeBirdFly(new Sparrow()); // This will work\\n        // makeBirdFly(new Ostrich()); // This will not compile, as expected\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle (LSP) because the Ostrich class, which is a subclass of Bird, cannot fly, leading to an UnsupportedOperationException when the fly method is called. To resolve this, I introduced a Flyable interface that only flying birds implement. This way, the makeBirdFly method only accepts instances of Flyable, ensuring that only birds that can actually fly are passed to it. This adheres to LSP by ensuring that subclasses can be substituted without altering the desirable properties of the program.\",\"SRP: 5 - The code adheres to the Single Responsibility Principle as each class has a clear responsibility.\\nOCP: 5 - The code can be extended with new bird types without modifying existing code.\\nLSP: 2 - The violation occurs because Ostrich cannot fulfill the contract of the Bird class regarding flying.\\nISP: 5 - The interface is not forced upon classes that do not need it, as only flying birds implement Flyable.\\nDIP: 5 - The code depends on abstractions (interfaces) rather than concrete implementations.\"}"
    },
    {
      "input": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Square();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n    }\n}",
      "output": "interface Shape {\n    int getArea();\n}\n\nclass Rectangle implements Shape {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width  height; }\n}\n\nclass Square implements Shape {\n    private int side;\n    public void setSide(int side) { this.side = side; }\n    public int getArea() { return side  side; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape r = new Rectangle();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n        \n        Shape s = new Square();\n        s.setSide(5);\n        System.out.println(s.getArea());\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The refactored code introduces an interface `Shape` to ensure that both `Rectangle` and `Square` adhere to the same contract without violating the Liskov Substitution Principle (LSP). The `Square` class no longer extends `Rectangle`, thus preventing the issue of setting width and height inconsistently. Each shape now has its own method for setting dimensions, which maintains the integrity of their respective area calculations. This change also improves adherence to the Open/Closed Principle (OCP) by allowing new shapes to be added without modifying existing code. Additionally, the Single Responsibility Principle (SRP) is respected as each class has a clear responsibility regarding its shape type."
    },
    {
      "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        throw new RuntimeException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
      "output": "interface Animal {\n    void makeSound();\n}\n\nclass Dog implements Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\nclass Cat implements Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal dog = new Dog();\n        dog.makeSound();\n        Animal cat = new Cat();\n        cat.makeSound();\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Dog class overrides the makeSound method in a way that throws an exception, which is not expected behavior for an Animal. In the refactored code, I introduced an Animal interface that both Dog and Cat implement, ensuring that all subclasses provide a valid implementation of makeSound without throwing exceptions. This allows for proper substitution of subclasses without unexpected behavior."
    },
    {
      "input": "class Payment {\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
      "output": "interface Payment {\n    void pay();\n}\n\nclass RegularPayment implements Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment implements Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Free payment processed\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p1 = new RegularPayment();\n        p1.pay();\n        Payment p2 = new FreePayment();\n        p2.pay();\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the FreePayment class throws an exception when the pay method is called, which is not expected behavior for a Payment. To fix this, I introduced an interface Payment that both RegularPayment and FreePayment implement. This ensures that both classes provide a valid implementation of the pay method, allowing them to be used interchangeably without causing runtime exceptions."
    },
    {
      "input": "class Vehicle {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.startEngine();\n    }\n}",
      "output": "interface EngineStartable {\n    void startEngine();\n}\n\nclass Vehicle implements EngineStartable {\n    @Override\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle implements EngineStartable {\n    @Override\n    public void startEngine() {\n        System.out.println(\"Bicycles do not have engines.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        EngineStartable v = new Bicycle();\n        v.startEngine();\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class, which extends Vehicle, throws an exception when startEngine is called, which is not expected behavior for a Vehicle. To fix this, I introduced an interface called EngineStartable that both Vehicle and Bicycle implement. This way, both classes provide their own implementation of startEngine, allowing for proper substitution without exceptions. The Bicycle class now indicates that it does not have an engine in a user-friendly way instead of throwing an exception."
    },
    {
      "input": "class FileReader {\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "output": "interface FileReader {\n    String read();\n}\n\nclass SimpleFileReader implements FileReader {\n    @Override\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader implements FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException(\"Access denied to secure file.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SimpleFileReader();\n        System.out.println(fr.read());\n        // Uncomment the line below to test SecureFileReader\n        // FileReader secureFr = new SecureFileReader();\n        // System.out.println(secureFr.read());\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the SecureFileReader class does not fulfill the expectations set by the FileReader interface. When a SecureFileReader is used in place of a FileReader, it throws a SecurityException, which is not the expected behavior. To fix this, I introduced an interface FileReader and created two implementations: SimpleFileReader and SecureFileReader. This way, both classes can be used interchangeably without violating the principle. The refactored code maintains the same functionality while adhering to SOLID principles."
    },
    {
      "input": "class Writer {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
      "output": "interface Writer {\n    void write(String data);\n}\n\nclass ConcreteWriter implements Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter implements Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ConcreteWriter();\n        w.write(\"Hello\");\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the ReadOnlyWriter class cannot be used interchangeably with the Writer class without causing an exception. To fix this, I introduced an interface called Writer that both ConcreteWriter and ReadOnlyWriter implement. This way, both classes can be treated as Writers, but the ReadOnlyWriter can be used in contexts where writing is not required, thus adhering to LSP."
    },
    {
      "input": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 0));\n    }\n}",
      "output": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator {\n    private Calculator calculator;\n\n    public SafeCalculator(Calculator calculator) {\n        this.calculator = calculator;\n    }\n\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Division by zero\");\n        }\n        return calculator.divide(a, b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator basicCalculator = new Calculator();\n        SafeCalculator safeCalculator = new SafeCalculator(basicCalculator);\n        try {\n            System.out.println(safeCalculator.divide(4, 0));\n        } catch (IllegalArgumentException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the SafeCalculator class does not behave as a true subclass of Calculator. Specifically, it changes the expected behavior of the divide method by throwing an exception for a valid input scenario (division by zero). In the refactored code, SafeCalculator is no longer a subclass of Calculator but instead uses an instance of Calculator to perform the division. This maintains the expected behavior of the Calculator class while allowing SafeCalculator to handle the division by zero case appropriately. This change adheres to the LSP by ensuring that SafeCalculator can be used interchangeably with Calculator without altering the expected behavior."
    },
    {
      "input": "class Shape {\n    \n    \n    public double area() {\n        System.out.println(\"Base Shape Area: 0.0\");\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    \n    \n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: \" + Double.NaN + \" (Violation)\");\n        return Double.NaN;\n    }\n}",
      "output": "abstract class Shape {\n    // Base class defines the contract: area() returns a double.\n    // Implicitly, this is expected to be a non-negative value representing size.\n    public abstract double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        if (radius < 0) throw new IllegalArgumentException(\"Radius cannot be negative\");\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        double area = Math.PI  radius  radius;\n        System.out.println(\"Circle Area: \" + area);\n        return area;\n    }\n}\n\nclass Square extends Shape {\n    private double side;\n\n    public Square(double side) {\n        if (side < 0) throw new IllegalArgumentException(\"Side cannot be negative\");\n        this.side = side;\n    }\n\n    @Override\n    public double area() {\n        double area = side  side;\n        System.out.println(\"Square Area: \" + area);\n        return area;\n    }\n}\n\nclass NullShape extends Shape {\n    // NullShape is a specific case that does not represent a valid shape.\n    @Override\n    public double area() {\n        throw new UnsupportedOperationException(\"NullShape does not have a valid area\");\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The refactored code introduces an abstract class `Shape` that defines the contract for calculating the area. The `NullShape` class now throws an exception when `area()` is called, which adheres to the Liskov Substitution Principle by ensuring that all subclasses provide a valid implementation of the `area()` method. Additionally, concrete shape classes like `Circle` and `Square` are added to demonstrate valid shapes with proper area calculations. This design prevents the violation of returning `Double.NaN` and maintains the integrity of the area contract."
    },
    {
      "input": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\nclass FileProcessor {\n    \n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    \n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    \n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    \n    \n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\ninterface FileProcessor {\n    String getStatus(String filePath);\n    void processFile(String filePath);\n}\n\nclass WritableFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The refactored code introduces an interface `FileProcessor` that defines the contract for file processing. This adheres to the Interface Segregation Principle (ISP) by allowing different implementations for writable and read-only file processors. The `WritableFileProcessor` class implements the methods for processing files, while the `ReadOnlyFileProcessor` class implements the read-only behavior. This separation ensures that each class adheres to its specific responsibility without violating the Liskov Substitution Principle (LSP)."
    },
    {
      "input": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        \n        \n        fakeMessagesLogged++;\n    }\n}",
      "output": "interface LoggerInterface {\n    void log(String message);\n    int getMessagesLoggedCount();\n}\n\nclass BaseLogger implements LoggerInterface {\n    private int messagesLogged = 0;\n\n    @Override\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger implements LoggerInterface {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public int getMessagesLoggedCount() {\n        return fakeMessagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        fakeMessagesLogged++;\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the subclass 'SilentCounterLogger' does not fulfill the expected behavior of the base class 'Logger'. Specifically, it overrides the 'log' method but does not log messages or update the count as expected. To fix this, I introduced an interface 'LoggerInterface' that both 'BaseLogger' and 'SilentCounterLogger' implement. This ensures that both classes provide their own implementations of the logging behavior while adhering to the contract defined by the interface."
    },
    {
      "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    \n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        \n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    \n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        \n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    \n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        \n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        \n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n        \n        \n        \n    }\n\n    \n    \n\n    \n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        \n        \n        \n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}\n\n\n",
      "output": "",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "{\"properties\":{\"refactored_code\":\"import java.io.File;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\ninterface DataLoader {\\n    boolean loadData(String source);\\n}\\n\\ninterface DataProcessorInterface {\\n    boolean processData();\\n}\\n\\ninterface DataSaver {\\n    boolean saveResults(String destination);\\n}\\n\\nclass DataProcessor implements DataLoader, DataProcessorInterface, DataSaver {\\n    protected Map<String, Object> data = null;\\n\\n    public DataProcessor() {\\n        System.out.println(\\\"DataProcessor created.\\\");\\n    }\\n\\n    / Loads data from the specified source. /\\n    @Override\\n    public boolean loadData(String source) {\\n        System.out.println(\\\"Base: Loading data from \\\" + source + \\\"...\\\");\\n        // Simulate loading data\\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        if (\\\"valid_source\\\".equals(source)) {\\n            data = new HashMap<>();\\n            data.put(\\\"key1\\\", \\\"value1\\\");\\n            data.put(\\\"key2\\\", 42);\\n            System.out.println(\\\"Base: Data loaded successfully.\\\");\\n            return true;\\n        } else {\\n            data = null;\\n            System.out.println(\\\"Base: Failed to load data.\\\");\\n            return false;\\n        }\\n    }\\n\\n    / Processes the loaded data. /\\n    @Override\\n    public boolean processData() {\\n        System.out.println(\\\"Base: Processing data...\\\");\\n        if (data == null) {\\n            System.out.println(\\\"Base: No data to process.\\\");\\n            return false;\\n        }\\n        // Simulate processing\\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        data.put(\\\"processed\\\", true);\\n        System.out.println(\\\"Base: Data processed.\\\");\\n        return true;\\n    }\\n\\n    / Saves the processed data to the specified destination. /\\n    @Override\\n    public boolean saveResults(String destination) {\\n        System.out.println(\\\"Base: Saving results to \\\" + destination + \\\"...\\\");\\n        if (data == null || !Boolean.TRUE.equals(data.get(\\\"processed\\\"))) {\\n            System.out.println(\\\"Base: No processed data to save.\\\");\\n            return false;\\n        }\\n        // Simulate saving data (e.g., writing to a file)\\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        // Example: new File(destination).createNewFile(); // Simplified simulation\\n        System.out.println(\\\"Base: Results saved to \\\" + destination + \\\".\\\");\\n        return true;\\n    }\\n}\\n\\nclass ReadOnlyDataProcessor extends DataProcessor {\\n\\n    public ReadOnlyDataProcessor() {\\n        super();\\n        System.out.println(\\\"ReadOnlyDataProcessor created.\\\");\\n    }\\n\\n    @Override\\n    public boolean saveResults(String destination) {\\n        System.out.println(\\\"ReadOnly: Attempted to save results to \\\" + destination + \\\".\\\");\\n        throw new UnsupportedOperationException(\\\"Cannot save results with a ReadOnlyDataProcessor.\\\");\\n    }\\n}\\n\\nclass ReadOnlyDataProcessorWithCopy extends DataProcessor {\\n\\n    public ReadOnlyDataProcessorWithCopy() {\\n        super();\\n        System.out.println(\\\"ReadOnlyDataProcessorWithCopy created.\\\");\\n    }\\n\\n    @Override\\n    public boolean processData() {\\n        System.out.println(\\\"ReadOnly: Processing data...\\\");\\n        if (data == null) {\\n            System.out.println(\\\"ReadOnly: No data to process.\\\");\\n            return false;\\n        }\\n        // Simulate processing on a copy\\n        Map<String, Object> processedData = new HashMap<>(data);\\n        processedData.put(\\\"processed\\\", true);\\n        System.out.println(\\\"ReadOnly: Data processed.\\\");\\n        return true;\\n    }\\n}\\n\\n// Example Usage demonstrating the violation:\\npublic class ViolationDemo {\\n    public static void performFullPipeline(DataProcessorInterface processor, String source, String destination) {\\n        System.out.println(\\\"Using processor: \\\" + processor.getClass().getSimpleName());\\n        if (processor instanceof DataLoader) {\\n            if (((DataLoader) processor).loadData(source)) {\\n                if (processor.processData()) {\\n                    if (processor instanceof DataSaver) {\\n                        ((DataSaver) processor).saveResults(destination);\\n                    }\\n                } else {\\n                    System.out.println(\\\"Processing failed.\\\");\\n                }\\n            } else {\\n                System.out.println(\\\"Loading failed.\\\");\\n            }\\n        }\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"--- Demonstrating Violation ---\\\");\\n\\n        // Works fine with the base class\\n        System.out.println(\\\"\\\\nTesting with DataProcessor:\\\");\\n        DataProcessor baseProc = new DataProcessor();\\n        performFullPipeline(baseProc, \\\"valid_source\\\", \\\"output.txt\\\");\\n\\n        System.out.println(\\\"\\\\nTesting with ReadOnlyDataProcessor (Violation expected):\\\");\\n        DataProcessor readOnlyProc = new ReadOnlyDataProcessor();\\n        try {\\n            performFullPipeline(readOnlyProc, \\\"valid_source\\\", \\\"output.txt\\\");\\n        } catch (UnsupportedOperationException ex) {\\n            System.out.println(\\\"Caught expected LSP violation exception: \\\" + ex.getMessage());\\n        } finally {\\n            File dummyFile = new File(\\\"output.txt\\\");\\n            if (dummyFile.exists()) dummyFile.delete();\\n        }\\n\\n        System.out.println(\\\"\\\\nTesting with ReadOnlyDataProcessorWithCopy:\\\");\\n        DataProcessor readOnlyCopyProc = new ReadOnlyDataProcessorWithCopy();\\n        performFullPipeline(readOnlyCopyProc, \\\"valid_source\\\", \\\"output.txt\\\");\\n    }\\n}\",\"explanation\":\"The refactored code separates the responsibilities of loading, processing, and saving data into distinct interfaces: DataLoader, DataProcessorInterface, and DataSaver. This adheres to the Single Responsibility Principle (SRP) by ensuring that each class has a clear purpose. The ReadOnlyDataProcessor now throws an exception when attempting to save results, but the new ReadOnlyDataProcessorWithCopy class processes data without modifying the original data, thus adhering to the Liskov Substitution Principle (LSP). The performFullPipeline method has been updated to work with the new interfaces, ensuring that the code remains flexible and adheres to the Dependency Inversion Principle (DIP). Overall, the refactoring improves the design by making it more modular and compliant with SOLID principles.\"},\"violation_type\":\"Liskov Substitution Principle (LSP)\"}"
    },
    {
      "input": "class Bird:\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise Exception('Ostriches cannot fly')",
      "output": "class Bird:\n    def fly(self):\n        raise NotImplementedError('This method should be overridden')\n\nclass FlyingBird(Bird):\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def run(self):\n        print('Running')\n\nclass Sparrow(FlyingBird):\n    def fly(self):\n        print('Sparrow is flying')\n\nclass Eagle(FlyingBird):\n    def fly(self):\n        print('Eagle is soaring')",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Ostrich class, which is a subclass of Bird, cannot fulfill the contract of the fly method. To refactor the code, I introduced an abstract method in the Bird class and created a separate FlyingBird class for birds that can fly. This way, the Ostrich class does not need to implement the fly method, and we can add other flying birds like Sparrow and Eagle that properly implement the fly method."
    },
    {
      "input": "class Rectangle:\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.height = height\n        self.width = height",
      "output": "class Shape:\n    def area(self):\n        raise NotImplementedError(\"Subclasses should implement this!\")\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def set_width(self, width):\n        self.width = width\n    \n    def set_height(self, height):\n        self.height = height\n    \n    def area(self):\n        return self.width  self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.width = side\n        self.height = side\n    \n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    \n    def set_height(self, height):\n        self.height = height\n        self.width = height\n    \n    def area(self):\n        return self.width  self.height\n",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the Square class does not behave as a true subclass of Rectangle. Specifically, setting the width or height of a Square affects both dimensions, which is not the case for a Rectangle. To fix this, I introduced a base class Shape with an area method that must be implemented by subclasses. Rectangle and Square now both inherit from Shape and implement their own area methods, ensuring that they can be used interchangeably without unexpected behavior. This adheres to the LSP."
    },
    {
      "input": "class Animal:\n    def make_sound(self):\n        print('Some sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        raise NotImplementedError('Fish cannot make sounds')",
      "output": "class Animal:\n    def make_sound(self):\n        raise NotImplementedError('This method should be overridden')\n\nclass Mammal(Animal):\n    def make_sound(self):\n        print('Some mammal sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        print('Fish cannot make sounds')\n\nclass Dog(Mammal):\n    def make_sound(self):\n        print('Bark')\n\nclass Cat(Mammal):\n    def make_sound(self):\n        print('Meow')\n\n# Example usage:\nif __name__ == '__main__':\n    dog = Dog()\n    dog.make_sound()  # Output: Bark\n    cat = Cat()\n    cat.make_sound()  # Output: Meow\n    fish = Fish()\n    fish.make_sound()  # Output: Fish cannot make sounds",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violated the Liskov Substitution Principle because the Fish class raised a NotImplementedError when calling make_sound, which is not a valid behavior for a subclass of Animal. In the refactored code, I introduced a base Animal class that defines make_sound as an abstract method, and created a Mammal subclass that implements this method. Fish is still a subclass of Animal but now provides a meaningful implementation that indicates it cannot make sounds, thus adhering to LSP."
    },
    {
      "input": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
      "output": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter:\n    def write(self):\n        raise Exception('Cannot write in read-only mode')\n\nclass FileHandler:\n    def __init__(self, writer):\n        self.writer = writer\n\n    def perform_write(self):\n        self.writer.write()",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the ReadOnlyWriter class cannot be used interchangeably with the Writer class without causing an exception. To resolve this, I created a separate FileHandler class that takes a Writer instance and calls its write method. This way, we can have different types of writers without violating the principle."
    },
    {
      "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')",
      "output": "class PaymentProcessor:\n    def process_payment(self, amount):\n        if amount < 0:\n            raise ValueError('Amount must be non-negative')\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')\n        super().process_payment(amount)",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the `FreePaymentProcessor` class does not behave as a proper substitute for the `PaymentProcessor` class. Specifically, it raises an exception for valid inputs that the base class would normally handle. In the refactored code, I added a check in the base class to ensure that the amount is non-negative, and in the `FreePaymentProcessor`, I call the base class's `process_payment` method for valid free account payments (which should be zero). This ensures that the derived class can be used interchangeably with the base class without unexpected behavior."
    },
    {
      "input": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
      "output": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass Printable:\n    def print_document(self):\n        raise NotImplementedError('Subclasses should implement this!')\n\nclass SecureDocument(Printable):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')\n\nclass RegularDocument(Document):\n    def print_document(self):\n        super().print_document()",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the SecureDocument class cannot be used interchangeably with the Document class without altering the expected behavior. To address this, I introduced a Printable interface that defines the print_document method. The SecureDocument class now inherits from this interface, ensuring that it adheres to the contract while still enforcing its own restrictions. Additionally, I created a RegularDocument class that extends Document, allowing for a clear distinction between secure and regular documents."
    },
    {
      "input": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
      "output": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Engine:\n    def start(self):\n        pass\n\nclass MotorVehicle(Vehicle):\n    def __init__(self):\n        self.engine = Engine()\n\n    def start_engine(self):\n        self.engine.start()\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        print('Bicycles do not have engines, no engine to start')\n\nclass Car(MotorVehicle):\n    class CarEngine(Engine):\n        def start(self):\n            print('Car engine started')\n\n    def __init__(self):\n        super().__init__()\n        self.engine = self.CarEngine()",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class cannot substitute the Vehicle class without causing an exception when calling start_engine. In the refactored code, I introduced an Engine class and a MotorVehicle class that can have engines. The Bicycle class now simply indicates that it does not have an engine without raising an exception. This allows for proper substitution of subclasses without breaking the expected behavior."
    },
    {
      "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise Exception('Cannot send email')",
      "output": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        print('No email sent')\n\nclass EmailService:\n    def __init__(self, email_sender: EmailSender):\n        self.email_sender = email_sender\n\n    def notify(self, address):\n        self.email_sender.send_email(address)\n\n# Example usage:\nif __name__ == '__main__':\n    email_sender = EmailSender()\n    null_email_sender = NullEmailSender()\n    service = EmailService(email_sender)\n    service.notify('example@example.com')\n    service = EmailService(null_email_sender)\n    service.notify('example@example.com')",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the `NullEmailSender` class does not behave as a proper substitute for the `EmailSender` class. Instead of raising an exception, it now provides a non-intrusive message indicating that no email will be sent. This allows the `EmailService` to work seamlessly with both `EmailSender` and `NullEmailSender`, adhering to LSP. Additionally, I introduced an `EmailService` class to encapsulate the email sending logic, promoting better separation of concerns."
    },
    {
      "input": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor(DataProcessor):\n    def __init__(self):\n        super().__init__()\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "output": "import os\nimport time\n\nclass DataLoader:\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            return {\"key1\": \"value1\", \"key2\": 42}\n        else:\n            print(\"Failed to load data.\")\n            return None\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def set_data(self, data):\n        self._data = data\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Processing data...\")\n        if self._data is None:\n            print(\"No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Data processed.\")\n        return True\n\nclass DataSaver:\n    def save_results(self, data, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Saving results to {destination}...\")\n        if data is None or not data.get(\"processed\"):\n            print(\"No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def set_data(self, data):\n        self._data = data\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Processing data...\")\n        if self._data is None:\n            print(\"No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")\n\n# Example usage\nif __name__ == '__main__':\n    loader = DataLoader()\n    data = loader.load_data(\"valid_source\")\n    processor = DataProcessor()\n    processor.set_data(data)\n    processor.process_data()\n    saver = DataSaver()\n    saver.save_results(processor._data, \"output.txt\")\n    \n    read_only_processor = ReadOnlyDataProcessor()\n    read_only_processor.set_data(data)\n    read_only_processor.process_data()\n    try:\n        read_only_processor.save_results(\"output.txt\")\n    except PermissionError as e:\n        print(e)",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "SRP",
      "explanation": "The refactored code separates the responsibilities of loading, processing, and saving data into distinct classes: DataLoader, DataProcessor, and DataSaver. This adheres to the Single Responsibility Principle (SRP) by ensuring each class has one reason to change. The Open/Closed Principle (OCP) is respected as new data processing or saving strategies can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since ReadOnlyDataProcessor can be used in place of DataProcessor without breaking functionality, although it raises an exception for saving. The Interface Segregation Principle (ISP) is satisfied as each class has a clear interface without unnecessary methods. Finally, the Dependency Inversion Principle (DIP) is upheld by depending on abstractions (interfaces) rather than concrete implementations. Overall, the most impactful violation was the SRP, as the original DataProcessor class handled multiple responsibilities."
    },
    {
      "input": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentCounterLogger(Logger):\n    def __init__(self):\n        super().__init__()\n        self._fake_messages_logged = 0\n\n    def log(self, message):\n        self._fake_messages_logged += 1\n",
      "output": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentLogger:\n    def __init__(self):\n        self._fake_messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._fake_messages_logged\n\n    def log(self, message):\n        # Silent logging, does not output anything\n        self._fake_messages_logged += 1\n\nclass LoggerFactory:\n    @staticmethod\n    def create_logger(logger_type):\n        if logger_type == 'silent':\n            return SilentLogger()\n        return Logger()",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The refactored code separates the logging functionality into distinct classes that adhere to the SOLID principles. The Logger class handles standard logging, while the SilentLogger class handles silent logging without affecting the base logger's state. This avoids the violation of the Liskov Substitution Principle (LSP) where derived classes should be substitutable for their base classes. Additionally, a LoggerFactory is introduced to create instances of the appropriate logger type, promoting the Open/Closed Principle (OCP) by allowing for easy extension of logger types without modifying existing code. Each logger now maintains its own state, ensuring consistency in behavior and state reporting."
    },
    {
      "input": "import os # Using os module for file operations\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return # Simplified: graceful exit if file missing\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\n\n\n\n\n",
      "output": "import os\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\nclass FileProcessorInterface:\n    def get_status(self, file_path):\n        pass\n\n    def process_file(self, file_path):\n        pass\n\nclass WritableFileProcessor(FileProcessor):\n    def process_file(self, file_path):\n        print(f\"Writable: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Writable: Error - File {file_path} not found for processing.\")\n            return\n        print(f\"Writable: File {file_path} processed successfully.\")\n\n# Example Usage demonstrating the violation:\n# import os\n\ntest_file_path = \"dummy.txt\"\nwith open(test_file_path, \"w\") as f: f.write(\"Some content\")\n\nbase_proc = WritableFileProcessor()\nprint(base_proc.get_status(test_file_path))\nbase_proc.process_file(test_file_path)\n\nprint(\"---\")\n\nread_only_proc = ReadOnlyFileProcessor()\nprint(read_only_proc.get_status(test_file_path))\n\ntry:\n    read_only_proc.process_file(test_file_path)\nexcept RuntimeError as ex:\n    print(f\"Caught expected violation exception: {ex}\")\nfinally:\n    if os.path.exists(test_file_path): os.remove(test_file_path)",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "LSP",
      "explanation": "In the refactored code, I introduced a new interface, `FileProcessorInterface`, to define the contract for file processing. This allows for better adherence to the Liskov Substitution Principle (LSP) by ensuring that any class implementing this interface can be used interchangeably without unexpected behavior. I also created a `WritableFileProcessor` class that extends `FileProcessor` to handle writable files, while `ReadOnlyFileProcessor` remains unchanged in its behavior. This separation clarifies the responsibilities of each class and maintains the integrity of the LSP. The original `process_file` method in `ReadOnlyFileProcessor` still raises an exception, but now it is clear that it is a specific behavior of that class, and the interface ensures that all processors can be used in a consistent manner."
    },
    {
      "input": "import math\n\nclass Shape:\n    def area(self):\n        print(\"Base Shape Area: 0.0\")\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        print(f\"Null Shape Area: {float('nan')} (Violation)\")\n        return float('nan') # Returning NaN is a subtle violation\n\n\n\n\n",
      "output": "import math\n\nclass Shape:\n    def area(self):\n        raise NotImplementedError(\"Subclasses must implement this method\")\n\nclass ValidShape(Shape):\n    def __init__(self, area):\n        if area < 0:\n            raise ValueError(\"Area cannot be negative\")\n        self._area = area\n\n    def area(self):\n        return self._area\n\nclass NullShape(Shape):\n    def area(self):\n        return 0.0  # Treating NullShape as having no area\n\n# Example Usage demonstrating the refactored code:\nbase_shape = ValidShape(0.0)\nbase_area = base_shape.area()\nprint(f\"Base Area: {base_area}\")\n\nprint(\"---\")\n\nnull_shape = NullShape()\nnull_area = null_shape.area()\nprint(f\"Null Area: {null_area}\")\n\n# Now total_area will be a valid number\n# total_area = base_area + null_area  # This will work correctly\n# print(f\"Total Area: {total_area}\")\n\nif null_area >= 0.0:\n    print(\"Area is non-negative\")\nelse:\n    print(\"Area is negative\")",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The refactored code introduces a new class, ValidShape, which ensures that the area is always a non-negative value. The NullShape class now returns 0.0, which is a valid area representation. The area method in the Shape class raises NotImplementedError, enforcing that subclasses must provide a valid implementation. This adheres to the Liskov Substitution Principle by ensuring that all subclasses return valid area values, and it also respects the Single Responsibility Principle by separating the concerns of valid area representation and shape definition."
    },
    {
      "input": "open class Bird {\n    open fun fly() {}\n}\n\nclass Ostrich : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun makeBirdFly(bird: Bird) {\n    bird.fly()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdFly(ostrich)\n}",
      "output": "interface Flyable {\n    fun fly()\n}\n\nopen class Bird {\n    open fun makeSound() {}\n}\n\nclass Sparrow : Bird(), Flyable {\n    override fun fly() {\n        println(\"Sparrow is flying\")\n    }\n}\n\nclass Ostrich : Bird() {\n    override fun makeSound() {\n        println(\"Ostrich sound\")\n    }\n}\n\nfun makeBirdFly(flyable: Flyable) {\n    flyable.fly()\n}\n\nfun main() {\n    val sparrow = Sparrow()\n    makeBirdFly(sparrow)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violated the Liskov Substitution Principle (LSP) because the Ostrich class, which is a subclass of Bird, does not support the fly() method, leading to an exception when called. To resolve this, I introduced a Flyable interface that defines the fly() method. Now, only classes that can actually fly (like Sparrow) implement this interface. This way, the makeBirdFly function only accepts Flyable objects, ensuring that it can safely call the fly() method without risking an exception. This refactoring adheres to the SOLID principles more effectively."
    },
    {
      "input": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override fun setWidth(w: Int) {\n        width = w\n        height = w\n    }\n    override fun setHeight(h: Int) {\n        width = h\n        height = h\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
      "output": "interface Shape {\n    fun area(): Int\n}\n\nclass Rectangle(var width: Int, var height: Int) : Shape {\n    override fun area(): Int {\n        return width  height\n    }\n\n    fun setWidth(w: Int) { width = w }\n    fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Shape {\n    private var size: Int = size\n\n    override fun area(): Int {\n        return size  size\n    }\n\n    fun setSize(s: Int) {\n        size = s\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val rectangle = Rectangle(5, 5)\n    resizeRectangle(rectangle)\n    println(\"Rectangle area: ${rectangle.area()}\")\n\n    val square = Square(5)\n    square.setSize(10)\n    println(\"Square area: ${square.area()}\")\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The refactored code introduces an interface `Shape` to adhere to the Interface Segregation Principle (ISP) and the Dependency Inversion Principle (DIP). The `Rectangle` and `Square` classes now implement the `Shape` interface, which allows for polymorphic behavior without forcing subclasses to inherit unnecessary methods. The `Square` class no longer overrides methods from `Rectangle`, thus adhering to the Liskov Substitution Principle (LSP). The `resizeRectangle` function is kept for rectangles only, ensuring that it does not affect squares. This separation of concerns improves maintainability and clarity."
    },
    {
      "input": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
      "output": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Cat : Animal() {\n    override fun makeSound() {\n        println(\"Meow\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        println(\"Blub\")\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val dog = Dog()\n    animalSound(dog)\n    val cat = Cat()\n    animalSound(cat)\n    val fish = Fish()\n    animalSound(fish)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Fish class throws an exception when its makeSound method is called, which is not expected behavior for an Animal. In the refactored code, I added a Cat class and modified the Fish class to provide a valid implementation of makeSound that does not throw an exception. This ensures that all subclasses of Animal can be used interchangeably without causing unexpected behavior."
    },
    {
      "input": "open class Payment {\n    open fun pay(amount: Double) {}\n}\n\nclass CashPayment : Payment() {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment() {\n    override fun pay(amount: Double) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"open class Payment {\\n    open fun pay(amount: Double) {}\\n}\\n\\nclass CashPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount using credit\\\")\\n    }\\n}\\n\\nclass PaymentProcessor {\\n    fun processPayment(payment: Payment, amount: Double) {\\n        payment.pay(amount)\\n    }\\n}\\n\\nfun main() {\\n    val cash = CashPayment()\\n    val credit = CreditPayment()\\n    val processor = PaymentProcessor()\\n    processor.processPayment(cash, 100.0)\\n    processor.processPayment(credit, 100.0)\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the `CreditPayment` class throws an exception when the `pay` method is called, which is not expected behavior for a subclass of `Payment`. In the refactored code, I modified the `CreditPayment` class to provide a valid implementation of the `pay` method, ensuring that it behaves correctly when substituted for its superclass. Additionally, I introduced a `PaymentProcessor` class to encapsulate the payment processing logic, adhering to the Single Responsibility Principle (SRP) and improving the overall design.\"}"
    },
    {
      "input": "open class Writer {\n    open fun write(data: String) {}\n}\n\nclass FileWriter : Writer() {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nclass ReadOnlyFileWriter : Writer() {\n    override fun write(data: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val readOnly = ReadOnlyFileWriter()\n    save(readOnly, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"open class Writer {\\n    open fun write(data: String) {}\\n}\\n\\ninterface Writable {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writable {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileWriter : Writable {\\n    override fun write(data: String) {\\n        throw UnsupportedOperationException(\\\"This writer is read-only.\\\")\\n    }\\n}\\n\\nfun save(writer: Writable, data: String) {\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val readOnly = ReadOnlyFileWriter()\\n    save(readOnly, \\\"Hello\\\")\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the ReadOnlyFileWriter class does not fulfill the contract of the Writer class by throwing an exception when write is called. To fix this, I introduced a Writable interface that both FileWriter and ReadOnlyFileWriter implement. This way, the save function can accept any Writable instance, and the behavior of each writer is clear and consistent.\"}"
    },
    {
      "input": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    override fun startEngine() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
      "output": "open class Vehicle {\n    open fun startEngine() {}\n}\n\ninterface EngineStartable {\n    fun startEngine()\n}\n\nclass Bicycle : Vehicle(), EngineStartable {\n    override fun startEngine() {\n        throw UnsupportedOperationException(\"Bicycles do not have engines.\")\n    }\n}\n\nclass Car : Vehicle(), EngineStartable {\n    override fun startEngine() {\n        println(\"Car engine started.\")\n    }\n}\n\nfun startVehicle(vehicle: EngineStartable) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n    val car = Car()\n    startVehicle(car)\n}",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class overrides the startEngine method to throw an exception, which is not a valid behavior for a subclass. To fix this, I introduced an interface called EngineStartable that defines the startEngine method. Now, both Bicycle and Car implement this interface, allowing for proper behavior without throwing exceptions. This way, we can ensure that all subclasses can be used interchangeably without causing errors."
    },
    {
      "input": "open class Notification {\n    open fun send(message: String) {}\n}\n\nclass EmailNotification : Notification() {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nclass SilentNotification : Notification() {\n    override fun send(message: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val silent = SilentNotification()\n    notifyUser(silent, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"open class Notification {\\n    open fun send(message: String) {}\\n}\\n\\nclass EmailNotification : Notification() {\\n    override fun send(message: String) {\\n        println(\\\"Email: \\$message\\\")\\n    }\\n}\\n\\nclass SilentNotification : Notification() {\\n    override fun send(message: String) {\\n        // Silent notification does not throw an exception, it simply does nothing.\\n    }\\n}\\n\\nclass NotificationSender {\\n    fun notifyUser(notification: Notification, message: String) {\\n        notification.send(message)\\n    }\\n}\\n\\nfun main() {\\n    val email = EmailNotification()\\n    val silent = SilentNotification()\\n    val sender = NotificationSender()\\n    sender.notifyUser(email, \\\"Hello via Email\\\")\\n    sender.notifyUser(silent, \\\"Hello via Silent Notification\\\")\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle (LSP) because the SilentNotification class throws an exception when the send method is called, which is not expected behavior for a Notification. In the refactored code, SilentNotification's send method is modified to do nothing instead of throwing an exception, allowing it to be used interchangeably with other Notification subclasses without causing runtime errors. Additionally, a NotificationSender class is introduced to encapsulate the notification sending logic, adhering to the Single Responsibility Principle (SRP) and improving the overall design.\"}"
    },
    {
      "input": "open class Printer {\n    open fun printDocument(document: String) {}\n}\n\nclass NetworkPrinter : Printer() {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nclass DummyPrinter : Printer() {\n    override fun printDocument(document: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val dummy = DummyPrinter()\n    print(dummy, \"Test\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"interface Printer {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass DummyPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        throw UnsupportedOperationException(\\\"Dummy printer cannot print documents.\\\")\\n    }\\n}\\n\\nclass RealPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing document: \\$document\\\")\\n    }\\n}\\n\\nfun print(printer: Printer, document: String) {\\n    printer.printDocument(document)\\n}\\n\\nfun main() {\\n    val networkPrinter = NetworkPrinter()\\n    print(networkPrinter, \\\"Test Document\\\")\\n    val realPrinter = RealPrinter()\\n    print(realPrinter, \\\"Another Test Document\\\")\\n    val dummy = DummyPrinter()\\n    try {\\n        print(dummy, \\\"Test\\\")\\n    } catch (e: UnsupportedOperationException) {\\n        println(e.message)\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle (LSP) because the DummyPrinter class does not fulfill the contract of the Printer interface by throwing an exception when its printDocument method is called. This means that it cannot be used interchangeably with other Printer implementations without causing errors. To fix this, I introduced an interface for Printer and created a RealPrinter class that can print documents normally. The DummyPrinter now throws a more descriptive exception, and the main function demonstrates the use of both a network printer and a real printer, while handling the dummy printer's unsupported operation gracefully.\"}"
    },
    {
      "input": "open class Logger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    open fun log(message: String) {\n        println(\"[BASE LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentCounterLogger : Logger() {\n    private var fakeMessagesLogged: Int = 0\n\n    override fun log(message: String) {\n        fakeMessagesLogged++\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"refactored_code\":\"interface Logger {\\n    fun log(message: String)\\n}\\n\\nclass ConsoleLogger : Logger {\\n    private var messagesLogged: Int = 0\\n\\n    fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    override fun log(message: String) {\\n        println(\\\"[BASE LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\nclass SilentLogger : Logger {\\n    private var fakeMessagesLogged: Int = 0\\n\\n    override fun log(message: String) {\\n        fakeMessagesLogged++\\n    }\\n}\",\"explanation\":\"The refactored code introduces an interface `Logger` that defines the logging behavior. This adheres to the Single Responsibility Principle (SRP) by separating the logging mechanism from the message counting. The `ConsoleLogger` class implements the logging to the console and counts messages, while the `SilentLogger` class implements a silent logging mechanism without counting. This design adheres to the Open/Closed Principle (OCP) as new loggers can be added without modifying existing code. The Liskov Substitution Principle (LSP) is respected since both `ConsoleLogger` and `SilentLogger` can be used interchangeably where a `Logger` is expected. The Interface Segregation Principle (ISP) is also respected as clients are not forced to depend on methods they do not use. Finally, the Dependency Inversion Principle (DIP) is satisfied as high-level modules depend on abstractions (the `Logger` interface) rather than concrete implementations.\",\"violation_type\":\"Multiple responsibilities in Logger class\"}"
    },
    {
      "input": "import java.util.concurrent.CopyOnWriteArrayList\n\nopen class Logger {\n    open fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger() {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "output": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\nclass ThreadSafeLogger : Logger {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogger : Logger {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "DIP + ISP",
      "explanation": "The refactored code introduces an interface `Logger` to adhere to the Dependency Inversion Principle (DIP) and the Interface Segregation Principle (ISP). This allows for different implementations of logging (both thread-safe and non-thread-safe) without forcing clients to depend on methods they do not use. The `ThreadSafeLogger` class uses `CopyOnWriteArrayList` to ensure thread safety, while `NonThreadSafeLogger` remains unchanged. This separation of concerns improves maintainability and scalability of the logging functionality."
    },
    {
      "input": "open class Shape {\n    open fun area(): Double {\n        println(\"Base Shape Area: 0.0\")\n        return 0.0\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        println(\"Null Shape Area: ${Double.NaN} (Violation)\")\n        return Double.NaN\n    }\n}",
      "output": "open class Shape {\n    open fun area(): Double {\n        return 0.0\n    }\n}\n\nclass Circle(private val radius: Double) : Shape() {\n    override fun area(): Double {\n        return Math.PI  radius  radius\n    }\n}\n\nclass Square(private val side: Double) : Shape() {\n    override fun area(): Double {\n        return side  side\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        throw UnsupportedOperationException(\"NullShape does not have a valid area.\")\n    }\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the NullShape class returns Double.NaN, which is not a valid area and can lead to unexpected behavior when substituting it for a Shape. In the refactored code, I introduced specific shape classes (Circle and Square) that provide valid area calculations. The NullShape now throws an exception when its area method is called, indicating that it does not have a valid area, thus adhering to the LSP."
    },
    {
      "input": "import java.io.File\n\nopen class FileProcessor {\n    open fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"Base: Checking status for $filePath - Found.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"Base: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    open fun processFile(filePath: String) {\n        println(\"Base: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n            println(\"Base: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"Base: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor() {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnly: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"ReadOnly: Attempted to process file $filePath.\")\n        throw UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "ALL",
      "explanation": "{\"refactored_code\":\"import java.io.File\\n\\ninterface FileStatusChecker {\\n    fun getStatus(filePath: String): String\\n}\\n\\ninterface FileProcessor {\\n    fun processFile(filePath: String)\\n}\\n\\nclass DefaultFileStatusChecker : FileStatusChecker {\\n    override fun getStatus(filePath: String): String {\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            println(\\\"Default: Checking status for \\$filePath - Found.\\\")\\n            \\\"Ready for processing\\\"\\n        } else {\\n            println(\\\"Default: Checking status for \\$filePath - Not Found.\\\")\\n            \\\"File not found\\\"\\n        }\\n    }\\n}\\n\\nclass ReadOnlyFileStatusChecker : FileStatusChecker {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"ReadOnly: Checking status for \\$filePath - Read-only access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Available (Read-only)\\\"\\n        } else {\\n            \\\"File not found (Read-only)\\\"\\n        }\\n    }\\n}\\n\\nclass WritableFileProcessor(private val statusChecker: FileStatusChecker) : FileProcessor {\\n    override fun processFile(filePath: String) {\\n        println(\\\"Writable: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"Writable: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"Writable: File \\$filePath processed successfully.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor(private val statusChecker: FileStatusChecker) : FileProcessor {\\n    override fun processFile(filePath: String) {\\n        println(\\\"ReadOnly: Attempted to process file \\$filePath.\\\")\\n        throw UnsupportedOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\")\\n    }\\n}\",\"explanation\":\"The refactored code separates the responsibilities of checking file status and processing files into distinct interfaces and classes, adhering to the Single Responsibility Principle (SRP). The Open/Closed Principle (OCP) is respected as new file processors can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since subclasses can be used interchangeably with their base classes. The Interface Segregation Principle (ISP) is satisfied by creating specific interfaces for file status checking and processing. The Dependency Inversion Principle (DIP) is implemented by depending on abstractions (interfaces) rather than concrete implementations. This design allows for better flexibility and maintainability.\",\"violation_type\":\"SRP, OCP, LSP, ISP, DIP\"}"
    },
    {
      "input": "class Bird { public virtual void Fly() { } } class Ostrich : Bird { public override void Fly() { throw new Exception(); } }",
      "output": "interface IFlyable { void Fly(); }\n\nclass Bird { }\n\nclass Sparrow : Bird, IFlyable { \n    public void Fly() { / Implementation for flying / } \n}\n\nclass Ostrich : Bird { \n    // Ostrich does not implement IFlyable, as it cannot fly.\n}",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Ostrich class overrides the Fly method in a way that throws an exception, which is not a valid behavior for a Bird that is expected to fly. By introducing an IFlyable interface, we separate the flying behavior from the Bird class, allowing only those birds that can fly (like Sparrow) to implement the Fly method. This adheres to the LSP, as any instance of IFlyable can be substituted without causing issues."
    },
    {
      "input": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width * Height; } } class Square : Rectangle { public override int Width { get => base.Width; set { base.Width = value; base.Height = value; } } public override int Height { get => base.Height; set { base.Width = value; base.Height = value; } } }",
      "output": "abstract class Shape { public abstract int Area(); } class Rectangle : Shape { public virtual int Width { get; set; } public virtual int Height { get; set; } public override int Area() { return Width  Height; } } class Square : Shape { public int Side { get; set; } public override int Area() { return Side  Side; } }",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Square class does not behave like a Rectangle. When a Square is substituted for a Rectangle, it does not maintain the expected behavior of width and height being independent. In the refactored code, I introduced an abstract base class Shape, which both Rectangle and Square inherit from. This allows each shape to define its own area calculation without violating the principles of substitution."
    },
    {
      "input": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
      "output": "abstract class Animal { public abstract void MakeSound(); } class Dog : Animal { public override void MakeSound() { Console.WriteLine(\"Bark\"); } } class Cat : Animal { public override void MakeSound() { Console.WriteLine(\"Meow\"); } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(\"Fish do not make sounds in the traditional sense.\"); } }",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Fish class does not provide a meaningful implementation of the MakeSound method, which can lead to unexpected behavior when substituting Fish for other Animal types. In the refactored code, I made the Animal class abstract and ensured that all derived classes provide a meaningful implementation of MakeSound, or throw a clear exception if they cannot. This adheres to LSP by ensuring that all subclasses can be used interchangeably without causing issues."
    },
    {
      "input": "class Payment { public virtual void Pay() { } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
      "output": "interface IPayment { void Pay(); }\n\nclass Payment : IPayment { \n    public virtual void Pay() { } \n}\n\nclass FreePayment : IPayment { \n    public void Pay() { throw new NotSupportedException(); } \n}\n\nclass PaidPayment : Payment { \n    public override void Pay() { / Implementation for paid payment / } \n}",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the FreePayment class does not fulfill the contract of the Payment class by throwing an exception when Pay is called. To refactor, I introduced an interface IPayment that both FreePayment and Payment implement. This allows FreePayment to define its own behavior without violating the expectations set by the Payment class."
    },
    {
      "input": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
      "output": "interface IFileWriter { void Write(string data); } class FileWriter : IFileWriter { public virtual void Write(string data) { / Implementation for writing data to a file / } } class ReadOnlyFileWriter : IFileWriter { public void Write(string data) { throw new InvalidOperationException(\"This writer is read-only.\"); } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the ReadOnlyFileWriter class does not fulfill the contract of the FileWriter class by throwing an exception when Write is called. To refactor, I introduced an interface (IFileWriter) that both classes implement, ensuring that they adhere to the expected behavior. This allows for proper substitution without unexpected exceptions."
    },
    {
      "input": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new NotImplementedException(); } }",
      "output": "abstract class Vehicle { public abstract void StartEngine(); } class Bicycle : Vehicle { public override void StartEngine() { // Bicycles do not have engines, so we can leave this empty or throw an exception if needed. } } class Car : Vehicle { public override void StartEngine() { // Implementation for starting a car engine. } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class overrides the StartEngine method and throws a NotImplementedException, which is not a valid behavior for a subclass. By making the Vehicle class abstract and defining StartEngine as an abstract method, we ensure that all subclasses must provide a valid implementation. In this case, the Bicycle class can either leave the method empty or throw a specific exception that indicates the method is not applicable, while other subclasses like Car can implement the method appropriately."
    },
    {
      "input": "class Document { public virtual void Print() { } } class DigitalDocument : Document { public override void Print() { throw new NotSupportedException(); } }",
      "output": "interface IDocument { void Print(); }\n\nclass Document : IDocument { public virtual void Print() { / Default print implementation / } }\n\nclass DigitalDocument : IDocument { public void Print() { throw new NotSupportedException(\"Digital documents cannot be printed.\"); } }\n\nclass PhysicalDocument : Document { public override void Print() { / Implementation for printing physical documents / } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the DigitalDocument class overrides the Print method in a way that it cannot be used interchangeably with its base class Document. To fix this, I introduced an IDocument interface that both Document and DigitalDocument implement. This way, DigitalDocument can indicate that it does not support printing without breaking the contract of the base class. Additionally, I created a PhysicalDocument class that extends Document to handle physical document printing, ensuring that all document types adhere to the expected behavior."
    },
    {
      "input": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Stop() { throw new NotSupportedException(); } }",
      "output": "abstract class Timer { public abstract void Start(); public abstract void Stop(); } class OneShotTimer : Timer { public override void Start() { / Implementation for starting the one-shot timer / } public override void Stop() { throw new NotSupportedException(\"OneShotTimer cannot be stopped.\"); } } class RepeatingTimer : Timer { public override void Start() { / Implementation for starting the repeating timer / } public override void Stop() { / Implementation for stopping the repeating timer / } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle (LSP)",
      "explanation": "The original code violates the Liskov Substitution Principle because the OneShotTimer class does not support the Stop method, which is expected to be implemented by all subclasses of Timer. To resolve this, I introduced an abstract Timer class with abstract methods for Start and Stop. I then created a OneShotTimer class that overrides these methods, throwing an exception for Stop, indicating that it cannot be stopped. Additionally, I added a RepeatingTimer class to demonstrate a timer that can be started and stopped, adhering to the LSP."
    },
    {
      "input": "using System;\nusing System.IO;\n\nclass FileProcessor\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\n            return \"Ready for processing\";\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n\n    public virtual void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n\n    public override void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\n        throw new InvalidOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "SRP",
      "explanation": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\nusing System.IO;\\n\\ninterface IFileStatusChecker\\n{\\n    string GetStatus(string filePath);\\n}\\n\\ninterface IFileProcessor\\n{\\n    void ProcessFile(string filePath);\\n}\\n\\nclass FileStatusChecker : IFileStatusChecker\\n{\\n    public string GetStatus(string filePath)\\n    {\\n        if (File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Checking status for {filePath} - Found.\");\\n            return \\\"Ready for processing\\\";\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Checking status for {filePath} - Not Found.\");\\n            return \\\"File not found\\\";\\n        }\\n    }\\n}\\n\\nclass FileProcessor : IFileProcessor\\n{\\n    public void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"Processing file {filePath}...\");\\n        if (!File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Error - File {filePath} not found for processing.\");\\n            return;\\n        }\\n        Console.WriteLine($\"File {filePath} processed successfully.\");\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor : IFileProcessor\\n{\\n    public void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"Attempted to process file {filePath}.\");\\n        throw new InvalidOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\");\\n    }\\n}\\n\\nclass Program\\n{\\n    static void Main(string[] args)\\n    {\\n        IFileStatusChecker statusChecker = new FileStatusChecker();\\n        IFileProcessor fileProcessor = new FileProcessor();\\n        IFileProcessor readOnlyProcessor = new ReadOnlyFileProcessor();\\n\\n        string filePath = \\\"example.txt\\\";\\n        Console.WriteLine(statusChecker.GetStatus(filePath));\\n        fileProcessor.ProcessFile(filePath);\\n        try\\n        {\\n            readOnlyProcessor.ProcessFile(filePath);\\n        }\\n        catch (InvalidOperationException ex)\\n        {\\n            Console.WriteLine(ex.Message);\\n        }\\n    }\\n}\",\"explanation\":\"The refactored code separates the responsibilities of checking file status and processing files into distinct classes and interfaces. This adheres to the Single Responsibility Principle (SRP) by ensuring that each class has one reason to change. The FileStatusChecker class is responsible for checking the status of files, while the FileProcessor and ReadOnlyFileProcessor classes handle file processing. This design also allows for easier extension and maintenance of the code.\"}"
    },
    {
      "input": "using System;\n\nclass Account\n{\n    public decimal Balance { get; protected set; } = 1000m;\n\n    public virtual void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (Balance >= amount)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : Account\n{\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public override void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount <= MaxWithdrawalLimit)\n        {\n            if (Balance >= amount)\n            {\n                Balance -= amount;\n                Console.WriteLine($\"Limited (Small): Successfully withdrew {amount}. New Balance: {Balance}\");\n            }\n            else\n            {\n                 Console.WriteLine($\"Limited (Small): Insufficient funds for withdrawal ({amount}). Balance: {Balance}\");\n            }\n        }\n        else\n        {\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\n        }\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "SRP",
      "explanation": "{\"refactored_code\":\"using System;\\n\\ninterface IWithdrawal\\n{\\n    void Withdraw(decimal amount);\\n}\\n\\nclass Account\\n{\\n    public decimal Balance { get; protected set; } = 1000m;\\n}\\n\\nclass StandardWithdrawal : IWithdrawal\\n{\\n    private readonly Account _account;\\n\\n    public StandardWithdrawal(Account account)\\n    {\\n        _account = account;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (_account.Balance >= amount)\\n        {\\n            _account.Balance -= amount;\\n            Console.WriteLine($\"Standard: Successfully withdrew {amount}. New Balance: {_account.Balance}\");\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Standard: Insufficient funds. Cannot withdraw {amount}. Balance: {_account.Balance}\");\\n        }\\n    }\\n}\\n\\nclass LimitedWithdrawal : IWithdrawal\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n    private readonly Account _account;\\n\\n    public LimitedWithdrawal(Account account)\\n    {\\n        _account = account;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount <= MaxWithdrawalLimit)\\n        {\\n            if (_account.Balance >= amount)\\n            {\\n                _account.Balance -= amount;\\n                Console.WriteLine($\"Limited: Successfully withdrew {amount}. New Balance: {_account.Balance}\");\\n            }\\n            else\\n            {\\n                Console.WriteLine($\"Limited: Insufficient funds for withdrawal ({amount}). Balance: {_account.Balance}\");\\n            }\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Limited: Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {_account.Balance}\");\\n        }\\n    }\\n}\\n\\nclass Program\\n{\\n    static void Main(string[] args)\\n    {\\n        Account account = new Account();\\n        IWithdrawal standardWithdrawal = new StandardWithdrawal(account);\\n        IWithdrawal limitedWithdrawal = new LimitedWithdrawal(account);\\n\\n        standardWithdrawal.Withdraw(100);\\n        limitedWithdrawal.Withdraw(30);\\n        limitedWithdrawal.Withdraw(60);\\n    }\\n}\",\"explanation\":\"The refactored code separates the withdrawal logic into different classes that implement the IWithdrawal interface, adhering to the Single Responsibility Principle (SRP) by allowing each withdrawal type to manage its own logic. This also enhances the Open/Closed Principle (OCP) as new withdrawal types can be added without modifying existing code. The Dependency Inversion Principle (DIP) is respected by depending on abstractions (IWithdrawal) rather than concrete implementations. The Liskov Substitution Principle (LSP) is maintained as the withdrawal classes can be used interchangeably. The Interface Segregation Principle (ISP) is also respected as the withdrawal interface is specific to withdrawal operations, avoiding unnecessary methods for the Account class.\",\"violation_type\":\"SRP\"}"
    },
    {
      "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"refactored_code\":\"using System;\\n\\ninterface ILogger\\n{\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger\\n{\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass TimestampedLogger : ILogger\\n{\\n    private readonly DateTime _creationTime;\\n\\n    public TimestampedLogger()\\n    {\\n        _creationTime = DateTime.Now;\\n    }\\n\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the derived class 'LoggerWithIncorrectTimestamp' does not behave as expected when substituted for its base class 'Logger'. The derived class uses a fixed timestamp instead of the current time, which can lead to unexpected behavior. To resolve this, I introduced an interface 'ILogger' that both 'ConsoleLogger' and 'TimestampedLogger' implement. This ensures that both classes can be used interchangeably while maintaining their own logging behavior.\"}"
    },
    {
      "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class CollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : CollectionProcessor\n{\n    public override void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ViolatingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n             var item = data[i];\n             Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\n             System.Threading.Thread.Sleep(10);\n\n             if (item.StartsWith(\"B\"))\n             {\n                 Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\n                 data.RemoveAt(i);\n                 i--;\n             }\n        }\n        Console.WriteLine(\"[ViolatingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n\n",
      "output": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic interface ICollectionProcessor\n{\n    void ProcessCollection(List<string> data);\n}\n\npublic class BaseCollectionProcessor : ICollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : ICollectionProcessor\n{\n    public void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ModifyingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n            var item = data[i];\n            Console.WriteLine($\"[ModifyingProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n\n            if (item.StartsWith(\"B\"))\n            {\n                Console.WriteLine($\"[ModifyingProcessor] Removing item: {item}\");\n                data.RemoveAt(i);\n                i--;\n            }\n        }\n        Console.WriteLine(\"[ModifyingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n\npublic class CollectionProcessorClient\n{\n    private readonly ICollectionProcessor _collectionProcessor;\n\n    public CollectionProcessorClient(ICollectionProcessor collectionProcessor)\n    {\n        _collectionProcessor = collectionProcessor;\n    }\n\n    public void Execute(List<string> data)\n    {\n        _collectionProcessor.ProcessCollection(data);\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        List<string> data = new List<string> { \"Apple\", \"Banana\", \"Berry\", \"Cherry\" };\n        ICollectionProcessor processor = new ModifyingCollectionProcessor();\n        CollectionProcessorClient client = new CollectionProcessorClient(processor);\n        client.Execute(data);\n    }\n}",
      "level": "HARD",
      "language": "C#",
      "violation": "Single Responsibility Principle (SRP)",
      "explanation": "The refactored code separates the responsibilities of processing collections into distinct classes that adhere to the Single Responsibility Principle (SRP). The `ICollectionProcessor` interface defines a contract for collection processors, while `BaseCollectionProcessor` and `ModifyingCollectionProcessor` implement this interface. This allows for better extensibility and maintainability. Additionally, a `CollectionProcessorClient` class is introduced to handle the execution of the processing, further decoupling the processing logic from the client code."
    }
  ]
}