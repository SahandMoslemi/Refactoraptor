{
    "code_examples": [
        {
            "input": "public class Employee {\n    private String name;\n\n    public Employee(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\npublic interface EmployeeRepository {\n    void saveToDatabase(Employee employee);\n}\n\npublic class SqlEmployeeRepository implements EmployeeRepository {\n    @Override\n    public void saveToDatabase(Employee employee) {\n        // save employee to database\n    }\n}\n\npublic interface ReportGenerator {\n    void generateReport(Employee employee);\n}\n\npublic class EmployeeReportGenerator implements ReportGenerator {\n    @Override\n    public void generateReport(Employee employee) {\n        // generate employee report\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "public class Book {\n    private String title;\n\n    public Book(String title) {\n        this.title = title;\n    }\n\n    public String getTitle() {\n        return title;\n    }\n}\n\npublic interface BookPrinter {\n    void print(Book book);\n}\n\npublic class ConsoleBookPrinter implements BookPrinter {\n    @Override\n    public void print(Book book) {\n        System.out.println(\"Book Title: \" + book.getTitle());\n    }\n}\n\npublic interface BookRepository {\n    void save(Book book);\n}\n\npublic class FileBookRepository implements BookRepository {\n    @Override\n    public void save(Book book) {\n        // save book to file logic\n        System.out.println(\"Saving book: \" + book.getTitle() + \" to file.\");\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "public class Invoice {\n    private double total;\n\n    public void calculateTotal() {\n        // calculate total logic\n        this.total = 100.0; // Example total calculation\n    }\n\n    public double getTotal() {\n        return total;\n    }\n}\n\npublic interface InvoicePrinter {\n    void printInvoice(Invoice invoice);\n}\n\npublic class SimpleInvoicePrinter implements InvoicePrinter {\n    public void printInvoice(Invoice invoice) {\n        // print invoice logic\n        System.out.println(\"Invoice Total: \" + invoice.getTotal());\n    }\n}\n\npublic interface InvoiceRepository {\n    void save(Invoice invoice);\n}\n\npublic class FileInvoiceRepository implements InvoiceRepository {\n    public void save(Invoice invoice) {\n        // save invoice to file logic\n        System.out.println(\"Invoice saved to file with total: \" + invoice.getTotal());\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3093654042,\"explanation\":\"The `Invoice` class previously handled both total calculation and printing/saving logic, violating SRP. Now, the responsibilities are separated into distinct classes for printing and saving invoices.\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `Invoice` class previously handled both total calculation and printing/saving logic, violating SRP. Now, the responsibilities are separated into distinct classes for printing and saving invoices."
        },
        {
            "input": "public class User {\n    private String username;\n\n    public User(String username) {\n        this.username = username;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n}\n\npublic interface Authenticator {\n    void login(User user);\n}\n\npublic class UserAuthenticator implements Authenticator {\n    @Override\n    public void login(User user) {\n        // login logic\n    }\n}\n\npublic interface EmailService {\n    void sendEmail(User user);\n}\n\npublic class UserEmailService implements EmailService {\n    @Override\n    public void sendEmail(User user) {\n        // send email to user\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":5134344292,\"explanation\":\"The original code had separate responsibilities for authentication and email services, but they were not encapsulated in a single service. The refactored code introduces a `UserService` that coordinates the login and email sending, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had separate responsibilities for authentication and email services, but they were not encapsulated in a single service. The refactored code introduces a `UserService` that coordinates the login and email sending, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "public class Order {\n    private List<String> items;\n\n    public Order() {\n        this.items = new ArrayList<>();\n    }\n\n    public void addItem(String item) {\n        items.add(item);\n    }\n\n    public List<String> getItems() {\n        return items;\n    }\n}\n\npublic interface PaymentProcessor {\n    void processPayment(Order order);\n}\n\npublic class CreditCardPaymentProcessor implements PaymentProcessor {\n    public void processPayment(Order order) {\n        // process credit card payment\n    }\n}\n\npublic class PayPalPaymentProcessor implements PaymentProcessor {\n    public void processPayment(Order order) {\n        // process PayPal payment\n    }\n}\n\npublic class EmailSender {\n    public void sendConfirmationEmail(Order order) {\n        // send confirmation email\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":5886790833,\"explanation\":\"The original code had the `EmailSender` class handling email sending, which is a separate concern from the order processing. The refactored code introduces an `OrderService` class that coordinates the payment processing and email sending, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had the `EmailSender` class handling email sending, which is a separate concern from the order processing. The refactored code introduces an `OrderService` class that coordinates the payment processing and email sending, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "public class Student {\n    private String name;\n\n    public Student(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\npublic interface CourseService {\n    void enrollInCourse(Student student, String course);\n}\n\npublic class EnrollmentService implements CourseService {\n    @Override\n    public void enrollInCourse(Student student, String course) {\n        // enroll logic\n    }\n}\n\npublic interface GPACalculationService {\n    double calculateGPA(Student student);\n}\n\npublic class GPACalculator implements GPACalculationService {\n    @Override\n    public double calculateGPA(Student student) {\n        // calculate GPA\n        return 0.0; // placeholder return value\n    }\n}\n\npublic interface TranscriptService {\n    void printTranscript(Student student);\n}\n\npublic class TranscriptPrinter implements TranscriptService {\n    @Override\n    public void printTranscript(Student student) {\n        // print transcript\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":5387463208,\"explanation\":\"The original code had multiple services that were not encapsulated within a single cohesive class, leading to a violation of SRP. The refactored code introduces a `StudentService` that coordinates the enrollment and transcript printing, ensuring that each class has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The original code had multiple services that were not encapsulated within a single cohesive class, leading to a violation of SRP. The refactored code introduces a `StudentService` that coordinates the enrollment and transcript printing, ensuring that each class has a single responsibility."
        },
        {
            "input": "public class Product {\n    private String name;\n\n    public Product(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}\n\npublic interface Stockable {\n    void updateStock(int amount);\n}\n\npublic class StockManager implements Stockable {\n    private int stock;\n\n    @Override\n    public void updateStock(int amount) {\n        this.stock += amount;\n    }\n\n    public int getStock() {\n        return stock;\n    }\n}\n\npublic interface Displayable {\n    void display();\n}\n\npublic class ProductDisplayer implements Displayable {\n    private Product product;\n\n    public ProductDisplayer(Product product) {\n        this.product = product;\n    }\n\n    @Override\n    public void display() {\n        System.out.println(\"Product: \" + product.getName());\n    }\n}\n\npublic class ChangeLogger {\n    public void logChange(Product product) {\n        System.out.println(\"Change logged for product: \" + product.getName());\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":9202256416,\"explanation\":\"The `ChangeLogger` class was previously responsible for logging changes, which could lead to a violation of SRP as it was tightly coupled with product management. The refactored code introduces a `ProductManager` class that handles the stock update and logging, ensuring that each class has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `ChangeLogger` class was previously responsible for logging changes, which could lead to a violation of SRP as it was tightly coupled with product management. The refactored code introduces a `ProductManager` class that handles the stock update and logging, ensuring that each class has a single responsibility."
        },
        {
            "input": "public interface Vehicle {\n    String getType();\n}\n\npublic class Car implements Vehicle {\n    private String type;\n\n    public Car(String type) {\n        this.type = type;\n    }\n\n    @Override\n    public String getType() {\n        return type;\n    }\n}\n\npublic class EngineStarter {\n    public void startEngine(Vehicle vehicle) {\n        // start engine\n    }\n}\n\npublic class FuelEfficiencyCalculator {\n    public void calculateFuelEfficiency(Vehicle vehicle) {\n        // calculate fuel efficiency\n    }\n}\n\npublic class MaintenanceScheduler {\n    public void scheduleMaintenance(Vehicle vehicle) {\n        // schedule maintenance\n    }\n}",
            "output": "NONE",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.UUID;\nimport javax.mail.;\nimport javax.mail.internet.;\nimport java.util.Properties;\n\npublic class User {\n    private final String id;\n    private final String username;\n    private final String email;\n    private final String passwordHash;\n\n    public User(String id, String username, String email, String passwordHash) {\n        this.id = id;\n        this.username = username;\n        this.email = email;\n        this.passwordHash = passwordHash;\n    }\n\n    public String getId() { return id; }\n    public String getUsername() { return username; }\n    public String getEmail() { return email; }\n    public String getPasswordHash() { return passwordHash; }\n}\n\npublic class UserProfile {\n    private final String userId;\n    private final String registrationDate;\n\n    public UserProfile(String userId, String registrationDate) {\n        this.userId = userId;\n        this.registrationDate = registrationDate;\n    }\n\n    public String getUserId() { return userId; }\n    public String getRegistrationDate() { return registrationDate; }\n}\n\ninterface UserRepository {\n    boolean exists(String username, String email);\n    boolean save(User user);\n}\n\nclass DatabaseUserRepository implements UserRepository {\n    private final String dbUrl;\n\n    public DatabaseUserRepository(String dbUrl) {\n        this.dbUrl = dbUrl;\n    }\n\n    @Override\n    public boolean exists(String username, String email) {\n        return executeQuery(\"SELECT COUNT() FROM users WHERE username = ? OR email = ?\", pstmt -> {\n            pstmt.setString(1, username);\n            pstmt.setString(2, email);\n        });\n    }\n\n    @Override\n    public boolean save(User user) {\n        return executeUpdate(\"INSERT INTO users (id, username, email, password_hash) VALUES (?, ?, ?, ?)\", pstmt -> {\n            pstmt.setString(1, user.getId());\n            pstmt.setString(2, user.getUsername());\n            pstmt.setString(3, user.getEmail());\n            pstmt.setString(4, user.getPasswordHash());\n        });\n    }\n\n    private boolean executeQuery(String sql, PreparedStatementConsumer consumer) {\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            consumer.accept(pstmt);\n            ResultSet rs = pstmt.executeQuery();\n            return rs.next() && rs.getInt(1) > 0;\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseUserRepository] Database error: \" + e.getMessage());\n            return false;\n        }\n    }\n\n    private boolean executeUpdate(String sql, PreparedStatementConsumer consumer) {\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            consumer.accept(pstmt);\n            return pstmt.executeUpdate() > 0;\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseUserRepository] Database error: \" + e.getMessage());\n            return false;\n        }\n    }\n}\n\n@FunctionalInterface\ninterface PreparedStatementConsumer {\n    void accept(PreparedStatement pstmt) throws SQLException;\n}\n\ninterface PasswordHasher {\n    String hash(String password);\n}\n\nclass SimplePasswordHasher implements PasswordHasher {\n    @Override\n    public String hash(String password) {\n        return \"hashed_\" + password;\n    }\n}\n\ninterface EmailService {\n    boolean sendVerificationEmail(String email, String userId);\n}\n\nclass SmtpEmailService implements EmailService {\n    private final String smtpHost;\n\n    public SmtpEmailService(String smtpHost) {\n        this.smtpHost = smtpHost;\n    }\n\n    @Override\n    public boolean sendVerificationEmail(String email, String userId) {\n        Properties props = new Properties();\n        props.put(\"mail.smtp.auth\", \"true\");\n        props.put(\"mail.smtp.starttls.enable\", \"true\");\n        props.put(\"mail.smtp.host\", smtpHost);\n        props.put(\"mail.smtp.port\", \"587\");\n\n        Session session = Session.getInstance(props, new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(\"no-reply@example.com\", \"password\");\n            }\n        });\n\n        try {\n            Message message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(\"no-reply@example.com\"));\n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(email));\n            message.setSubject(\"Verify Your Email Address\");\n            message.setText(\"Please click the link to verify your email: http://app.com/verify?id=\" + userId);\n\n            Transport.send(message);\n            return true;\n        } catch (MessagingException e) {\n            System.err.println(\"[SmtpEmailService] Error sending email: \" + e.getMessage());\n            return false;\n        }\n    }\n}\n\ninterface UserProfileRepository {\n    boolean initializeProfile(String userId);\n}\n\nclass DatabaseUserProfileRepository implements UserProfileRepository {\n    private final String dbUrl;\n\n    public DatabaseUserProfileRepository(String dbUrl) {\n        this.dbUrl = dbUrl;\n    }\n\n    @Override\n    public boolean initializeProfile(String userId) {\n        return executeUpdate(\"INSERT INTO user_profiles (user_id, registration_date) VALUES (?, CURRENT_DATE)\", pstmt -> {\n            pstmt.setString(1, userId);\n        });\n    }\n\n    private boolean executeUpdate(String sql, PreparedStatementConsumer consumer) {\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            consumer.accept(pstmt);\n            return pstmt.executeUpdate() > 0;\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseUserProfileRepository] Database error: \" + e.getMessage());\n            return false;\n        }\n    }\n}\n\ninterface AuditLogger {\n    void log(String eventType, String relatedUser, String details);\n}\n\nclass ConsoleAuditLogger implements AuditLogger {\n    @Override\n    public void log(String eventType, String relatedUser, String details) {\n        System.out.println(\"[ConsoleAuditLogger] LOG: Type=\" + eventType + \", User=\" + relatedUser + \", Details=\" + details);\n    }\n}\n\npublic class UserOnboardingWorkflow {\n    private final UserRepository userRepository;\n    private final PasswordHasher passwordHasher;\n    private final EmailService emailService;\n    private final UserProfileRepository userProfileRepository;\n    private final AuditLogger auditLogger;\n\n    public UserOnboardingWorkflow(\n            UserRepository userRepository,\n            PasswordHasher passwordHasher,\n            EmailService emailService,\n            UserProfileRepository userProfileRepository,\n            AuditLogger auditLogger) {\n        this.userRepository = userRepository;\n        this.passwordHasher = passwordHasher;\n        this.emailService = emailService;\n        this.userProfileRepository = userProfileRepository;\n        this.auditLogger = auditLogger;\n    }\n\n    public boolean onboardNewUser(String username, String email, String password) {\n        if (userRepository.exists(username, email)) {\n            auditLogger.log(\"UserRegistrationFailed\", username, \"User already exists\");\n            return false;\n        }\n\n        String userId = UUID.randomUUID().toString();\n        String passwordHash = passwordHasher.hash(password);\n\n        User newUser = new User(userId, username, email, passwordHash);\n        if (!userRepository.save(newUser)) {\n            auditLogger.log(\"UserRegistrationFailed\", username, \"DB Save Failed\");\n            return false;\n        }\n\n        if (!emailService.sendVerificationEmail(email, userId)) {\n            auditLogger.log(\"UserRegistrationFailed\", username, \"Email Sending Failed\");\n            return false;\n        }\n\n        if (!userProfileRepository.initializeProfile(userId)) {\n            auditLogger.log(\"UserRegistrationFailed\", username, \"Profile Initialization Failed\");\n            return false;\n        }\n\n        auditLogger.log(\"UserRegistered\", username, \"Success\");\n        return true;\n    }\n\n    public static void main(String[] args) {\n        String testDbUrl = \"jdbc:sqlite:test_onboarding_refactored.db\";\n        String testSmtpHost = \"localhost\";\n\n        try (Connection conn = DriverManager.getConnection(testDbUrl)) {\n            conn.createStatement().execute(\"DROP TABLE IF EXISTS users;\");\n            conn.createStatement().execute(\"CREATE TABLE users (id TEXT PRIMARY KEY, username TEXT UNIQUE, email TEXT UNIQUE, password_hash TEXT);\");\n            conn.createStatement().execute(\"DROP TABLE IF EXISTS user_profiles;\");\n            conn.createStatement().execute(\"CREATE TABLE user_profiles (user_id TEXT PRIMARY KEY, registration_date DATE);\");\n            conn.createStatement().execute(\"DROP TABLE IF EXISTS audit_log;\");\n            conn.createStatement().execute(\"CREATE TABLE audit_log (event_type TEXT, related_user TEXT, details TEXT);\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        UserRepository userRepository = new DatabaseUserRepository(testDbUrl);\n        PasswordHasher passwordHasher = new SimplePasswordHasher();\n        EmailService emailService = new SmtpEmailService(testSmtpHost);\n        UserProfileRepository userProfileRepository = new DatabaseUserProfileRepository(testDbUrl);\n        AuditLogger auditLogger = new ConsoleAuditLogger();\n\n        UserOnboardingWorkflow workflow = new UserOnboardingWorkflow(\n                userRepository, passwordHasher, emailService, userProfileRepository, auditLogger);\n\n        workflow.onboardNewUser(\"johndoe\", \"john.doe@example.com\", \"securepass\");\n        workflow.onboardNewUser(\"johndoe\", \"john.doe@example.com\", \"anotherpass\"); \n        workflow.onboardNewUser(\"janedoe\", \"jane.doe@example.com\", \"easypass\");\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":33073843000,\"explanation\":\"The `UserOnboardingWorkflow` class was previously responsible for user onboarding, including user creation, email verification, and profile initialization, which violates the Single Responsibility Principle (SRP). The refactored code separates these responsibilities into distinct classes, allowing each class to focus on a single task.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `UserOnboardingWorkflow` class was previously responsible for user onboarding, including user creation, email verification, and profile initialization, which violates the Single Responsibility Principle (SRP). The refactored code separates these responsibilities into distinct classes, allowing each class to focus on a single task."
        },
        {
            "input": "import java.io.FileWriter;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport javax.mail.;\nimport javax.mail.internet.;\nimport java.util.Properties;\n\npublic class InvoiceItem {\n    private String productName;\n    private int quantity;\n    private double price;\n\n    public InvoiceItem(String productName, int quantity, double price) {\n        this.productName = productName;\n        this.quantity = quantity;\n        this.price = price;\n    }\n\n    public String getProductName() { return productName; }\n    public int getQuantity() { return quantity; }\n    public double getPrice() { return price; }\n}\n\npublic class Invoice {\n    private final String invoiceNumber;\n    private final int orderId;\n    private final String customerEmail;\n    private final double totalAmount;\n    private final Date invoiceDate;\n    private final List<InvoiceItem> items;\n\n    public Invoice(String invoiceNumber, int orderId, String customerEmail, double totalAmount, Date invoiceDate, List<InvoiceItem> items) {\n        this.invoiceNumber = invoiceNumber;\n        this.orderId = orderId;\n        this.customerEmail = customerEmail;\n        this.totalAmount = totalAmount;\n        this.invoiceDate = invoiceDate;\n        this.items = items;\n    }\n\n    public String getInvoiceNumber() { return invoiceNumber; }\n    public int getOrderId() { return orderId; }\n    public String getCustomerEmail() { return customerEmail; }\n    public double getTotalAmount() { return totalAmount; }\n    public Date getInvoiceDate() { return invoiceDate; }\n    public List<InvoiceItem> getItems() { return items; }\n}\n\ninterface OrderRepository {\n    List<InvoiceItem> fetchOrderItems(int orderId);\n}\n\nclass DatabaseOrderRepository implements OrderRepository {\n    private final String dbUrl;\n\n    public DatabaseOrderRepository(String dbUrl) {\n        this.dbUrl = dbUrl;\n    }\n\n    @Override\n    public List<InvoiceItem> fetchOrderItems(int orderId) {\n        List<InvoiceItem> items = new ArrayList<>();\n        String sql = \"SELECT product_name, quantity, price FROM order_items WHERE order_id = ?\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setInt(1, orderId);\n\n            // Simulating database fetch\n            items.add(new InvoiceItem(\"Gadget A\", 2, 19.99));\n            items.add(new InvoiceItem(\"Widget B\", 1, 45.50));\n\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseOrderRepository] Database error fetching items: \" + e.getMessage());\n            return null;\n        }\n        return items;\n    }\n}\n\ninterface InvoiceCalculator {\n    double calculateTotal(List<InvoiceItem> items);\n}\n\nclass SimpleInvoiceCalculator implements InvoiceCalculator {\n    @Override\n    public double calculateTotal(List<InvoiceItem> items) {\n        double total = 0;\n        if (items != null) {\n            for (InvoiceItem item : items) {\n                total += item.getQuantity()  item.getPrice();\n            }\n        }\n        return total;\n    }\n}\n\ninterface InvoiceNumberGenerator {\n    String generate(int orderId);\n}\n\nclass SimpleInvoiceNumberGenerator implements InvoiceNumberGenerator {\n    @Override\n    public String generate(int orderId) {\n        return \"INV-\" + orderId + \"-\" + new Date().getTime();\n    }\n}\n\ninterface InvoiceRepository {\n    boolean save(Invoice invoice);\n}\n\nclass DatabaseInvoiceRepository implements InvoiceRepository {\n    private final String dbUrl;\n\n    public DatabaseInvoiceRepository(String dbUrl) {\n        this.dbUrl = dbUrl;\n    }\n\n    @Override\n    public boolean save(Invoice invoice) {\n        String sql = \"INSERT INTO invoices (invoice_number, order_id, customer_email, total_amount, invoice_date) VALUES (?, ?, ?, ?, CURRENT_DATE)\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, invoice.getInvoiceNumber());\n            pstmt.setInt(2, invoice.getOrderId());\n            pstmt.setString(3, invoice.getCustomerEmail());\n            pstmt.setDouble(4, invoice.getTotalAmount());\n            int affectedRows = pstmt.executeUpdate();\n            return affectedRows > 0;\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseInvoiceRepository] Database error saving invoice: \" + e.getMessage());\n            return false;\n        }\n    }\n}\n\ninterface InvoiceFileGenerator {\n    String generate(Invoice invoice);\n}\n\nclass PdfInvoiceFileGenerator implements InvoiceFileGenerator {\n    private final String outputDirectory;\n\n    public PdfInvoiceFileGenerator(String outputDirectory) {\n        this.outputDirectory = outputDirectory;\n        new java.io.File(outputDirectory).mkdirs();\n    }\n\n    @Override\n    public String generate(Invoice invoice) {\n        String filePath = outputDirectory + \"/\" + invoice.getInvoiceNumber() + \".pdf\";\n        try (FileWriter writer = new FileWriter(filePath)) {\n            writer.write(\"Invoice Number: \" + invoice.getInvoiceNumber() + \"\\n\");\n            writer.write(\"Customer: \" + invoice.getCustomerEmail() + \"\\n\");\n            writer.write(\"Items:\\n\");\n            for (InvoiceItem item : invoice.getItems()) {\n                writer.write(\"  \" + item.getProductName() + \" x\" + item.getQuantity() + \" @ \" + item.getPrice() + \"\\n\");\n            }\n            writer.write(\"Total: \" + invoice.getTotalAmount() + \"\\n\");\n            return filePath;\n        } catch (IOException e) {\n            System.err.println(\"[PdfInvoiceFileGenerator] Error generating PDF file: \" + e.getMessage());\n            return null;\n        }\n    }\n}\n\ninterface InvoiceMailer {\n    boolean email(String recipientEmail, String invoiceFilePath);\n}\n\nclass SmtpInvoiceMailer implements InvoiceMailer {\n    private final String smtpHost;\n\n    public SmtpInvoiceMailer(String smtpHost) {\n        this.smtpHost = smtpHost;\n    }\n\n    @Override\n    public boolean email(String recipientEmail, String invoiceFilePath) {\n        Properties props = new Properties();\n        props.put(\"mail.smtp.auth\", \"true\");\n        props.put(\"mail.smtp.starttls.enable\", \"true\");\n        props.put(\"mail.smtp.host\", smtpHost);\n        props.put(\"mail.smtp.port\", \"587\");\n\n        Session session = Session.getInstance(props, new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(\"invoices@example.com\", \"password\");\n            }\n        });\n\n        try {\n            Message message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(\"invoices@example.com\"));\n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipientEmail));\n            message.setSubject(\"Your Invoice\");\n            message.setText(\"Please find your invoice attached.\");\n\n            MimeBodyPart messageBodyPart = new MimeBodyPart();\n            messageBodyPart.setText(\"Please find your invoice attached.\");\n\n            Multipart multipart = new MimeMultipart();\n            multipart.addBodyPart(messageBodyPart);\n\n            MimeBodyPart attachmentPart = new MimeBodyPart();\n            attachmentPart.attachFile(invoiceFilePath);\n            multipart.addBodyPart(attachmentPart);\n\n            message.setContent(multipart);\n\n            Transport.send(message);\n            return true;\n        } catch (MessagingException | IOException e) {\n            System.err.println(\"[SmtpInvoiceMailer] Error emailing invoice: \" + e.getMessage());\n            return false;\n        }\n    }\n}\n\npublic class InvoiceProcessingWorkflow {\n    private final OrderRepository orderRepository;\n    private final InvoiceCalculator invoiceCalculator;\n    private final InvoiceNumberGenerator invoiceNumberGenerator;\n    private final InvoiceRepository invoiceRepository;\n    private final InvoiceFileGenerator invoiceFileGenerator;\n    private final InvoiceMailer invoiceMailer;\n\n    public InvoiceProcessingWorkflow(\n            OrderRepository orderRepository,\n            InvoiceCalculator invoiceCalculator,\n            InvoiceNumberGenerator invoiceNumberGenerator,\n            InvoiceRepository invoiceRepository,\n            InvoiceFileGenerator invoiceFileGenerator,\n            InvoiceMailer invoiceMailer) {\n        this.orderRepository = orderRepository;\n        this.invoiceCalculator = invoiceCalculator;\n        this.invoiceNumberGenerator = invoiceNumberGenerator;\n        this.invoiceRepository = invoiceRepository;\n        this.invoiceFileGenerator = invoiceFileGenerator;\n        this.invoiceMailer = invoiceMailer;\n    }\n\n    public boolean processAndSendInvoice(int orderId, String customerEmail) {\n        List<InvoiceItem> items = orderRepository.fetchOrderItems(orderId);\n        if (items == null || items.isEmpty()) {\n            return false;\n        }\n\n        double totalAmount = invoiceCalculator.calculateTotal(items);\n        String invoiceNumber = invoiceNumberGenerator.generate(orderId);\n\n        Invoice invoice = new Invoice(invoiceNumber, orderId, customerEmail, totalAmount, new Date(), items);\n\n        if (!invoiceRepository.save(invoice)) {\n            return false;\n        }\n\n        String invoiceFilePath = invoiceFileGenerator.generate(invoice);\n        if (invoiceFilePath == null) {\n            return false;\n        }\n\n        return invoiceMailer.email(customerEmail, invoiceFilePath);\n    }\n\n    public static void main(String[] args) {\n        String testDbUrl = \"jdbc:sqlite:test_invoices_refactored.db\";\n        String testInvoicePath = \"./invoices_refactored\";\n        String testSmtpHost = \"localhost\";\n\n        try (Connection conn = DriverManager.getConnection(testDbUrl)) {\n            conn.createStatement().execute(\"DROP TABLE IF EXISTS order_items;\");\n            conn.createStatement().execute(\"CREATE TABLE order_items (order_id INTEGER, product_name TEXT, quantity INTEGER, price REAL);\");\n            conn.createStatement().execute(\"INSERT INTO order_items (order_id, product_name, quantity, price) VALUES (101, 'Gadget A', 2, 19.99);\");\n            conn.createStatement().execute(\"INSERT INTO order_items (order_id, product_name, quantity, price) VALUES (101, 'Widget B', 1, 45.50);\");\n\n            conn.createStatement().execute(\"DROP TABLE IF EXISTS invoices;\");\n            conn.createStatement().execute(\"CREATE TABLE invoices (invoice_number TEXT PRIMARY KEY, order_id INTEGER UNIQUE, customer_email TEXT, total_amount REAL, invoice_date DATE);\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        OrderRepository orderRepository = new DatabaseOrderRepository(testDbUrl);\n        InvoiceCalculator invoiceCalculator = new SimpleInvoiceCalculator();\n        InvoiceNumberGenerator invoiceNumberGenerator = new SimpleInvoiceNumberGenerator();\n        InvoiceRepository invoiceRepository = new DatabaseInvoiceRepository(testDbUrl);\n        InvoiceFileGenerator invoiceFileGenerator = new PdfInvoiceFileGenerator(testInvoicePath);\n        InvoiceMailer invoiceMailer = new SmtpInvoiceMailer(testSmtpHost);\n\n        InvoiceProcessingWorkflow workflow = new InvoiceProcessingWorkflow(\n                orderRepository, invoiceCalculator, invoiceNumberGenerator, invoiceRepository, invoiceFileGenerator, invoiceMailer);\n\n        workflow.processAndSendInvoice(101, \"customer1@example.com\");\n        workflow.processAndSendInvoice(102, \"customer2@example.com\");\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":41441349708,\"explanation\":\"The `InvoiceProcessingWorkflow` class was handling multiple responsibilities including fetching order items, calculating totals, generating invoice numbers, saving invoices, generating files, and sending emails. This was refactored to ensure that each class has a single responsibility, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "SRP",
            "explanation": "The `InvoiceProcessingWorkflow` class was handling multiple responsibilities including fetching order items, calculating totals, generating invoice numbers, saving invoices, generating files, and sending emails. This was refactored to ensure that each class has a single responsibility, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\ninterface SourceDataReader<T> {\n    List<T> read();\n}\n\nclass DatabaseSourceDataReader implements SourceDataReader<SourceData> {\n    private final String dbUrl;\n    private final String sourceTable;\n\n    public DatabaseSourceDataReader(String dbUrl, String sourceTable) {\n        this.dbUrl = dbUrl;\n        this.sourceTable = sourceTable;\n    }\n\n    @Override\n    public List<SourceData> read() {\n        System.out.println(\"[DatabaseSourceDataReader] Fetching data from source DB \" + dbUrl + \" table \" + sourceTable + \"...\");\n        List<SourceData> records = new ArrayList<>();\n        String sql = \"SELECT id, raw_value FROM \" + sourceTable + \" WHERE processed = FALSE LIMIT 100\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql);\n             ResultSet rs = pstmt.executeQuery()) {\n\n            while (rs.next()) {\n                records.add(new SourceData(rs.getInt(\"id\"), rs.getString(\"raw_value\")));\n            }\n\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseSourceDataReader] Database error fetching source data: \" + e.getMessage());\n            return null;\n        }\n        return records;\n    }\n}\n\ninterface DataTransformer<TSource, TTarget> {\n    List<TTarget> transform(List<TSource> sourceData);\n}\n\nclass SimpleDataTransformer implements DataTransformer<SourceData, TargetData> {\n    @Override\n    public List<TargetData> transform(List<SourceData> sourceData) {\n        System.out.println(\"[SimpleDataTransformer] Transforming data...\");\n        List<TargetData> targetRecords = new ArrayList<>();\n        if (sourceData != null) {\n            for (SourceData record : sourceData) {\n                if (record.getRawValue() != null && record.getRawValue().length() > 2) {\n                    targetRecords.add(new TargetData(record.getId(), record.getRawValue().toUpperCase()));\n                }\n            }\n        }\n        return targetRecords;\n    }\n}\n\ninterface TargetDataWriter<T> {\n    int write(List<T> data);\n}\n\nclass DatabaseTargetDataWriter implements TargetDataWriter<TargetData> {\n    private final String dbUrl;\n    private final String targetTable;\n\n    public DatabaseTargetDataWriter(String dbUrl, String targetTable) {\n        this.dbUrl = dbUrl;\n        this.targetTable = targetTable;\n        initializeTargetDb();\n    }\n\n    private void initializeTargetDb() {\n        System.out.println(\"[DatabaseTargetDataWriter] Initializing target DB \" + dbUrl + \" table \" + targetTable + \"...\");\n        String sql = \"CREATE TABLE IF NOT EXISTS \" + targetTable + \" (id INTEGER PRIMARY KEY, value TEXT)\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.executeUpdate();\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseTargetDataWriter] Error initializing target DB: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public int write(List<TargetData> targetRecords) {\n        System.out.println(\"[DatabaseTargetDataWriter] Saving data to target DB \" + dbUrl + \" table \" + targetTable + \"...\");\n        String sql = \"INSERT INTO \" + targetTable + \" (id, value) VALUES (?, ?)\";\n        int importedCount = 0;\n        if (targetRecords == null || targetRecords.isEmpty()) return 0;\n\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n\n            for (TargetData record : targetRecords) {\n                pstmt.setInt(1, record.getId());\n                pstmt.setString(2, record.getValue());\n                pstmt.addBatch();\n            }\n            int[] results = pstmt.executeBatch();\n            for (int count : results) {\n                if (count >= 0) { \n                    importedCount += count; \n                }\n            }\n\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseTargetDataWriter] Database error saving target data: \" + e.getMessage());\n\n        }\n        return importedCount;\n    }\n}\n\ninterface MigrationLogger {\n    void log(String eventType, String details, int count, boolean success);\n}\n\nclass ConsoleMigrationLogger implements MigrationLogger {\n    @Override\n    public void log(String eventType, String details, int count, boolean success) {\n         System.out.println(\"[ConsoleMigrationLogger] LOG: Type=\" + eventType + \", Details=\" + details + \", Count=\" + count + \", Success=\" + success);\n\n    }\n}\n\nclass SourceData {\n    private int id;\n    private String rawValue;\n    SourceData(int id, String rawValue) { this.id = id; this.rawValue = rawValue; }\n    public int getId() { return id; }\n    public String getRawValue() { return rawValue; }\n}\n\nclass TargetData {\n    private int id;\n    private String value;\n    TargetData(int id, String value) { this.id = id; this.value = value; }\n    public int getId() { return id; }\n    public String getValue() { return value; }\n}\n\npublic class DataMigrationWorkflow {\n    private final SourceDataReader<SourceData> sourceReader;\n    private final DataTransformer<SourceData, TargetData> dataTransformer;\n    private final TargetDataWriter<TargetData> targetWriter;\n    private final MigrationLogger migrationLogger;\n\n    public DataMigrationWorkflow(\n            SourceDataReader<SourceData> sourceReader,\n            DataTransformer<SourceData, TargetData> dataTransformer,\n            TargetDataWriter<TargetData> targetWriter,\n            MigrationLogger migrationLogger) {\n        this.sourceReader = sourceReader;\n        this.dataTransformer = dataTransformer;\n        this.targetWriter = targetWriter;\n        this.migrationLogger = migrationLogger;\n    }\n\n    public int migrateData() {\n        System.out.println(\"[DataMigrationWorkflow] Starting data migration workflow.\");\n\n        List<SourceData> sourceRecords = sourceReader.read();\n        if (sourceRecords == null || sourceRecords.isEmpty()) {\n            System.out.println(\"[DataMigrationWorkflow] No data found in source.\");\n            migrationLogger.log(\"Migration\", \"No data in source\", 0, false);\n            return 0;\n        }\n        System.out.println(\"[DataMigrationWorkflow] Fetched \" + sourceRecords.size() + \" records from source.\");\n\n        List<TargetData> targetRecords = dataTransformer.transform(sourceRecords);\n        if (targetRecords == null) { \n             System.out.println(\"[DataMigrationWorkflow] Transformation failed.\");\n             migrationLogger.log(\"Migration\", \"Transformation failed\", sourceRecords.size(), false);\n             return 0;\n        }\n         if (targetRecords.isEmpty()) {\n            System.out.println(\"[DataMigrationWorkflow] No data after transformation.\");\n            migrationLogger.log(\"Migration\", \"No data after transformation\", sourceRecords.size(), false);\n            return 0;\n        }\n        System.out.println(\"[DataMigrationWorkflow] Transformed \" + targetRecords.size() + \" records.\");\n\n        int importedCount = targetWriter.write(targetRecords);\n        System.out.println(\"[DataMigrationWorkflow] Saved \" + importedCount + \" records to target.\");\n\n        if (importedCount == targetRecords.size()) {\n            migrationLogger.log(\"Migration\", \"Success\", importedCount, true);\n             System.out.println(\"[DataMigrationWorkflow] Data migration workflow complete. \" + importedCount + \" records migrated.\");\n        } else {\n             migrationLogger.log(\"Migration\", \"Partial Success or Failure\", importedCount, false);\n             System.out.println(\"[DataMigrationWorkflow] Data migration workflow complete with issues. \" + importedCount + \" records migrated out of \" + targetRecords.size() +.\");\n        }\n\n        return importedCount;\n    }\n\n    public static void main(String[] args) {\n        String sourceDbUrl = \"jdbc:sqlite:source_migration_refactored.db\";\n        String targetDbUrl = \"jdbc:sqlite:target_migration_refactored.db\";\n\n         try (Connection conn = DriverManager.getConnection(sourceDbUrl)) {\n            conn.createStatement().execute(\"DROP TABLE IF EXISTS source_data;\");\n            conn.createStatement().execute(\"CREATE TABLE source_data (id INTEGER PRIMARY KEY, raw_value TEXT, processed BOOLEAN);\");\n            conn.createStatement().execute(\"INSERT INTO source_data (id, raw_value, processed) VALUES (1, 'value1', FALSE);\");\n            conn.createStatement().execute(\"INSERT INTO source_data (id, raw_value, processed) VALUES (2, 'value2', FALSE);\");\n            conn.createStatement().execute(\"INSERT INTO source_data (id, raw_value, processed) VALUES (3, 'a', FALSE);\"); \n             conn.createStatement().execute(\"INSERT INTO source_data (id, raw_value, processed) VALUES (4, NULL, FALSE);\"); \n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n         new java.io.File(\"target_migration_refactored.db\").delete();\n\n        SourceDataReader<SourceData> sourceReader = new DatabaseSourceDataReader(sourceDbUrl, \"source_data\");\n        DataTransformer<SourceData, TargetData> dataTransformer = new SimpleDataTransformer();\n        TargetDataWriter<TargetData> targetWriter = new DatabaseTargetDataWriter(targetDbUrl, \"migrated_data\");\n        MigrationLogger migrationLogger = new ConsoleMigrationLogger();\n\n        DataMigrationWorkflow workflow = new DataMigrationWorkflow(\n                sourceReader, dataTransformer, targetWriter, migrationLogger);\n\n        workflow.migrateData();\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":8781321292,\"explanation\":\"The `DatabaseSourceDataReader` and `DatabaseTargetDataWriter` classes were handling both data access and database connection management, which violates the Single Responsibility Principle (SRP). The refactored code separates the concerns of reading from and writing to the database, allowing each class to focus on a single responsibility.\"}",
            "level": "HARD",
            "language": "java",
            "violation": "SRP",
            "explanation": "The `DatabaseSourceDataReader` and `DatabaseTargetDataWriter` classes were handling both data access and database connection management, which violates the Single Responsibility Principle (SRP). The refactored code separates the concerns of reading from and writing to the database, allowing each class to focus on a single responsibility."
        },
        {
            "input": "import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport javax.mail.;\nimport javax.mail.internet.;\nimport java.util.Properties;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Event {\n    private final String type;\n    private final String payload;\n\n    public Event(String type, String payload) {\n        this.type = type;\n        this.payload = payload;\n    }\n\n    public String getType() { return type; }\n    public String getPayload() { return payload; }\n}\n\ninterface MetricsRepository {\n    void incrementUserCount();\n    void addSalesAmount(double amount);\n}\n\nclass DatabaseMetricsRepository implements MetricsRepository {\n    private final String dbUrl;\n\n    public DatabaseMetricsRepository(String dbUrl) {\n        this.dbUrl = dbUrl;\n        initializeDb();\n    }\n\n    private void initializeDb() {\n        System.out.println(\"[DatabaseMetricsRepository] Initializing DB \" + dbUrl + \"...\");\n        String sql = \"CREATE TABLE IF NOT EXISTS metrics (user_count INTEGER DEFAULT 0, total_sales REAL DEFAULT 0.0)\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.executeUpdate();\n            String insertSql = \"INSERT INTO metrics(user_count, total_sales) SELECT 0, 0.0 WHERE NOT EXISTS (SELECT 1 FROM metrics)\";\n            conn.createStatement().executeUpdate(insertSql);\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseMetricsRepository] Error initializing DB: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void incrementUserCount() {\n        System.out.println(\"[DatabaseMetricsRepository] Updating user count in DB \" + dbUrl + \"...\");\n        String sql = \"UPDATE metrics SET user_count = user_count + 1\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.executeUpdate();\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseMetricsRepository] Database error updating user count: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void addSalesAmount(double amount) {\n        System.out.println(\"[DatabaseMetricsRepository] Updating sales metrics in DB \" + dbUrl + \" with amount: \" + amount + \"...\");\n        String sql = \"UPDATE metrics SET total_sales = total_sales + ?\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setDouble(1, amount);\n            pstmt.executeUpdate();\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseMetricsRepository] Database error updating sales metrics: \" + e.getMessage());\n        }\n    }\n}\n\ninterface NotificationService {\n    void sendWelcomeEmail(String recipientEmail);\n}\n\nclass EmailNotificationService implements NotificationService {\n    private final String smtpHost;\n\n    public EmailNotificationService(String smtpHost) {\n        this.smtpHost = smtpHost;\n    }\n\n    @Override\n    public void sendWelcomeEmail(String recipientEmail) {\n        System.out.println(\"[EmailNotificationService] Sending welcome email to \" + recipientEmail + \" (SMTP: \" + smtpHost + \")...\");\n        Properties props = new Properties();\n        props.put(\"mail.smtp.auth\", \"true\");\n        props.put(\"mail.smtp.starttls.enable\", \"true\");\n        props.put(\"mail.smtp.host\", smtpHost);\n        props.put(\"mail.smtp.port\", \"587\");\n\n        Session session = Session.getInstance(props, new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(\"welcome@example.com\", \"password\");\n            }\n        });\n\n        try {\n            Message message = new MimeMessage(session);\n            message.setFrom(new InternetAddress(\"welcome@example.com\"));\n            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipientEmail));\n            message.setSubject(\"Welcome!\");\n            message.setText(\"Welcome to our service!\");\n\n            Transport.send(message);\n        } catch (MessagingException e) {\n            System.err.println(\"[EmailNotificationService] Error sending welcome email: \" + e.getMessage());\n        }\n    }\n}\n\ninterface EventLogger {\n    void log(String eventType, String payload);\n}\n\nclass ConsoleEventLogger implements EventLogger {\n    @Override\n    public void log(String eventType, String payload) {\n        System.out.println(\"[ConsoleEventLogger] LOG: Type=\" + eventType + \", Payload=\" + payload);\n    }\n}\n\ninterface EventRepository {\n    void save(Event event);\n}\n\nclass DatabaseEventRepository implements EventRepository {\n    private final String dbUrl;\n\n    public DatabaseEventRepository(String dbUrl) {\n        this.dbUrl = dbUrl;\n        initializeDb();\n    }\n\n    private void initializeDb() {\n        System.out.println(\"[DatabaseEventRepository] Initializing DB \" + dbUrl + \"...\");\n        String sql = \"CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, event_type TEXT, payload TEXT, processed_at DATETIME DEFAULT CURRENT_TIMESTAMP)\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.executeUpdate();\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseEventRepository] Error initializing DB: \" + e.getMessage());\n        }\n    }\n\n    @Override\n    public void save(Event event) {\n        System.out.println(\"[DatabaseEventRepository] Saving event \" + event.getType() + \" to DB \" + dbUrl + \"...\");\n        String sql = \"INSERT INTO events (event_type, payload) VALUES (?, ?)\";\n        try (Connection conn = DriverManager.getConnection(dbUrl);\n             PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setString(1, event.getType());\n            pstmt.setString(2, event.getPayload());\n            pstmt.executeUpdate();\n        } catch (SQLException e) {\n            System.err.println(\"[DatabaseEventRepository] Database error saving event: \" + e.getMessage());\n        }\n    }\n}\n\ninterface EventHandler {\n    String getEventType();\n    void handle(String payload);\n}\n\nclass UserCreatedEventHandler implements EventHandler {\n    private final MetricsRepository metricsRepository;\n    private final NotificationService notificationService;\n\n    public UserCreatedEventHandler(MetricsRepository metricsRepository, NotificationService notificationService) {\n        this.metricsRepository = metricsRepository;\n        this.notificationService = notificationService;\n    }\n\n    @Override\n    public String getEventType() { return \"USER_CREATED\"; }\n\n    @Override\n    public void handle(String payload) {\n        System.out.println(\"[UserCreatedEventHandler] Handling USER_CREATED event with payload: \" + payload);\n        metricsRepository.incrementUserCount();\n        notificationService.sendWelcomeEmail(payload);\n    }\n}\n\nclass OrderPlacedEventHandler implements EventHandler {\n    private final MetricsRepository metricsRepository;\n\n    public OrderPlacedEventHandler(MetricsRepository metricsRepository) {\n        this.metricsRepository = metricsRepository;\n    }\n\n    @Override\n    public String getEventType() { return \"ORDER_PLACED\"; }\n\n    @Override\n    public void handle(String payload) {\n        System.out.println(\"[OrderPlacedEventHandler] Handling ORDER_PLACED event with payload: \" + payload);\n        try {\n            double amount = Double.parseDouble(payload);\n            metricsRepository.addSalesAmount(amount);\n        } catch (NumberFormatException e) {\n            System.err.println(\"[OrderPlacedEventHandler] Invalid payload format for ORDER_PLACED: \" + payload);\n        }\n    }\n}\n\nclass EventDispatchWorkflow {\n    private final EventRepository eventRepository;\n    private final EventLogger eventLogger;\n    private final Map<String, EventHandler> handlers;\n\n    public EventDispatchWorkflow(\n            EventRepository eventRepository,\n            EventLogger eventLogger,\n            java.util.List<EventHandler> eventHandlers) {\n        this.eventRepository = eventRepository;\n        this.eventLogger = eventLogger;\n        this.handlers = new HashMap<>();\n        for (EventHandler handler : eventHandlers) {\n            this.handlers.put(handler.getEventType(), handler);\n        }\n    }\n\n    public void dispatchAndHandle(String eventType, String payload) {\n        System.out.println(\"[EventDispatchWorkflow] Dispatching event: Type=\" + eventType + \", Payload=\" + payload);\n\n        Event event = new Event(eventType, payload);\n        eventRepository.save(event);\n        System.out.println(\"[EventDispatchWorkflow] Event saved to DB.\");\n\n        EventHandler handler = handlers.get(eventType);\n\n        if (handler != null) {\n            try {\n                System.out.println(\"[EventDispatchWorkflow] Found handler for type: \" + eventType + \". Executing...\");\n                handler.handle(payload);\n                eventLogger.log(eventType, \"Handled Successfully\");\n            } catch (Exception e) {\n                System.err.println(\"[EventDispatchWorkflow] Error handling event \" + eventType + \": \" + e.getMessage());\n                eventLogger.log(eventType, \"Handling Failed: \" + e.getMessage());\n            }\n        } else {\n            System.out.println(\"[EventDispatchWorkflow] No handler found for event type: \" + eventType);\n            eventLogger.log(eventType, \"No Handler Found\");\n        }\n\n        System.out.println(\"[EventDispatchWorkflow] Event dispatch complete for type: \" + eventType);\n    }\n\n    public static void main(String[] args) {\n        String testDbUrl = \"jdbc:sqlite:test_events_refactored.db\";\n        String testSmtpHost = \"localhost\";\n\n        new java.io.File(\"test_events_refactored.db\").delete();\n\n        MetricsRepository metricsRepository = new DatabaseMetricsRepository(testDbUrl);\n        NotificationService notificationService = new EmailNotificationService(testSmtpHost);\n\n        EventRepository eventRepository = new DatabaseEventRepository(testDbUrl);\n        EventLogger eventLogger = new ConsoleEventLogger();\n\n        java.util.List<EventHandler> handlers = new java.util.ArrayList<>();\n        handlers.add(new UserCreatedEventHandler(metricsRepository, notificationService));\n        handlers.add(new OrderPlacedEventHandler(metricsRepository));\n\n        EventDispatchWorkflow workflow = new EventDispatchWorkflow(eventRepository, eventLogger, handlers);\n\n        workflow.dispatchAndHandle(\"USER_CREATED\", \"newuser@example.com\");\n        workflow.dispatchAndHandle(\"ORDER_PLACED\", \"150.75\");\n        workflow.dispatchAndHandle(\"USER_CREATED\", \"another@example.com\");\n        workflow.dispatchAndHandle(\"UNKNOWN_EVENT\", \"some payload\");\n        workflow.dispatchAndHandle(\"ORDER_PLACED\", \"invalid_amount\");\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":31731642708,\"explanation\":\"The `EventDispatchWorkflow` class was handling both event dispatching and logging, which violates the Single Responsibility Principle (SRP). The refactored code separates the concerns of event handling and logging into distinct classes, ensuring that each class has a single responsibility.\"}",
            "level": "HARD",
            "language": "java",
            "violation": "SRP",
            "explanation": "The `EventDispatchWorkflow` class was handling both event dispatching and logging, which violates the Single Responsibility Principle (SRP). The refactored code separates the concerns of event handling and logging into distinct classes, ensuring that each class has a single responsibility."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":5702993833,\"explanation\":\"This refactoring separates the notification responsibility into a new class, UserNotifier, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1980856125,\"explanation\":\"This refactoring separates the notification responsibility into a new class, UserNotifier, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "This refactoring separates the notification responsibility into a new class, UserNotifier, adhering to the Single Responsibility Principle by ensuring that each class has one reason to change."
        },
        {
            "input": "class Report:\n    def __init__(self, data):\n        self.data = data\n    def calculate_statistics(self):\n        return sum(self.data) / len(self.data)\n\nclass ReportPrinter:\n    def print_report(self, report):\n        print(f\"Report: {report.data}\")\n\nclass ReportStatistics:\n    def __init__(self, report):\n        self.report = report\n    def calculate_statistics(self):\n        return sum(self.report.data) / len(self.report.data)\n\n# Example usage:\nif __name__ == '__main__':\n    data = [1, 2, 3, 4, 5]\n    report = Report(data)\n    statistics = ReportStatistics(report)\n    print(f\"Statistics: {statistics.calculate_statistics()}\")\n    printer = ReportPrinter()\n    printer.print_report(report)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3198228250,\"explanation\":\"The original code had a potential SRP violation as the `Report` class was responsible for both holding data and calculating statistics. The refactoring maintains the separation of concerns by keeping the `Report` class focused solely on data storage, while the `ReportStatistics` class handles the calculation of statistics.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code had a potential SRP violation as the `Report` class was responsible for both holding data and calculating statistics. The refactoring maintains the separation of concerns by keeping the `Report` class focused solely on data storage, while the `ReportStatistics` class handles the calculation of statistics."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2517633375,\"explanation\":\"The refactoring separates the responsibility of calculating the order total from sending the email confirmation, adhering to the Single Responsibility Principle.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1603871875,\"explanation\":\"The refactoring separates the responsibility of calculating the order total from sending the email confirmation, adhering to the Single Responsibility Principle.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The refactoring separates the responsibility of calculating the order total from sending the email confirmation, adhering to the Single Responsibility Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":4206818042,\"explanation\":\"The original `BookManager` class violated the Single Responsibility Principle by managing both the display and serialization of the book. The refactored code creates instances of `BookDisplayer` and `BookSerializer` within the methods, ensuring that `BookManager` only manages the book itself and delegates the responsibilities of displaying and serializing to their respective classes.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3873455375,\"explanation\":\"The original `BookManager` class violated the Single Responsibility Principle by managing both the display and serialization of the book. The refactored code creates instances of `BookDisplayer` and `BookSerializer` within the methods, ensuring that `BookManager` only manages the book itself and delegates the responsibilities of displaying and serializing to their respective classes.\"}",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original `BookManager` class violated the Single Responsibility Principle by managing both the display and serialization of the book. The refactored code creates instances of `BookDisplayer` and `BookSerializer` within the methods, ensuring that `BookManager` only manages the book itself and delegates the responsibilities of displaying and serializing to their respective classes."
        },
        {
            "input": "class Invoice:\n    def __init__(self, amount):\n        self.amount = amount\n\n    def calculate_tax(self):\n        return self.amount  0.2\n\nclass InvoiceSaver:\n    def save_to_file(self, invoice):\n        with open('invoice.txt', 'w') as f:\n            f.write(f'Invoice Amount: {invoice.amount}\\nTax: {invoice.calculate_tax()}')\n\nclass InvoicePrinter:\n    def print_invoice(self, invoice):\n        print(f'Invoice Amount: {invoice.amount}')\n        print(f'Tax: {invoice.calculate_tax()}')",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":6213872458,\"explanation\":\"The original `Invoice` class was responsible for both calculating tax and managing its representation in files and prints. The refactoring introduces an `InvoiceManager` class to handle the saving and printing of invoices, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original `Invoice` class was responsible for both calculating tax and managing its representation in files and prints. The refactoring introduces an `InvoiceManager` class to handle the saving and printing of invoices, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3088014083,\"explanation\":\"The original code violates the Single Responsibility Principle because the `DiscountManager` class is responsible for both applying discounts and logging price changes, which are two distinct responsibilities. The refactored code separates these concerns into different classes.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2543539792,\"explanation\":\"The original code violates the Single Responsibility Principle because the `DiscountManager` class is responsible for both applying discounts and logging price changes, which are two distinct responsibilities. The refactored code separates these concerns into different classes.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the `DiscountManager` class is responsible for both applying discounts and logging price changes, which are two distinct responsibilities. The refactored code separates these concerns into different classes."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2396956583,\"explanation\":\"The original code violates the Single Responsibility Principle because the `Customer` class is responsible for both holding customer data and providing discount information. The refactored code separates these concerns into distinct classes, ensuring that each class has a single responsibility.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2385716667,\"explanation\":\"The original code violated the Single Responsibility Principle because the `Customer` class was responsible for both holding customer data and providing discount information. The refactored code separates these concerns into distinct classes, ensuring that each class has a single responsibility.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `Customer` class was responsible for both holding customer data and providing discount information. The refactored code separates these concerns into distinct classes, ensuring that each class has a single responsibility."
        },
        {
            "input": "class FileManager:\n    def __init__(self, filename):\n        self.filename = filename\n    def read(self):\n        with open(self.filename) as f:\n            return f.read()\n\nclass Encryptor:\n    def encrypt(self, data):\n        return data[::-1]\n\nclass FileEncryptor:\n    def __init__(self, filename, encryptor):\n        self.file_manager = FileManager(filename)\n        self.encryptor = encryptor\n    def read_and_encrypt(self):\n        data = self.file_manager.read()\n        return self.encryptor.encrypt(data)",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":6630476750,\"explanation\":\"The `FileEncryptor` class previously instantiated `FileManager` directly, which made it responsible for both file management and encryption logic. Now, it accepts a `FileManager` instance, adhering to SRP by separating concerns.\"}",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The `FileEncryptor` class previously instantiated `FileManager` directly, which made it responsible for both file management and encryption logic. Now, it accepts a `FileManager` instance, adhering to SRP by separating concerns."
        },
        {
            "input": "class UserAccount:\n    def __init__(self, username, password_hash, role='user', permissions=None, user_id=None):\n        self.user_id = user_id\n        self.username = username\n        self.password_hash = password_hash\n        self.role = role\n        self.permissions = permissions if permissions is not None else {}\n\nclass UserRepository:\n    def __init__(self, db_path):\n        self.db_path = db_path\n        self._create_table_if_not_exists()\n\n    def _get_conn(self):\n        return sqlite3.connect(self.db_path)\n\n    def _create_table_if_not_exists(self):\n        conn = None\n        try:\n            conn = self._get_conn()\n            cursor = conn.cursor()\n            cursor.execute(\"\"\"CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                username TEXT UNIQUE NOT NULL,\n                password_hash TEXT NOT NULL,\n                role TEXT NOT NULL DEFAULT 'user',\n                permissions TEXT\n            )\"\"\")\n            conn.commit()\n        except sqlite3.Error as e:\n            print(f\"[UserRepository] Database error during creation: {e}\")\n        finally:\n            if conn:\n                conn.close()\n\n    def exists_by_username(self, username):\n        print(f\"[UserRepository] Checking existence of {username}...\")\n        conn = None\n        try:\n            conn = self._get_conn()\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT 1 FROM users WHERE username = ?\", (username,))\n            return cursor.fetchone() is not None\n        except sqlite3.Error as e:\n            print(f\"[UserRepository] Database error: {e}\")\n            return False\n        finally:\n            if conn:\n                conn.close()\n\n    def save(self, user: UserAccount):\n        print(f\"[UserRepository] Saving user {user.username}...\")\n        conn = None\n        try:\n            conn = self._get_conn()\n            cursor = conn.cursor()\n            permissions_json = json.dumps(user.permissions)\n            cursor.execute(\"INSERT INTO users (username, password_hash, role, permissions) VALUES (?, ?, ?, ?)\",\n                           (user.username, user.password_hash, user.role, permissions_json))\n            conn.commit()\n            user.user_id = cursor.lastrowid\n            return True\n        except sqlite3.IntegrityError:\n            print(f\"[UserRepository] User {user.username} already exists (Integrity Error).\")\n            return False\n        except sqlite3.Error as e:\n            print(f\"[UserRepository] Database error: {e}\")\n            return False\n        finally:\n            if conn:\n                conn.close()\n\n    def update_role(self, username, new_role):\n        print(f\"[UserRepository] Updating role for {username}...\")\n        conn = None\n        try:\n            conn = self._get_conn()\n            cursor = conn.cursor()\n            cursor.execute(\"UPDATE users SET role = ? WHERE username = ?\", (new_role, username))\n            conn.commit()\n            return cursor.rowcount > 0\n        except sqlite3.Error as e:\n            print(f\"[UserRepository] Database error: {e}\")\n            return False\n        finally:\n            if conn:\n                conn.close()\n\n    def find_by_username(self, username):\n        print(f\"[UserRepository] Finding user {username}...\")\n        conn = None\n        try:\n            conn = self._get_conn()\n            cursor = conn.cursor()\n            cursor.execute(\"SELECT id, username, password_hash, role, permissions FROM users WHERE username = ?\", (username,))\n            row = cursor.fetchone()\n            if row:\n                user_id, username, password_hash, role, permissions_json = row\n                permissions = json.loads(permissions_json) if permissions_json else {}\n                return UserAccount(username, password_hash, role, permissions, user_id)\n            return None\n        except sqlite3.Error as e:\n            print(f\"[UserRepository] Database error: {e}\")\n            return None\n        finally:\n            if conn:\n                conn.close()\n\nclass PasswordHasher:\n    def hash_password(self, password):\n         print(\"[PasswordHasher] Hashing password...\")\n         return hashlib.sha256(password.encode()).hexdigest()\n\n    def verify_password(self, password, password_hash):\n        print(\"[PasswordHasher] Verifying password...\")\n        return self.hash_password(password) == password_hash\n\nclass AuditLogger:\n    def __init__(self, log_path):\n        self.log_path = log_path\n\n    def log(self, action, user, details, success):\n        print(f\"[AuditLogger] AUDIT: Action='{action}', User='{user}', Details='{details}', Success={success}\")\n        try:\n            timestamp = datetime.now().isoformat()\n            log_entry = f\"{timestamp}|{action}|{user}|{details}|{success}\\n\"\n            with open(self.log_path, 'a') as f:\n                f.write(log_entry)\n        except IOError as e:\n            print(f\"[AuditLogger] Error writing to audit log: {e}\")\n\nclass UserAccountCreationWorkflow:\n    def __init__(self, user_repository: UserRepository, password_hasher: PasswordHasher, audit_logger: AuditLogger):\n        self.user_repository = user_repository\n        self.password_hasher = password_hasher\n        self.audit_logger = audit_logger\n\n    def create_account(self, username, password, role='user', permissions=None):\n        print(f\"[UserAccountCreationWorkflow] Starting account creation for {username}\")\n\n        if self.user_repository.exists_by_username(username):\n            print(f\"[UserAccountCreationWorkflow] User {username} already exists.\")\n            self.audit_logger.log('CreateAccount', username, 'User Exists', False)\n            return False\n        print(\"[UserAccountCreationWorkflow] User does not exist.\")\n\n        password_hash = self.password_hasher.hash_password(password)\n        print(\"[UserAccountCreationWorkflow] Password hashed.\")\n\n        new_user = UserAccount(username=username, password_hash=password_hash, role=role, permissions=permissions)\n\n        if not self.user_repository.save(new_user):\n            print(f\"[UserAccountCreationWorkflow] Failed to save user {username} to database.\")\n            self.audit_logger.log('CreateAccount', username, 'DB Save Failed', False)\n            return False\n        print(f\"[UserAccountCreationWorkflow] User {username} saved to database.\")\n\n        self.audit_logger.log('CreateAccount', username, 'Success', True)\n        print(f\"[UserAccountCreationWorkflow] Account creation workflow complete for {username}.\")\n        return True\n\nclass UserRoleAssignmentWorkflow:\n    def __init__(self, user_repository: UserRepository, audit_logger: AuditLogger):\n        self.user_repository = user_repository\n        self.audit_logger = audit_logger\n\n    def assign_role(self, username, new_role):\n        print(f\"[UserRoleAssignmentWorkflow] Starting role assignment for {username}\")\n\n        if not self.user_repository.exists_by_username(username):\n            print(f\"[UserRoleAssignmentWorkflow] User {username} not found for role assignment.\")\n            self.audit_logger.log('AssignRole', username, 'User Not Found', False)\n            return False\n        print(\"[UserRoleAssignmentWorkflow] User found.\")\n\n        if not self.user_repository.update_role(username, new_role):\n            print(f\"[UserRoleAssignmentWorkflow] Failed to update role for {username} in database.\")\n            self.audit_logger.log('AssignRole', username, 'DB Update Failed', False)\n            return False\n        print(f\"[UserRoleAssignmentWorkflow] Role updated for {username} to {new_role}.\")\n\n        self.audit_logger.log('AssignRole', username, f'Role changed to {new_role}', True)\n        print(f\"[UserRoleAssignmentWorkflow] Role assignment workflow complete for {username}.\")\n        return True",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":21715341917,\"explanation\":\"The original code had multiple responsibilities within the `UserAccountCreationWorkflow` and `UserRoleAssignmentWorkflow` classes, including user existence checks, password hashing, and logging. The refactored code maintains a single responsibility for each class, focusing on account creation and role assignment separately, thus adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original code had multiple responsibilities within the `UserAccountCreationWorkflow` and `UserRoleAssignmentWorkflow` classes, including user existence checks, password hashing, and logging. The refactored code maintains a single responsibility for each class, focusing on account creation and role assignment separately, thus adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "import csv\nimport json\nfrom datetime import datetime\nimport os\nimport requests\n\n# Responsibility: Data Source Reading\nclass DataReader:\n    def read(self, source_path):\n        print(f\"[DataReader] Reading data from {source_path}...\")\n        try:\n            # Assuming source is a local JSON file\n            with open(source_path, 'r') as f:\n                return json.load(f)\n        except (IOError, json.JSONDecodeError) as e:\n            print(f\"[DataReader] Error reading/parsing data: {e}\")\n            return None\n\n# Responsibility: Data Processing / Business Logic\nclass ReportDataProcessor:\n    def process(self, raw_data, report_type):\n        print(f\"[ReportDataProcessor] Processing data for report type: {report_type}...\")\n        if not raw_data:\n            return None\n\n        if report_type == 'SUMMARY':\n            total_value = sum(item.get('value', 0) for item in raw_data)\n            return [{\"summary_type\": \"Total Value\", \"value\": total_value}]\n        elif report_type == 'CATEGORY_SUMMARY':\n            category_totals = {}\n            for item in raw_data:\n                category = item.get('category', 'Unknown')\n                category_totals[category] = category_totals.get(category, 0) + item.get('value', 0)\n            return [{\"category\": cat, \"total_value\": total} for cat, total in category_totals.items()]\n        else:\n            print(f\"[ReportDataProcessor] Unknown report type: {report_type}\")\n            return None\n\n# Responsibility: Report Formatting / Generation (to file)\nclass ReportFileGenerator:\n    def __init__(self, output_directory):\n        self.output_directory = output_directory\n        if not os.path.exists(self.output_directory):\n            os.makedirs(self.output_directory)\n\n    def generate_csv(self, data, filename):\n        print(f\"[ReportFileGenerator] Generating CSV report {filename} in {self.output_directory}...\")\n        filepath = os.path.join(self.output_directory, filename)\n        try:\n            with open(filepath, 'w', newline='') as csvfile:\n                if not data:\n                    return filepath\n                writer = csv.DictWriter(csvfile, fieldnames=data[0].keys() if data else [])\n                writer.writeheader()\n                writer.writerows(data)\n            return filepath\n        except IOError as e:\n            print(f\"[ReportFileGenerator] Error writing CSV file: {e}\")\n            return None\n\n# Responsibility: Report Uploading\nclass ReportUploader:\n    def __init__(self, upload_service_url):\n        self.upload_service_url = upload_service_url\n\n    def upload(self, filepath):\n        print(f\"[ReportUploader] Uploading report from {filepath} to {self.upload_service_url}...\")\n        try:\n            with open(filepath, 'rb') as f:\n                files = {'file': f}\n                response = requests.post(self.upload_service_url, files=files)\n                response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)\n            print(\"[ReportUploader] File uploaded successfully.\")\n            return True\n        except Exception as e:\n            print(f\"[ReportUploader] Error uploading file: {e}\")\n            return False\n\n# New Class: Report Generation Workflow (SRP: Orchestrates the process)\nclass ReportGenerationWorkflow:\n    def __init__(self,\n                 data_reader: DataReader,\n                 data_processor: ReportDataProcessor,\n                 file_generator: ReportFileGenerator,\n                 uploader: ReportUploader):\n        self.data_reader = data_reader\n        self.data_processor = data_processor\n        self.file_generator = file_generator\n        self.uploader = uploader\n\n    def generate_and_upload_report(self, input_source, report_type):\n        print(f\"[ReportGenerationWorkflow] Starting workflow for report type: {report_type}\")\n\n        raw_data = self.data_reader.read(input_source)\n        if raw_data is None:\n            print(\"[ReportGenerationWorkflow] Failed to read raw data.\")\n            return False\n        print(f\"[ReportGenerationWorkflow] Read {len(raw_data)} items.\")\n\n        processed_data = self.data_processor.process(raw_data, report_type)\n        if processed_data is None:\n            print(\"[ReportGenerationWorkflow] Failed to process data or unknown report type.\")\n            return False\n        print(f\"[ReportGenerationWorkflow] Processed data has {len(processed_data)} items.\")\n\n        filename = f\"{report_type.lower()}_{datetime.now().strftime('%Y%m%d%H%M%S')}.csv\"\n        output_filepath = self.file_generator.generate_csv(processed_data, filename)\n        if output_filepath is None or not os.path.exists(output_filepath):\n            print(\"[ReportGenerationWorkflow] Failed to generate report file.\")\n            return False\n        print(f\"[ReportGenerationWorkflow] Report file generated at {output_filepath}.\")\n\n        if not self.uploader.upload(output_filepath):\n            print(f\"[ReportGenerationWorkflow] Failed to upload report from {output_filepath}.\")\n            return False\n        print(f\"[ReportGenerationWorkflow] Report {output_filepath} uploaded successfully.\")\n\n        print(f\"[ReportGenerationWorkflow] Workflow complete for report type: {report_type}.\")\n        return True\n\n# Example Usage (outside the classes):\ninput_file = 'data_refactored.json'\noutput_dir = 'reports_refactored'\nupload_url = 'http://upload.service/api/reports_refactored'\n# Create a dummy input file\nwith open(input_file, 'w') as f:\n    json.dump([{\"id\": 1, \"value\": 100, \"category\": \"A\"}, {\"id\": 2, \"value\": 200, \"category\": \"B\"}, {\"id\": 3, \"value\": 150, \"category\": \"A\"}], f)\n\ndata_reader = DataReader()\ndata_processor = ReportDataProcessor()\nfile_generator = ReportFileGenerator(output_dir)\nuploader = ReportUploader(upload_url)\n\nworkflow = ReportGenerationWorkflow(data_reader, data_processor, file_generator, uploader)\n\nworkflow.generate_and_upload_report(input_file, 'SUMMARY')\nworkflow.generate_and_upload_report(input_file, 'CATEGORY_SUMMARY')\nworkflow.generate_and_upload_report(input_file, 'UNKNOWN_TYPE')",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":21930327500,\"explanation\":\"The original `process` method in `ReportDataProcessor` used multiple `if-else` statements to handle different report types, violating the Open/Closed Principle (OCP). The refactored code introduces a method `get_processor` that returns the appropriate processing function based on the report type, allowing for easy extension without modifying existing code.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original `process` method in `ReportDataProcessor` used multiple `if-else` statements to handle different report types, violating the Open/Closed Principle (OCP). The refactored code introduces a method `get_processor` that returns the appropriate processing function based on the report type, allowing for easy extension without modifying existing code."
        },
        {
            "input": "class NotificationDispatcherWorkflow:\n    def __init__(self, user_preference_fetcher):\n        self.user_preference_fetcher = user_preference_fetcher\n        self.senders = []\n\n    def register_sender(self, sender):\n        self.senders.append(sender)\n\n    def dispatch(self, user_id, subject, body):\n        print(f\"[NotificationDispatcherWorkflow] Dispatching notification for user {user_id}\")\n\n        preferences = self.user_preference_fetcher(user_id)\n        if not preferences:\n            print(f\"[NotificationDispatcherWorkflow] Could not fetch preferences for user {user_id}. Aborting.\")\n            return False\n        print(f\"[NotificationDispatcherWorkflow] User preferences: {preferences}\")\n\n        sent_count = 0\n\n        for sender in self.senders:\n            if sender.can_send(preferences):\n                print(f\"[NotificationDispatcherWorkflow] User prefers {sender.__class__.__name__}. Attempting to send...\")\n                if sender.send(preferences, subject, body):\n                    print(f\"[NotificationDispatcherWorkflow] {sender.__class__.__name__} sent successfully.\")\n                    sent_count += 1\n                else:\n                    print(f\"[NotificationDispatcherWorkflow] Failed to send {sender.__class__.__name__}.\")\n\n        if sent_count == 0:\n            print(f\"[NotificationDispatcherWorkflow] No notifications sent for user {user_id}.\")\n\n        print(f\"[NotificationDispatcherWorkflow] Notification dispatch complete for user {user_id}. Sent count: {sent_count}\")\n        return sent_count > 0",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":4463368917,\"explanation\":\"The original class handled both the dispatching of notifications and logging messages, violating the Single Responsibility Principle (SRP). The refactored code separates the logging functionality into a `NotificationLogger` class, allowing `NotificationDispatcher` to focus solely on dispatching notifications.\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The original class handled both the dispatching of notifications and logging messages, violating the Single Responsibility Principle (SRP). The refactored code separates the logging functionality into a `NotificationLogger` class, allowing `NotificationDispatcher` to focus solely on dispatching notifications."
        },
        {
            "input": "class OrderStatusUpdateWorkflow:\n    def __init__(self, order_repository: OrderRepository,\n                 payment_checker: PaymentStatusChecker,\n                 status_decision_service: OrderStatusDecisionService,\n                 order_notifier: OrderNotifier):\n        self.order_repository = order_repository\n        self.payment_checker = payment_checker\n        self.status_decision_service = status_decision_service\n        self.order_notifier = order_notifier\n\n    def update_status_based_on_payment(self, order_number):\n        print(f\"[OrderStatusUpdateWorkflow] Starting status update workflow for order {order_number}.\")\n\n        order = self.order_repository.find_by_order_number(order_number)\n        if order is None:\n            print(f\"[OrderStatusUpdateWorkflow] Order {order_number} not found.\")\n            return False\n        print(f\"[OrderStatusUpdateWorkflow] Order found.\")\n\n        new_status = self.status_decision_service.determine_new_status(order, self.payment_checker)\n\n        if new_status != order.status:\n            print(f\"[OrderStatusUpdateWorkflow] Status requires update from {order.status} to {new_status}.\")\n            if self.order_repository.update_status(order.id, new_status):\n                print(f\"[OrderStatusUpdateWorkflow] Status updated in DB for order {order_number}.\")\n                self.order_notifier.send_status_update_email(order.customer_email, order_number, new_status)\n                print(f\"[OrderStatusUpdateWorkflow] Status update email sent.\")\n                return True\n            else:\n                print(f\"[OrderStatusUpdateWorkflow] Failed to update status in DB for order {order_number}.\")\n                return False\n        else:\n            print(f\"[OrderStatusUpdateWorkflow] No status update needed for order {order_number}.\")\n            return False",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":7008387750,\"explanation\":\"The class previously handled multiple responsibilities, including finding orders, determining new statuses, updating the database, and sending notifications. The refactoring separates the status update logic into its own method, adhering to the Single Responsibility Principle (SRP).\"}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "SRP",
            "explanation": "The class previously handled multiple responsibilities, including finding orders, determining new statuses, updating the database, and sending notifications. The refactoring separates the status update logic into its own method, adhering to the Single Responsibility Principle (SRP)."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2468346542,\"explanation\":\"The UserService class originally handled both user registration and email sending, violating the Single Responsibility Principle. The refactoring separates the email sending functionality into its own method, clarifying the responsibilities of the class.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":1876730750,\"explanation\":\"The UserService class originally handled both user registration and email sending, violating the Single Responsibility Principle. The refactoring separates the email sending functionality into its own method, clarifying the responsibilities of the class.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The UserService class originally handled both user registration and email sending, violating the Single Responsibility Principle. The refactoring separates the email sending functionality into its own method, clarifying the responsibilities of the class."
        },
        {
            "input": "class ReportGenerator {\n    fun generateReport(): String {\n        return \"Generated Report\"\n    }\n}\n\nclass ReportPrinter {\n    fun printReport(report: String) {\n        println(report)\n    }\n}\n\nfun main() {\n    val reportGenerator = ReportGenerator()\n    val reportPrinter = ReportPrinter()\n    val report = reportGenerator.generateReport()\n    reportPrinter.printReport(report)\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2209975291,\"explanation\":\"The original code had separate responsibilities for generating and printing reports, which is in line with SRP. However, since both classes are already well-defined and focused on a single responsibility, no refactoring was necessary.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code had separate responsibilities for generating and printing reports, which is in line with SRP. However, since both classes are already well-defined and focused on a single responsibility, no refactoring was necessary."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3321435750,\"explanation\":\"The `Order` class violates the Single Responsibility Principle because it handles both the calculation of the total and the saving of the order, which are two distinct responsibilities.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2070344333,\"explanation\":\"The `Order` class previously handled both the calculation of the total and the saving of the order. Now, the calculation is separated into its own method, and a new `OrderRepository` class is introduced to handle the saving, adhering to the Single Responsibility Principle.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The `Order` class previously handled both the calculation of the total and the saving of the order. Now, the calculation is separated into its own method, and a new `OrderRepository` class is introduced to handle the saving, adhering to the Single Responsibility Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3054834500,\"explanation\":\"The original `InvoiceProcessor` class had multiple responsibilities: creating an invoice and sending it. By separating the concerns and injecting the `InvoiceSender` dependency, we adhere to the Single Responsibility Principle.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2675335250,\"explanation\":\"The original `InvoiceProcessor` class had multiple responsibilities: creating an invoice and sending it. By separating the concerns and injecting the `InvoiceSender` dependency, we adhere to the Single Responsibility Principle.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original `InvoiceProcessor` class had multiple responsibilities: creating an invoice and sending it. By separating the concerns and injecting the `InvoiceSender` dependency, we adhere to the Single Responsibility Principle."
        },
        {
            "input": "class User {\n    var name: String = \"\"\n    var email: String = \"\"\n}\n\nclass UserService {\n    fun registerUser(user: User) {\n        // Logic to register user\n    }\n}\n\nclass UserNotifier {\n    fun sendWelcomeEmail(user: User) {\n        // Logic to send welcome email\n    }\n}\n\nfun main() {\n    val user = User().apply { name = \"John Doe\"; email = \"john@example.com\" }\n    val userService = UserService()\n    val userNotifier = UserNotifier()\n\n    userService.registerUser(user)\n    userNotifier.sendWelcomeEmail(user)\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3163239791,\"explanation\":\"The original code had a `User` class that was mutable and allowed for changes to its properties, which could lead to unintended side effects. The refactored code makes `User` immutable by using a constructor to set its properties, adhering to the Single Responsibility Principle (SRP) by ensuring that the `User` class only represents user data.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code had a `User` class that was mutable and allowed for changes to its properties, which could lead to unintended side effects. The refactored code makes `User` immutable by using a constructor to set its properties, adhering to the Single Responsibility Principle (SRP) by ensuring that the `User` class only represents user data."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":2247794333,\"explanation\":\"The `CustomerManager` class violates the Single Responsibility Principle because it handles both customer management and email sending responsibilities. This can lead to difficulties in maintaining and testing the code.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2338908542,\"explanation\":\"The `CustomerManager` class previously handled both customer management and email sending responsibilities. Now, it only manages customers, while the `EmailService` class is responsible for sending emails, adhering to the Single Responsibility Principle.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The `CustomerManager` class previously handled both customer management and email sending responsibilities. Now, it only manages customers, while the `EmailService` class is responsible for sending emails, adhering to the Single Responsibility Principle."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"class FileHandler : FileOperations {\\n    override fun readFile(path: String): String {\\n        // Read file logic\\n        return \\\"file content\\\"\\n    }\\n    override fun writeFile(path: String, content: String) {\\n        // Write file logic\\n    }\\n}\\n\\nclass FileLogger {\\n    fun logOperation(operation: String) {\\n        // Log file operation logic\\n    }\\n}\\n\\nclass FileService(private val fileHandler: FileOperations) {\\n    fun performFileOperation(path: String, content: String) {\\n        fileHandler.writeFile(path, content)\\n    }\\n\\n    fun readFileOperation(path: String): String {\\n        return fileHandler.readFile(path)\\n    }\\n}\\n\\nclass FileOperationLogger(private val fileLogger: FileLogger) {\\n    fun logWriteOperation(path: String) {\\n        fileLogger.logOperation(\\\"Wrote to file at \\$path\\\")\\n    }\\n\\n    fun logReadOperation(path: String) {\\n        fileLogger.logOperation(\\\"Read from file at \\$path\\\")\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle because the FileService class is responsible for both file operations and logging operations. The refactored code separates the logging functionality into a new class, FileOperationLogger, which handles logging independently, allowing FileService to focus solely on file operations.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":4214466792,\"explanation\":\"The original code violates the Single Responsibility Principle because the FileService class is responsible for both file operations and logging operations. The refactored code separates the logging functionality into a new class, FileOperationLogger, which handles logging independently, allowing FileService to focus solely on file operations.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle because the FileService class is responsible for both file operations and logging operations. The refactored code separates the logging functionality into a new class, FileOperationLogger, which handles logging independently, allowing FileService to focus solely on file operations."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"total_duration\":3372355250,\"explanation\":\"The original code violates the Single Responsibility Principle because the `AuthService` class is responsible for both authentication and notification, which are two distinct responsibilities. The refactored code separates these concerns into different classes.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2452576125,\"explanation\":\"The original code violated the Single Responsibility Principle because the `AuthService` class was responsible for both authentication and notification. The refactored code separates these concerns into the `AuthService` for authentication and a new `Notifier` class for handling notifications.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle because the `AuthService` class was responsible for both authentication and notification. The refactored code separates these concerns into the `AuthService` for authentication and a new `Notifier` class for handling notifications."
        },
        {
            "input": "import java.sql.Connection\nimport java.sql.DriverManager\nimport javax.mail.internet.InternetAddress\nimport javax.mail.internet.MimeMessage\nimport javax.mail.Session\nimport java.util.Properties\nimport java.util.Date\n\ndata class ScheduledTask(val id: String, val type: String, val payload: String, var status: String, var lastRun: Date?)\n\ninterface TaskRepository {\n    fun fetchPending(): List<ScheduledTask>\n    fun updateStatus(task: ScheduledTask)\n    fun updateLastRun(task: ScheduledTask)\n}\n\nclass DatabaseTaskRepository(private val dbUrl: String) : TaskRepository {\n    private fun getConnection(): Connection? {\n        return try {\n            DriverManager.getConnection(dbUrl)\n        } catch (e: Exception) {\n            println(\"[DatabaseTaskRepository] DB Connection Error: ${'$'}{e.message}\")\n            null\n        }\n    }\n\n    override fun fetchPending(): List<ScheduledTask> {\n        println(\"[DatabaseTaskRepository] Fetching pending tasks from DB $dbUrl...\")\n        val tasks = mutableListOf<ScheduledTask>()\n        val conn = getConnection()\n        conn?.use { connection ->\n            // Simulated fetching tasks from DB\n            tasks.add(ScheduledTask(\"task1\", \"REPORT_EMAIL\", \"user@example.com,ReportA\", \"PENDING\", null))\n            tasks.add(ScheduledTask(\"task2\", \"DATA_SYNC\", \"SourceX,DestY\", \"PENDING\", null))\n            tasks.add(ScheduledTask(\"task3\", \"UNKNOWN_TYPE\", \"payload\", \"PENDING\", null))\n        }\n        return tasks\n    }\n\n    override fun updateStatus(task: ScheduledTask) {\n        println(\"[DatabaseTaskRepository] Updating status for task ${'$'}{task.id} to ${'$'}{task.status} in DB $dbUrl...\")\n        val conn = getConnection()\n        conn?.use { connection ->\n            // Simulated update status in DB\n        }\n    }\n\n    override fun updateLastRun(task: ScheduledTask) {\n        println(\"[DatabaseTaskRepository] Updating last run for task ${'$'}{task.id} to ${'$'}{task.lastRun} in DB $dbUrl...\")\n        val conn = getConnection()\n        conn?.use { connection ->\n            // Simulated update last run in DB\n        }\n    }\n}\n\ninterface TaskExecutor {\n    val taskType: String\n    fun execute(payload: String): Boolean\n}\n\nclass ReportEmailTaskExecutor(private val emailService: EmailService) : TaskExecutor {\n    override val taskType = \"REPORT_EMAIL\"\n\n    override fun execute(payload: String): Boolean {\n        println(\"[ReportEmailTaskExecutor] Running Send Report Email Task with payload: $payload\")\n        val parts = payload.split(\",\")\n        if (parts.size != 2) {\n            println(\"[ReportEmailTaskExecutor] Invalid payload format.\")\n            return false\n        }\n        val email = parts[0]\n        val reportName = parts[1]\n\n        val reportContent = \"Report content for $reportName\"\n\n        emailService.send(email, \"Your $reportName\", reportContent)\n        println(\"[ReportEmailTaskExecutor] Simulated sending $reportName report to $email.\")\n        return true\n    }\n}\n\nclass DataSyncTaskExecutor : TaskExecutor {\n    override val taskType = \"DATA_SYNC\"\n\n    override fun execute(payload: String): Boolean {\n        println(\"[DataSyncTaskExecutor] Running Data Sync Task with payload: $payload\")\n        val parts = payload.split(\",\")\n        if (parts.size != 2) {\n            println(\"[DataSyncTaskExecutor] Invalid payload format.\")\n            return false\n        }\n        val source = parts[0]\n        val dest = parts[1]\n        println(\"[DataSyncTaskExecutor] Simulating syncing data from $source to $dest...\")\n\n        return true\n    }\n}\n\ninterface TaskFailureNotifier {\n    fun notify(task: ScheduledTask, reason: String)\n}\n\nclass EmailTaskFailureNotifier(private val smtpHost: String) : TaskFailureNotifier {\n    override fun notify(task: ScheduledTask, reason: String) {\n        println(\"[EmailTaskFailureNotifier] Sending failure notification for task ${'$'}{task.id}...\")\n        val props = Properties()\n        props[\"mail.smtp.host\"] = smtpHost\n        val session = Session.getInstance(props)\n        val message = MimeMessage(session)\n        message.setFrom(InternetAddress(\"no-reply@jobexecutor.com\"))\n\n        message.setRecipients(MimeMessage.RecipientType.TO, InternetAddress.parse(\"admin@example.com\"))\n        message.subject = \"Scheduled Task Failed: ${'$'}{task.id}\"\n        message.setText(\"Task ${'$'}{task.id} (${'$'}{task.type}) failed.\\nReason: ${'$'}{reason}\\nPayload: ${'$'}{task.payload}\")\n    }\n}\n\ninterface EmailService {\n    fun send(to: String, subject: String, body: String)\n}\n\nclass SmtpEmailService(private val smtpHost: String) : EmailService {\n    override fun send(to: String, subject: String, body: String) {\n        println(\"[SmtpEmailService] Sending email to $to via $smtpHost...\")\n        val props = Properties()\n        props[\"mail.smtp.host\"] = smtpHost\n        val session = Session.getInstance(props)\n        val message = MimeMessage(session)\n        message.setFrom(InternetAddress(\"noreply@system.com\"))\n        message.setRecipients(MimeMessage.RecipientType.TO, InternetAddress.parse(to))\n        message.subject = subject\n        message.setText(body)\n    }\n}\n\nclass JobExecutionWorkflow(\n    private val taskRepository: TaskRepository,\n    private val taskExecutors: List<TaskExecutor>,\n    private val failureNotifier: TaskFailureNotifier\n) {\n\n    private val executorMap = taskExecutors.associateBy { it.taskType }\n\n    fun executePendingJobs() {\n        println(\"[JobExecutionWorkflow] Starting execution of pending jobs.\")\n\n        val pendingTasks = taskRepository.fetchPending()\n        println(\"[JobExecutionWorkflow] Fetched ${'$'}{pendingTasks.size} pending tasks.\")\n\n        if (pendingTasks.isEmpty()) {\n            println(\"[JobExecutionWorkflow] No pending tasks to execute.\")\n            return\n        }\n\n        for (task in pendingTasks) {\n            println(\"[JobExecutionWorkflow] Processing task: ${'$'}{task.id} (${'$'}{task.type})\")\n            task.status = \"RUNNING\"\n            taskRepository.updateStatus(task)\n\n            val executor = executorMap[task.type]\n\n            try {\n                val success = if (executor != null) {\n                    executor.execute(task.payload)\n                } else {\n                    println(\"[JobExecutionWorkflow] No executor found for task type: ${'$'}{task.type}\")\n                    false\n                }\n\n                task.status = if (success) \"COMPLETED\" else \"FAILED\"\n                if (!success) {\n                    val reason = if (executor == null) \"Unknown task type\" else \"Task execution failed\"\n                    failureNotifier.notify(task, reason)\n                }\n            } catch (e: Exception) {\n                task.status = \"FAILED\"\n                println(\"[JobExecutionWorkflow] Task ${'$'}{task.id} failed with exception: ${'$'}{e.message}\")\n                failureNotifier.notify(task, \"Exception: ${'$'}{e.message}\")\n            }\n            task.lastRun = Date()\n            taskRepository.updateStatus(task)\n            taskRepository.updateLastRun(task)\n        }\n\n        println(\"[JobExecutionWorkflow] Finished execution of pending jobs.\")\n    }\n}",
            "output": "{\"violation_type\":\"OCP\",\"total_duration\":6328541833,\"explanation\":\"The original code used multiple `if-else` statements to handle different task types in the `JobExecutionWorkflow` class. By introducing an abstract base class `BaseTaskExecutor`, we can now handle common validation logic in one place, allowing for easier extension of new task types without modifying existing code, thus adhering to the Open/Closed Principle (OCP).\"}",
            "level": "HARD",
            "language": "kotlin",
            "violation": "OCP",
            "explanation": "The original code used multiple `if-else` statements to handle different task types in the `JobExecutionWorkflow` class. By introducing an abstract base class `BaseTaskExecutor`, we can now handle common validation logic in one place, allowing for easier extension of new task types without modifying existing code, thus adhering to the Open/Closed Principle (OCP)."
        },
        {
            "input": "{\"violation_type\":\"Inappropriate Intimacy\",\"refactored_code\":\"class ProductApiEndpoint(\\n    private val requestValidator: RequestValidator,\\n    private val productService: ProductService,\\n    private val apiLogger: ApiLogger\\n) {\\n\\n    fun handleRequest(request: ApiRequest): ApiResponse {\\n        println(\\\"[ProductApiEndpoint] Handling request: \\${request.method} \\${request.path}\\\")\\n\\n        val response: ApiResponse = when {\\n            request.path == \\\"/products\\\" && request.method == \\\"GET\\\" -> productService.handleGetProducts(request)\\n            request.path == \\\"/products\\\" && request.method == \\\"POST\\\" -> productService.handlePostProduct(request)\\n            else -> ApiResponse(404, emptyMap(), \\\"Not Found\\\")\\n        }\\n\\n        apiLogger.logRequest(request.method, request.path, response.statusCode, response.body ?: \\\"\\\")\\n        println(\\\"[ProductApiEndpoint] Request handling complete. Response: \\${response.statusCode}\\\")\\n        return response\\n    }\\n}\",\"explanation\":\"The refactoring separates the concerns of handling requests and processing business logic by delegating the product handling to the ProductService. This reduces the inappropriate intimacy between the ProductApiEndpoint and the ProductRepository, making the code cleaner and adhering to the Single Responsibility Principle.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3546387084,\"explanation\":\"The class previously handled both request processing and logging, which violates the Single Responsibility Principle. The refactoring maintains the request handling while ensuring that logging is managed separately, thus adhering to SRP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The class previously handled both request processing and logging, which violates the Single Responsibility Principle. The refactoring maintains the request handling while ensuring that logging is managed separately, thus adhering to SRP."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"import java.sql.Connection\\nimport java.sql.DriverManager\\nimport java.io.File\\nimport java.awt.Image\\nimport javax.imageio.ImageIO\\nimport javax.mail.internet.InternetAddress\\nimport javax.mail.internet.MimeMessage\\nimport javax.mail.Session\\nimport java.util.Properties\\n\\ndata class UserProfile(var id: String, var name: String, var bio: String?, var profilePicturePath: String?, val email: String)\\n\\ninterface UserProfileRepository {\\n    fun fetch(userId: String): UserProfile?\\n    fun save(profile: UserProfile): Boolean\\n}\\n\\nclass DatabaseUserProfileRepository(private val dbUrl: String) : UserProfileRepository {\\n    override fun fetch(userId: String): UserProfile? {\\n        println(\\\"[DatabaseUserProfileRepository] Fetching profile for \\$userId from \\$dbUrl...\\\")\\n        var conn: Connection? = null\\n        try {\\n            conn = DriverManager.getConnection(dbUrl)\\n            return UserProfile(userId, \\\"Test User\\\", \\\"Just a test user\\\", \\\"\\\", \\\"test@example.com\\\")\\n        } catch (e: Exception) {\\n            println(\\\"[DatabaseUserProfileRepository] DB Fetch Error: \\$e.message\\\")\\n            return null\\n        } finally {\\n            conn?.close()\\n        }\\n    }\\n\\n    override fun save(profile: UserProfile): Boolean {\\n        println(\\\"[DatabaseUserProfileRepository] Saving profile for \\$profile.id to \\$dbUrl...\\\")\\n        var conn: Connection? = null\\n        try {\\n            conn = DriverManager.getConnection(dbUrl)\\n            return true\\n        } catch (e: Exception) {\\n            println(\\\"[DatabaseUserProfileRepository] DB Save Error: \\$e.message\\\")\\n            return false\\n        } finally {\\n            conn?.close()\\n        }\\n    }\\n}\\n\\ninterface ProfilePictureStorage {\\n    fun save(userId: String, imageFile: File): String?\\n    fun validate(imageFile: File): Boolean\\n}\\n\\nclass FileSystemProfilePictureStorage(private val profilePictureDir: String) : ProfilePictureStorage {\\n    override fun validate(imageFile: File): Boolean {\\n        println(\\\"[FileSystemProfilePictureStorage] Validating image file: \\$imageFile.name\\\")\\n        return imageFile.exists() && imageFile.length() > 0\\n    }\\n\\n    override fun save(userId: String, imageFile: File): String? {\\n        println(\\\"[FileSystemProfilePictureStorage] Saving profile picture for \\$userId to \\$profilePictureDir...\\\")\\n        val image = ImageIO.read(imageFile)\\n        if (image == null) {\\n            println(\\\"[FileSystemProfilePictureStorage] Could not read image file.\\\")\\n            return null\\n        }\\n        val resizedImage: Image = image.getScaledInstance(128, 128, Image.SCALE_SMOOTH)\\n        val outputFileName = \\\"\\$userId_profile.jpg\\\"\\n        val outputFile = File(profilePictureDir, outputFileName)\\n        try {\\n            ImageIO.write(resizedImage, \\\"jpg\\\", outputFile)\\n            return outputFile.absolutePath\\n        } catch (e: Exception) {\\n            println(\\\"[FileSystemProfilePictureStorage] Image Save Error: \\$e.message\\\")\\n            return null\\n        }\\n    }\\n}\\n\\ninterface UserNotifier {\\n    fun notifyProfileUpdate(userEmail: String, userName: String)\\n}\\n\\nclass EmailUserNotifier(private val smtpHost: String) : UserNotifier {\\n    override fun notifyProfileUpdate(userEmail: String, userName: String) {\\n        println(\\\"[EmailUserNotifier] Notifying user \\$userName at \\$userEmail via \\$smtpHost...\\\")\\n        val props = Properties()\\n        props[\\\"mail.smtp.host\\\"] = smtpHost\\n        val session = Session.getInstance(props)\\n        val message = MimeMessage(session)\\n        message.setFrom(InternetAddress(\\\"no-reply@app.com\\\"))\\n        message.setRecipients(MimeMessage.RecipientType.TO, InternetAddress.parse(userEmail))\\n        message.subject = \\\"Your Profile Has Been Updated\\\"\\n        message.setText(\\\"Hello \\$userName, your profile information was recently updated.\\\")\\n    }\\n}\\n\\nclass UserProfileUpdateWorkflow(\\n    private val userProfileRepository: UserProfileRepository,\\n    private val profilePictureStorage: ProfilePictureStorage,\\n    private val userNotifier: UserNotifier\\n) {\\n\\n    fun updateProfile(userId: String, name: String?, bio: String?, profilePictureFile: File?): UserProfile? {\\n        println(\\\"[UserProfileUpdateWorkflow] Starting profile update for user \\$userId\\\")\\n\\n        val existingProfile = userProfileRepository.fetch(userId)\\n        if (existingProfile == null) {\\n            println(\\\"[UserProfileUpdateWorkflow] User profile not found for \\$userId.\\\")\\n            return null\\n        }\\n        println(\\\"[UserProfileUpdateWorkflow] Existing profile fetched.\\\")\\n\\n        existingProfile.name = name ?: existingProfile.name\\n        existingProfile.bio = bio ?: existingProfile.bio\\n        println(\\\"[UserProfileUpdateWorkflow] Profile data updated in memory.\\\")\\n\\n        var newProfilePicturePath: String? = existingProfile.profilePicturePath\\n        if (profilePictureFile != null) {\\n            if (!profilePictureStorage.validate(profilePictureFile)) {\\n                println(\\\"[UserProfileUpdateWorkflow] Invalid profile picture file.\\\")\\n                return null\\n            }\\n\\n            newProfilePicturePath = profilePictureStorage.save(userId, profilePictureFile)\\n            existingProfile.profilePicturePath = newProfilePicturePath\\n            println(\\\"[UserProfileUpdateWorkflow] Profile picture processed and path updated.\\\")\\n        }\\n\\n        if (!userProfileRepository.save(existingProfile)) {\\n            println(\\\"[UserProfileUpdateWorkflow] Failed to save updated profile.\\\")\\n            return null\\n        }\\n        println(\\\"[UserProfileUpdateWorkflow] Profile saved to database.\\\")\\n\\n        userNotifier.notifyProfileUpdate(existingProfile.email, existingProfile.name)\\n        println(\\\"[UserProfileUpdateWorkflow] User notified of profile update.\\\")\\n\\n        println(\\\"[UserProfileUpdateWorkflow] Profile update complete for user \\$userId.\\\")\\n        return existingProfile\\n    }\\n}\\n\\nclass UserProfileService(\\n    private val userProfileRepository: UserProfileRepository,\\n    private val profilePictureStorage: ProfilePictureStorage,\\n    private val userNotifier: UserNotifier\\n) {\\n    fun updateProfile(userId: String, name: String?, bio: String?, profilePictureFile: File?): UserProfile? {\\n        val workflow = UserProfileUpdateWorkflow(userProfileRepository, profilePictureStorage, userNotifier)\\n        return workflow.updateProfile(userId, name, bio, profilePictureFile)\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `UserProfileUpdateWorkflow` class is responsible for multiple tasks: fetching user profiles, updating user data, saving profiles, validating images, and notifying users. This makes the class harder to maintain and test. To refactor, I introduced a `UserProfileService` class that encapsulates the workflow logic, allowing `UserProfileUpdateWorkflow` to focus solely on the update process. This separation of concerns improves code readability and maintainability. Additionally, the code structure remains intact, ensuring it is still compilable and functional.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":25023264541,\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `UserProfileUpdateWorkflow` class is responsible for multiple tasks: fetching user profiles, updating user data, saving profiles, validating images, and notifying users. This makes the class harder to maintain and test. To refactor, I introduced a `UserProfileService` class that encapsulates the workflow logic, allowing `UserProfileUpdateWorkflow` to focus solely on the update process. This separation of concerns improves code readability and maintainability. Additionally, the code structure remains intact, ensuring it is still compilable and functional.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `UserProfileUpdateWorkflow` class is responsible for multiple tasks: fetching user profiles, updating user data, saving profiles, validating images, and notifying users. This makes the class harder to maintain and test. To refactor, I introduced a `UserProfileService` class that encapsulates the workflow logic, allowing `UserProfileUpdateWorkflow` to focus solely on the update process. This separation of concerns improves code readability and maintainability. Additionally, the code structure remains intact, ensuring it is still compilable and functional."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"import java.sql.Connection\\nimport java.sql.DriverManager\\nimport javax.mail.internet.InternetAddress\\nimport javax.mail.internet.MimeMessage\\nimport javax.mail.Session\\nimport java.util.Properties\\n\\ndata class Product(val id: String, val name: String, val price: Double)\\ndata class CartItem(val product: Product, val quantity: Int)\\ndata class ShoppingCart(val items: List<CartItem>)\\ndata class Order(val id: String, val items: List<CartItem>, val totalAmount: Double, val customerEmail: String)\\n\\ninterface CartValidator {\\n    fun validate(cart: ShoppingCart): Boolean\\n}\\n\\nclass SimpleCartValidator : CartValidator {\\n    override fun validate(cart: ShoppingCart): Boolean {\\n        println(\\\"[SimpleCartValidator] Validating cart...\\\")\\n        return cart.items.isNotEmpty()\\n    }\\n}\\n\\ninterface InventoryService {\\n    fun checkInventory(cart: ShoppingCart): Boolean\\n    fun updateInventory(cart: ShoppingCart)\\n}\\n\\nclass ExternalInventoryService(private val inventoryServiceUrl: String) : InventoryService {\\n    override fun checkInventory(cart: ShoppingCart): Boolean {\\n        println(\\\"[ExternalInventoryService] Checking inventory via \\$inventoryServiceUrl...\\\")\\n        return true\\n    }\\n\\n    override fun updateInventory(cart: ShoppingCart) {\\n        println(\\\"[ExternalInventoryService] Updating inventory via \\$inventoryServiceUrl...\\\")\\n    }\\n}\\n\\ninterface PaymentGateway {\\n    fun processPayment(email: String, amount: Double): Boolean\\n}\\n\\nclass ExternalPaymentGateway(private val paymentGatewayUrl: String) : PaymentGateway {\\n    override fun processPayment(email: String, amount: Double): Boolean {\\n        println(\\\"[ExternalPaymentGateway] Processing payment for \\$amount via \\$paymentGatewayUrl...\\\")\\n        return true\\n    }\\n}\\n\\ninterface OrderRepository {\\n    fun save(cart: ShoppingCart, totalAmount: Double, customerEmail: String): Order?\\n}\\n\\nclass DatabaseOrderRepository(private val dbUrl: String) : OrderRepository {\\n    override fun save(cart: ShoppingCart, totalAmount: Double, customerEmail: String): Order? {\\n        println(\\\"[DatabaseOrderRepository] Saving order to DB \\$dbUrl...\\\")\\n        var conn: Connection? = null\\n        try {\\n            conn = DriverManager.getConnection(dbUrl)\\n            val orderId = \\\"ORDER_\\${System.currentTimeMillis()}\\\"\\n            return Order(orderId, cart.items, totalAmount, customerEmail)\\n        } catch (e: Exception) {\\n            println(\\\"[DatabaseOrderRepository] DB Error: \\${e.message}\\\")\\n            return null\\n        } finally {\\n            conn?.close()\\n        }\\n    }\\n}\\n\\ninterface EmailService {\\n    fun sendOrderConfirmation(email: String, order: Order)\\n}\\n\\nclass SmtpEmailService(private val smtpHost: String) : EmailService {\\n    override fun sendOrderConfirmation(email: String, order: Order) {\\n        println(\\\"[SmtpEmailService] Sending confirmation email to \\$email via \\$smtpHost...\\\")\\n        val props = Properties()\\n        props[\\\"mail.smtp.host\\\"] = smtpHost\\n        val session = Session.getInstance(props)\\n        val message = MimeMessage(session)\\n        message.setFrom(InternetAddress(\\\"no-reply@app.com\\\"))\\n        message.setRecipients(MimeMessage.RecipientType.TO, InternetAddress.parse(email))\\n        message.subject = \\\"Order Confirmation \\${order.id}\\\"\\n        message.setText(\\\"Thank you for your order! Order ID: \\${order.id}, Total: \\${order.totalAmount}\\\")\\n    }\\n}\\n\\ninterface TotalCalculator {\\n    fun calculate(cart: ShoppingCart): Double\\n}\\n\\nclass ShoppingCartTotalCalculator : TotalCalculator {\\n    override fun calculate(cart: ShoppingCart): Double {\\n        println(\\\"[ShoppingCartTotalCalculator] Calculating total...\\\")\\n        return cart.items.sumByDouble { it.product.price  it.quantity }\\n    }\\n}\\n\\nclass CheckoutWorkflow(\\n    private val cartValidator: CartValidator,\\n    private val inventoryService: InventoryService,\\n    private val paymentGateway: PaymentGateway,\\n    private val orderRepository: OrderRepository,\\n    private val emailService: EmailService,\\n    private val totalCalculator: TotalCalculator\\n) {\\n\\n    fun processCheckout(cart: ShoppingCart, customerEmail: String): Order? {\\n        println(\\\"[CheckoutWorkflow] Starting checkout process...\\\")\\n\\n        if (!cartValidator.validate(cart)) {\\n            println(\\\"[CheckoutWorkflow] Cart validation failed.\\\")\\n            return null\\n        }\\n        println(\\\"[CheckoutWorkflow] Cart validated.\\\")\\n\\n        if (!inventoryService.checkInventory(cart)) {\\n            println(\\\"[CheckoutWorkflow] Inventory check failed.\\\")\\n            return null\\n        }\\n        println(\\\"[CheckoutWorkflow] Inventory checked.\\\")\\n\\n        val totalAmount = totalCalculator.calculate(cart)\\n        println(\\\"[CheckoutWorkflow] Total amount calculated: \\$totalAmount\\\")\\n\\n        if (!paymentGateway.processPayment(customerEmail, totalAmount)) {\\n            println(\\\"[CheckoutWorkflow] Payment processing failed.\\\")\\n            return null\\n        }\\n        println(\\\"[CheckoutWorkflow] Payment processed.\\\")\\n\\n        val order = orderRepository.save(cart, totalAmount, customerEmail)\\n        if (order == null) {\\n            println(\\\"[CheckoutWorkflow] Failed to save order.\\\")\\n            return null\\n        }\\n        println(\\\"[CheckoutWorkflow] Order saved: \\${order.id}\\\")\\n\\n        inventoryService.updateInventory(cart)\\n        println(\\\"[CheckoutWorkflow] Inventory updated.\\\")\\n\\n        emailService.sendOrderConfirmation(customerEmail, order)\\n        println(\\\"[CheckoutWorkflow] Order confirmation email sent.\\\")\\n\\n        println(\\\"[CheckoutWorkflow] Checkout process completed successfully.\\\")\\n        return order\\n    }\\n}\\n\\nclass CheckoutService(\\n    private val checkoutWorkflow: CheckoutWorkflow\\n) {\\n    fun executeCheckout(cart: ShoppingCart, customerEmail: String): Order? {\\n        return checkoutWorkflow.processCheckout(cart, customerEmail)\\n    }\\n}\\n\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `CheckoutWorkflow` class is responsible for multiple tasks: validating the cart, checking inventory, processing payment, saving the order, updating inventory, and sending confirmation emails. This makes the class harder to maintain and test. To refactor, I introduced a `CheckoutService` class that encapsulates the `CheckoutWorkflow`, allowing for a clearer separation of concerns. Each class now has a single responsibility, improving maintainability and testability.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":22377086834,\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `CheckoutWorkflow` class is responsible for multiple tasks: validating the cart, checking inventory, processing payment, saving the order, updating inventory, and sending confirmation emails. This makes the class harder to maintain and test. To refactor, I introduced a `CheckoutService` class that encapsulates the `CheckoutWorkflow`, allowing for a clearer separation of concerns. Each class now has a single responsibility, improving maintainability and testability.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `CheckoutWorkflow` class is responsible for multiple tasks: validating the cart, checking inventory, processing payment, saving the order, updating inventory, and sending confirmation emails. This makes the class harder to maintain and test. To refactor, I introduced a `CheckoutService` class that encapsulates the `CheckoutWorkflow`, allowing for a clearer separation of concerns. Each class now has a single responsibility, improving maintainability and testability."
        },
        {
            "input": "public class InvoiceProcessor {\n    private readonly IInvoiceCalculator _invoiceCalculator;\n    private readonly IInvoiceRepository _invoiceRepository;\n\n    public InvoiceProcessor(IInvoiceCalculator invoiceCalculator, IInvoiceRepository invoiceRepository) {\n        _invoiceCalculator = invoiceCalculator;\n        _invoiceRepository = invoiceRepository;\n    }\n\n    public void Process(Invoice invoice) {\n        invoice.Total = _invoiceCalculator.CalculateTotal(invoice);\n        _invoiceRepository.SaveToDatabase(invoice);\n    }\n}",
            "output": "NONE",
            "level": "EASY",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "public class Report {\n    public void GenerateReport() {\n        // generate report\n    }\n}\n\npublic class ReportPrinter {\n    public void PrintReport(Report report) {\n        // print report\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2693698584,\"explanation\":\"The original code had the `Report` class responsible for generating and printing reports, which violates the Single Responsibility Principle (SRP). The refactored code separates the report generation into a new `ReportGenerator` class, allowing each class to have a single responsibility.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had the `Report` class responsible for generating and printing reports, which violates the Single Responsibility Principle (SRP). The refactored code separates the report generation into a new `ReportGenerator` class, allowing each class to have a single responsibility."
        },
        {
            "input": "public class User {\n    public string Email { get; set; }\n}\n\npublic interface IUserRegistrationService {\n    void RegisterUser(User user);\n}\n\npublic class UserRegistrationService : IUserRegistrationService {\n    private readonly IEmailService _emailService;\n\n    public UserRegistrationService(IEmailService emailService) {\n        _emailService = emailService;\n    }\n\n    public void RegisterUser(User user) {\n        // register user logic\n        _emailService.SendEmail(user);\n    }\n}\n\npublic interface IEmailService {\n    void SendEmail(User user);\n}\n\npublic class EmailService : IEmailService {\n    public void SendEmail(User user) {\n        // send email\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3979082833,\"explanation\":\"The `UserRegistrationService` class was handling both user registration and email sending, violating the Single Responsibility Principle (SRP). The email sending logic has been extracted into a separate method, allowing the class to focus solely on user registration.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The `UserRegistrationService` class was handling both user registration and email sending, violating the Single Responsibility Principle (SRP). The email sending logic has been extracted into a separate method, allowing the class to focus solely on user registration."
        },
        {
            "input": "public class FileManager : IFileReader {\n    public void ReadFile() {\n        // read file\n    }\n}\n\npublic class Logger : ILogger {\n    public void LogError(string message) {\n        // log error\n    }\n}\n\npublic class Application {\n    private readonly IFileReader _fileReader;\n    private readonly ILogger _logger;\n\n    public Application(IFileReader fileReader, ILogger logger) {\n        _fileReader = fileReader;\n        _logger = logger;\n    }\n\n    public void Run() {\n        try {\n            _fileReader.ReadFile();\n        } catch (Exception ex) {\n            _logger.LogError(ex.Message);\n        }\n    }\n}",
            "output": "{\"violation_type\":\"DIP\",\"total_duration\":4073000292,\"explanation\":\"The original code had a direct dependency on concrete implementations of `IFileReader` and `ILogger` in the `Application` class. By using interfaces, the code now adheres to the Dependency Inversion Principle, allowing for easier testing and flexibility in swapping implementations.\"}",
            "level": "EASY",
            "language": "C#",
            "violation": "DIP",
            "explanation": "The original code had a direct dependency on concrete implementations of `IFileReader` and `ILogger` in the `Application` class. By using interfaces, the code now adheres to the Dependency Inversion Principle, allowing for easier testing and flexibility in swapping implementations."
        },
        {
            "input": "public class Order {\n    public void PlaceOrder() {\n        // place order\n    }\n}\n\npublic interface IEmailSender {\n    void SendConfirmationEmail(Order order);\n}\n\npublic class EmailSender : IEmailSender {\n    public void SendConfirmationEmail(Order order) {\n        // send email\n    }\n}\n\npublic interface IStockManager {\n    void UpdateStock(Order order);\n}\n\npublic class StockManager : IStockManager {\n    public void UpdateStock(Order order) {\n        // update stock\n    }\n}\n\npublic class OrderService {\n    private readonly IEmailSender _emailSender;\n    private readonly IStockManager _stockManager;\n\n    public OrderService(IEmailSender emailSender, IStockManager stockManager) {\n        _emailSender = emailSender;\n        _stockManager = stockManager;\n    }\n\n    public void ProcessOrder(Order order) {\n        order.PlaceOrder();\n        _emailSender.SendConfirmationEmail(order);\n        _stockManager.UpdateStock(order);\n    }\n}",
            "output": "NONE",
            "level": "MODERATE",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "public interface ICustomerRepository {\n    void AddCustomer(Customer customer);\n}\n\npublic interface ICustomerArchiver {\n    void ArchiveCustomer(Customer customer);\n}\n\npublic class CustomerRepository : ICustomerRepository, ICustomerArchiver {\n    public void AddCustomer(Customer customer) {\n        // add customer to database\n    }\n\n    public void ArchiveCustomer(Customer customer) {\n        // archive customer in database\n    }\n}\n\npublic interface IReportGenerator {\n    void GenerateCustomerReport(Customer customer);\n}\n\npublic class CustomerReportGenerator : IReportGenerator {\n    public void GenerateCustomerReport(Customer customer) {\n        // generate report for customer\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":2929949917,\"explanation\":\"The `CustomerRepository` class previously handled both adding and archiving customers, violating the Single Responsibility Principle (SRP). The refactored code separates these responsibilities into two distinct classes: `CustomerRepository` for adding customers and `CustomerArchiver` for archiving customers.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The `CustomerRepository` class previously handled both adding and archiving customers, violating the Single Responsibility Principle (SRP). The refactored code separates these responsibilities into two distinct classes: `CustomerRepository` for adding customers and `CustomerArchiver` for archiving customers."
        },
        {
            "input": "public class Product {\n    public string Name { get; set; }\n    public decimal Price { get; set; }\n\n    public Product(string name, decimal price) {\n        Name = name;\n        Price = price;\n    }\n}\n\npublic interface IDiscountCalculator {\n    decimal CalculateDiscount(Product product);\n}\n\npublic class PercentageDiscountCalculator : IDiscountCalculator {\n    private readonly decimal _discountPercentage;\n\n    public PercentageDiscountCalculator(decimal discountPercentage) {\n        _discountPercentage = discountPercentage;\n    }\n\n    public decimal CalculateDiscount(Product product) {\n        return product.Price  _discountPercentage / 100;\n    }\n}\n\npublic interface IWarehouseNotifier {\n    void NotifyWarehouse(Product product);\n}\n\npublic class EmailWarehouseNotifier : IWarehouseNotifier {\n    public void NotifyWarehouse(Product product) {\n        // Logic to notify warehouse via email\n    }\n}\n\npublic class ProductService {\n    private readonly IDiscountCalculator _discountCalculator;\n    private readonly IWarehouseNotifier _warehouseNotifier;\n\n    public ProductService(IDiscountCalculator discountCalculator, IWarehouseNotifier warehouseNotifier) {\n        _discountCalculator = discountCalculator;\n        _warehouseNotifier = warehouseNotifier;\n    }\n\n    public void AddProduct(Product product) {\n        // Logic to add product\n        var discount = _discountCalculator.CalculateDiscount(product);\n        // Apply discount logic\n        _warehouseNotifier.NotifyWarehouse(product);\n    }\n}",
            "output": "NONE",
            "level": "MODERATE",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "public class Employee {\n    public string Name { get; set; }\n    public decimal BaseSalary { get; set; }\n\n    public Employee(string name, decimal baseSalary) {\n        Name = name;\n        BaseSalary = baseSalary;\n    }\n}\n\npublic class SalaryCalculator {\n    public decimal CalculateSalary(Employee employee) {\n        return employee.BaseSalary; // Simplified for example\n    }\n}\n\npublic class EmployeeRepository {\n    public void SaveEmployeeData(Employee employee) {\n        // save data logic\n    }\n}\n\npublic class PayrollEmailSender {\n    public void SendPayrollEmail(Employee employee) {\n        // send email logic\n    }\n}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":3567233250,\"explanation\":\"The original code had classes that handled multiple responsibilities, such as saving employee data and sending emails, which violates the Single Responsibility Principle (SRP). The refactored code separates these responsibilities into distinct interfaces and classes, ensuring that each class has one reason to change.\"}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had classes that handled multiple responsibilities, such as saving employee data and sending emails, which violates the Single Responsibility Principle (SRP). The refactored code separates these responsibilities into distinct interfaces and classes, ensuring that each class has one reason to change."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Threading;\\n\\npublic interface ITask\\n{\\n    Guid Id { get; }\\n    string Type { get; }\\n    string Payload { get; }\\n}\\n\\npublic class SimpleTask : ITask\\n{\\n    public Guid Id { get; set; }\\n    public string Type { get; set; }\\n    public string Payload { get; set; }\\n}\\n\\npublic interface ITaskQueue\\n{\\n    ITask Dequeue();\\n    void Enqueue(ITask task);\\n}\\n\\npublic class InMemoryTaskQueue : ITaskQueue\\n{\\n    private readonly Queue<ITask> _tasks = new Queue<ITask>();\\n\\n    public void Enqueue(ITask task)\\n    {\\n        lock (_tasks)\\n        {\\n            _tasks.Enqueue(task);\\n            Console.WriteLine($\"[InMemoryTaskQueue] Enqueued task {task.Type}.\");\\n        }\\n    }\\n\\n    public ITask Dequeue()\\n    {\\n        lock (_tasks)\\n        {\\n            if (_tasks.Any())\\n            {\\n                return _tasks.Dequeue();\\n            }\\n            return null;\\n        }\\n    }\\n}\\n\\npublic interface ITaskHandler\\n{\\n    string TaskType { get; }\\n    void Handle(ITask task, ITaskLogger logger);\\n}\\n\\npublic class ProcessOrderTaskHandler : ITaskHandler\\n{\\n    public string TaskType => \\\"ProcessOrder\\\";\\n\\n    public void Handle(ITask task, ITaskLogger logger)\\n    {\\n        Console.WriteLine($\"[ProcessOrderTaskHandler] Processing order with payload: {task.Payload}\");\\n        logger.Log(task.Id, task.Type, true, \\\"Success\\\");\\n    }\\n}\\n\\npublic class SendEmailTaskHandler : ITaskHandler\\n{\\n    public string TaskType => \\\"SendEmail\\\";\\n\\n    public void Handle(ITask task, ITaskLogger logger)\\n    {\\n        Console.WriteLine($\"[SendEmailTaskHandler] Sending email with payload: {task.Payload}\");\\n        logger.Log(task.Id, task.Type, true, \\\"Success\\\");\\n    }\\n}\\n\\npublic interface ITaskLogger\\n{\\n    void Log(Guid taskId, string taskType, bool success, string resultDetails);\\n}\\n\\npublic class ConsoleTaskLogger : ITaskLogger\\n{\\n    public void Log(Guid taskId, string taskType, bool success, string resultDetails)\\n    {\\n        Console.WriteLine($\"[ConsoleTaskLogger] LOG: TaskId={taskId}, Type={taskType}, Success={success}, Details='{resultDetails}'\");\\n    }\\n}\\n\\npublic class TaskProcessingWorkflow\\n{\\n    private readonly ITaskQueue _taskQueue;\\n    private readonly IReadOnlyDictionary<string, ITaskHandler> _taskHandlers;\\n    private readonly ITaskLogger _taskLogger;\\n\\n    public TaskProcessingWorkflow(\\n        ITaskQueue taskQueue,\\n        IEnumerable<ITaskHandler> taskHandlers,\\n        ITaskLogger taskLogger)\\n    {\\n        _taskQueue = taskQueue;\\n        _taskHandlers = taskHandlers.ToDictionary(h => h.TaskType, h => h);\\n        _taskLogger = taskLogger;\\n    }\\n\\n    public void StartProcessing(CancellationToken cancellationToken)\\n    {\\n        Console.WriteLine(\\\"[TaskProcessingWorkflow] Starting processing workflow...\\\");\\n\\n        while (!cancellationToken.IsCancellationRequested)\\n        {\\n            try\\n            {\\n                var task = _taskQueue.Dequeue();\\n                if (task == null)\\n                {\\n                    Console.WriteLine(\\\"[TaskProcessingWorkflow] No tasks in queue. Waiting...\\\");\\n                    Thread.Sleep(1000);\\n                    continue;\\n                }\\n\\n                Console.WriteLine($\"[TaskProcessingWorkflow] Dequeued task type: {task.Type}, Payload: {task.Payload}\");\\n\\n                if (_taskHandlers.TryGetValue(task.Type, out var handler))\\n                {\\n                    try\\n                    {\\n                        Console.WriteLine($\"[TaskProcessingWorkflow] Executing handler for task type: {task.Type}\");\\n                        handler.Handle(task, _taskLogger);\\n                        Console.WriteLine($\"[TaskProcessingWorkflow] Task {task.Type} executed successfully.\");\\n                    }\\n                    catch (Exception ex)\\n                    {\\n                        Console.WriteLine($\"[TaskProcessingWorkflow] Error executing task {task.Type}: {ex.Message}\\\");\\n                        _taskLogger.Log(task.Id, task.Type, false, $\\\"Execution Error: {ex.Message}\\\");\\n                    }\\n                }\\n                else\\n                {\\n                    Console.WriteLine($\"[TaskProcessingWorkflow] No handler found for task type: {task.Type}\");\\n                    _taskLogger.Log(task.Id, task.Type, false, \\\"No Handler Found\\\");\\n                }\\n            }\\n            catch (Exception ex)\\n            {\\n                Console.WriteLine($\"[TaskProcessingWorkflow] Error dequeuing task: {ex.Message}\\\");\\n                Thread.Sleep(5000);\\n            }\\n        }\\n\\n        Console.WriteLine(\\\"[TaskProcessingWorkflow] Processing workflow stopped.\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `TaskProcessingWorkflow` class is responsible for both processing tasks and logging, which can lead to difficulties in maintaining and testing the code. The refactored code addresses this by allowing each `ITaskHandler` to handle the task and log its results, thus separating the concerns of task processing and logging.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":17374032667,\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `TaskProcessingWorkflow` class is responsible for both processing tasks and logging, which can lead to difficulties in maintaining and testing the code. The refactored code addresses this by allowing each `ITaskHandler` to handle the task without logging, while the `TaskProcessingWorkflow` manages the logging separately, thus separating the concerns of task processing and logging.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `TaskProcessingWorkflow` class is responsible for both processing tasks and logging, which can lead to difficulties in maintaining and testing the code. The refactored code addresses this by allowing each `ITaskHandler` to handle the task without logging, while the `TaskProcessingWorkflow` manages the logging separately, thus separating the concerns of task processing and logging."
        },
        {
            "input": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Data;\\nusing System.Data.SqlClient;\\nusing System.IO;\\nusing System.Linq;\\n\\npublic interface ISalesDataFetcher\\n{\\n    DataTable Fetch(DateTime startDate, DateTime endDate);\\n}\\n\\npublic class DatabaseSalesDataFetcher : ISalesDataFetcher\\n{\\n    private readonly string _dbConnectionString;\\n\\n    public DatabaseSalesDataFetcher(string dbConnectionString) {\\n        _dbConnectionString = dbConnectionString;\\n    }\\n\\n    public DataTable Fetch(DateTime startDate, DateTime endDate)\\n    {\\n        Console.WriteLine($\\\"[DatabaseSalesDataFetcher] Fetching sales data from DB {_dbConnectionString}...\\\");\\n        var dt = new DataTable();\\n        dt.Columns.Add(\\\"SaleDate\\\", typeof(DateTime));\\n        dt.Columns.Add(\\\"Amount\\\", typeof(decimal));\\n        // Simulating data fetching from the database\\n        dt.Rows.Add(DateTime.Now.AddDays(-1), 100.0m);\\n        dt.Rows.Add(DateTime.Now.AddDays(-2), 150.0m);\\n        return dt;\\n    }\\n}\\n\\npublic interface IReportDataTransformer<TInput, TOutput>\\n{\\n    TOutput Transform(TInput rawData);\\n}\\n\\npublic class SalesSummaryTransformer : IReportDataTransformer<DataTable, DataTable>\\n{\\n    public DataTable Transform(DataTable rawData)\\n    {\\n        Console.WriteLine(\\\"[SalesSummaryTransformer] Transforming data...\\\");\\n        var transformed = new DataTable();\\n        transformed.Columns.Add(\\\"Period\\\", typeof(string));\\n        transformed.Columns.Add(\\\"TotalSales\\\", typeof(decimal));\\n        decimal total = 0;\\n        foreach(DataRow row in rawData.Rows)\\n        {\\n            total += (decimal)row[\\\"Amount\\\"];\\n        }\\n        transformed.Rows.Add($\"{DateTime.Now:yyyy-MM}\", total);\\n        return transformed;\\n    }\\n}\\n\\npublic interface IReportGenerator<TData>\\n{\\n    string Generate(TData data, DateTime startDate, DateTime endDate);\\n}\\n\\npublic class CsvReportGenerator : IReportGenerator<DataTable>\\n{\\n    private readonly string _outputDirectory;\\n\\n    public CsvReportGenerator(string outputDirectory) {\\n        _outputDirectory = outputDirectory;\\n    }\\n\\n    public string Generate(DataTable data, DateTime startDate, DateTime endDate)\\n    {\\n        Console.WriteLine($\\\"[CsvReportGenerator] Generating CSV report in {_outputDirectory}...\\\");\\n        string filename = $\\\"SalesSummary_{startDate:yyyyMMdd}_{endDate:yyyyMMdd}.csv\\\";\\n        string fullPath = Path.Combine(_outputDirectory, filename);\\n        try\\n        {\\n             var lines = new List<string>();\\n             lines.Add(string.Join(\\\",\\\", data.Columns.Cast<DataColumn>().Select(c => c.ColumnName)));\\n             foreach(DataRow row in data.Rows)\\n             {\\n                 lines.Add(string.Join(\\\",\\\", row.ItemArray.Select(item => item.ToString())));\\n             }\\n             File.WriteAllLines(fullPath, lines);\\n             return fullPath;\\n        }\\n        catch (Exception ex)\\n        {\\n             Console.WriteLine($\\\"[CsvReportGenerator] Error: {ex.Message}\\\");\\n             return null;\\n        }\\n    }\\n}\\n\\npublic interface IReportUploader\\n{\\n    bool Upload(string reportFilePath);\\n}\\n\\npublic class ExternalReportUploader : IReportUploader\\n{\\n    private readonly string _uploadServiceEndpoint;\\n\\n    public ExternalReportUploader(string uploadServiceEndpoint) {\\n        _uploadServiceEndpoint = uploadServiceEndpoint;\\n    }\\n\\n    public bool Upload(string reportFilePath)\\n    {\\n        Console.WriteLine($\\\"[ExternalReportUploader] Uploading report {reportFilePath} to service at {_uploadServiceEndpoint}...\\\");\\n        return true;\\n    }\\n}\\n\\npublic class SalesReportWorkflow\\n{\\n    private readonly ISalesDataFetcher _dataFetcher;\\n    private readonly IReportDataTransformer<DataTable, DataTable> _dataTransformer;\\n    private readonly IReportGenerator<DataTable> _reportGenerator;\\n    private readonly IReportUploader _reportUploader;\\n\\n    public SalesReportWorkflow(\\n        ISalesDataFetcher dataFetcher,\\n        IReportDataTransformer<DataTable, DataTable> dataTransformer,\\n        IReportGenerator<DataTable> reportGenerator,\\n        IReportUploader reportUploader)\\n    {\\n        _dataFetcher = dataFetcher;\\n        _dataTransformer = dataTransformer;\\n        _reportGenerator = reportGenerator;\\n        _reportUploader = reportUploader;\\n    }\\n\\n    public bool GenerateAndUploadSummary(DateTime startDate, DateTime endDate)\\n    {\\n        Console.WriteLine($\\\"[SalesReportWorkflow] Starting sales summary workflow for {startDate:d} to {endDate:d}\\\");\\n\\n        var rawData = _dataFetcher.Fetch(startDate, endDate);\\n        if (rawData == null || rawData.Rows.Count == 0)\\n        {\\n            Console.WriteLine(\\\"[SalesReportWorkflow] No data found for the report.\\\");\\n            return false;\\n        }\\n        Console.WriteLine($\\\"[SalesReportWorkflow] Fetched {rawData.Rows.Count} rows of data.\\\");\\n\\n        var transformedData = _dataTransformer.Transform(rawData);\\n        Console.WriteLine(\\\"[SalesReportWorkflow] Data transformed.\\\");\\n\\n        string reportFilePath = _reportGenerator.Generate(transformedData, startDate, endDate);\\n        if (string.IsNullOrEmpty(reportFilePath) || !File.Exists(reportFilePath))\\n        {\\n            Console.WriteLine(\\\"[SalesReportWorkflow] Report file generation failed.\\\");\\n            return false;\\n        }\\n        Console.WriteLine($\\\"[SalesReportWorkflow] Report file generated at {reportFilePath}\\\");\\n\\n        if (!_reportUploader.Upload(reportFilePath))\\n        {\\n            Console.WriteLine($\\\"[SalesReportWorkflow] Failed to upload report file {reportFilePath}.\\\");\\n            return false;\\n        }\\n        Console.WriteLine($\\\"[SalesReportWorkflow] Report file {reportFilePath} uploaded successfully.\\\");\\n\\n        Console.WriteLine(\\\"[SalesReportWorkflow] Sales summary workflow complete.\\\");\\n        return true;\\n    }\\n}\",\"explanation\":\"The original code had several SOLID principle violations. The most significant violation was the Single Responsibility Principle (SRP), as the `SalesReportWorkflow` class was responsible for multiple tasks: fetching data, transforming data, generating reports, and uploading reports. This was refactored by creating separate classes for each responsibility, ensuring that each class has a single reason to change. Additionally, the code was cleaned up to ensure better separation of concerns and maintainability.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":19533331542,\"explanation\":\"The original code had several SOLID principle violations. The most significant violation was the Single Responsibility Principle (SRP), as the `SalesReportWorkflow` class was responsible for multiple tasks: fetching data, transforming data, generating reports, and uploading reports. This was refactored by creating separate classes for each responsibility, ensuring that each class has a single reason to change. Additionally, the code was cleaned up to ensure better separation of concerns and maintainability.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code had several SOLID principle violations. The most significant violation was the Single Responsibility Principle (SRP), as the `SalesReportWorkflow` class was responsible for multiple tasks: fetching data, transforming data, generating reports, and uploading reports. This was refactored by creating separate classes for each responsibility, ensuring that each class has a single reason to change. Additionally, the code was cleaned up to ensure better separation of concerns and maintainability."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"using System;\\nusing System.Data.SqlClient;\\nusing System.Security.Cryptography;\\nusing System.Text;\\n\\npublic interface IUserRepository\\n{\\n    bool Exists(string username);\\n    bool Save(UserAccount user);\\n    bool UpdateRole(string username, string newRole);\\n    UserAccount GetByUsername(string username); \\n}\\n\\npublic class DatabaseUserRepository : IUserRepository\\n{\\n    private readonly string _dbConnectionString;\\n\\n    public DatabaseUserRepository(string dbConnectionString) {\\n        _dbConnectionString = dbConnectionString;\\n    }\\n\\n    public bool Exists(string username)\\n    {\\n        Console.WriteLine($\"[DatabaseUserRepository] Checking existence of {username} in DB {_dbConnectionString}...\");\\n        using (var conn = new SqlConnection(_dbConnectionString))\\n        {\\n            // Database logic to check existence\\n        }\\n        return username == \\\"existingUser\\\";\\n    }\\n\\n    public bool Save(UserAccount user)\\n    {\\n        Console.WriteLine($\"[DatabaseUserRepository] Saving user {user.Username} to DB {_dbConnectionString}...\");\\n        using (var conn = new SqlConnection(_dbConnectionString))\\n        {\\n            // Database logic to save user\\n        }\\n        return true;\\n    }\\n\\n    public bool UpdateRole(string username, string newRole)\\n    {\\n        Console.WriteLine($\"[DatabaseUserRepository] Updating role for {username} in DB {_dbConnectionString}...\");\\n        using (var conn = new SqlConnection(_dbConnectionString))\\n        {\\n            // Database logic to update role\\n        }\\n        return true;\\n    }\\n\\n    public UserAccount GetByUsername(string username) \\n    {\\n        Console.WriteLine($\"[DatabaseUserRepository] Getting user {username} from DB {_dbConnectionString}...\");\\n        using (var conn = new SqlConnection(_dbConnectionString))\\n        {\\n            // Database logic to get user\\n        }\\n        return Exists(username) ? new UserAccount { Username = username, PasswordHash = \\\"hashed\\\", Role = \\\"user\\\", PermissionsJson = \\\"{}\\\" } : null;\\n    }\\n}\\n\\npublic interface IPasswordHasher\\n{\\n    string Hash(string password);\\n    bool Verify(string password, string passwordHash);\\n}\\n\\npublic class SHA256PasswordHasher : IPasswordHasher\\n{\\n    public string Hash(string password)\\n    {\\n         Console.WriteLine(\\\"[SHA256PasswordHasher] Hashing password...\\\");\\n         using (var sha256 = SHA256.Create())\\n         {\\n             var bytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(password));\\n             return Convert.ToBase64String(bytes);\\n         }\\n    }\\n\\n    public bool Verify(string password, string passwordHash)\\n    {\\n        Console.WriteLine(\\\"[SHA256PasswordHasher] Verifying password...\\\");\\n        string hashOfInput = Hash(password);\\n        StringComparer comparer = StringComparer.OrdinalIgnoreCase;\\n        return comparer.Compare(hashOfInput, passwordHash) == 0;\\n    }\\n}\\n\\npublic interface IAuditLogger\\n{\\n    void Log(string action, string user, string details, bool success);\\n}\\n\\npublic class ConsoleAuditLogger : IAuditLogger\\n{\\n    public void Log(string action, string user, string details, bool success)\\n    {\\n        Console.WriteLine($\"[ConsoleAuditLogger] AUDIT: Action=\\'{action}\\', User=\\'{user}\\', Details=\\'{details}\\', Success={success}\");\\n    }\\n}\\n\\npublic class UserAccount\\n{\\n    public string Username { get; set; }\\n    public string PasswordHash { get; set; }\\n    public string Role { get; set; }\\n    public string PermissionsJson { get; set; }\\n}\\n\\npublic class UserService\\n{\\n    private readonly IUserRepository _userRepository;\\n    private readonly IPasswordHasher _passwordHasher;\\n    private readonly IAuditLogger _auditLogger;\\n\\n    public UserService(\\n        IUserRepository userRepository,\\n        IPasswordHasher passwordHasher,\\n        IAuditLogger auditLogger)\\n    {\\n        _userRepository = userRepository;\\n        _passwordHasher = passwordHasher;\\n        _auditLogger = auditLogger;\\n    }\\n\\n    public bool CreateAccount(string username, string password, string role, string permissionsJson)\\n    {\\n        Console.WriteLine($\"[UserService] Starting account creation for {username}\");\\n\\n        if (_userRepository.Exists(username))\\n        {\\n            Console.WriteLine(\\\"[UserService] User {username} already exists.\\\");\\n            _auditLogger.Log(\\\"CreateAccount\\\", username, \\\"User Exists\\\", false);\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[UserService] User does not exist.\\\");\\n\\n        string passwordHash = _passwordHasher.Hash(password);\\n        Console.WriteLine(\\\"[UserService] Password hashed.\\\");\\n\\n        var newUser = new UserAccount\\n        {\\n            Username = username,\\n            PasswordHash = passwordHash,\\n            Role = role,\\n            PermissionsJson = permissionsJson\\n        };\\n\\n        if (!_userRepository.Save(newUser))\\n        {\\n            Console.WriteLine(\\\"[UserService] Failed to save user {username} to database.\\\");\\n            _auditLogger.Log(\\\"CreateAccount\\\", username, \\\"DB Save Failed\\\", false);\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[UserService] User {username} saved to database.\\\");\\n\\n        _auditLogger.Log(\\\"CreateAccount\\\", username, \\\"Success\\\", true);\\n        Console.WriteLine($\"[UserService] Account creation workflow complete for {username}.\");\\n        return true;\\n    }\\n\\n    public bool AssignRole(string username, string newRole)\\n    {\\n        Console.WriteLine($\"[UserService] Starting role assignment for {username}\");\\n\\n        if (!_userRepository.Exists(username))\\n        {\\n            Console.WriteLine(\\\"[UserService] User {username} not found for role assignment.\\\");\\n            _auditLogger.Log(\\\"AssignRole\\\", username, \\\"User Not Found\\\", false);\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[UserService] User found.\\\");\\n\\n        if (!_userRepository.UpdateRole(username, newRole))\\n        {\\n            Console.WriteLine(\\\"[UserService] Failed to update role for {username} in database.\\\");\\n            _auditLogger.Log(\\\"AssignRole\\\", username, \\\"DB Update Failed\\\", false);\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[UserService] Role updated for {username} to {newRole}.\\\");\\n\\n        _auditLogger.Log(\\\"AssignRole\\\", username, $\\\"Role changed to {newRole}\\\", true);\\n        Console.WriteLine($\"[UserService] Role assignment workflow complete for {username}.\");\\n        return true;\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `UserAccountCreationWorkflow` and `UserRoleAssignmentWorkflow` classes handle multiple responsibilities related to user management. The refactored code introduces a `UserService` class that consolidates user-related operations, allowing for better adherence to SRP. Each class now has a single responsibility, making the code more maintainable and extensible.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":22640691959,\"explanation\":\"The original code violated the Single Responsibility Principle (SRP) because the `UserService` class was responsible for both user account creation and role assignment, leading to a class that handled multiple responsibilities. The refactored code maintains a single responsibility for user management, making it easier to manage and extend. Each method in `UserService` now focuses on a specific task related to user operations.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The original code violated the Single Responsibility Principle (SRP) because the `UserService` class was responsible for both user account creation and role assignment, leading to a class that handled multiple responsibilities. The refactored code maintains a single responsibility for user management, making it easier to manage and extend. Each method in `UserService` now focuses on a specific task related to user operations."
        },
        {
            "input": "{\"violation_type\":\"SRP\",\"refactored_code\":\"public class OrderFulfillmentWorkflow\\n{\\n    private readonly IOrderRepository _orderRepository;\\n    private readonly IInventoryService _inventoryService;\\n    private readonly IShippingService _shippingService;\\n    private readonly INotificationService _notificationService;\\n\\n    public OrderFulfillmentWorkflow(\\n        IOrderRepository orderRepository,\\n        IInventoryService inventoryService,\\n        IShippingService shippingService,\\n        INotificationService notificationService)\\n    {\\n        _orderRepository = orderRepository;\\n        _inventoryService = inventoryService;\\n        _shippingService = shippingService;\\n        _notificationService = notificationService;\\n    }\\n\\n    public bool FulfillOrder(int orderId)\\n    {\\n        Console.WriteLine($\"[OrderFulfillmentWorkflow] Starting fulfillment workflow for Order ID: {orderId}\");\\n\\n        var order = _orderRepository.GetById(orderId);\\n        if (order == null)\\n        {\\n            Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Order not found.\\\");\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Order details fetched.\\\");\\n\\n        if (!ReserveInventory(order))\\n        {\\n            return false;\\n        }\\n\\n        var shippingLabel = GenerateShippingLabel(order);\\n        if (string.IsNullOrEmpty(shippingLabel))\\n        {\\n            return false;\\n        }\\n\\n        if (!UpdateOrderStatus(orderId))\\n        {\\n            return false;\\n        }\\n\\n        SendNotification(order.CustomerEmail, shippingLabel);\\n\\n        Console.WriteLine($\"[OrderFulfillmentWorkflow] Order ID: {orderId} fulfilled successfully.\");\\n        return true;\\n    }\\n\\n    private bool ReserveInventory(Order order)\\n    {\\n        if (!_inventoryService.Reserve(order))\\n        {\\n            Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Inventory reservation failed.\\\");\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Inventory reserved.\\\");\\n        return true;\\n    }\\n\\n    private string GenerateShippingLabel(Order order)\\n    {\\n        var shippingLabel = _shippingService.GenerateLabel(order);\\n        if (string.IsNullOrEmpty(shippingLabel))\\n        {\\n            Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Shipping label generation failed.\\\");\\n            _inventoryService.Release(order);\\n            return null;\\n        }\\n        Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Shipping label generated.\\\");\\n        return shippingLabel;\\n    }\\n\\n    private bool UpdateOrderStatus(int orderId)\\n    {\\n        if (!_orderRepository.UpdateStatus(orderId, \\\"SHIPPED\\\"))\\n        {\\n            Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Failed to update order status.\\\");\\n            return false;\\n        }\\n        Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Order status updated to SHIPPED.\\\");\\n        return true;\\n    }\\n\\n    private void SendNotification(string recipientEmail, string shippingLabelPath)\\n    {\\n        _notificationService.SendShippingNotification(recipientEmail, shippingLabelPath);\\n        Console.WriteLine(\\\"[OrderFulfillmentWorkflow] Shipping notification sent.\\\");\\n    }\\n}\",\"explanation\":\"The refactored code separates the responsibilities of the OrderFulfillmentWorkflow class into smaller, private methods, each handling a specific task. This adheres to the Single Responsibility Principle (SRP) by ensuring that the class has only one reason to change, which is to fulfill an order. Each method now focuses on a single aspect of the fulfillment process, making the code cleaner, easier to maintain, and more aligned with SOLID principles.\"}",
            "output": "{\"violation_type\":\"SRP\",\"total_duration\":11008584459,\"explanation\":\"The refactored code separates the responsibilities of the OrderFulfillmentWorkflow class into smaller, private methods, each handling a specific task. This adheres to the Single Responsibility Principle (SRP) by ensuring that the class has only one reason to change, which is to fulfill an order. Each method now focuses on a single aspect of the fulfillment process, making the code cleaner, easier to maintain, and more aligned with SOLID principles.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "SRP",
            "explanation": "The refactored code separates the responsibilities of the OrderFulfillmentWorkflow class into smaller, private methods, each handling a specific task. This adheres to the Single Responsibility Principle (SRP) by ensuring that the class has only one reason to change, which is to fulfill an order. Each method now focuses on a single aspect of the fulfillment process, making the code cleaner, easier to maintain, and more aligned with SOLID principles."
        }
    ]
}