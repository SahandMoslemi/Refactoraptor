{
  "code_examples": [
    {
      "input": "class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Bird bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Ostrich());\n    }\n}",
      "output": "interface Flyable {\n    void fly();\n}\n\nclass Bird {\n    // Other bird-related methods can be added here\n}\n\nclass Sparrow extends Bird implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Sparrow is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    // Ostrich does not implement Flyable\n}\n\npublic class Main {\n    public static void makeBirdFly(Flyable bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Sparrow()); // This will work\n        // makeBirdFly(new Ostrich()); // This will not compile\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Ostrich class, which is a subclass of Bird, cannot substitute for Bird without causing an error when the fly method is called. By introducing a Flyable interface, we ensure that only birds that can actually fly implement this interface, thus adhering to the principle."
    },
    {
      "input": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Square();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n    }\n}",
      "output": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width  height; }\n}\n\nclass Square extends Rectangle {\n    public Square(int side) {\n        this.width = side;\n        this.height = side;\n    }\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Rectangle();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea()); // Outputs 50\n        \n        Square s = new Square(5);\n        System.out.println(s.getArea()); // Outputs 25\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because a Square is a Rectangle, but it does not behave like one when using the setWidth and setHeight methods. The refactored code separates the creation of a Square from the Rectangle class and ensures that the Square class maintains its own properties without altering the behavior of the Rectangle class."
    },
    {
      "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        throw new RuntimeException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
      "output": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound(); // Outputs: Bark\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Dog class overrides the makeSound method in a way that throws an exception instead of providing a valid implementation. This means that a Dog cannot be used wherever an Animal is expected without causing an error. The refactored code provides a valid implementation for the makeSound method in the Dog class, allowing it to be substituted for the Animal class without issues."
    },
    {
      "input": "class Payment {\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
      "output": "abstract class Payment {\n    public abstract void pay();\n}\n\nclass PaidPayment extends Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Free payment, no processing required\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment paidPayment = new PaidPayment();\n        paidPayment.pay();\n        Payment freePayment = new FreePayment();\n        freePayment.pay();\n    }\n}",
      "level": "EASY",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the FreePayment class does not fulfill the contract of the Payment class by throwing an exception when the pay method is called. The refactored code introduces an abstract Payment class with an abstract pay method, and two concrete implementations: PaidPayment and FreePayment, both of which provide valid implementations of the pay method."
    },
    {
      "input": "class Vehicle {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.startEngine();\n    }\n}",
      "output": "abstract class Vehicle {\n    public abstract void startEngine();\n}\n\nclass Car extends Vehicle {\n    @Override\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException(\"Bicycles do not have an engine.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Car(); // or new Bicycle();\n        v.startEngine();\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class cannot substitute the Vehicle class without throwing an exception when calling startEngine(). To fix this, we can make Vehicle an abstract class with an abstract method startEngine(). This way, each subclass (Car and Bicycle) can implement the method appropriately, ensuring that they can be used interchangeably without causing runtime errors."
    },
    {
      "input": "class FileReader {\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "output": "abstract class FileReader {\n    public abstract String read();\n}\n\nclass SimpleFileReader extends FileReader {\n    @Override\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException(\"Access denied\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SimpleFileReader();\n        System.out.println(fr.read());\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the subclass `SecureFileReader` does not behave as expected when substituting the base class `FileReader`. Specifically, it throws a `SecurityException` instead of returning a valid string, which breaks the contract established by the base class. The refactored code introduces an abstract class `FileReader` with an abstract method `read()`, ensuring that all subclasses must provide a valid implementation of `read()`, thus adhering to the Liskov Substitution Principle."
    },
    {
      "input": "class Writer {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
      "output": "interface Writer {\n    void write(String data);\n}\n\nclass WritableWriter implements Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter implements Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new WritableWriter();\n        w.write(\"Hello\");\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the ReadOnlyWriter class cannot be used interchangeably with the Writer class without causing an exception. To fix this, I introduced an interface 'Writer' and created two separate classes: WritableWriter for writing data and ReadOnlyWriter for read-only operations. This ensures that both classes can be used interchangeably without violating the expected behavior."
    },
    {
      "input": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 0));\n    }\n}",
      "output": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\ninterface SafeCalculator {\n    int safeDivide(int a, int b);\n}\n\nclass SafeCalculatorImpl implements SafeCalculator {\n    @Override\n    public int safeDivide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        SafeCalculator safeCalculator = new SafeCalculatorImpl();\n        System.out.println(safeCalculator.safeDivide(4, 0));\n    }\n}",
      "level": "MODERATE",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the subclass SafeCalculator does not behave as a true substitute for its superclass Calculator. Specifically, the divide method in SafeCalculator throws an exception for a valid input (0 for the divisor), which is not the expected behavior of the base class. To comply with the principle, I introduced an interface SafeCalculator that defines a method safeDivide, allowing for a clear separation of concerns and ensuring that the implementation can handle safety checks without altering the expected behavior of the base class."
    },
    {
      "input": "class Shape {\n    \n    \n    public double area() {\n        System.out.println(\"Base Shape Area: 0.0\");\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    \n    \n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: \" + Double.NaN + \" (Violation)\");\n        return Double.NaN;\n    }\n}",
      "output": "abstract class Shape {\n    // Base class defines the contract: area() returns a double.\n    // Implicitly, this is expected to be a non-negative value representing size.\n    public abstract double area();\n}\n\nclass ValidShape extends Shape {\n    private double size;\n\n    public ValidShape(double size) {\n        if (size < 0) throw new IllegalArgumentException(\"Size cannot be negative\");\n        this.size = size;\n    }\n\n    @Override\n    public double area() {\n        System.out.println(\"Valid Shape Area: \" + size);\n        return size;\n    }\n}\n\nclass NullShape extends Shape {\n    // NullShape should not exist as a valid Shape.\n    @Override\n    public double area() {\n        throw new UnsupportedOperationException(\"NullShape does not have a valid area\");\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the NullShape class overrides the area() method to return Double.NaN, which breaks the expected behavior of the base class Shape. In the refactored code, I introduced an abstract class Shape that enforces a valid area calculation. The NullShape class is modified to throw an exception instead of returning an invalid area, ensuring that all subclasses adhere to the contract defined by the Shape class."
    },
    {
      "input": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\nclass FileProcessor {\n    \n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    \n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    \n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    \n    \n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\ninterface FileProcessor {\n    String getStatus(String filePath);\n    void processFile(String filePath);\n}\n\nclass WritableFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the `ReadOnlyFileProcessor` class does not fulfill the contract of the `processFile` method from the `FileProcessor` class. Specifically, it throws an exception when `processFile` is called, which is not expected behavior for a subclass. To refactor this, I introduced an interface `FileProcessor` that both `WritableFileProcessor` and `ReadOnlyFileProcessor` implement. This way, each class can define its own behavior for `processFile`, and the violation is resolved."
    },
    {
      "input": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        \n        \n        fakeMessagesLogged++;\n    }\n}",
      "output": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        // This method now logs a message to the console as well\n        System.out.println(\"[SILENT LOG] \" + message);\n        fakeMessagesLogged++;\n    }\n\n    public int getFakeMessagesLoggedCount() {\n        return fakeMessagesLogged;\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original implementation of SilentCounterLogger violates the Liskov Substitution Principle because it does not fulfill the expected behavior of the log method from the Logger class. The log method in SilentCounterLogger does not log messages as expected, which can lead to unexpected behavior when substituting Logger with SilentCounterLogger. The refactored code ensures that SilentCounterLogger still logs messages (albeit in a different format) while maintaining its own counting functionality."
    },
    {
      "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    \n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        \n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    \n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        \n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    \n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        \n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        \n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n        \n        \n        \n    }\n\n    \n    \n\n    \n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        \n        \n        \n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}\n\n\n",
      "output": "class DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    / Loads data from the specified source. /\n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        // Simulate loading data\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    / Processes the loaded data. /\n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        // Simulate processing\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    / Saves the processed data to the specified destination. /\n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        // Simulate saving data (e.g., writing to a file)\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Cannot save results.\");\n        return false; // Instead of throwing an exception, return false to indicate failure\n    }\n}",
      "level": "HARD",
      "language": "JAVA",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the `ReadOnlyDataProcessor` class overrides the `saveResults` method to throw an exception, which is not expected behavior for a `DataProcessor`. To comply with LSP, the `ReadOnlyDataProcessor` should provide a valid implementation of `saveResults` that indicates it cannot save results (e.g., by returning false) instead of throwing an exception."
    },
    {
      "input": "class Bird:\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise Exception('Ostriches cannot fly')",
      "output": "class Bird:\n    def fly(self):\n        raise NotImplementedError('This method should be overridden')\n\nclass FlyingBird(Bird):\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    pass",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Ostrich class, which is a subclass of Bird, cannot fulfill the contract of the fly method. To comply with this principle, we can create a separate class for flying birds, allowing Ostrich to inherit from Bird without implementing the fly method."
    },
    {
      "input": "class Rectangle:\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.height = height\n        self.width = height",
      "output": "class Shape:\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def set_width(self, width):\n        self.width = width\n    \n    def set_height(self, height):\n        self.height = height\n    \n    def area(self):\n        return self.width  self.height\n\nclass Square(Shape):\n    def set_side(self, side):\n        self.width = side\n        self.height = side\n    \n    def area(self):\n        return self.width  self.height",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Square class does not behave as a true subclass of Rectangle. Specifically, setting the width or height of a Square affects both dimensions, which is not the case for a Rectangle. The refactored code introduces a base class 'Shape' and separates the behavior of Rectangle and Square, ensuring that they can be used interchangeably without unexpected behavior."
    },
    {
      "input": "class Animal:\n    def make_sound(self):\n        print('Some sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        raise NotImplementedError('Fish cannot make sounds')",
      "output": "class Animal:\n    def make_sound(self):\n        raise NotImplementedError('Subclasses must implement this method')\n\nclass Mammal(Animal):\n    def make_sound(self):\n        print('Some mammal sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        return 'Fish cannot make sounds'",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Fish class does not properly implement the make_sound method, which leads to an exception when it is called. To comply with this principle, I refactored the code to ensure that the Animal class defines make_sound as an abstract method, and subclasses like Fish can provide a meaningful response without raising an error."
    },
    {
      "input": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
      "output": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter:\n    def write(self):\n        raise Exception('Cannot write in read-only mode')\n\nclass ReadOnly:\n    def read(self):\n        print('Reading from file')",
      "level": "EASY",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the ReadOnlyWriter class cannot be used interchangeably with the Writer class without causing an exception. To comply with this principle, I separated the read functionality into a new ReadOnly class, allowing ReadOnlyWriter to focus solely on read-only operations without inheriting from Writer."
    },
    {
      "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')",
      "output": "class PaymentProcessor:\n    def process_payment(self, amount):\n        raise NotImplementedError(\"Subclasses should implement this method\")\n\nclass PaidPaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')\n        print('Processed free account payment')",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the FreePaymentProcessor class does not behave as a true subtype of PaymentProcessor. Specifically, it raises an exception when a positive amount is processed, which is unexpected behavior for a subclass. The refactored code introduces a base class with an abstract method and separates the payment processing logic into two distinct subclasses, ensuring that each subclass adheres to the expected behavior."
    },
    {
      "input": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
      "output": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass PrintableDocument:\n    def print_document(self):\n        raise NotImplementedError('Subclasses should implement this!')\n\nclass RegularDocument(Document, PrintableDocument):\n    pass\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the subclass SecureDocument does not fulfill the contract of the base class Document, which expects that all documents can be printed. By introducing a PrintableDocument interface, we ensure that only documents that can be printed implement the print_document method, while SecureDocument can still inherit from Document without violating the principle."
    },
    {
      "input": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
      "output": "class Vehicle:\n    def start_engine(self):\n        raise NotImplementedError('This method should be overridden')\n\nclass EngineVehicle(Vehicle):\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class cannot be used interchangeably with the Vehicle class without causing an exception. To fix this, we can create a new base class, EngineVehicle, that includes the start_engine method, and have all engine-based vehicles inherit from it. The Bicycle class can still inherit from Vehicle but does not implement the start_engine method, thus adhering to the principle."
    },
    {
      "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise Exception('Cannot send email')",
      "output": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise NotImplementedError('Cannot send email')",
      "level": "MODERATE",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The NullEmailSender class violates the Liskov Substitution Principle because it cannot be used interchangeably with the EmailSender class without causing an exception. To comply with this principle, we can modify NullEmailSender to raise a NotImplementedError instead of a generic Exception, indicating that the method is not implemented, which is a clearer and more appropriate response."
    },
    {
      "input": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor(DataProcessor):\n    def __init__(self):\n        super().__init__()\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "output": "import os\nimport time\n\nclass DataLoader:\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Data loaded successfully.\")\n        else:\n            data = None\n            print(\"Failed to load data.\")\n        return data\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def process_data(self, data):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Processing data...\")\n        if data is None:\n            print(\"No data to process.\")\n            return False\n        time.sleep(0.2)\n        data[\"processed\"] = True\n        print(\"Data processed.\")\n        return data\n\nclass DataSaver:\n    def save_results(self, data, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Saving results to {destination}...\")\n        if data is None or not data.get(\"processed\"):\n            print(\"No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor:\n    def __init__(self):\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "Single Responsibility Principle",
      "explanation": "The original DataProcessor class violates the Single Responsibility Principle because it handles multiple responsibilities: loading data, processing data, and saving results. This refactored code separates these responsibilities into three distinct classes: DataLoader, DataProcessor, and DataSaver. Each class now has a single responsibility, making the code easier to maintain and extend."
    },
    {
      "input": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentCounterLogger(Logger):\n    def __init__(self):\n        super().__init__()\n        self._fake_messages_logged = 0\n\n    def log(self, message):\n        self._fake_messages_logged += 1\n",
      "output": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentLogger(Logger):\n    def log(self, message):\n        # Silent logger does not log anything\n        pass\n\nclass CounterLogger(Logger):\n    def log(self, message):\n        super().log(message)  # Calls the base log method to log and increment the counter\n\n# Usage\nlogger = CounterLogger()\nlogger.log(\"This is a log message.\")\nprint(logger.get_messages_logged_count())  # Should print 1\n\nsilent_logger = SilentLogger()\nsilent_logger.log(\"This will not be logged.\")\nprint(silent_logger.get_messages_logged_count())  # Should print 0",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the derived class 'SilentCounterLogger' does not behave as expected when substituting for the base class 'Logger'. Specifically, the 'log' method in 'SilentCounterLogger' does not perform the logging action or update the message count as the base class does, leading to inconsistent behavior. The refactored code introduces a 'SilentLogger' that does not log anything and a 'CounterLogger' that correctly logs messages and increments the count, ensuring that both derived classes can be used interchangeably without breaking the expected behavior."
    },
    {
      "input": "import os # Using os module for file operations\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return # Simplified: graceful exit if file missing\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\n\n\n\n\n",
      "output": "import os\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        return \"Cannot process (write to) a file using a ReadOnlyFileProcessor. This operation is not allowed.\"",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the `process_file` method in the `ReadOnlyFileProcessor` class raises a `RuntimeError`, while the base class `FileProcessor` does not raise an exception for valid file paths. To comply with LSP, the `process_file` method in `ReadOnlyFileProcessor` has been refactored to return a message indicating that the operation is not allowed instead of raising an exception."
    },
    {
      "input": "import math\n\nclass Shape:\n    def area(self):\n        print(\"Base Shape Area: 0.0\")\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        print(f\"Null Shape Area: {float('nan')} (Violation)\")\n        return float('nan') # Returning NaN is a subtle violation\n\n\n\n\n",
      "output": "class Shape:\n    def area(self):\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        raise ValueError(\"NullShape does not have a valid area.\")\n\n# Example Usage demonstrating the refactor:\nbase_shape = Shape()\nbase_area = base_shape.area() # Returns 0.0\nprint(f\"Base Area: {base_area}\")\n\nprint(\"---\")\n\nnull_shape = NullShape() # Now raises an error on area()\ntry:\n    null_area = null_shape.area() # Raises ValueError\nexcept ValueError as e:\n    print(e)",
      "level": "HARD",
      "language": "PYTHON",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the derived class `NullShape` does not adhere to the expected behavior of the base class `Shape`. Specifically, it returns NaN, which is not a valid area value. The refactored code addresses this by raising a ValueError in `NullShape` when `area()` is called, clearly indicating that it does not have a valid area, thus maintaining the contract established by the base class."
    },
    {
      "input": "open class Bird {\n    open fun fly() {}\n}\n\nclass Ostrich : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun makeBirdFly(bird: Bird) {\n    bird.fly()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdFly(ostrich)\n}",
      "output": "open class Bird {\n    open fun fly() {}\n}\n\ninterface Flyable {\n    fun fly()\n}\n\nclass Sparrow : Bird(), Flyable {\n    override fun fly() {\n        // Implementation for flying\n    }\n}\n\nclass Ostrich : Bird() {\n    // Ostrich does not implement Flyable\n}\n\nfun makeBirdFly(bird: Flyable) {\n    bird.fly()\n}\n\nfun main() {\n    val sparrow = Sparrow()\n    makeBirdFly(sparrow)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the `Ostrich` class, which is a subclass of `Bird`, cannot fulfill the contract of the `fly` method. To comply with this principle, I introduced a `Flyable` interface that only flying birds implement. This way, `Ostrich` does not need to implement `fly`, and we can ensure that only birds that can actually fly are passed to the `makeBirdFly` function."
    },
    {
      "input": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override fun setWidth(w: Int) {\n        width = w\n        height = w\n    }\n    override fun setHeight(h: Int) {\n        width = h\n        height = h\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
      "output": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override var width: Int\n        get() = super.width\n        set(value) {\n            super.width = value\n            super.height = value\n        }\n    override var height: Int\n        get() = super.height\n        set(value) {\n            super.width = value\n            super.height = value\n        }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the behavior of the Square class does not conform to the expectations set by the Rectangle class. Specifically, when a Square is resized, both its width and height change, which is not the case for a Rectangle. The refactored code ensures that the width and height properties of Square are overridden to maintain the expected behavior of a Rectangle."
    },
    {
      "input": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
      "output": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        // Fish do not make sounds, so we can choose to do nothing or throw an exception\n    }\n}\n\ninterface Soundable {\n    fun makeSound()\n}\n\nclass Dog : Animal(), Soundable {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    // Fish does not implement Soundable\n}\n\nfun animalSound(animal: Soundable) {\n    animal.makeSound()\n}\n\nfun main() {\n    val dog = Dog()\n    animalSound(dog)\n    // val fish = Fish() // This will not be passed to animalSound as it does not implement Soundable\n}",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Fish class does not properly implement the makeSound method, which leads to an UnsupportedOperationException when called. To refactor the code, we can introduce an interface called Soundable that only classes that can make a sound will implement. This way, Fish does not need to implement makeSound, thus adhering to the Liskov Substitution Principle."
    },
    {
      "input": "open class Payment {\n    open fun pay(amount: Double) {}\n}\n\nclass CashPayment : Payment() {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment() {\n    override fun pay(amount: Double) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
      "output": "",
      "level": "EASY",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"open class Payment {\\n    open fun pay(amount: Double) {}\\n}\\n\\nclass CashPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount with credit\\\")\\n    }\\n}\\n\\nclass UnsupportedPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        throw UnsupportedOperationException(\\\"Payment method not supported\\\")\\n    }\\n}\\n\\nfun processPayment(payment: Payment, amount: Double) {\\n    payment.pay(amount)\\n}\\n\\nfun main() {\\n    val credit = CreditPayment()\\n    processPayment(credit, 100.0)\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the CreditPayment class throws an exception when the pay method is called, which is not expected behavior for a subclass of Payment. To comply with this principle, I introduced an UnsupportedPayment class that explicitly handles unsupported payment methods, allowing all subclasses of Payment to provide a valid implementation of the pay method.\"}"
    },
    {
      "input": "open class Writer {\n    open fun write(data: String) {}\n}\n\nclass FileWriter : Writer() {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nclass ReadOnlyFileWriter : Writer() {\n    override fun write(data: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val readOnly = ReadOnlyFileWriter()\n    save(readOnly, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"open class Writer {\\n    open fun write(data: String) {}\\n}\\n\\ninterface Writable {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writable {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileWriter : Writable {\\n    override fun write(data: String) {\\n        throw UnsupportedOperationException(\\\"Cannot write to read-only file\\\")\\n    }\\n}\\n\\nfun save(writer: Writable, data: String) {\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val readOnly = ReadOnlyFileWriter()\\n    save(readOnly, \\\"Hello\\\")\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the ReadOnlyFileWriter class does not fulfill the contract of the Writer class by throwing an exception when the write method is called. To fix this, I introduced a Writable interface that both FileWriter and ReadOnlyFileWriter implement, ensuring that they adhere to a consistent contract.\"}"
    },
    {
      "input": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    override fun startEngine() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
      "output": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    // Bicycle does not have an engine, so we should not override startEngine\n}\n\nclass Car : Vehicle() {\n    override fun startEngine() {\n        // Implementation for starting a car engine\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    if (vehicle is Car) {\n        vehicle.startEngine()\n    } else {\n        throw UnsupportedOperationException(\"This vehicle cannot start an engine.\")\n    }\n}\n\nfun main() {\n    val bike = Bicycle()\n    val car = Car()\n    startVehicle(car) // This will work\n    // startVehicle(bike) // This will throw an exception\n}",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Bicycle class does not support the behavior of starting an engine, which is expected from the Vehicle class. The refactored code introduces a check in the startVehicle function to ensure that only vehicles that can start an engine (like Car) are allowed to do so, thus adhering to the principle."
    },
    {
      "input": "open class Notification {\n    open fun send(message: String) {}\n}\n\nclass EmailNotification : Notification() {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nclass SilentNotification : Notification() {\n    override fun send(message: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val silent = SilentNotification()\n    notifyUser(silent, \"Hello\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"open class Notification {\\n    open fun send(message: String) {}\\n}\\n\\nclass EmailNotification : Notification() {\\n    override fun send(message: String) {\\n        println(\\\"Email: \\$message\\\")\\n    }\\n}\\n\\nclass SilentNotification : Notification() {\\n    override fun send(message: String) {\\n        // No operation for silent notification\\n    }\\n}\\n\\nfun notifyUser(notification: Notification, message: String) {\\n    notification.send(message)\\n}\\n\\nfun main() {\\n    val silent = SilentNotification()\\n    notifyUser(silent, \\\"Hello\\\")\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the `SilentNotification` class throws an exception when the `send` method is called, which is not expected behavior for a subclass of `Notification`. To comply with this principle, the `SilentNotification` class should implement the `send` method without throwing an exception, possibly by doing nothing or logging that the notification is silent.\"}"
    },
    {
      "input": "open class Printer {\n    open fun printDocument(document: String) {}\n}\n\nclass NetworkPrinter : Printer() {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nclass DummyPrinter : Printer() {\n    override fun printDocument(document: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val dummy = DummyPrinter()\n    print(dummy, \"Test\")\n}",
      "output": "",
      "level": "MODERATE",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"open class Printer {\\n    open fun printDocument(document: String) {}\\n}\\n\\nclass NetworkPrinter : Printer() {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass DummyPrinter : Printer() {\\n    override fun printDocument(document: String) {\\n        throw UnsupportedOperationException(\\\"Dummy printer cannot print documents.\\\")\\n    }\\n}\\n\\ninterface Printable {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printable {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass DummyPrinter : Printable {\\n    override fun printDocument(document: String) {\\n        throw UnsupportedOperationException(\\\"Dummy printer cannot print documents.\\\")\\n    }\\n}\\n\\nfun print(printer: Printable, document: String) {\\n    printer.printDocument(document)\\n}\\n\\nfun main() {\\n    val dummy: Printable = DummyPrinter()\\n    print(dummy, \\\"Test\\\")\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the DummyPrinter class does not fulfill the contract of the Printer class, as it throws an exception when trying to print a document. To comply with this principle, I introduced an interface called Printable that both NetworkPrinter and DummyPrinter implement. This way, both classes can be used interchangeably without violating the expected behavior.\"}"
    },
    {
      "input": "open class Logger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    open fun log(message: String) {\n        println(\"[BASE LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentCounterLogger : Logger() {\n    private var fakeMessagesLogged: Int = 0\n\n    override fun log(message: String) {\n        fakeMessagesLogged++\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "SRP",
      "explanation": "{\"violation_type\":\"Single Responsibility Principle\",\"refactored_code\":\"open class Logger {\\n    private var messagesLogged: Int = 0\\n\\n    fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    open fun log(message: String) {\\n        println(\\\"[BASE LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\ninterface Loggable {\\n    fun log(message: String)\\n}\\n\\nclass ConsoleLogger : Logger(), Loggable {\\n    override fun log(message: String) {\\n        super.log(message)\\n    }\\n}\\n\\nclass SilentLogger : Loggable {\\n    private var fakeMessagesLogged: Int = 0\\n\\n    override fun log(message: String) {\\n        fakeMessagesLogged++\\n    }\\n}\",\"explanation\":\"The original Logger class violates the Single Responsibility Principle because it combines the responsibilities of logging messages and counting the number of messages logged. To refactor it, I introduced an interface 'Loggable' to separate the logging functionality from the counting functionality. The 'ConsoleLogger' class extends 'Logger' to handle console logging, while 'SilentLogger' implements 'Loggable' to handle silent logging without counting messages.\"}"
    },
    {
      "input": "import java.util.concurrent.CopyOnWriteArrayList\n\nopen class Logger {\n    open fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger() {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "output": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\nclass SafeLogger : Logger {\n    override fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "Single Responsibility Principle",
      "explanation": "The original code violates the Single Responsibility Principle because the Logger class is responsible for both logging messages and providing a thread-safe logging mechanism. By separating the logging functionality into different classes (SafeLogger and NonThreadSafeLogger), each class now has a single responsibility."
    },
    {
      "input": "open class Shape {\n    open fun area(): Double {\n        println(\"Base Shape Area: 0.0\")\n        return 0.0\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        println(\"Null Shape Area: ${Double.NaN} (Violation)\")\n        return Double.NaN\n    }\n}",
      "output": "open class Shape {\n    open fun area(): Double {\n        throw UnsupportedOperationException(\"Area not implemented\")\n    }\n}\n\nclass Circle(private val radius: Double) : Shape() {\n    override fun area(): Double {\n        return Math.PI  radius  radius\n    }\n}\n\nclass Square(private val side: Double) : Shape() {\n    override fun area(): Double {\n        return side  side\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        throw UnsupportedOperationException(\"NullShape does not have an area\")\n    }\n}",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the NullShape class returns Double.NaN for the area, which is not a valid area value and can lead to unexpected behavior when substituting it for a Shape. The refactored code ensures that all subclasses of Shape provide a valid implementation of the area method, throwing an exception for NullShape instead."
    },
    {
      "input": "import java.io.File\n\nopen class FileProcessor {\n    open fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"Base: Checking status for $filePath - Found.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"Base: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    open fun processFile(filePath: String) {\n        println(\"Base: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n            println(\"Base: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"Base: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor() {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnly: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"ReadOnly: Attempted to process file $filePath.\")\n        throw UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "KOTLIN",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"import java.io.File\\n\\nopen class FileProcessor {\\n    open fun getStatus(filePath: String): String {\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            println(\\\"Base: Checking status for \\$filePath - Found.\\\")\\n            \\\"Ready for processing\\\"\\n        }\\n        else {\\n            println(\\\"Base: Checking status for \\$filePath - Not Found.\\\")\\n            \\\"File not found\\\"\\n        }\\n    }\\n\\n    open fun processFile(filePath: String) {\\n        println(\\\"Base: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"Base: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"Base: File \\$filePath processed successfully.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor : FileProcessor() {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"ReadOnly: Checking status for \\$filePath - Read-only access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Available (Read-only)\\\"\\n        }\\n        else {\\n            \\\"File not found (Read-only)\\\"\\n        }\\n    }\\n\\n    override fun processFile(filePath: String) {\\n        throw UnsupportedOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\")\\n    }\\n}\\n\\nclass WritableFileProcessor : FileProcessor() {\\n    override fun processFile(filePath: String) {\\n        println(\\\"Writable: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"Writable: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"Writable: File \\$filePath processed successfully.\\\")\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the `ReadOnlyFileProcessor` class cannot be used interchangeably with the `FileProcessor` class without causing unexpected behavior (it throws an exception when trying to process a file). To comply with this principle, I created a new class `WritableFileProcessor` that handles file processing, allowing `ReadOnlyFileProcessor` to only handle read operations without throwing exceptions when its methods are called.\"}"
    },
    {
      "input": "class Bird { public virtual void Fly() { } } class Ostrich : Bird { public override void Fly() { throw new Exception(); } }",
      "output": "abstract class Bird { public abstract void Fly(); } class FlyingBird : Bird { public override void Fly() { / Implementation for flying birds / } } class Ostrich : Bird { public override void Fly() { throw new InvalidOperationException(\"Ostriches cannot fly.\"); } }",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the Ostrich class cannot fulfill the contract of the Bird class, which expects all birds to be able to fly. By introducing an abstract class for flying birds, we separate the flying behavior from the Bird class, allowing Ostrich to inherit from Bird without needing to implement the Fly method."
    },
    {
      "input": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width * Height; } } class Square : Rectangle { public override int Width { get => base.Width; set { base.Width = value; base.Height = value; } } public override int Height { get => base.Height; set { base.Width = value; base.Height = value; } } }",
      "output": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width  Height; } } class Square : IShape { private int side; public Square(int side) { this.side = side; } public int Width { get => side; set => side = value; } public int Height { get => side; set => side = value; } public int Area() { return side  side; } } interface IShape { int Width { get; set; } int Height { get; set; } int Area(); }",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because a Square is a specific type of Rectangle, but it does not behave like a Rectangle when it comes to setting Width and Height. The refactored code introduces an interface (IShape) that both Rectangle and Square implement, ensuring that both classes can be used interchangeably without breaking the expected behavior."
    },
    {
      "input": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
      "output": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotSupportedException(\"Fish do not make sounds.\"); } }",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. In this case, the Fish class overrides the MakeSound method but throws a NotImplementedException, which violates this principle. Instead, we can throw a NotSupportedException to indicate that Fish do not make sounds, making it clear that this behavior is not applicable."
    },
    {
      "input": "class Payment { public virtual void Pay() { } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
      "output": "class Payment { public virtual void Pay() { } } class PaidPayment : Payment { public override void Pay() { / Implementation for paid payment / } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(\"Free payment does not support payment processing.\"); } }",
      "level": "EASY",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the FreePayment class does not fulfill the contract of the Payment class by throwing an exception when Pay is called. This means that FreePayment cannot be used interchangeably with Payment without causing issues. The refactored code introduces a clearer distinction between paid and free payments, ensuring that each class adheres to its intended behavior."
    },
    {
      "input": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
      "output": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } } class WritableFileWriter : FileWriter { public override void Write(string data) { // Implementation for writing data } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the ReadOnlyFileWriter class cannot be used interchangeably with its base class FileWriter without causing unexpected behavior (throwing an exception). To comply with this principle, we can create a separate class WritableFileWriter that extends FileWriter for writing operations, allowing ReadOnlyFileWriter to remain a distinct type without altering the expected behavior of FileWriter."
    },
    {
      "input": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new NotImplementedException(); } }",
      "output": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new InvalidOperationException(\"Bicycles do not have engines.\"); } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. In this case, the Bicycle class overrides StartEngine() but throws a NotImplementedException, which violates this principle. The refactored code throws an InvalidOperationException instead, providing a clearer indication that the operation is not applicable for a Bicycle."
    },
    {
      "input": "class Document { public virtual void Print() { } } class DigitalDocument : Document { public override void Print() { throw new NotSupportedException(); } }",
      "output": "class Document { public virtual void Print() { } } class PrintableDocument : Document { public override void Print() { / Implementation for printing / } } class DigitalDocument : Document { // DigitalDocument does not implement Print method, as it is not printable }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. In the original code, the DigitalDocument class overrides the Print method but throws a NotSupportedException, which violates this principle. The refactored code introduces a new class, PrintableDocument, that implements the Print method, allowing DigitalDocument to exist without needing to implement Print."
    },
    {
      "input": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Stop() { throw new NotSupportedException(); } }",
      "output": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Start() { / Implementation for one-shot timer / } public override void Stop() { throw new NotSupportedException(); } } class ITimer { void Start(); void Stop(); } class OneShotTimer : ITimer { public void Start() { / Implementation for one-shot timer / } public void Stop() { throw new NotSupportedException(); } }",
      "level": "MODERATE",
      "language": "C#",
      "violation": "Liskov Substitution Principle",
      "explanation": "The original code violates the Liskov Substitution Principle because the derived class OneShotTimer does not fully support the behavior expected from the base class Timer. Specifically, it throws an exception when Stop() is called, which is not expected behavior for a Timer. To refactor, we can introduce an interface ITimer that defines the Start and Stop methods, allowing OneShotTimer to implement only the methods it supports without violating the principle."
    },
    {
      "input": "using System;\nusing System.IO;\n\nclass FileProcessor\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\n            return \"Ready for processing\";\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n\n    public virtual void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n\n    public override void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\n        throw new InvalidOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"using System;\\nusing System.IO;\\n\\ninterface IFileProcessor\\n{\\n    string GetStatus(string filePath);\\n    void ProcessFile(string filePath);\\n}\\n\\nclass FileProcessor : IFileProcessor\\n{\\n    public virtual string GetStatus(string filePath)\\n    {\\n        if (File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\\n            return \\\"Ready for processing\\\";\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\\n            return \\\"File not found\\\";\\n        }\\n    }\\n\\n    public virtual void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\\n        if (!File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\\n            return;\\n        }\\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor : IFileProcessor\\n{\\n    public string GetStatus(string filePath)\\n    {\\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\\n        if (File.Exists(filePath))\\n        {\\n            return \\\"Available (Read-only)\\\";\\n        }\\n        else\\n        {\\n            return \\\"File not found (Read-only)\\\";\\n        }\\n    }\\n\\n    public void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\\n        throw new InvalidOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the derived class `ReadOnlyFileProcessor` does not fulfill the expectations set by the base class `FileProcessor`. Specifically, it throws an exception when `ProcessFile` is called, which is not the expected behavior of a file processor. By introducing an interface `IFileProcessor`, we ensure that both `FileProcessor` and `ReadOnlyFileProcessor` implement the same methods without violating the principle.\"}"
    },
    {
      "input": "using System;\n\nclass Account\n{\n    public decimal Balance { get; protected set; } = 1000m;\n\n    public virtual void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (Balance >= amount)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : Account\n{\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public override void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount <= MaxWithdrawalLimit)\n        {\n            if (Balance >= amount)\n            {\n                Balance -= amount;\n                Console.WriteLine($\"Limited (Small): Successfully withdrew {amount}. New Balance: {Balance}\");\n            }\n            else\n            {\n                 Console.WriteLine($\"Limited (Small): Insufficient funds for withdrawal ({amount}). Balance: {Balance}\");\n            }\n        }\n        else\n        {\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\n        }\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"using System;\\n\\ninterface IAccount\\n{\\n    decimal Balance { get; }\\n    void Withdraw(decimal amount);\\n}\\n\\nclass Account : IAccount\\n{\\n    public decimal Balance { get; protected set; } = 1000m;\\n\\n    public virtual void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (Balance >= amount)\\n        {\\n            Balance -= amount;\\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\\n        }\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : Account\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public override void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount <= MaxWithdrawalLimit)\\n        {\\n            base.Withdraw(amount);\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\\n        }\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle because the derived class 'LimitedWithdrawalAccount' alters the expected behavior of the 'Withdraw' method from the base class 'Account'. Instead of simply extending the functionality, it introduces additional logic that could lead to unexpected behavior when substituting 'LimitedWithdrawalAccount' for 'Account'. The refactored code introduces an interface 'IAccount' to ensure that all account types adhere to a consistent contract, allowing for proper substitution without altering expected behaviors.\"}"
    },
    {
      "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "LSP",
      "explanation": "{\"violation_type\":\"Liskov Substitution Principle\",\"refactored_code\":\"using System;\\n\\nclass Logger\\n{\\n    public virtual void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass LoggerWithFixedTimestamp : Logger\\n{\\n    private readonly DateTime _creationTime;\\n\\n    public LoggerWithFixedTimestamp(DateTime creationTime)\\n    {\\n        _creationTime = creationTime;\\n    }\\n\\n    public override void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original LoggerWithIncorrectTimestamp class violates the Liskov Substitution Principle because it changes the behavior of the base class Logger in a way that could lead to unexpected results when substituting one for the other. Specifically, it uses a fixed timestamp instead of the current time, which can lead to confusion. The refactored code introduces a constructor that allows the creation time to be set when the LoggerWithFixedTimestamp is instantiated, ensuring that it behaves consistently with the expectations of the Logger class.\"}"
    },
    {
      "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class CollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : CollectionProcessor\n{\n    public override void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ViolatingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n             var item = data[i];\n             Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\n             System.Threading.Thread.Sleep(10);\n\n             if (item.StartsWith(\"B\"))\n             {\n                 Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\n                 data.RemoveAt(i);\n                 i--;\n             }\n        }\n        Console.WriteLine(\"[ViolatingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n\n",
      "output": "",
      "level": "HARD",
      "language": "C#",
      "violation": "SRP",
      "explanation": "{\"violation_type\":\"Single Responsibility Principle\",\"refactored_code\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic class CollectionProcessor\\n{\\n    public virtual void ProcessCollection(List<string> data)\\n    {\\n        Console.WriteLine(\\\"[BaseProcessor] Starting processing...\\\");\\n        foreach (var item in data)\\n        {\\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\\n            System.Threading.Thread.Sleep(10);\\n        }\\n        Console.WriteLine(\\\"[BaseProcessor] Processing finished.\\\");\\n    }\\n}\\n\\npublic class ModifyingCollectionProcessor : CollectionProcessor\\n{\\n    private readonly IItemModifier _itemModifier;\\n\\n    public ModifyingCollectionProcessor(IItemModifier itemModifier)\\n    {\\n        _itemModifier = itemModifier;\\n    }\\n\\n    public override void ProcessCollection(List<string> data)\\n    {\\n        Console.WriteLine(\\\"[ViolatingProcessor] Starting processing...\\\");\\n        for (int i = 0; i < data.Count; i++)\\n        {\\n            var item = data[i];\\n            Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\\n            System.Threading.Thread.Sleep(10);\\n\\n            if (_itemModifier.ShouldRemove(item))\\n            {\\n                Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\\n                data.RemoveAt(i);\\n                i--;\\n            }\\n        }\\n        Console.WriteLine(\\\"[ViolatingProcessor] Processing finished. List size after modification: \\\" + data.Count);\\n    }\\n}\\n\\npublic interface IItemModifier\\n{\\n    bool ShouldRemove(string item);\\n}\\n\\npublic class BItemModifier : IItemModifier\\n{\\n    public bool ShouldRemove(string item)\\n    {\\n        return item.StartsWith(\\\"B\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle because the `ModifyingCollectionProcessor` class is responsible for both processing the collection and modifying it by removing items. This can lead to difficulties in maintaining and testing the code. The refactored code introduces an interface `IItemModifier` that encapsulates the logic for determining whether an item should be removed. This separates the concerns of processing and modifying, allowing each class to have a single responsibility.\"}"
    }
  ]
}