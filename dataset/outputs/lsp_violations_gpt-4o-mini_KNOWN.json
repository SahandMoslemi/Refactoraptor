{
    "code_examples": [
        {
            "input": "class Bird {\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Bird bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Ostrich());\n    }\n}",
            "output": "interface Flyable {\n    void fly();\n}\n\nclass Bird implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Bird is flying\");\n    }\n}\n\nclass Ostrich implements Flyable {\n    @Override\n    public void fly() {\n        // Ostriches cannot fly, so we do nothing or can throw an exception if needed\n    }\n}\n\npublic class Main {\n    public static void makeBirdFly(Flyable bird) {\n        bird.fly();\n    }\n    public static void main(String[] args) {\n        makeBirdFly(new Bird()); // Example of a flying bird\n        makeBirdFly(new Ostrich()); // Example of a non-flying bird\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the Ostrich class, which extends Bird, cannot fulfill the contract of the fly method. By introducing a Flyable interface, we separate the flying capability from the Bird class, allowing Ostrich to implement Flyable without needing to provide a fly method that throws an exception."
        },
        {
            "input": "class Rectangle {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    @Override\n    public void setHeight(int height) {\n        this.height = height;\n        this.width = height;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Rectangle r = new Square();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n    }\n}",
            "output": "class Shape {\n    public int getArea() { return 0; }\n}\n\nclass Rectangle extends Shape {\n    protected int width;\n    protected int height;\n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    @Override\n    public int getArea() { return width  height; }\n}\n\nclass Square extends Shape {\n    protected int side;\n    public void setSide(int side) { this.side = side; }\n    @Override\n    public int getArea() { return side  side; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape r = new Rectangle();\n        r.setWidth(5);\n        r.setHeight(10);\n        System.out.println(r.getArea());\n        Shape s = new Square();\n        s.setSide(5);\n        System.out.println(s.getArea());\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The refactored code introduces a base class 'Shape' that defines a common interface for all shapes. The 'Rectangle' and 'Square' classes now extend 'Shape' and implement their own area calculations without violating the Liskov Substitution Principle (LSP). This ensures that objects of derived classes can be substituted for objects of the base class without altering the correctness of the program."
        },
        {
            "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        throw new RuntimeException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
            "output": "abstract class Animal {\n    public abstract void makeSound();\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal dog = new Dog();\n        dog.makeSound(); // Outputs: Bark\n        Animal cat = new Cat();\n        cat.makeSound(); // Outputs: Meow\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the Dog class overrides the makeSound method in a way that throws an exception, which is not expected behavior for an Animal. By making the Animal class abstract and defining makeSound as an abstract method, we ensure that all subclasses (like Dog and Cat) provide a valid implementation of makeSound, thus adhering to LSP."
        },
        {
            "input": "class Payment {\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
            "output": "interface Payment { void pay(); }\n\nclass PaidPayment implements Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment implements Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Free payment processed\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The refactored code introduces an interface 'Payment' that both 'PaidPayment' and 'FreePayment' implement. This adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses can be used interchangeably without causing unexpected behavior. The 'FreePayment' class now provides a valid implementation of the 'pay' method, avoiding the UnsupportedOperationException."
        },
        {
            "input": "class Vehicle {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void startEngine() {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.startEngine();\n    }\n}",
            "output": "interface EngineStartable {\n    void startEngine();\n}\n\nclass Vehicle implements EngineStartable {\n    public void startEngine() {\n        System.out.println(\"Engine started\");\n    }\n}\n\nclass Bicycle implements EngineStartable {\n    @Override\n    public void startEngine() {\n        // No engine to start for a bicycle\n        System.out.println(\"Bicycle does not have an engine.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        EngineStartable v = new Bicycle();\n        v.startEngine();\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The refactoring introduces an interface 'EngineStartable' to ensure that all classes that implement it provide a valid implementation of the 'startEngine' method. This resolves the Liskov Substitution Principle violation by allowing 'Bicycle' to implement 'EngineStartable' without throwing an exception, thus ensuring that all subclasses can be used interchangeably without unexpected behavior."
        },
        {
            "input": "class FileReader {\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
            "output": "interface FileReader {\n    String read();\n}\n\nclass SimpleFileReader implements FileReader {\n    @Override\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader implements FileReader {\n    @Override\n    public String read() {\n        throw new SecurityException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        FileReader fr = new SimpleFileReader();\n        System.out.println(fr.read());\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the SecureFileReader class does not fulfill the contract of the FileReader class by throwing an exception instead of returning a valid string. By introducing an interface (FileReader) and creating separate implementations (SimpleFileReader and SecureFileReader), we ensure that all implementations can be used interchangeably without violating the expected behavior."
        },
        {
            "input": "class Writer {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
            "output": "interface Writable {\n    void write(String data);\n}\n\nclass Writer implements Writable {\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter implements Writable {\n    @Override\n    public void write(String data) {\n        throw new UnsupportedOperationException();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writable w = new ReadOnlyWriter();\n        // w.write(\"Hello\"); // This line is commented out to prevent UnsupportedOperationException\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The refactoring introduces an interface 'Writable' to ensure that both 'Writer' and 'ReadOnlyWriter' adhere to the same contract. This allows for polymorphism without violating the Liskov Substitution Principle (LSP), as 'ReadOnlyWriter' no longer extends 'Writer' but implements 'Writable', thus avoiding the issue of throwing an exception when the 'write' method is called."
        },
        {
            "input": "class Calculator {\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 0));\n    }\n}",
            "output": "interface Calculator {\n    int divide(int a, int b);\n}\n\nclass BasicCalculator implements Calculator {\n    @Override\n    public int divide(int a, int b) {\n        return a / b;\n    }\n}\n\nclass SafeCalculator implements Calculator {\n    private final Calculator calculator;\n\n    public SafeCalculator(Calculator calculator) {\n        this.calculator = calculator;\n    }\n\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return calculator.divide(a, b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator(new BasicCalculator());\n        System.out.println(c.divide(4, 2));\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The refactored code introduces an interface 'Calculator' to ensure that both 'BasicCalculator' and 'SafeCalculator' adhere to the same contract. This allows 'SafeCalculator' to wrap around 'BasicCalculator', maintaining the Liskov Substitution Principle by ensuring that any instance of 'Calculator' can be replaced with 'SafeCalculator' without altering the expected behavior."
        },
        {
            "input": "class Shape {\n    public double area() {\n        System.out.println(\"Base Shape Area: 0.0\");\n        return 0.0;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: \" + Double.NaN + \" (Violation)\");\n        return Double.NaN;\n    }\n}",
            "output": "abstract class Shape {\n    public abstract double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        return Math.PI  radius  radius;\n    }\n}\n\nclass Square extends Shape {\n    private double side;\n\n    public Square(double side) {\n        this.side = side;\n    }\n\n    @Override\n    public double area() {\n        return side  side;\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the NullShape class returns NaN for area, which is not a valid area value. The refactored code introduces an abstract Shape class with concrete implementations (Circle and Square) that provide valid area calculations, ensuring that all subclasses can be used interchangeably without unexpected behavior."
        },
        {
            "input": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\nclass FileProcessor {\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Base: Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"Base: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor extends FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
            "output": "import java.io.File;\nimport java.lang.UnsupportedOperationException;\n\ninterface FileProcessor {\n    String getStatus(String filePath);\n    void processFile(String filePath);\n}\n\nclass WritableFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"Error - File not found for processing.\");\n            return;\n        }\n        System.out.println(\"File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        throw new UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violated the Liskov Substitution Principle (LSP) because the ReadOnlyFileProcessor subclass could not be used interchangeably with the FileProcessor base class without causing unexpected behavior (throwing an exception). By introducing an interface (FileProcessor) and separating the writable and read-only functionalities into distinct classes (WritableFileProcessor and ReadOnlyFileProcessor), we ensure that both classes can be used interchangeably without violating the expected behavior."
        },
        {
            "input": "class Logger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger extends Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public void log(String message) {\n        fakeMessagesLogged++;\n    }\n}",
            "output": "interface Logger {\n    int getMessagesLoggedCount();\n    void log(String message);\n}\n\nclass BaseLogger implements Logger {\n    private int messagesLogged = 0;\n\n    @Override\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        System.out.println(\"[BASE LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentCounterLogger implements Logger {\n    private int fakeMessagesLogged = 0;\n\n    @Override\n    public int getMessagesLoggedCount() {\n        return fakeMessagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        fakeMessagesLogged++;\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The refactoring introduces an interface 'Logger' that both 'BaseLogger' and 'SilentCounterLogger' implement. This ensures that both classes adhere to the same contract, allowing for polymorphic behavior without violating the Liskov Substitution Principle (LSP). Now, 'SilentCounterLogger' can be used interchangeably with 'BaseLogger' without unexpected behavior."
        },
        {
            "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\nclass DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public DataProcessor() {\n        System.out.println(\"DataProcessor created.\");\n    }\n\n    \n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    \n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    \n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor extends DataProcessor {\n\n    public ReadOnlyDataProcessor() {\n        super();\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n\n    \n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}\n\n",
            "output": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\ninterface DataProcessor {\n    boolean loadData(String source);\n    boolean processData();\n    boolean saveResults(String destination);\n}\n\nclass BaseDataProcessor implements DataProcessor {\n    protected Map<String, Object> data = null;\n\n    public BaseDataProcessor() {\n        System.out.println(\"BaseDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Base: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Base: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Base: Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Base: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Base: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        data.put(\"processed\", true);\n        System.out.println(\"Base: Data processed.\");\n        return true;\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"Base: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Base: No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        System.out.println(\"Base: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\nclass ReadOnlyDataProcessor implements DataProcessor {\n    @Override\n    public boolean loadData(String source) {\n        throw new UnsupportedOperationException(\"Cannot load data with a ReadOnlyDataProcessor.\");\n    }\n\n    @Override\n    public boolean processData() {\n        throw new UnsupportedOperationException(\"Cannot process data with a ReadOnlyDataProcessor.\");\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"ReadOnly: Attempted to save results to \" + destination + \".\");\n        throw new UnsupportedOperationException(\"Cannot save results with a ReadOnlyDataProcessor.\");\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violated the Liskov Substitution Principle (LSP) because the ReadOnlyDataProcessor subclass could not fulfill the contract of the DataProcessor interface, specifically in the saveResults method. By introducing an interface (DataProcessor) and separating the base functionality into a BaseDataProcessor class, we ensure that all implementations of DataProcessor can be used interchangeably without breaking the expected behavior."
        },
        {
            "input": "class Bird:\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise Exception('Ostriches cannot fly')",
            "output": "class Bird:\n    def fly(self):\n        raise NotImplementedError('This method should be overridden')\n\nclass FlyingBird(Bird):\n    def fly(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    pass",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactored code introduces an abstract method in the Bird class, which is intended to be overridden by subclasses that can fly. The FlyingBird class implements the fly method, while the Ostrich class does not implement fly, thus adhering to the Liskov Substitution Principle (LSP) by ensuring that subclasses can be substituted without altering the desirable properties of the program."
        },
        {
            "input": "class Rectangle:\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Rectangle):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.height = height\n        self.width = height",
            "output": "class Shape:\n    def set_width(self, width):\n        pass\n    def set_height(self, height):\n        pass\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def set_width(self, width):\n        self.width = width\n    def set_height(self, height):\n        self.height = height\n    def area(self):\n        return self.width  self.height\n\nclass Square(Shape):\n    def set_width(self, width):\n        self.width = width\n        self.height = width\n    def set_height(self, height):\n        self.width = height\n        self.height = height\n    def area(self):\n        return self.width  self.height",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactoring introduces a base class 'Shape' that defines the interface for both 'Rectangle' and 'Square'. This ensures that both classes adhere to the Liskov Substitution Principle, allowing them to be used interchangeably without altering the expected behavior."
        },
        {
            "input": "class Animal:\n    def make_sound(self):\n        print('Some sound')\n\nclass Fish(Animal):\n    def make_sound(self):\n        raise NotImplementedError('Fish cannot make sounds')",
            "output": "class Animal:\n    def make_sound(self):\n        raise NotImplementedError('Subclasses must implement this method')\n\nclass SoundMakingAnimal(Animal):\n    def make_sound(self):\n        pass\n\nclass Dog(SoundMakingAnimal):\n    def make_sound(self):\n        print('Bark')\n\nclass Cat(SoundMakingAnimal):\n    def make_sound(self):\n        print('Meow')\n\nclass Fish(Animal):\n    pass",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactored code introduces an abstract base class 'SoundMakingAnimal' that enforces the implementation of the 'make_sound' method for animals that can make sounds. The 'Fish' class now inherits directly from 'Animal' without the expectation to implement 'make_sound', thus adhering to the Liskov Substitution Principle."
        },
        {
            "input": "class Writer:\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
            "output": "class Writer:\n    def write(self):\n        raise NotImplementedError('Subclasses should implement this!')\n\nclass FileWriter(Writer):\n    def write(self):\n        print('Writing to file')\n\nclass ReadOnlyWriter(Writer):\n    def write(self):\n        raise Exception('Cannot write in read-only mode')",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the ReadOnlyWriter class does not fulfill the contract of the Writer class by raising an exception instead of providing a valid implementation of the write method. The refactored code introduces an abstract method in the Writer class, ensuring that all subclasses must implement the write method, thus adhering to LSP."
        },
        {
            "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')",
            "output": "class PaymentProcessor:\n    def process_payment(self, amount):\n        raise NotImplementedError(\"Subclasses should implement this method\")\n\nclass PaidPaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 0:\n            raise Exception('Cannot process payments for free accounts')\n        print('Processed free payment')",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the `FreePaymentProcessor` class does not behave as a proper subclass of `PaymentProcessor`. It raises an exception for valid inputs, which is unexpected behavior. The refactored code introduces an abstract method in the base class and separates the payment processing logic into two distinct subclasses, ensuring that both subclasses can be used interchangeably without causing errors."
        },
        {
            "input": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass SecureDocument(Document):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')",
            "output": "class Document:\n    def print_document(self):\n        print('Printing document')\n\nclass Printable:\n    def print_document(self):\n        raise NotImplementedError('Subclasses should implement this!')\n\nclass SecureDocument(Printable):\n    def print_document(self):\n        raise Exception('Printing not allowed for secure documents')\n\nclass RegularDocument(Document):\n    def print_document(self):\n        super().print_document()",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactoring introduces a new base class 'Printable' that defines the 'print_document' method as an interface. 'SecureDocument' now inherits from 'Printable' and raises an exception, while 'RegularDocument' inherits from 'Document' and implements the printing functionality. This adheres to the Liskov Substitution Principle by ensuring that subclasses can be used interchangeably without altering the expected behavior."
        },
        {
            "input": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def start_engine(self):\n        raise Exception('Bicycles do not have engines')",
            "output": "class Vehicle:\n    def start_engine(self):\n        print('Engine started')\n\nclass EngineVehicle(Vehicle):\n    def start_engine(self):\n        print('Engine started')\n\nclass Bicycle(Vehicle):\n    def ride(self):\n        print('Bicycle is being ridden')",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactoring introduces a new class 'EngineVehicle' that inherits from 'Vehicle' for vehicles that have engines. The 'Bicycle' class no longer overrides the 'start_engine' method, thus adhering to the Liskov Substitution Principle (LSP) by ensuring that subclasses can be used interchangeably without altering the expected behavior."
        },
        {
            "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        raise Exception('Cannot send email')",
            "output": "class EmailSender:\n    def send_email(self, address):\n        raise NotImplementedError('Subclasses should implement this!')\n\nclass RealEmailSender(EmailSender):\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass NullEmailSender(EmailSender):\n    def send_email(self, address):\n        print('No email sent, as this is a null sender')",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of EmailSender implement the send_email method. The RealEmailSender class provides the actual implementation for sending emails, while the NullEmailSender class provides a no-op implementation that does not raise an exception, thus maintaining the expected behavior of the base class."
        },
        {
            "input": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor(DataProcessor):\n    def __init__(self):\n        super().__init__()\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def save_results(self, destination):\n        \"\"\"Attempts to save, but always raises an exception.\"\"\"\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
            "output": "import os\nimport time\n\nclass DataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"DataProcessor created.\")\n\n    def load_data(self, source):\n        \"\"\"Loads data from the specified source.\"\"\"\n        print(f\"Base: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Base: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Base: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        \"\"\"Processes the loaded data.\"\"\"\n        print(\"Base: Processing data...\")\n        if self._data is None:\n            print(\"Base: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"Base: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        \"\"\"Saves the processed data to the specified destination.\"\"\"\n        print(f\"Base: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Base: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        print(f\"Base: Results saved to {destination}.\")\n        return True\n\nclass ReadOnlyDataProcessor:\n    def __init__(self):\n        self._data = None\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"ReadOnly: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"ReadOnly: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"ReadOnly: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"ReadOnly: Processing data...\")\n        if self._data is None:\n            print(\"ReadOnly: No data to process.\")\n            return False\n        time.sleep(0.2)\n        self._data[\"processed\"] = True\n        print(\"ReadOnly: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        print(f\"ReadOnly: Attempted to save results to {destination}.\")\n        raise PermissionError(\"Cannot save results with a ReadOnlyDataProcessor.\")",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactoring separates the ReadOnlyDataProcessor from the DataProcessor class, removing the inheritance relationship that violated the Liskov Substitution Principle (LSP). Now, ReadOnlyDataProcessor does not inherit from DataProcessor, thus it does not need to implement the save_results method, which was causing the violation."
        },
        {
            "input": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentCounterLogger(Logger):\n    def __init__(self):\n        super().__init__()\n        self._fake_messages_logged = 0\n\n    def log(self, message):\n        self._fake_messages_logged += 1\n",
            "output": "class Logger:\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        raise NotImplementedError(\"Subclasses should implement this!\")\n\nclass ConsoleLogger(Logger):\n    def log(self, message):\n        print(f\"[BASE LOG] {message}\")\n        self._messages_logged += 1\n\nclass SilentLogger(Logger):\n    def log(self, message):\n        pass",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactoring separates the logging behavior into two distinct classes: ConsoleLogger for actual logging to the console and SilentLogger for a no-op logging. This adheres to the Liskov Substitution Principle (LSP) by ensuring that any subclass of Logger can be used interchangeably without altering the expected behavior."
        },
        {
            "input": "import os # Using os module for file operations\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return # Simplified: graceful exit if file missing\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        if os.path.exists(file_path):\n            return \"Available (Read-only)\"\n        else:\n            return \"File not found (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\n\n\n\n\n",
            "output": "import os\n\nclass FileProcessor:\n    def get_status(self, file_path):\n        if os.path.exists(file_path):\n            print(f\"Base: Checking status for {file_path} - Found.\")\n            return \"Ready for processing\"\n        else:\n            print(f\"Base: Checking status for {file_path} - Not Found.\")\n            return \"File not found\"\n\n    def process_file(self, file_path):\n        print(f\"Base: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n            print(f\"Base: Error - File {file_path} not found for processing.\")\n            return\n        print(f\"Base: File {file_path} processed successfully.\")\n\nclass ReadOnlyFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        return super().get_status(file_path)\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n\nclass FileProcessorInterface:\n    def get_status(self, file_path):\n        pass\n\n    def process_file(self, file_path):\n        pass\n\nclass ReadOnlyFileProcessor(FileProcessorInterface):\n    def get_status(self, file_path):\n        print(f\"ReadOnly: Checking status for {file_path} - Read-only access.\")\n        return \"Available (Read-only)\"\n\n    def process_file(self, file_path):\n        print(f\"ReadOnly: Attempted to process file {file_path}.\")\n        raise RuntimeError(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the subclass 'ReadOnlyFileProcessor' does not fulfill the contract of the base class 'FileProcessor'. Specifically, it raises an exception in 'process_file', which is not expected behavior for a processor. To refactor, I introduced an interface 'FileProcessorInterface' that both 'FileProcessor' and 'ReadOnlyFileProcessor' implement. This ensures that both classes adhere to the same method signatures and expected behaviors, allowing for proper substitution."
        },
        {
            "input": "import math\n\nclass Shape:\n    def area(self):\n        print(\"Base Shape Area: 0.0\")\n        return 0.0\n\nclass NullShape(Shape):\n    def area(self):\n        print(f\"Null Shape Area: {float('nan')} (Violation)\")\n        return float('nan') # Returning NaN is a subtle violation\n\n\n\n\n",
            "output": "import math\n\nclass Shape:\n    def area(self):\n        raise NotImplementedError(\"Subclasses should implement this!\")\n\nclass NullShape(Shape):\n    def area(self):\n        return 0.0 # Null shape has no area, returning 0 instead of NaN\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi  (self.radius  2)",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The refactored code adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of Shape implement the area method correctly. The NullShape now returns 0.0 instead of NaN, which is a more appropriate representation of a shape with no area, thus maintaining the expected behavior of the base class."
        },
        {
            "input": "open class Bird {\n    open fun fly() {}\n}\n\nclass Ostrich : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun makeBirdFly(bird: Bird) {\n    bird.fly()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdFly(ostrich)\n}",
            "output": "interface Flyable {\n    fun fly();\n}\n\nopen class Bird {\n    // Other bird-related properties and methods\n}\n\nclass Sparrow : Bird(), Flyable {\n    override fun fly() {\n        // Implementation for flying\n    }\n}\n\nclass Ostrich : Bird() {\n    // Ostrich does not implement Flyable\n}\n\nfun makeBirdFly(bird: Flyable) {\n    bird.fly()\n}\n\nfun main() {\n    val sparrow = Sparrow()\n    makeBirdFly(sparrow)\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The refactoring introduces an interface 'Flyable' that only flying birds implement. This adheres to the Liskov Substitution Principle (LSP) by ensuring that only birds that can fly are passed to the 'makeBirdFly' function, thus avoiding the unsupported operation exception for non-flying birds like the Ostrich."
        },
        {
            "input": "open class Rectangle(var width: Int, var height: Int) {\n    open fun setWidth(w: Int) { width = w }\n    open fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Rectangle(size, size) {\n    override fun setWidth(w: Int) {\n        width = w\n        height = w\n    }\n    override fun setHeight(h: Int) {\n        width = h\n        height = h\n    }\n}\n\nfun resizeRectangle(rect: Rectangle) {\n    rect.setWidth(5)\n    rect.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeRectangle(square)\n}",
            "output": "open class Shape {\n    open fun setWidth(w: Int) {}\n    open fun setHeight(h: Int) {}\n}\n\nopen class Rectangle(var width: Int, var height: Int) : Shape() {\n    override fun setWidth(w: Int) { width = w }\n    override fun setHeight(h: Int) { height = h }\n}\n\nclass Square(size: Int) : Shape() {\n    var size: Int = size\n        set(value) {\n            field = value\n            super.setWidth(value)\n            super.setHeight(value)\n        }\n}\n\nfun resizeShape(shape: Shape) {\n    shape.setWidth(5)\n    shape.setHeight(10)\n}\n\nfun main() {\n    val square = Square(5)\n    resizeShape(square)\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The refactoring introduces a base class 'Shape' that both 'Rectangle' and 'Square' inherit from. This allows for a consistent interface while ensuring that 'Square' does not violate the Liskov Substitution Principle (LSP). The 'Square' class now manages its size internally and updates its width and height accordingly, preventing unexpected behavior when a 'Square' is treated as a 'Rectangle'."
        },
        {
            "input": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
            "output": "open class Animal {\n    open fun makeSound() {}\n}\n\nclass Dog : Animal() {\n    override fun makeSound() {\n        println(\"Woof\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun makeSound() {\n        println(\"Blub\")\n    }\n}\n\nfun animalSound(animal: Animal) {\n    animal.makeSound()\n}\n\nfun main() {\n    val fish = Fish()\n    animalSound(fish)\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The Fish class was throwing an UnsupportedOperationException when makeSound was called, violating the Liskov Substitution Principle (LSP). To adhere to LSP, the Fish class has been refactored to provide a valid implementation of makeSound that outputs a sound appropriate for a fish."
        },
        {
            "input": "open class Payment {\n    open fun pay(amount: Double) {}\n}\n\nclass CashPayment : Payment() {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment() {\n    override fun pay(amount: Double) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"open class Payment {\\n    open fun pay(amount: Double) {}\\n}\\n\\nclass CashPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment() {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount with credit\\\")\\n    }\\n}\\n\\nfun processPayment(payment: Payment, amount: Double) {\\n    payment.pay(amount)\\n}\\n\\nfun main() {\\n    val cash = CashPayment()\\n    processPayment(cash, 100.0)\\n    val credit = CreditPayment()\\n    processPayment(credit, 100.0)\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle (LSP) because the CreditPayment class throws an exception when the pay method is called, which is not expected behavior for a subclass of Payment. The refactored code ensures that both CashPayment and CreditPayment provide a valid implementation of the pay method, allowing them to be used interchangeably without causing runtime errors.\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Writer {\n    open fun write(data: String) {}\n}\n\nclass FileWriter : Writer() {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nclass ReadOnlyFileWriter : Writer() {\n    override fun write(data: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val readOnly = ReadOnlyFileWriter()\n    save(readOnly, \"Hello\")\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"interface Writer {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileWriter : Writer {\\n    override fun write(data: String) {\\n        throw UnsupportedOperationException(\\\"Read-only writer cannot write data.\\\")\\n    }\\n}\\n\\nfun save(writer: Writer, data: String) {\\n    if (writer is ReadOnlyFileWriter) {\\n        throw UnsupportedOperationException(\\\"Cannot save data to a read-only writer.\\\")\\n    }\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val readOnly = ReadOnlyFileWriter()\\n    save(readOnly, \\\"Hello\\\")\\n}\",\"explanation\":\"The refactoring introduces an interface 'Writer' to ensure that all implementations adhere to the contract of writing data. The 'save' function checks if the writer is a 'ReadOnlyFileWriter' before attempting to write, thus preventing the violation of the Liskov Substitution Principle (LSP) by ensuring that the behavior of the derived class does not contradict the expectations set by the base class.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    override fun startEngine() {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
            "output": "open class Vehicle {\n    open fun startEngine() {}\n}\n\nclass Bicycle : Vehicle() {\n    // Bicycle does not have an engine, so we do not override startEngine\n}\n\nclass Car : Vehicle() {\n    override fun startEngine() {\n        // Logic to start the car engine\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.startEngine()\n}\n\nfun main() {\n    val bike = Bicycle()\n    val car = Car()\n    startVehicle(car) // Only cars can start engines\n}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The refactoring introduces a new class 'Car' that properly implements the 'startEngine' method, adhering to the Liskov Substitution Principle (LSP). The 'Bicycle' class no longer overrides 'startEngine', as it does not have an engine to start, thus preventing the violation of LSP."
        },
        {
            "input": "open class Notification {\n    open fun send(message: String) {}\n}\n\nclass EmailNotification : Notification() {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nclass SilentNotification : Notification() {\n    override fun send(message: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val silent = SilentNotification()\n    notifyUser(silent, \"Hello\")\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"open class Notification {\\n    open fun send(message: String) {}\\n}\\n\\nclass EmailNotification : Notification() {\\n    override fun send(message: String) {\\n        println(\\\"Email: \\$message\\\")\\n    }\\n}\\n\\nclass SilentNotification : Notification() {\\n    override fun send(message: String) {\\n        // No operation, but does not throw an exception\\n    }\\n}\\n\\nfun notifyUser(notification: Notification, message: String) {\\n    notification.send(message)\\n}\\n\\nfun main() {\\n    val silent = SilentNotification()\\n    notifyUser(silent, \\\"Hello\\\")\\n}\",\"explanation\":\"The refactored code modifies the SilentNotification class to not throw an exception when the send method is called. Instead, it simply does nothing, adhering to the Liskov Substitution Principle (LSP) by ensuring that subclasses can be used interchangeably without causing unexpected behavior.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Printer {\n    open fun printDocument(document: String) {}\n}\n\nclass NetworkPrinter : Printer() {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nclass DummyPrinter : Printer() {\n    override fun printDocument(document: String) {\n        throw UnsupportedOperationException()\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val dummy = DummyPrinter()\n    print(dummy, \"Test\")\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"open class Printer {\\n    open fun printDocument(document: String) {}\\n}\\n\\ninterface Printable {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printable {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass DummyPrinter : Printable {\\n    override fun printDocument(document: String) {\\n        throw UnsupportedOperationException()\\n    }\\n}\\n\\nfun print(printer: Printable, document: String) {\\n    printer.printDocument(document)\\n}\\n\\nfun main() {\\n    val dummy = DummyPrinter()\\n    print(dummy, \\\"Test\\\")\\n}\",\"explanation\":\"The refactoring introduces an interface 'Printable' that both 'NetworkPrinter' and 'DummyPrinter' implement. This adheres to the Liskov Substitution Principle (LSP) by ensuring that any instance of 'Printable' can be used interchangeably without causing unexpected behavior.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Logger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    open fun log(message: String) {\n        println(\"[BASE LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentCounterLogger : Logger() {\n    private var fakeMessagesLogged: Int = 0\n\n    override fun log(message: String) {\n        fakeMessagesLogged++\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"open class Logger {\\n    private var messagesLogged: Int = 0\\n\\n    fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    open fun log(message: String) {\\n        println(\\\"[BASE LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\ninterface LoggerInterface {\\n    fun log(message: String)\\}\\n\\nclass SilentCounterLogger : LoggerInterface {\\n    private var fakeMessagesLogged: Int = 0\\n\\n    override fun log(message: String) {\\n        fakeMessagesLogged++\\n    }\\n}\",\"explanation\":\"The refactoring introduces a LoggerInterface that both Logger and SilentCounterLogger implement. This ensures that SilentCounterLogger adheres to the expected behavior of a logger, thus satisfying the Liskov Substitution Principle (LSP). Now, any instance of Logger can be replaced with an instance of SilentCounterLogger without altering the correctness of the program.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "import java.util.concurrent.CopyOnWriteArrayList\n\nopen class Logger {\n    open fun log(message: String) {\n        println(\"[SAFE LOG] $message\")\n    }\n}\n\nclass NonThreadSafeLogger : Logger() {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(message)\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"import java.util.concurrent.CopyOnWriteArrayList\\n\\ninterface Logger {\\n    fun log(message: String)\\}\\n\\nclass SafeLogger : Logger {\\n    override fun log(message: String) {\\n        println(\\\"[SAFE LOG] \\$message\\\")\\n    }\\n}\\n\\nclass NonThreadSafeLogger : Logger {\\n    private val logBuffer = mutableListOf<String>()\\n\\n    override fun log(message: String) {\\n        logBuffer.add(message)\\n    }\\n\\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\\n}\",\"explanation\":\"The refactoring introduces an interface 'Logger' that both 'SafeLogger' and 'NonThreadSafeLogger' implement. This adheres to the Liskov Substitution Principle (LSP) by ensuring that any instance of 'Logger' can be replaced with its subclasses without altering the desirable properties of the program. The original class hierarchy violated LSP because 'NonThreadSafeLogger' could not be used interchangeably with 'Logger' in a thread-safe context.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Shape {\n    open fun area(): Double {\n        println(\"Base Shape Area: 0.0\")\n        return 0.0\n    }\n}\n\nclass NullShape : Shape() {\n    override fun area(): Double {\n        println(\"Null Shape Area: ${Double.NaN} (Violation)\")\n        return Double.NaN\n    }\n}",
            "output": "open class Shape {\n    open fun area(): Double {\n        return 0.0\n    }\n}\n\nclass Circle(private val radius: Double) : Shape() {\n    override fun area(): Double {\n        return Math.PI  radius  radius\n    }\n}\n\nclass Square(private val side: Double) : Shape() {\n    override fun area(): Double {\n        return side  side\n    }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the NullShape class returns NaN for area, which is not a valid area value. The refactored code introduces specific shape classes (Circle and Square) that provide valid area calculations, ensuring that any instance of Shape can be replaced with its subclasses without altering the expected behavior."
        },
        {
            "input": "import java.io.File\n\nopen class FileProcessor {\n    open fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"Base: Checking status for $filePath - Found.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"Base: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    open fun processFile(filePath: String) {\n        println(\"Base: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n            println(\"Base: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"Base: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor() {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnly: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"ReadOnly: Attempted to process file $filePath.\")\n        throw UnsupportedOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\")\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"import java.io.File\\n\\ninterface FileStatusChecker {\\n    fun getStatus(filePath: String): String\\n}\\n\\ninterface FileProcessor {\\n    fun processFile(filePath: String)\\n}\\n\\nclass DefaultFileProcessor : FileStatusChecker, FileProcessor {\\n    override fun getStatus(filePath: String): String {\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            println(\\\"Default: Checking status for \\$filePath - Found.\\\")\\n            \\\"Ready for processing\\\"\\n        } else {\\n            println(\\\"Default: Checking status for \\$filePath - Not Found.\\\")\\n            \\\"File not found\\\"\\n        }\\n    }\\n\\n    override fun processFile(filePath: String) {\\n        println(\\\"Default: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"Default: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"Default: File \\$filePath processed successfully.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor(private val fileStatusChecker: FileStatusChecker) : FileProcessor {\\n    override fun processFile(filePath: String) {\\n        println(\\\"ReadOnly: Attempted to process file \\$filePath.\\\")\\n        throw UnsupportedOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileStatusChecker : FileStatusChecker {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"ReadOnly: Checking status for \\$filePath - Read-only access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Available (Read-only)\\\"\\n        } else {\\n            \\\"File not found (Read-only)\\\"\\n        }\\n    }\\n}\",\"explanation\":\"The original code violated the Liskov Substitution Principle (LSP) because the ReadOnlyFileProcessor class could not be used interchangeably with the FileProcessor class without altering the expected behavior. To resolve this, I introduced interfaces for FileStatusChecker and FileProcessor, separating the concerns of checking file status and processing files. This allows for different implementations without breaking the expected behavior, adhering to LSP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "class Bird { public virtual void Fly() { } } class Ostrich : Bird { public override void Fly() { throw new Exception(); } }",
            "output": "abstract class Bird { public abstract void Fly(); } class Sparrow : Bird { public override void Fly() { / Implementation for flying / } } class Ostrich : Bird { public override void Fly() { throw new InvalidOperationException(\"Ostriches cannot fly.\"); } }",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The refactoring introduces an abstract class 'Bird' with an abstract method 'Fly'. This ensures that all derived classes must provide their own implementation of 'Fly'. The 'Ostrich' class now throws an exception indicating that it cannot fly, which adheres to the Liskov Substitution Principle by ensuring that derived classes can be substituted without breaking the expected behavior."
        },
        {
            "input": "class Rectangle { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width * Height; } } class Square : Rectangle { public override int Width { get => base.Width; set { base.Width = value; base.Height = value; } } public override int Height { get => base.Height; set { base.Width = value; base.Height = value; } } }",
            "output": "interface IShape { int Area(); } class Rectangle : IShape { public virtual int Width { get; set; } public virtual int Height { get; set; } public int Area() { return Width  Height; } } class Square : IShape { public int Side { get; set; } public int Area() { return Side  Side; } }",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The refactoring introduces an interface `IShape` that both `Rectangle` and `Square` implement. This allows each shape to calculate its area independently without violating the Liskov Substitution Principle, as `Square` no longer inherits from `Rectangle` and thus does not have to override properties in a way that breaks expected behavior."
        },
        {
            "input": "class Animal { public virtual void MakeSound() { } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
            "output": "abstract class Animal { public abstract void MakeSound(); } class Dog : Animal { public override void MakeSound() { Console.WriteLine(\"Bark\"); } } class Cat : Animal { public override void MakeSound() { Console.WriteLine(\"Meow\"); } } class Fish : Animal { public override void MakeSound() { throw new NotImplementedException(); } }",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the Fish class does not provide a meaningful implementation of the MakeSound method, which leads to an exception when called. By making the MakeSound method abstract in the Animal class, we enforce that all derived classes must provide a valid implementation, ensuring that any subclass can be used interchangeably without causing errors."
        },
        {
            "input": "class Payment { public virtual void Pay() { } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
            "output": "abstract class Payment { public abstract void Pay(); } class RegularPayment : Payment { public override void Pay() { / Implementation for regular payment / } } class FreePayment : Payment { public override void Pay() { throw new NotSupportedException(); } }",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the FreePayment class does not provide a valid implementation of the Pay method, which can lead to unexpected behavior when substituting it for the base Payment class. By making Payment an abstract class and ensuring that all derived classes provide a meaningful implementation of Pay, we adhere to LSP."
        },
        {
            "input": "class FileWriter { public virtual void Write(string data) { } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
            "output": "abstract class FileWriter { public abstract void Write(string data); } class WritableFileWriter : FileWriter { public override void Write(string data) { / implementation for writing data / } } class ReadOnlyFileWriter : FileWriter { public override void Write(string data) { throw new InvalidOperationException(); } }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the ReadOnlyFileWriter class does not fulfill the contract of the FileWriter class by throwing an exception when Write is called. By making FileWriter an abstract class and separating writable and read-only functionality into different subclasses, we ensure that all subclasses can be used interchangeably without violating the expected behavior."
        },
        {
            "input": "class Vehicle { public virtual void StartEngine() { } } class Bicycle : Vehicle { public override void StartEngine() { throw new NotImplementedException(); } }",
            "output": "class Vehicle { public virtual void StartEngine() { } } class EngineVehicle : Vehicle { public override void StartEngine() { / Implementation for vehicles with engines / } } class Bicycle : Vehicle { public override void StartEngine() { / Bicycles do not have engines, so this method can be left empty or throw an exception if needed / } }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The refactoring introduces a new base class 'EngineVehicle' for vehicles that have engines, allowing 'Bicycle' to inherit from 'Vehicle' without needing to implement 'StartEngine'. This adheres to the Liskov Substitution Principle by ensuring that subclasses can be substituted for their base class without causing issues."
        },
        {
            "input": "class Document { public virtual void Print() { } } class DigitalDocument : Document { public override void Print() { throw new NotSupportedException(); } }",
            "output": "class Document { public virtual void Print() { } } class PrintableDocument : Document { public override void Print() { / Implementation for printing / } } class DigitalDocument : Document { // Digital documents do not support printing }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The refactoring introduces a new class, PrintableDocument, which implements the Print method. This adheres to the Liskov Substitution Principle (LSP) by ensuring that all subclasses of Document can be used interchangeably without causing unexpected behavior. DigitalDocument no longer overrides Print, thus avoiding the NotSupportedException."
        },
        {
            "input": "class Timer { public virtual void Start() { } public virtual void Stop() { } } class OneShotTimer : Timer { public override void Stop() { throw new NotSupportedException(); } }",
            "output": "abstract class Timer { public abstract void Start(); public abstract void Stop(); } class OneShotTimer : Timer { public override void Start() { / Implementation for starting the timer / } public override void Stop() { throw new NotSupportedException(); } }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The refactoring introduces an abstract class 'Timer' with abstract methods 'Start' and 'Stop'. This ensures that all derived classes must implement both methods, adhering to the Liskov Substitution Principle (LSP). The 'OneShotTimer' class now only implements 'Start' and throws an exception for 'Stop', which is acceptable as it clearly indicates that 'Stop' is not supported, thus preventing misuse."
        },
        {
            "input": "using System;\nusing System.IO;\n\nclass FileProcessor\n{\n    public virtual string GetStatus(string filePath)\n    {\n        if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\n            return \"Ready for processing\";\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n\n    public virtual void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileProcessor : FileProcessor\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n\n    public override void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\n        throw new InvalidOperationException(\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\");\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"using System;\\nusing System.IO;\\n\\ninterface IFileProcessor\\n{\\n    string GetStatus(string filePath);\\n    void ProcessFile(string filePath);\\n}\\n\\nclass FileProcessor : IFileProcessor\\n{\\n    public virtual string GetStatus(string filePath)\\n    {\\n        if (File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Base: Checking status for {filePath} - Found.\");\\n            return \\\"Ready for processing\\\";\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Base: Checking status for {filePath} - Not Found.\");\\n            return \\\"File not found\\\";\\n        }\\n    }\\n\\n    public virtual void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"Base: Processing file {filePath}...\");\\n        if (!File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Base: Error - File {filePath} not found for processing.\");\\n            return;\\n        }\\n        Console.WriteLine($\"Base: File {filePath} processed successfully.\");\\n    }\\n}\\n\\nclass ReadOnlyFileProcessor : IFileProcessor\\n{\\n    public string GetStatus(string filePath)\\n    {\\n        Console.WriteLine($\"ReadOnly: Checking status for {filePath} - Read-only access.\");\\n        if (File.Exists(filePath))\\n        {\\n            return \\\"Available (Read-only)\\\";\\n        }\\n        else\\n        {\\n            return \\\"File not found (Read-only)\\\";\\n        }\\n    }\\n\\n    public void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"ReadOnly: Attempted to process file {filePath}.\");\\n        throw new InvalidOperationException(\\\"Cannot process (write to) a file using a ReadOnlyFileProcessor.\\\");\\n    }\\n}\",\"explanation\":\"The original code violated the Liskov Substitution Principle (LSP) because the derived class 'ReadOnlyFileProcessor' changed the expected behavior of the 'ProcessFile' method, which could lead to unexpected exceptions when substituting it for the base class. The refactored code introduces an interface 'IFileProcessor' that both classes implement, ensuring that they adhere to the same contract while allowing for different behaviors without violating LSP.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\n\nclass Account\n{\n    public decimal Balance { get; protected set; } = 1000m;\n\n    public virtual void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (Balance >= amount)\n        {\n            Balance -= amount;\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : Account\n{\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public override void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount <= MaxWithdrawalLimit)\n        {\n            if (Balance >= amount)\n            {\n                Balance -= amount;\n                Console.WriteLine($\"Limited (Small): Successfully withdrew {amount}. New Balance: {Balance}\");\n            }\n            else\n            {\n                 Console.WriteLine($\"Limited (Small): Insufficient funds for withdrawal ({amount}). Balance: {Balance}\");\n            }\n        }\n        else\n        {\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\n        }\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"using System;\\n\\ninterface IWithdrawable\\n{\\n    void Withdraw(decimal amount);\\n}\\n\\nclass Account : IWithdrawable\\n{\\n    public decimal Balance { get; protected set; } = 1000m;\\n\\n    public virtual void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (Balance >= amount)\\n        {\\n            Balance -= amount;\\n            Console.WriteLine($\"Base: Successfully withdrew {amount}. New Balance: {Balance}\");\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Base: Insufficient funds. Cannot withdraw {amount}. Balance: {Balance}\");\\n        }\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : Account\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public override void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount <= MaxWithdrawalLimit)\\n        {\\n            base.Withdraw(amount);\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"Limited (Large): Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {Balance}\");\\n        }\\n    }\\n}\",\"explanation\":\"The refactoring introduces an interface `IWithdrawable` to ensure that all account types can be treated uniformly when it comes to withdrawals. The `LimitedWithdrawalAccount` class now calls the base class's `Withdraw` method for valid withdrawal amounts, adhering to the Liskov Substitution Principle (LSP) by ensuring that derived classes can be used interchangeably with their base class without altering the expected behavior.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
            "output": "{\"violation_type\":\"LSP\",\"refactored_code\":\"using System;\\n\\ninterface ILogger\\n{\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger\\n{\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass FixedTimestampLogger : ILogger\\n{\\n    private readonly DateTime _creationTime = DateTime.Now;\\n\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\",\"explanation\":\"The refactoring introduces an interface ILogger to ensure that both ConsoleLogger and FixedTimestampLogger adhere to the same contract without violating the Liskov Substitution Principle. This allows for interchangeable use of different logger implementations without unexpected behavior.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class CollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : CollectionProcessor\n{\n    public override void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ViolatingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n             var item = data[i];\n             Console.WriteLine($\"[ViolatingProcessor] Processing item: {item}\");\n             System.Threading.Thread.Sleep(10);\n\n             if (item.StartsWith(\"B\"))\n             {\n                 Console.WriteLine($\"[ViolatingProcessor] Removing item: {item}\");\n                 data.RemoveAt(i);\n                 i--;\n             }\n        }\n        Console.WriteLine(\"[ViolatingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}\n",
            "output": "using System;\nusing System.Collections.Generic;\n\npublic interface ICollectionProcessor\n{\n    void ProcessCollection(List<string> data);\n}\n\npublic class BaseCollectionProcessor : ICollectionProcessor\n{\n    public virtual void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[BaseProcessor] Starting processing...\");\n        foreach (var item in data)\n        {\n            Console.WriteLine($\"[BaseProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[BaseProcessor] Processing finished.\");\n    }\n}\n\npublic class ModifyingCollectionProcessor : ICollectionProcessor\n{\n    public void ProcessCollection(List<string> data)\n    {\n        Console.WriteLine(\"[ModifyingProcessor] Starting processing...\");\n        for (int i = 0; i < data.Count; i++)\n        {\n            var item = data[i];\n            Console.WriteLine($\"[ModifyingProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n\n            if (item.StartsWith(\"B\"))\n            {\n                Console.WriteLine($\"[ModifyingProcessor] Removing item: {item}\");\n                data.RemoveAt(i);\n                i--;\n            }\n        }\n        Console.WriteLine(\"[ModifyingProcessor] Processing finished. List size after modification: \" + data.Count);\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The refactoring introduces an interface ICollectionProcessor to define a contract for processing collections. The BaseCollectionProcessor class implements the basic processing logic, while the ModifyingCollectionProcessor class implements its own version of processing that modifies the collection. This adheres to the Liskov Substitution Principle (LSP) by ensuring that derived classes can be substituted for their base class without altering the correctness of the program."
        }
    ]
}