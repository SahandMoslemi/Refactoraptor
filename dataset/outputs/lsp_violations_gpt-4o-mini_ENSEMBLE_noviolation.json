{
    "code_examples": [
        {
            "input": "class Bird {\n    public void move() {\n        System.out.println(\"Bird is moving\");\n    }\n}\n\nclass Ostrich extends Bird {\n    @Override\n    public void move() {\n        System.out.println(\"Ostrich is running\");\n    }\n}\n\npublic class Main {\n    public static void makeBirdMove(Bird bird) {\n        bird.move();\n    }\n    public static void main(String[] args) {\n        makeBirdMove(new Ostrich());\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"class Bird {\\n    public void move() {\\n        System.out.println(\\\"Bird is moving\\\");\\n    }\\n}\\n\\ninterface Movable {\\n    void move();\\n}\\n\\nclass Ostrich extends Bird implements Movable {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Ostrich is running\\\");\\n    }\\n}\\n\\nclass Sparrow extends Bird implements Movable {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Sparrow is flying\\\");\\n    }\\n}\\n\\npublic class Main {\\n    public static void makeBirdMove(Movable bird) {\\n        bird.move();\\n    }\\n    public static void main(String[] args) {\\n        makeBirdMove(new Ostrich());\\n        makeBirdMove(new Sparrow());\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the Bird class is not designed to be a general interface for all types of birds that can move in different ways. By introducing a Movable interface, we ensure that only classes that need to implement movement behavior do so, adhering to the ISP. Additionally, this refactoring allows for more flexibility and extensibility, as new bird types can be added without modifying existing code. The code now also adheres better to the Open/Closed Principle (OCP) by allowing new bird types to be added without changing the existing movement logic.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":4465251166}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "abstract class Shape {\n    public abstract int getArea();\n}\n\nclass Rectangle extends Shape {\n    protected int width;\n    protected int height;\n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    @Override\n    public int getArea() { return width * height; }\n}\n\nclass Square extends Shape {\n    protected int side;\n    public Square(int side) {\n        this.side = side;\n    }\n    @Override\n    public int getArea() { return side * side; }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Shape s = new Square(5);\n        System.out.println(s.getArea());\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"public interface Shape {\\n    int getArea();\\n}\\n\\nclass Rectangle implements Shape {\\n    protected int width;\\n    protected int height;\\n    public Rectangle(int width, int height) {\\n        this.width = width;\\n        this.height = height;\\n    }\\n    @Override\\n    public int getArea() { return width  height; }\\n}\\n\\nclass Square implements Shape {\\n    protected int side;\\n    public Square(int side) {\\n        this.side = side;\\n    }\\n    @Override\\n    public int getArea() { return side  side; }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Shape s = new Square(5);\\n        System.out.println(s.getArea());\\n    }\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because it uses an abstract class for shapes, which can lead to unnecessary dependencies if more shape types are added. By changing the abstract class to an interface, we allow for more flexibility and adherence to the ISP. Additionally, the Open/Closed Principle (OCP) is better supported as new shapes can be added without modifying existing code. The other principles are not significantly violated, but the most impactful violation is ISP.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":7378302000}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "class Animal {\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.makeSound();\n    }\n}",
            "output": "interface Soundable {\n    void makeSound();\n}\n\nclass Animal implements Soundable {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bark\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Soundable a = new Dog();\n        a.makeSound();\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The refactored code introduces an interface `Soundable` to adhere to the Single Responsibility Principle (SRP). Each class now has a single responsibility: `Animal` and `Dog` implement the `makeSound` method, allowing for better separation of concerns. This also enhances the Open/Closed Principle (OCP) by allowing new animal types to be added without modifying existing code."
        },
        {
            "input": "abstract class Payment {\n    public abstract void pay();\n}\n\nclass PaidPayment extends Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"Payment processed\");\n    }\n}\n\nclass FreePayment extends Payment {\n    @Override\n    public void pay() {\n        System.out.println(\"No payment needed\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Payment p = new FreePayment();\n        p.pay();\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.util.ArrayList;\\nimport java.util.List;\\n\\ninterface PaymentStrategy {\\n    void pay();\\n}\\n\\nclass PaidPayment implements PaymentStrategy {\\n    @Override\\n    public void pay() {\\n        System.out.println(\\\"Payment processed\\\");\\n    }\\n}\\n\\nclass FreePayment implements PaymentStrategy {\\n    @Override\\n    public void pay() {\\n        System.out.println(\\\"No payment needed\\\");\\n    }\\n}\\n\\nclass PaymentProcessor {\\n    private List<PaymentStrategy> payments = new ArrayList<>();\\n\\n    public void addPayment(PaymentStrategy payment) {\\n        payments.add(payment);\\n    }\\n\\n    public void processPayments() {\\n        for (PaymentStrategy payment : payments) {\\n            payment.pay();\\n        }\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        PaymentProcessor processor = new PaymentProcessor();\\n        processor.addPayment(new FreePayment());\\n        processor.addPayment(new PaidPayment());\\n        processor.processPayments();\\n    }\\n}\",\"explanation\":\"The refactored code introduces the PaymentStrategy interface to adhere to the Open/Closed Principle (OCP) by allowing new payment types to be added without modifying existing code. It also separates the payment processing logic into a PaymentProcessor class, which adheres to the Single Responsibility Principle (SRP) by ensuring that each class has one reason to change. This design allows for better extensibility and maintainability.\"},\"violation_type\":\"OCP, SRP\",\"total_duration\":4995361333}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "OCP, SRP",
            "explanation": ""
        },
        {
            "input": "abstract class Vehicle {\n    public abstract void move();\n}\n\nclass Car extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Car is moving\");\n    }\n}\n\nclass Bicycle extends Vehicle {\n    @Override\n    public void move() {\n        System.out.println(\"Bicycle is moving\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Vehicle v = new Bicycle();\n        v.move();\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"java\\ninterface Movable {\\n    void move();\\n}\\n\\nabstract class Vehicle implements Movable {\\n    // Additional properties and methods can be added here\\n}\\n\\nclass Car extends Vehicle {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Car is moving\\\");\\n    }\\n}\\n\\nclass Bicycle extends Vehicle {\\n    @Override\\n    public void move() {\\n        System.out.println(\\\"Bicycle is moving\\\");\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Movable v = new Bicycle();\\n        v.move();\\n    }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the Vehicle class is not utilizing any interfaces, which could lead to unnecessary dependencies if more vehicle types are added. By introducing a Movable interface, we ensure that classes only implement the methods they need. This also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes. The refactored code maintains the same functionality while improving adherence to SOLID principles.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":5545131709}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "abstract class Reader {\n    public abstract String read();\n}\n\nclass FileReader extends Reader {\n    @Override\n    public String read() {\n        return \"Reading from file\";\n    }\n}\n\nclass SecureFileReader extends Reader {\n    @Override\n    public String read() {\n        return \"Reading from secure file\";\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Reader fr = new SecureFileReader();\n        System.out.println(fr.read());\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"java\\ninterface Reader {\\n    String read();\\n}\\n\\nclass FileReader implements Reader {\\n    @Override\\n    public String read() {\\n        return \\\"Reading from file\\\";\\n    }\\n}\\n\\nclass SecureFileReader implements Reader {\\n    @Override\\n    public String read() {\\n        return \\\"Reading from secure file\\\";\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Reader fr = new SecureFileReader();\\n        System.out.println(fr.read());\\n    }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because it uses an abstract class instead of an interface. By changing the abstract class to an interface, we allow for more flexible implementations without forcing subclasses to inherit unnecessary methods. This change also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes. The refactored code maintains the same functionality while improving adherence to SOLID principles.\",\"violation_type\":\"Interface Segregation Principle (ISP)\"},\"total_duration\":4104747917}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "abstract class Writer {\n    public abstract void write(String data);\n}\n\nclass FileWriter extends Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Writing: \" + data);\n    }\n}\n\nclass ReadOnlyWriter extends Writer {\n    @Override\n    public void write(String data) {\n        System.out.println(\"Cannot write: Read only\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Writer w = new ReadOnlyWriter();\n        w.write(\"Hello\");\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.util.ArrayList;\\nimport java.util.List;\\n\\ninterface Writer {\\n    void write(String data);\\n}\\n\\nclass FileWriter implements Writer {\\n    @Override\\n    public void write(String data) {\\n        System.out.println(\\\"Writing: \\\" + data);\\n    }\\n}\\n\\nclass ReadOnlyWriter implements Writer {\\n    @Override\\n    public void write(String data) {\\n        System.out.println(\\\"Cannot write: Read only\\\");\\n    }\\n}\\n\\nclass WriterManager {\\n    private List<Writer> writers = new ArrayList<>();\\n\\n    public void addWriter(Writer writer) {\\n        writers.add(writer);\\n    }\\n\\n    public void writeAll(String data) {\\n        for (Writer writer : writers) {\\n            writer.write(data);\\n        }\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        WriterManager manager = new WriterManager();\\n        manager.addWriter(new FileWriter());\\n        manager.addWriter(new ReadOnlyWriter());\\n        manager.writeAll(\\\"Hello\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Liskov Substitution Principle (LSP) because the ReadOnlyWriter class does not fulfill the contract of the Writer interface, which expects all writers to be able to write data. This leads to unexpected behavior when using a ReadOnlyWriter in place of a Writer. The refactored code introduces a WriterManager class that manages multiple writers and allows for writing data to all writers, thus adhering to the LSP. Additionally, the use of an interface instead of an abstract class allows for better flexibility and adherence to the Open/Closed Principle (OCP). The refactored code also maintains the Single Responsibility Principle (SRP) by separating the concerns of writing and managing writers.\"},\"violation_type\":\"Liskov Substitution Principle (LSP)\",\"total_duration\":8157778542}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "Liskov Substitution Principle (LSP)",
            "explanation": ""
        },
        {
            "input": "class Calculator {\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException();\n        }\n        return a / b;\n    }\n}\n\nclass SafeCalculator extends Calculator {\n    @Override\n    public int divide(int a, int b) {\n        return super.divide(a, b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator();\n        System.out.println(c.divide(4, 2));\n    }\n}",
            "output": "interface Calculator {\n    int divide(int a, int b);\n}\n\nclass BasicCalculator implements Calculator {\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Division by zero\");\n        }\n        return a / b;\n    }\n}\n\nclass SafeCalculator implements Calculator {\n    private final Calculator calculator;\n\n    public SafeCalculator(Calculator calculator) {\n        this.calculator = calculator;\n    }\n\n    @Override\n    public int divide(int a, int b) {\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Division by zero\");\n        }\n        return calculator.divide(a, b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculator c = new SafeCalculator(new BasicCalculator());\n        System.out.println(c.divide(4, 2));\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the SafeCalculator class does not provide any additional functionality or behavior that justifies its existence as a subclass of Calculator. Instead, it simply calls the superclass method without adding any safety features. The refactored code introduces an interface (Calculator) and separates the basic functionality into a BasicCalculator class. The SafeCalculator now takes a Calculator instance and checks for division by zero before delegating the call, adhering to LSP by ensuring that any instance of Calculator can be substituted without altering the expected behavior."
        },
        {
            "input": "import java.lang.Math;\n\ninterface IShape {\n    double area();\n}\n\nclass Circle implements IShape {\n    private double radius;\n    public Circle(double radius) { this.radius = radius; }\n    @Override\n    public double area() {\n        double calculatedArea = Math.PI * radius * radius;\n        System.out.println(\"Circle Area: \" + calculatedArea);\n        return calculatedArea;\n    }\n}\n\nclass NullShape implements IShape {\n    @Override\n    public double area() {\n        System.out.println(\"Null Shape Area: 0.0 (LSP Compliant)\");\n        return 0.0;\n    }\n}",
            "output": "import java.lang.Math;\n\ninterface IShape {\n    double area();\n}\n\nabstract class Shape implements IShape {\n    public abstract double area();\n}\n\nclass Circle extends Shape {\n    private double radius;\n    public Circle(double radius) { this.radius = radius; }\n    @Override\n    public double area() {\n        double calculatedArea = Math.PI  radius  radius;\n        return calculatedArea;\n    }\n}\n\nclass NullShape extends Shape {\n    @Override\n    public double area() {\n        return 0.0;\n    }\n}\n\nclass AreaCalculator {\n    public void printArea(IShape shape) {\n        double calculatedArea = shape.area();\n        System.out.println(shape.getClass().getSimpleName() + \" Area: \" + calculatedArea);\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "",
            "explanation": "The refactored code introduces an abstract class `Shape` that implements the `IShape` interface. This allows for better adherence to the Open/Closed Principle (OCP) by enabling the addition of new shapes without modifying existing code. The `AreaCalculator` class is introduced to handle the printing of area, separating the responsibility of area calculation from output, thus improving Single Responsibility Principle (SRP) compliance. The `NullShape` class remains compliant with the Liskov Substitution Principle (LSP) as it still adheres to the expected behavior of the `IShape` interface."
        },
        {
            "input": "import java.io.File;\n\ninterface FileStatusProvider {\n    String getStatus(String filePath);\n}\n\ninterface FileProcessor extends FileStatusProvider {\n    void processFile(String filePath);\n}\n\nclass RealFileProcessor implements FileProcessor {\n    @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Ready for processing\" : \"File not found\";\n    }\n\n    @Override\n    public void processFile(String filePath) {\n        File file = new File(filePath);\n        if (!file.exists()) {\n            System.out.println(\"RealProcessor: Error - File not found.\");\n            return;\n        }\n        System.out.println(\"RealProcessor: File processed successfully.\");\n    }\n}\n\nclass ReadOnlyFileStatusProvider implements FileStatusProvider {\n     @Override\n    public String getStatus(String filePath) {\n        File file = new File(filePath);\n        return file.exists() ? \"Available (Read-only)\" : \"File not found (Read-only)\";\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.io.File;\\n\\ninterface FileStatusProvider {\\n    String getStatus(String filePath);\\n}\\n\\ninterface FileProcessor {\\n    void processFile(String filePath);\\n}\\n\\nclass FileProcessorImpl implements FileProcessor {\\n    private final FileStatusProvider fileStatusProvider;\\n\\n    public FileProcessorImpl(FileStatusProvider fileStatusProvider) {\\n        this.fileStatusProvider = fileStatusProvider;\\n    }\\n\\n    @Override\\n    public void processFile(String filePath) {\\n        String status = fileStatusProvider.getStatus(filePath);\\n        if (status.contains(\\\"not found\\\")) {\\n            System.out.println(\\\"FileProcessor: Error - File not found.\\\");\\n            return;\\n        }\\n        System.out.println(\\\"FileProcessor: File processed successfully.\\\");\\n    }\\n}\\n\\nclass ReadOnlyFileStatusProvider implements FileStatusProvider {\\n    @Override\\n    public String getStatus(String filePath) {\\n        File file = new File(filePath);\\n        return file.exists() ? \\\"Available (Read-only)\\\" : \\\"File not found (Read-only)\\\";\\n    }\\n}\\n\\nclass RealFileStatusProvider implements FileStatusProvider {\\n    @Override\\n    public String getStatus(String filePath) {\\n        File file = new File(filePath);\\n        return file.exists() ? \\\"Ready for processing\\\" : \\\"File not found\\\";\\n    }\\n}\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        FileStatusProvider readOnlyProvider = new ReadOnlyFileStatusProvider();\\n        FileProcessor readOnlyProcessor = new FileProcessorImpl(readOnlyProvider);\\n        readOnlyProcessor.processFile(\\\"path/to/read-only/file.txt\\\");\\n\\n        FileStatusProvider realProvider = new RealFileStatusProvider();\\n        FileProcessor realProcessor = new FileProcessorImpl(realProvider);\\n        realProcessor.processFile(\\\"path/to/real/file.txt\\\");\\n    }\\n}\",\"explanation\":\"The refactored code separates the concerns of file processing and file status retrieval, adhering to the Single Responsibility Principle (SRP). The FileProcessor interface no longer extends FileStatusProvider, which allows for better adherence to the Interface Segregation Principle (ISP). Additionally, the Dependency Inversion Principle (DIP) is respected by injecting the FileStatusProvider into the FileProcessorImpl class, allowing for more flexible and testable code. Each file status provider can now be used independently, promoting the Open/Closed Principle (OCP) as new providers can be added without modifying existing code.\"},\"violation_type\":\"Multiple violations of SOLID principles\",\"total_duration\":8053383125}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "Multiple violations of SOLID principles",
            "explanation": ""
        },
        {
            "input": "interface SimpleLogger {\n    void log(String message);\n}\n\nclass CountingLogger implements SimpleLogger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        System.out.println(\"[COUNTING LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentLogger implements SimpleLogger {\n    @Override\n    public void log(String message) {\n        // This implementation simply does nothing, which is a valid behavior\n        // for a SimpleLogger if the contract doesn't guarantee visible output.\n    }\n}",
            "output": "interface SimpleLogger {\n    void log(String message);\n}\n\nclass CountingLogger implements SimpleLogger {\n    private int messagesLogged = 0;\n\n    public int getMessagesLoggedCount() {\n        return messagesLogged;\n    }\n\n    @Override\n    public void log(String message) {\n        System.out.println(\"[COUNTING LOG] \" + message);\n        messagesLogged++;\n    }\n}\n\nclass SilentLogger implements SimpleLogger {\n    @Override\n    public void log(String message) {\n        // This implementation simply does nothing, which is a valid behavior\n    }\n}\n\nclass LoggerFactory {\n    public static SimpleLogger createLogger(String type) {\n        if (type.equals(\"counting\")) {\n            return new CountingLogger();\n        } else if (type.equals(\"silent\")) {\n            return new SilentLogger();\n        }\n        throw new IllegalArgumentException(\"Unknown logger type: \" + type);\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code adheres to the SOLID principles fairly well, but it can be improved by introducing a LoggerFactory to handle the creation of different logger types. This change enhances the Open/Closed Principle (OCP) by allowing the addition of new logger types without modifying existing code. The Single Responsibility Principle (SRP) is also respected as each logger class has a single responsibility. The refactored code maintains the same functionality while improving extensibility."
        },
        {
            "input": "import java.io.File;\nimport java.util.HashMap;\nimport java.util.Map;\n\n// Define interfaces for different capabilities\ninterface DataLoader {\n    boolean loadData(String source);\n}\n\ninterface DataProcessorCapability {\n    boolean processData();\n}\n\ninterface DataSaverCapability {\n    boolean saveResults(String destination);\n}\n\n// A concrete implementation that can do all three\nclass FullDataProcessor implements DataLoader, DataProcessorCapability, DataSaverCapability {\n    private Map<String, Object> data = null;\n\n    public FullDataProcessor() {\n        System.out.println(\"FullDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"Full: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"Full: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"Full: Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"Full: Processing data...\");\n        if (data == null) {\n            System.out.println(\"Full: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        // Simulate processing\n        data.put(\"processed\", true);\n        System.out.println(\"Full: Data processed.\");\n        return true;\n    }\n\n    @Override\n    public boolean saveResults(String destination) {\n        System.out.println(\"Full: Saving results to \" + destination + \"...\");\n        if (data == null || !Boolean.TRUE.equals(data.get(\"processed\"))) {\n            System.out.println(\"Full: No processed data to save.\");\n            return false;\n        }\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        // Simulate saving\n        // Example: try { new File(destination).createNewFile(); } catch (IOException e) { e.printStackTrace(); return false; }\n        System.out.println(\"Full: Results saved to \" + destination + \".\");\n        return true;\n    }\n}\n\n// A concrete implementation that can load and process (read-only concept)\n// It implements DataLoader and DataProcessorCapability but NOT DataSaverCapability.\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessorCapability {\n    private Map<String, Object> data = null; // Manage its own state\n\n    public ReadOnlyDataProcessor() {\n        System.out.println(\"ReadOnlyDataProcessor created.\");\n    }\n\n    @Override\n    public boolean loadData(String source) {\n        System.out.println(\"ReadOnly: Loading data from \" + source + \"...\");\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        if (\"valid_source\".equals(source)) {\n            data = new HashMap<>();\n            data.put(\"key1\", \"value1\");\n            data.put(\"key2\", 42);\n            System.out.println(\"ReadOnly: Data loaded successfully.\");\n            return true;\n        } else {\n            data = null;\n            System.out.println(\"ReadOnly: Failed to load data.\");\n            return false;\n        }\n    }\n\n    @Override\n    public boolean processData() {\n        System.out.println(\"ReadOnly: Processing data (read-only simulation)...\");\n        if (data == null) {\n            System.out.println(\"ReadOnly: No data to process.\");\n            return false;\n        }\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\n        // Simulate processing without making it 'savable' in the sense required by DataSaverCapability\n        // Could even work on a shallow copy of 'data' if deep processing wasn't intended to modify the original\n        // data = new HashMap<>(data); // Example: process on a copy\n        data.put(\"processed\", true); // Still mark as processed internally for its own logic\n        System.out.println(\"ReadOnly: Data processed (read-only).\");\n        return true;\n    }\n\n    // This class does NOT have a saveResults method from the DataSaverCapability interface.\n    // Therefore, it cannot be substituted where DataSaverCapability is required.\n}\n\n// Example Usage (LSP Compliant - requires specific capabilities):\n/*\nimport java.io.File;\n\npublic class ComplianceDemo {\n    // A method requiring saving capability MUST ask for DataSaverCapability (or FullDataProcessor)\n    public static void saveProcessedData(DataSaverCapability saver, String destination) {\n         // This method knows it can save\n         System.out.println(\"Attempting to save using a saver...\");\n         // saver.loadData(...) // This would be a compile-time error - DataSaverCapability doesn't have loadData\n         // saver.processData() // This would be a compile-time error - DataSaverCapability doesn't have processData\n         saver.saveResults(destination); // This call is guaranteed to exist (though might fail for other reasons like disk full)\n    }\n\n    // A method requiring only processing capability can ask for DataProcessorCapability\n    public static void processSomeData(DataProcessorCapability processor) {\n         // This method knows it can process\n         System.out.println(\"Attempting to process using a processor...\");\n         // processor.loadData(...) // Compile-time error\n         processor.processData(); // This call is guaranteed to exist\n         // processor.saveResults(...) // Compile-time error\n    }\n\n    // A method requiring only loading capability can ask for DataLoader\n    public static void loadSomeData(DataLoader loader) {\n         // This method knows it can load\n         System.out.println(\"Attempting to load using a loader...\");\n         loader.loadData(\"valid_source\"); // This call is guaranteed to exist\n         // loader.processData() // Compile-time error\n         // loader.saveResults(...) // Compile-time error\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"--- Demonstrating Compliance ---\");\n\n        // Instantiate classes\n        FullDataProcessor fullProc = new FullDataProcessor();\n        ReadOnlyDataProcessor readOnlyProc = new ReadOnlyDataProcessor();\n\n        System.out.println(\"\\nUsing FullDataProcessor where saver is needed:\");\n        // Need to load/process first if save logic requires state\n        if (fullProc.loadData(\"valid_source\")) {\n            if (fullProc.processData()) {\n                saveProcessedData(fullProc, \"output_compliant.txt\"); // Works (FullDataProcessor implements DataSaverCapability)\n            }\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\");\n        // saveProcessedData(readOnlyProc, \"output_compliant.txt\"); // This line would cause a compile-time type error\n        System.out.println(\"// Cannot pass ReadOnlyDataProcessor where DataSaverCapability is expected.\");\n\n        System.out.println(\"\\nUsing FullDataProcessor where processor is needed:\");\n        // Need to load first if process logic requires state\n        if (fullProc.loadData(\"valid_source\")) {\n             processSomeData(fullProc); // Works (FullDataProcessor implements DataProcessorCapability)\n        }\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\");\n        // Need to load first if process logic requires state\n        if (readOnlyProc.loadData(\"valid_source\")) {\n            processSomeData(readOnlyProc); // Works (ReadOnlyDataProcessor implements DataProcessorCapability)\n        }\n\n        System.out.println(\"\\nUsing FullDataProcessor where loader is needed:\");\n        loadSomeData(fullProc); // Works (FullDataProcessor implements DataLoader)\n\n        System.out.println(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\");\n        loadSomeData(readOnlyProc); // Works (ReadOnlyDataProcessor implements DataLoader)\n\n        // Clean up\n        File dummyFile = new File(\"output_compliant.txt\");\n        if (dummyFile.exists()) dummyFile.delete();\n    }\n}\n*/",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import java.io.File;\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\n// Define interfaces for different capabilities\\ninterface DataLoader {\\n    boolean loadData(String source);\\n}\\n\\ninterface DataProcessor {\\n    boolean processData();\\n}\\n\\ninterface DataSaver {\\n    boolean saveResults(String destination);\\n}\\n\\n// A concrete implementation that can load, process, and save data\\nclass DataProcessorImpl implements DataLoader, DataProcessor, DataSaver {\\n    private Map<String, Object> data = null;\\n\\n    public DataProcessorImpl() {\\n        System.out.println(\\\"DataProcessorImpl created.\\\");\\n    }\\n\\n    @Override\\n    public boolean loadData(String source) {\\n        System.out.println(\\\"Loading data from \\\" + source + \\\"...\\\");\\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        if (\\\"valid_source\\\".equals(source)) {\\n            data = new HashMap<>();\\n            data.put(\\\"key1\\\", \\\"value1\\\");\\n            data.put(\\\"key2\\\", 42);\\n            System.out.println(\\\"Data loaded successfully.\\\");\\n            return true;\\n        } else {\\n            data = null;\\n            System.out.println(\\\"Failed to load data.\\\");\\n            return false;\\n        }\\n    }\\n\\n    @Override\\n    public boolean processData() {\\n        System.out.println(\\\"Processing data...\\\");\\n        if (data == null) {\\n            System.out.println(\\\"No data to process.\\\");\\n            return false;\\n        }\\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        data.put(\\\"processed\\\", true);\\n        System.out.println(\\\"Data processed.\\\");\\n        return true;\\n    }\\n\\n    @Override\\n    public boolean saveResults(String destination) {\\n        System.out.println(\\\"Saving results to \\\" + destination + \\\"...\\\");\\n        if (data == null || !Boolean.TRUE.equals(data.get(\\\"processed\\\"))) {\\n            System.out.println(\\\"No processed data to save.\\\");\\n            return false;\\n        }\\n        try { Thread.sleep(300); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        System.out.println(\\\"Results saved to \\\" + destination + \\\".\\\");\\n        return true;\\n    }\\n}\\n\\n// A concrete implementation that can load and process data but not save\\nclass ReadOnlyDataProcessor implements DataLoader, DataProcessor {\\n    private Map<String, Object> data = null;\\n\\n    public ReadOnlyDataProcessor() {\\n        System.out.println(\\\"ReadOnlyDataProcessor created.\\\");\\n    }\\n\\n    @Override\\n    public boolean loadData(String source) {\\n        System.out.println(\\\"Loading data from \\\" + source + \\\"...\\\");\\n        try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        if (\\\"valid_source\\\".equals(source)) {\\n            data = new HashMap<>();\\n            data.put(\\\"key1\\\", \\\"value1\\\");\\n            data.put(\\\"key2\\\", 42);\\n            System.out.println(\\\"Data loaded successfully.\\\");\\n            return true;\\n        } else {\\n            data = null;\\n            System.out.println(\\\"Failed to load data.\\\");\\n            return false;\\n        }\\n    }\\n\\n    @Override\\n    public boolean processData() {\\n        System.out.println(\\\"Processing data (read-only simulation)...\\\");\\n        if (data == null) {\\n            System.out.println(\\\"No data to process.\\\");\\n            return false;\\n        }\\n        try { Thread.sleep(200); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }\\n        data.put(\\\"processed\\\", true);\\n        System.out.println(\\\"Data processed (read-only).\\\");\\n        return true;\\n    }\\n}\\n\\n// Example Usage\\npublic class ComplianceDemo {\\n    public static void saveProcessedData(DataSaver saver, String destination) {\\n        System.out.println(\\\"Attempting to save using a saver...\\\");\\n        saver.saveResults(destination);\\n    }\\n\\n    public static void processSomeData(DataProcessor processor) {\\n        System.out.println(\\\"Attempting to process using a processor...\\\");\\n        processor.processData();\\n    }\\n\\n    public static void loadSomeData(DataLoader loader) {\\n        System.out.println(\\\"Attempting to load using a loader...\\\");\\n        loader.loadData(\\\"valid_source\\\");\\n    }\\n\\n    public static void main(String[] args) {\\n        System.out.println(\\\"--- Demonstrating Compliance ---\\\");\\n\\n        // Instantiate classes\\n        DataProcessorImpl fullProc = new DataProcessorImpl();\\n        ReadOnlyDataProcessor readOnlyProc = new ReadOnlyDataProcessor();\\n\\n        System.out.println(\\\"\\\\nUsing DataProcessorImpl where saver is needed:\\\");\\n        if (fullProc.loadData(\\\"valid_source\\\")) {\\n            if (fullProc.processData()) {\\n                saveProcessedData(fullProc, \\\"output_compliant.txt\\\");\\n            }\\n        }\\n\\n        System.out.println(\\\"\\\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\\\");\\n        // saveProcessedData(readOnlyProc, \\\"output_compliant.txt\\\"); // This line would cause a compile-time type error\\n        System.out.println(\\\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\\\");\\n\\n        System.out.println(\\\"\\\\nUsing DataProcessorImpl where processor is needed:\\\");\\n        if (fullProc.loadData(\\\"valid_source\\\")) {\\n            processSomeData(fullProc);\\n        }\\n\\n        System.out.println(\\\"\\\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\\\");\\n        if (readOnlyProc.loadData(\\\"valid_source\\\")) {\\n            processSomeData(readOnlyProc);\\n        }\\n\\n        System.out.println(\\\"\\\\nUsing DataProcessorImpl where loader is needed:\\\");\\n        loadSomeData(fullProc);\\n\\n        System.out.println(\\\"\\\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\\\");\\n        loadSomeData(readOnlyProc);\\n\\n        // Clean up\\n        File dummyFile = new File(\\\"output_compliant.txt\\\");\\n        if (dummyFile.exists()) dummyFile.delete();\\n    }\\n}\",\"explanation\":\"The refactored code separates the responsibilities more clearly by ensuring that each class adheres to the Single Responsibility Principle (SRP). The interfaces are kept distinct, and the classes implement only the interfaces they need. This avoids the violation of the Interface Segregation Principle (ISP) where classes were forced to implement methods they did not use. The refactored code also maintains compliance with the Liskov Substitution Principle (LSP) by ensuring that subclasses can be substituted without altering the correctness of the program. Overall, the refactoring improves the design by making it more modular and easier to maintain.\"}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "class Bird:\n    def move(self):\n        print('Moving')\n\nclass Ostrich(Bird):\n    def move(self):\n        print('Running')\n",
            "output": "class Bird:\n    def move(self):\n        raise NotImplementedError(\"Subclasses should implement this!\")\n\nclass FlyingBird(Bird):\n    def move(self):\n        print('Flying')\n\nclass Ostrich(Bird):\n    def move(self):\n        print('Running')\n\nclass Sparrow(FlyingBird):\n    def move(self):\n        print('Flying high')\n",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the `Ostrich` class does not behave as a typical `Bird` would, specifically in terms of movement. To adhere to LSP, I introduced an abstract method in the `Bird` class and created a separate `FlyingBird` class for birds that can fly. This way, `Ostrich` and other birds can be substituted without breaking the expected behavior."
        },
        {
            "input": "class Shape:\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    def area(self):\n        return self.width * self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side * self.side\n",
            "output": "class Shape:\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    def area(self):\n        return self.width  self.height\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n    def area(self):\n        return self.side  self.side\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    def area(self):\n        import math\n        return math.pi  (self.radius  2)\n\nshapes = [Rectangle(3, 4), Square(5), Circle(2)]\nfor shape in shapes:\n    print(f'Area: {shape.area()}')",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code violates the Open/Closed Principle (OCP) because the Shape class is not open for extension. If we want to add new shapes, we need to modify the existing code. In the refactored code, I added a Circle class that extends Shape without modifying the existing Rectangle and Square classes. This allows for new shapes to be added easily without changing the existing code."
        },
        {
            "input": "class Animal:\n    def move(self):\n        print('Moving')\n\nclass Fish(Animal):\n    def move(self):\n        print('Swimming')\n",
            "output": "from abc import ABC, abstractmethod\n\nclass Animal(ABC):\n    @abstractmethod\n    def move(self):\n        pass\n\nclass Fish(Animal):\n    def move(self):\n        print('Swimming')\n\nclass Bird(Animal):\n    def move(self):\n        print('Flying')\n\nclass Mammal(Animal):\n    def move(self):\n        print('Running')\n\n# Example usage\nanimals = [Fish(), Bird(), Mammal()]\nfor animal in animals:\n    animal.move()",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code violates the Open/Closed Principle (OCP) because the `Animal` class is not designed to be extended without modifying existing code. By using an abstract base class and defining an interface for movement, we can add new animal types (like `Bird` and `Mammal`) without changing the existing code. This makes the system more flexible and adheres to the OCP."
        },
        {
            "input": "class FileHandler:\n    def read(self):\n        print('Reading file')\n\nclass Writer(FileHandler):\n    def write(self):\n        print('Writing to file')\n",
            "output": "class FileReader:\n    def read(self):\n        print('Reading file')\n\nclass FileWriter:\n    def write(self):\n        print('Writing to file')\n\nclass FileHandler:\n    def __init__(self, reader: FileReader, writer: FileWriter):\n        self.reader = reader\n        self.writer = writer\n\n    def read_file(self):\n        self.reader.read()\n\n    def write_file(self):\n        self.writer.write()",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `Writer` class inherits from `FileHandler`, which combines reading and writing responsibilities. In the refactored code, I separated the reading and writing functionalities into distinct classes: `FileReader` and `FileWriter`. The `FileHandler` class now acts as a facade that uses these two classes to perform file operations, adhering to SRP by ensuring that each class has a single responsibility."
        },
        {
            "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor:\n    def process_free(self):\n        print('Processed free payment')\n",
            "output": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f'Processed payment of {amount}')\n\nclass FreePaymentProcessor:\n    def process_payment(self):\n        print('Processed free payment')\n\nclass Payment:\n    def __init__(self, amount=0):\n        self.amount = amount\n\nclass PaymentFactory:\n    @staticmethod\n    def create_payment(payment_type, amount=0):\n        if payment_type == 'free':\n            return FreePaymentProcessor()\n        else:\n            return PaymentProcessor()",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `FreePaymentProcessor` class has a method that does not align with the payment processing responsibility. Additionally, the code lacks extensibility for different payment types. The refactored code introduces a `Payment` class to encapsulate payment details and a `PaymentFactory` to create the appropriate payment processor based on the type. This separation of concerns allows each class to have a single responsibility, improving maintainability and scalability."
        },
        {
            "input": "class Document:\n    def show(self):\n        print('Showing document')\n\nclass SecureDocument(Document):\n    def show(self):\n        print('Showing secure document')\n",
            "output": "class Document:\n    def show(self):\n        print('Showing document')\n\nclass SecureDocument(Document):\n    def show(self):\n        print('Showing secure document')\n\nclass DocumentViewer:\n    def display(self, document: Document):\n        document.show()\n\n# Example usage\nif __name__ == '__main__':\n    doc = Document()\n    secure_doc = SecureDocument()\n    viewer = DocumentViewer()\n    viewer.display(doc)\n    viewer.display(secure_doc)",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because it does not provide a clear way to handle different types of documents in a consistent manner. The refactored code introduces a `DocumentViewer` class that takes a `Document` type and calls its `show` method. This allows for any subclass of `Document` to be used interchangeably without breaking the functionality, adhering to LSP."
        },
        {
            "input": "class Vehicle:\n    def move(self):\n        print('Vehicle is moving')\n\nclass Bicycle(Vehicle):\n    def move(self):\n        print('Bicycle is moving')\n",
            "output": "class Vehicle:\n    def move(self):\n        raise NotImplementedError(\"Subclasses should implement this method\")\n\nclass Bicycle(Vehicle):\n    def move(self):\n        print('Bicycle is moving')\n\nclass Car(Vehicle):\n    def move(self):\n        print('Car is moving')\n\nclass VehicleMover:\n    def move_vehicle(self, vehicle: Vehicle):\n        vehicle.move()",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "OCP",
            "explanation": "The original code violates the Open/Closed Principle (OCP) because the `Vehicle` class is not designed to be easily extended with new types of vehicles without modifying existing code. By introducing a `VehicleMover` class and making `move` an abstract method in `Vehicle`, we allow for new vehicle types to be added without changing the existing code structure. This adheres to OCP by allowing the system to be open for extension but closed for modification."
        },
        {
            "input": "class EmailSender:\n    def send_email(self, address):\n        print(f'Sending email to {address}')\n\nclass Logger:\n    def log(self, message):\n        print(message)\n",
            "output": "class EmailSender:\n    def __init__(self, logger):\n        self.logger = logger\n\n    def send_email(self, address):\n        self.logger.log(f'Sending email to {address}')\n\nclass Logger:\n    def log(self, message):\n        print(message)\n\n# Example usage\nlogger = Logger()\nemail_sender = EmailSender(logger)\nemail_sender.send_email('example@example.com')",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the EmailSender class is responsible for both sending emails and logging the action. In the refactored code, the EmailSender class now takes a Logger instance as a dependency, allowing it to focus solely on sending emails while delegating the logging responsibility to the Logger class. This separation of concerns improves maintainability and adheres to the SRP."
        },
        {
            "input": "import abc\nimport os\nimport time\n\n# Define ABCs for different capabilities\nclass DataLoader(abc.ABC):\n    @abc.abstractmethod\n    def load_data(self, source):\n        pass\n\nclass DataProcessorCapability(abc.ABC):\n    @abc.abstractmethod\n    def process_data(self):\n        pass\n\nclass DataSaverCapability(abc.ABC):\n    @abc.abstractmethod\n    def save_results(self, destination):\n        pass\n\n# A concrete implementation that can do all three\nclass FullDataProcessor(DataLoader, DataProcessorCapability, DataSaverCapability):\n    def __init__(self):\n        self._data = None\n        print(\"FullDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"Full: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"Full: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"Full: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"Full: Processing data...\")\n        if self._data is None:\n            print(\"Full: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing\n        self._data[\"processed\"] = True\n        print(\"Full: Data processed.\")\n        return True\n\n    def save_results(self, destination):\n        print(f\"Full: Saving results to {destination}...\")\n        if self._data is None or not self._data.get(\"processed\"):\n            print(\"Full: No processed data to save.\")\n            return False\n        time.sleep(0.3)\n        # Simulate saving\n        print(f\"Full: Results saved to {destination}.\")\n        return True\n\n# A concrete implementation that can load and process (read-only concept)\n# It implements DataLoader and DataProcessorCapability but NOT DataSaverCapability.\nclass ReadOnlyDataProcessor(DataLoader, DataProcessorCapability):\n    def __init__(self):\n        self._data = None # Manage its own state\n        print(\"ReadOnlyDataProcessor created.\")\n\n    def load_data(self, source):\n        print(f\"ReadOnly: Loading data from {source}...\")\n        time.sleep(0.1)\n        if source == \"valid_source\":\n            self._data = {\"key1\": \"value1\", \"key2\": 42}\n            print(\"ReadOnly: Data loaded successfully.\")\n        else:\n            self._data = None\n            print(\"ReadOnly: Failed to load data.\")\n        return self._data is not None\n\n    def process_data(self):\n        print(\"ReadOnly: Processing data (read-only simulation)...\")\n        if self._data is None:\n            print(\"ReadOnly: No data to process.\")\n            return False\n        time.sleep(0.2)\n        # Simulate processing without making it 'savable'\n        # Could even shallow copy self._data if deep processing wasn't intended\n        print(\"ReadOnly: Data processed (read-only).\")\n        return True\n\n    # This class does NOT have a save_results method.\n    # Therefore, it cannot be substituted where DataSaverCapability is required.\n\n# Example Usage (LSP Compliant - requires specific capabilities):\n# def demonstrate_compliance():\n#     print(\"--- Demonstrating Compliance ---\")\n\n#     # A function requiring saving capability MUST ask for DataSaverCapability (or FullDataProcessor)\n#     def save_processed_data(saver: DataSaverCapability, destination):\n#          # This function knows it can save\n#          print(\"Attempting to save using a saver...\")\n#          # saver.load_data() # This would be a type error - DataSaverCapability doesn't have load_data\n#          # saver.process_data() # This would be a type error - DataSaverCapability doesn't have process_data\n#          saver.save_results(destination) # This call is guaranteed to exist (though might fail for other reasons like disk full)\n\n#     # A function requiring only processing capability can ask for DataProcessorCapability\n#     def process_some_data(processor: DataProcessorCapability):\n#          # This function knows it can process\n#          print(\"Attempting to process using a processor...\")\n#          # processor.load_data() # Type error\n#          processor.process_data() # This call is guaranteed to exist\n#          # processor.save_results() # Type error\n\n#     # A function requiring only loading capability can ask for DataLoader\n#     def load_some_data(loader: DataLoader):\n#          # This function knows it can load\n#          print(\"Attempting to load using a loader...\")\n#          loader.load_data(\"valid_source\") # This call is guaranteed to exist\n#          # loader.process_data() # Type error\n#          # loader.save_results() # Type error\n\n#     # Instantiate classes\n#     full_proc = FullDataProcessor()\n#     read_only_proc = ReadOnlyDataProcessor()\n\n#     print(\"\\nUsing FullDataProcessor where saver is needed:\")\n#     # Need to load/process first if save logic requires state\n#     if full_proc.load_data(\"valid_source\"): full_proc.process_data()\n#     save_processed_data(full_proc, \"output_compliant.txt\") # Works (FullDataProcessor implements DataSaverCapability)\n\n#     print(\"\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\")\n#     # save_processed_data(read_only_proc, \"output_compliant.txt\") # This line would cause a TypeError\n#     print(\"// Cannot pass ReadOnlyDataProcessor where DataSaverCapability is expected.\")\n\n#     print(\"\\nUsing FullDataProcessor where processor is needed:\")\n#     # Need to load first if process logic requires state\n#     if full_proc.load_data(\"valid_source\"): process_some_data(full_proc) # Works (FullDataProcessor implements DataProcessorCapability)\n\n#     print(\"\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\")\n#     # Need to load first if process logic requires state\n#     if read_only_proc.load_data(\"valid_source\"): process_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataProcessorCapability)\n\n#     print(\"\\nUsing FullDataProcessor where loader is needed:\")\n#     load_some_data(full_proc) # Works (FullDataProcessor implements DataLoader)\n\n#     print(\"\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\")\n#     load_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataLoader)\n\n#     # Clean up\n#     if os.path.exists(\"output_compliant.txt\"): os.remove(\"output_compliant.txt\")\n\n# demonstrate_compliance()\n",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import abc\\nimport os\\nimport time\\n\\n# Define ABCs for different capabilities\\nclass DataLoader(abc.ABC):\\n    @abc.abstractmethod\\n    def load_data(self, source):\\n        pass\\n\\nclass DataProcessor(abc.ABC):\\n    @abc.abstractmethod\\n    def process_data(self):\\n        pass\\n\\nclass DataSaver(abc.ABC):\\n    @abc.abstractmethod\\n    def save_results(self, destination):\\n        pass\\n\\n# A concrete implementation that can do all three\\nclass FullDataProcessor(DataLoader, DataProcessor, DataSaver):\\n    def __init__(self):\\n        self._data = None\\n        print(\\\"FullDataProcessor created.\\\")\\n\\n    def load_data(self, source):\\n        print(f\\\"Full: Loading data from {source}...\\\")\\n        time.sleep(0.1)\\n        if source == \\\"valid_source\\\":\\n            self._data = {\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": 42}\\n            print(\\\"Full: Data loaded successfully.\\\")\\n        else:\\n            self._data = None\\n            print(\\\"Full: Failed to load data.\\\")\\n        return self._data is not None\\n\\n    def process_data(self):\\n        print(\\\"Full: Processing data...\\\")\\n        if self._data is None:\\n            print(\\\"Full: No data to process.\\\")\\n            return False\\n        time.sleep(0.2)\\n        # Simulate processing\\n        self._data[\\\"processed\\\"] = True\\n        print(\\\"Full: Data processed.\\\")\\n        return True\\n\\n    def save_results(self, destination):\\n        print(f\\\"Full: Saving results to {destination}...\\\")\\n        if self._data is None or not self._data.get(\\\"processed\\\"):\\n            print(\\\"Full: No processed data to save.\\\")\\n            return False\\n        time.sleep(0.3)\\n        # Simulate saving\\n        print(f\\\"Full: Results saved to {destination}.\\\")\\n        return True\\n\\n# A concrete implementation that can load and process (read-only concept)\\nclass ReadOnlyDataProcessor(DataLoader, DataProcessor):\\n    def __init__(self):\\n        self._data = None # Manage its own state\\n        print(\\\"ReadOnlyDataProcessor created.\\\")\\n\\n    def load_data(self, source):\\n        print(f\\\"ReadOnly: Loading data from {source}...\\\")\\n        time.sleep(0.1)\\n        if source == \\\"valid_source\\\":\\n            self._data = {\\\"key1\\\": \\\"value1\\\", \\\"key2\\\": 42}\\n            print(\\\"ReadOnly: Data loaded successfully.\\\")\\n        else:\\n            self._data = None\\n            print(\\\"ReadOnly: Failed to load data.\\\")\\n        return self._data is not None\\n\\n    def process_data(self):\\n        print(\\\"ReadOnly: Processing data (read-only simulation)...\\\")\\n        if self._data is None:\\n            print(\\\"ReadOnly: No data to process.\\\")\\n            return False\\n        time.sleep(0.2)\\n        # Simulate processing without making it 'savable'\\n        print(\\\"ReadOnly: Data processed (read-only).\\\")\\n        return True\\n\\n# Example Usage (LSP Compliant - requires specific capabilities):\\ndef demonstrate_compliance():\\n    print(\\\"--- Demonstrating Compliance ---\\\")\\n\\n    # A function requiring saving capability MUST ask for DataSaver (or FullDataProcessor)\\n    def save_processed_data(saver: DataSaver, destination):\\n         # This function knows it can save\\n         print(\\\"Attempting to save using a saver...\\\")\\n         saver.save_results(destination) # This call is guaranteed to exist (though might fail for other reasons like disk full)\\n\\n    # A function requiring only processing capability can ask for DataProcessor\\n    def process_some_data(processor: DataProcessor):\\n         # This function knows it can process\\n         print(\\\"Attempting to process using a processor...\\\")\\n         processor.process_data() # This call is guaranteed to exist\\n\\n    # A function requiring only loading capability can ask for DataLoader\\n    def load_some_data(loader: DataLoader):\\n         # This function knows it can load\\n         print(\\\"Attempting to load using a loader...\\\")\\n         loader.load_data(\\\"valid_source\\\") # This call is guaranteed to exist\\n\\n    # Instantiate classes\\n    full_proc = FullDataProcessor()\\n    read_only_proc = ReadOnlyDataProcessor()\\n\\n    print(\\\"\\\\nUsing FullDataProcessor where saver is needed:\\\")\\n    # Need to load/process first if save logic requires state\\n    if full_proc.load_data(\\\"valid_source\\\"): full_proc.process_data()\\n    save_processed_data(full_proc, \\\"output_compliant.txt\\\") # Works (FullDataProcessor implements DataSaver)\\n\\n    print(\\\"\\\\nUsing ReadOnlyDataProcessor where saver is needed (compile-time error):\\\")\\n    # save_processed_data(read_only_proc, \\\"output_compliant.txt\\\") # This line would cause a TypeError\\n    print(\\\"// Cannot pass ReadOnlyDataProcessor where DataSaver is expected.\\\")\\n\\n    print(\\\"\\\\nUsing FullDataProcessor where processor is needed:\\\")\\n    # Need to load first if process logic requires state\\n    if full_proc.load_data(\\\"valid_source\\\"): process_some_data(full_proc) # Works (FullDataProcessor implements DataProcessor)\\n\\n    print(\\\"\\\\nUsing ReadOnlyDataProcessor where processor is needed (LSP compliant):\\\")\\n    # Need to load first if process logic requires state\\n    if read_only_proc.load_data(\\\"valid_source\\\"): process_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataProcessor)\\n\\n    print(\\\"\\\\nUsing FullDataProcessor where loader is needed:\\\")\\n    load_some_data(full_proc) # Works (FullDataProcessor implements DataLoader)\\n\\n    print(\\\"\\\\nUsing ReadOnlyDataProcessor where loader is needed (LSP compliant):\\\")\\n    load_some_data(read_only_proc) # Works (ReadOnlyDataProcessor implements DataLoader)\\n\\n    # Clean up\\n    if os.path.exists(\\\"output_compliant.txt\\\"): os.remove(\\\"output_compliant.txt\\\")\\n\\ndemonstrate_compliance()\",\"explanation\":\"The refactored code separates the concerns of data loading, processing, and saving into distinct interfaces, ensuring that classes only implement the methods they need. This adheres to the Interface Segregation Principle (ISP) by preventing classes from being forced to implement methods they do not use. The original code had a violation of ISP because the ReadOnlyDataProcessor class was forced to implement the save_results method, which it did not need. The refactored code maintains the same functionality while improving adherence to SOLID principles.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":23593955750}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "import abc\n\n# Define an ABC for the core logging capability\nclass SimpleLogger(abc.ABC):\n    @abc.abstractmethod\n    def log(self, message):\n        pass\n\n# An implementation that logs and also tracks a count\nclass CountingLogger(SimpleLogger):\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[COUNTING LOG] {message}\")\n        self._messages_logged += 1\n\n# An implementation that simply logs (or does nothing)\n# It fulfills the SimpleLogger interface but doesn't support counting via an inherited method.\nclass SilentLogger(SimpleLogger):\n    def log(self, message):\n        # This implementation simply does nothing, which is a valid behavior\n        # for a SimpleLogger if the contract doesn't guarantee visible output.\n        pass\n\n# If you need a logger that *must* provide a count, you could define a separate ABC:\n# class CountableLogger(SimpleLogger, abc.ABC):\n#     @abc.abstractmethod\n#     def get_messages_logged_count(self):\n#         pass\n# Then CountingLogger would inherit from CountableLogger, and SilentLogger would not.\n# Code expecting CountableLogger would only accept types that can provide a count reliably.\n",
            "output": "import abc\n\n# Define an ABC for the core logging capability\nclass SimpleLogger(abc.ABC):\n    @abc.abstractmethod\n    def log(self, message):\n        pass\n\n# Define an ABC for loggers that can provide a count\nclass CountableLogger(SimpleLogger):\n    @abc.abstractmethod\n    def get_messages_logged_count(self):\n        pass\n\n# An implementation that logs and also tracks a count\nclass CountingLogger(CountableLogger):\n    def __init__(self):\n        self._messages_logged = 0\n\n    def get_messages_logged_count(self):\n        return self._messages_logged\n\n    def log(self, message):\n        print(f\"[COUNTING LOG] {message}\")\n        self._messages_logged += 1\n\n# An implementation that simply logs (or does nothing)\nclass SilentLogger(SimpleLogger):\n    def log(self, message):\n        # This implementation simply does nothing, which is a valid behavior\n        # for a SimpleLogger if the contract doesn't guarantee visible output.\n        pass\n",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "ISP",
            "explanation": "The original code violated the Interface Segregation Principle (ISP) because the SilentLogger class was forced to implement the log method without needing to provide a count, which is only relevant for CountingLogger. By introducing a separate CountableLogger interface, we ensure that only loggers that need to provide a count implement that functionality, adhering to the ISP. This refactoring also maintains the Single Responsibility Principle (SRP) by keeping the responsibilities of each logger clear."
        },
        {
            "input": "import abc\nimport os\n\n# Represents a component that can provide the status of a file\nclass FileStatusProvider(abc.ABC):\n    @abc.abstractmethod\n    def get_status(self, file_path):\n        pass\n\n# Represents a component that can process files (inherits status capability by implementing both)\nclass FileProcessor(FileStatusProvider, abc.ABC): # FileProcessor *is a* FileStatusProvider\n     @abc.abstractmethod\n     def process_file(self, file_path):\n         pass\n\n# A concrete implementation of a processor\nclass RealFileProcessor(FileProcessor):\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Ready for processing\" if file_exists else \"File not found\"\n        print(f\"RealProcessor: Checking status for {file_path} - {status}.\")\n        return status\n\n    def process_file(self, file_path):\n        print(f\"RealProcessor: Processing file {file_path}...\")\n        if not os.path.exists(file_path):\n             print(f\"RealProcessor: Error - File {file_path} not found for processing.\")\n            return\n        # Simulate processing...\n        # Example: with open(file_path, 'a') as f: f.write('\\nProcessed by real')\n        print(f\"RealProcessor: File {file_path} processed successfully.\")\n\n# Represents a component that can *only* check file status (read-only)\n# It implements FileStatusProvider but NOT FileProcessor.\nclass ReadOnlyFileStatusProvider(FileStatusProvider): # Only implements status capability\n    def get_status(self, file_path):\n        file_exists = os.path.exists(file_path)\n        status = \"Available (Read-only)\" if file_exists else \"File not found (Read-only)\"\n        print(f\"ReadOnlyStatusProvider: Checking status for {file_path} - {status}.\")\n        return status\n    # This class simply *does not have* a process_file method.\n    # Therefore, it cannot be substituted where a FileProcessor is expected,\n    # preventing the LSP violation.\n\n# Example Usage (LSP Compliant):\n# import os\n\n# test_file_path = \"dummy_refactored.txt\"\n# with open(test_file_path, \"w\") as f: f.write(\"Some content\") # Create a dummy file\n\n# # When you need processing capability, you must use FileProcessor:\n# processor: FileProcessor = RealFileProcessor() # Substitutes for FileProcessor\n# print(processor.get_status(test_file_path)) # RealProcessor: ... Ready.\n# processor.process_file(test_file_path)     # RealProcessor: ... processed successfully.\n\n# print(\"---\")\n\n# # When you only need status capability, you can use FileStatusProvider:\n# status_provider1: FileStatusProvider = RealFileProcessor() # Substitutes for FileStatusProvider\n# print(status_provider1.get_status(test_file_path)) # RealProcessor: ... Ready.\n\n# status_provider2: FileStatusProvider = ReadOnlyFileStatusProvider() # LSP compliant substitution\n# print(status_provider2.get_status(test_file_path)) # ReadOnlyStatusProvider: ... Available (Read-only)\n\n# # The critical part: A ReadOnlyFileStatusProvider CANNOT be treated as a FileProcessor.\n# # The following line would cause a type error at runtime if type hints were enforced, or logical error:\n# # invalid_processor: FileProcessor = ReadOnlyFileStatusProvider() # Type checker error / Runtime error if instantiated\n# # If you tried to call invalid_processor.process_file(...), it would fail because the method doesn't exist.\n\n# if os.path.exists(test_file_path): os.remove(test_file_path) # Clean up dummy file\n",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import abc\\nimport os\\n\\n# Represents a component that can provide the status of a file\\nclass FileStatusProvider(abc.ABC):\\n    @abc.abstractmethod\\n    def get_status(self, file_path):\\n        pass\\n\\n# Represents a component that can process files\\nclass FileProcessor(abc.ABC):\\n    @abc.abstractmethod\\n    def process_file(self, file_path):\\n        pass\\n\\n# A concrete implementation of a processor\\nclass RealFileProcessor(FileProcessor, FileStatusProvider):\\n    def get_status(self, file_path):\\n        file_exists = os.path.exists(file_path)\\n        status = \\\"Ready for processing\\\" if file_exists else \\\"File not found\\\"\\n        print(f\\\"RealProcessor: Checking status for {file_path} - {status}.\\\")\\n        return status\\n\\n    def process_file(self, file_path):\\n        print(f\\\"RealProcessor: Processing file {file_path}...\\\")\\n        if not os.path.exists(file_path):\\n            print(f\\\"RealProcessor: Error - File {file_path} not found for processing.\\\")\\n            return\\n        # Simulate processing...\\n        print(f\\\"RealProcessor: File {file_path} processed successfully.\\\")\\n\\n# Represents a component that can only check file status (read-only)\\nclass ReadOnlyFileStatusProvider(FileStatusProvider):\\n    def get_status(self, file_path):\\n        file_exists = os.path.exists(file_path)\\n        status = \\\"Available (Read-only)\\\" if file_exists else \\\"File not found (Read-only)\\\"\\n        print(f\\\"ReadOnlyStatusProvider: Checking status for {file_path} - {status}.\\\")\\n        return status\\n\\n# Example Usage:\\n# import os\\n\\ntest_file_path = \\\"dummy_refactored.txt\\\"\\nwith open(test_file_path, \\\"w\\\") as f: f.write(\\\"Some content\\\") # Create a dummy file\\n\\n# When you need processing capability, you must use FileProcessor:\\nprocessor: FileProcessor = RealFileProcessor() # Substitutes for FileProcessor\\nprint(processor.get_status(test_file_path)) # RealProcessor: ... Ready.\\nprocessor.process_file(test_file_path)     # RealProcessor: ... processed successfully.\\n\\nprint(\\\"---\\\")\\n\\n# When you only need status capability, you can use FileStatusProvider:\\nstatus_provider1: FileStatusProvider = RealFileProcessor() # Substitutes for FileStatusProvider\\nprint(status_provider1.get_status(test_file_path)) # RealProcessor: ... Ready.\\n\\nstatus_provider2: FileStatusProvider = ReadOnlyFileStatusProvider() # LSP compliant substitution\\nprint(status_provider2.get_status(test_file_path)) # ReadOnlyStatusProvider: ... Available (Read-only)\\n\\nif os.path.exists(test_file_path): os.remove(test_file_path) # Clean up dummy file\",\"explanation\":\"The refactored code separates the concerns of file processing and status checking more clearly by ensuring that both functionalities are encapsulated in their respective classes. The `FileProcessor` class no longer inherits from `FileStatusProvider`, which allows for a clearer distinction between processing and status checking. This change improves adherence to the Single Responsibility Principle (SRP) and the Interface Segregation Principle (ISP). The `RealFileProcessor` class now implements both interfaces, allowing it to be used interchangeably where either functionality is required.\"},\"violation_type\":\"LSP\",\"total_duration\":10944176708}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "LSP",
            "explanation": ""
        },
        {
            "input": "import abc\nimport math\n\n# Define an ABC for shapes that can provide an area.\n# The ABC contract simply says 'there is an area() method returning float'.\n# The expectation that this is a meaningful non-negative number is implicit in the *concept* of \"Area\".\nclass IShape(abc.ABC):\n    @abc.abstractmethod\n    def area(self) -> float:\n        pass\n\n# A standard shape implementation (like a circle)\nclass Circle(IShape):\n    def __init__(self, radius: float):\n        self.radius = radius\n\n    def area(self) -> float:\n        calculated_area = math.pi * self.radius * self.radius\n        print(f\"Circle Area: {calculated_area}\")\n        return calculated_area # Returns a valid, non-negative number\n\n# An implementation representing a shape with no area (the \"null\" concept).\n# This now adheres to LSP by returning a valid numerical area (0.0),\n# which is the correct representation for a shape with no size.\nclass NullShape(IShape): # Now implements the ABC\n    # This is LSP compliant because returning 0.0 is a valid float value\n    # and represents a shape having no area, which is a sensible\n    # specialization of the IShape contract (returning a float).\n    def area(self) -> float:\n        print(\"Null Shape Area: 0.0 (LSP Compliant)\")\n        return 0.0 # Returning 0.0 makes this compliant\n\n# Example Usage (LSP Compliant):\n# concrete = Circle(5.0) # Substitutes for IShape\n# concrete_area = concrete.area() # Returns a valid number\n# print(f\"Concrete Area: {concrete_area}\")\n\n# print(\"---\")\n\n# null_shape_compliant = NullShape() # Substitutes for IShape\n# null_area_compliant = null_shape_compliant.area() # Returns 0.0\n# print(f\"Null Area (Compliant): {null_area_compliant}\")\n\n# # Downstream code works correctly:\n# total_area = concrete_area + null_area_compliant # total_area is ~78.54 + 0.0\n# print(f\"Total Area: {total_area}\")\n\n# if null_area_compliant >= 0.0: # This check works as expected with 0.0\n#     print(\"Area is non-negative (check passes for 0.0)\")\n# else:\n#     print(\"Area is negative or NaN\")\n",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"import abc\\nimport math\\n\\n# Define an ABC for shapes that can provide an area.\\nclass IShape(abc.ABC):\\n    @abc.abstractmethod\\n    def area(self) -> float:\\n        pass\\n\\n# A standard shape implementation (like a circle)\\nclass Circle(IShape):\\n    def __init__(self, radius: float):\\n        self.radius = radius\\n\\n    def area(self) -> float:\\n        calculated_area = math.pi  self.radius  self.radius\\n        return calculated_area\\n\\n# An implementation representing a shape with no area (the \\\"null\\\" concept).\\nclass NullShape(IShape):\\n    def area(self) -> float:\\n        return 0.0\\n\\n# A new class for Rectangle to demonstrate OCP compliance\\nclass Rectangle(IShape):\\n    def __init__(self, width: float, height: float):\\n        self.width = width\\n        self.height = height\\n\\n    def area(self) -> float:\\n        return self.width  self.height\\n\\n# Example Usage:\\nshapes = [Circle(5.0), NullShape(), Rectangle(4.0, 6.0)]\\n\\nfor shape in shapes:\\n    print(f\\\"Area: {shape.area()}\\\")\\n\\n# Downstream code works correctly:\\ntotal_area = sum(shape.area() for shape in shapes)\\nprint(f\\\"Total Area: {total_area}\\\")\\n\\nif total_area >= 0.0:\\n    print(\\\"Total area is non-negative (check passes)\\\")\\nelse:\\n    print(\\\"Total area is negative or NaN\\\")\",\"explanation\":\"The refactored code introduces a new shape class, Rectangle, to demonstrate adherence to the Open/Closed Principle (OCP). This allows for the addition of new shapes without modifying existing code. The Single Responsibility Principle (SRP) is maintained as each class has a single responsibility. The Liskov Substitution Principle (LSP) is upheld as all shapes can be used interchangeably without affecting the correctness of the program. The Interface Segregation Principle (ISP) and Dependency Inversion Principle (DIP) are not directly violated in the original code, but the refactoring maintains their compliance by ensuring that interfaces are not bloated and that high-level modules do not depend on low-level modules.\"},\"total_duration\":15391190709}",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Bird {\n    open fun move() {}\n}\n\nclass Ostrich : Bird() {\n    override fun move() {\n        // Ostrich runs\n    }\n}\n\nclass Sparrow : Bird() {\n    override fun move() {\n        // Sparrow flies\n    }\n}\n\nfun makeBirdMove(bird: Bird) {\n    bird.move()\n}\n\nfun main() {\n    val ostrich = Ostrich()\n    makeBirdMove(ostrich)\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"open class Bird {\\n    open fun move() {}\\n}\\n\\ninterface Movable {\\n    fun move()\\n}\\n\\nclass Ostrich : Bird(), Movable {\\n    override fun move() {\\n        // Ostrich runs\\n    }\\n}\\n\\nclass Sparrow : Bird(), Movable {\\n    override fun move() {\\n        // Sparrow flies\\n    }\\n}\\n\\nfun makeBirdMove(movable: Movable) {\\n    movable.move()\\n}\\n\\nfun main() {\\n    val ostrich = Ostrich()\\n    makeBirdMove(ostrich)\\n    val sparrow = Sparrow()\\n    makeBirdMove(sparrow)\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the Bird class forces all derived classes to implement the move method, even if they don't need to. By introducing a Movable interface, we allow classes to implement only the functionality they require. This also adheres to the Dependency Inversion Principle (DIP) by depending on abstractions (Movable) rather than concrete implementations (Bird). The refactored code maintains the same functionality while improving adherence to SOLID principles.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":4968191000}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "open class Shape {\n    open fun area(): Int = 0\n}\n\nclass Rectangle(var width: Int, var height: Int) : Shape() {\n    override fun area(): Int = width * height\n}\n\nclass Square(size: Int) : Shape() {\n    private val side = size\n    override fun area(): Int = side * side\n}\n\nfun printArea(shape: Shape) {\n    println(shape.area())\n}\n\nfun main() {\n    val square = Square(5)\n    printArea(square)\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"open class Shape {\\n    open fun area(): Int = 0\\n}\\n\\ninterface AreaCalculable {\\n    fun area(): Int\\n}\\n\\nclass Rectangle(var width: Int, var height: Int) : Shape(), AreaCalculable {\\n    override fun area(): Int = width  height\\n}\\n\\nclass Square(size: Int) : Shape(), AreaCalculable {\\n    private val side = size\\n    override fun area(): Int = side  side\\n}\\n\\nfun printArea(shape: AreaCalculable) {\\n    println(shape.area())\\n}\\n\\nfun main() {\\n    val square = Square(5)\\n    printArea(square)\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `Shape` class is not an interface and does not provide a clear contract for area calculation. By introducing an `AreaCalculable` interface, we ensure that only classes that need to calculate an area implement this interface, adhering to the ISP. This change also maintains the functionality of the original code while improving its design.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":4348858125}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "open class Animal {\n    open fun move() {}\n}\n\nclass Dog : Animal() {\n    override fun move() {\n        println(\"Dog runs\")\n    }\n}\n\nclass Fish : Animal() {\n    override fun move() {\n        println(\"Fish swims\")\n    }\n}\n\nfun animalMove(animal: Animal) {\n    animal.move()\n}\n\nfun main() {\n    val fish = Fish()\n    animalMove(fish)\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"open class Animal {\\n    open fun move() {}\\n}\\n\\ninterface Movable {\\n    fun move()\\n}\\n\\nclass Dog : Animal(), Movable {\\n    override fun move() {\\n        println(\\\"Dog runs\\\")\\n    }\\n}\\n\\nclass Fish : Animal(), Movable {\\n    override fun move() {\\n        println(\\\"Fish swims\\\")\\n    }\\n}\\n\\nfun animalMove(movable: Movable) {\\n    movable.move()\\n}\\n\\nfun main() {\\n    val fish = Fish()\\n    animalMove(fish)\\n    val dog = Dog()\\n    animalMove(dog)\\n}\",\"explanation\":\"The original code violates the Interface Segregation Principle (ISP) because the `Animal` class is not designed to be an interface for movement. By introducing a `Movable` interface, we ensure that only classes that need to implement movement behavior do so, adhering to the ISP. Additionally, this refactoring allows for better extensibility and separation of concerns.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\",\"total_duration\":3885656292}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "Interface Segregation Principle (ISP)",
            "explanation": ""
        },
        {
            "input": "interface Payment {\n    fun pay(amount: Double)\n}\n\nclass CashPayment : Payment {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount in cash\")\n    }\n}\n\nclass CreditPayment : Payment {\n    override fun pay(amount: Double) {\n        println(\"Paid $amount by credit card\")\n    }\n}\n\nfun processPayment(payment: Payment, amount: Double) {\n    payment.pay(amount)\n}\n\nfun main() {\n    val credit = CreditPayment()\n    processPayment(credit, 100.0)\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"interface Payment {\\n    fun pay(amount: Double)\\n}\\n\\nclass CashPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount in cash\\\")\\n    }\\n}\\n\\nclass CreditPayment : Payment {\\n    override fun pay(amount: Double) {\\n        println(\\\"Paid \\$amount by credit card\\\")\\n    }\\n}\\n\\nclass PaymentProcessor {\\n    fun processPayment(payment: Payment, amount: Double) {\\n        payment.pay(amount)\\n    }\\n}\\n\\nfun main() {\\n    val credit = CreditPayment()\\n    val paymentProcessor = PaymentProcessor()\\n    paymentProcessor.processPayment(credit, 100.0)\\n}\",\"explanation\":\"The refactored code introduces a `PaymentProcessor` class that encapsulates the payment processing logic, adhering to the Single Responsibility Principle (SRP) by separating the payment processing from the payment methods. This change also enhances the Open/Closed Principle (OCP) by allowing new payment methods to be added without modifying the existing processing logic. The overall structure remains intact, ensuring that the code is still compilable and functional.\"},\"violation_type\":\"SRP\"}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "interface Writer {\n    fun write(data: String)\n}\n\nclass FileWriter : Writer {\n    override fun write(data: String) {\n        println(\"Writing to file: $data\")\n    }\n}\n\nfun save(writer: Writer, data: String) {\n    writer.write(data)\n}\n\nfun main() {\n    val fileWriter = FileWriter()\n    save(fileWriter, \"Hello\")\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"kotlin\\ninterface Writer {\\n    fun write(data: String)\\n}\\n\\nclass FileWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to file: \\$data\\\")\\n    }\\n}\\n\\nclass ConsoleWriter : Writer {\\n    override fun write(data: String) {\\n        println(\\\"Writing to console: \\$data\\\")\\n    }\\n}\\n\\nfun save(writer: Writer, data: String) {\\n    writer.write(data)\\n}\\n\\nfun main() {\\n    val fileWriter = FileWriter()\\n    save(fileWriter, \\\"Hello\\\")\\n    val consoleWriter = ConsoleWriter()\\n    save(consoleWriter, \\\"Hello World\\\")\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code adheres to the SOLID principles fairly well, but it can be improved for the Open/Closed Principle (OCP). The OCP states that software entities should be open for extension but closed for modification. In the original code, if we wanted to add a new type of writer (e.g., ConsoleWriter), we would need to modify the existing code. By introducing a new class for ConsoleWriter, we can extend the functionality without modifying the existing FileWriter class or the save function. This makes the code more maintainable and adheres better to the OCP.\"},\"violation_type\":\"OCP\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "open class Vehicle {\n    open fun move() {}\n}\n\nclass Car : Vehicle() {\n    override fun move() {\n        println(\"Car drives\")\n    }\n}\n\nclass Bicycle : Vehicle() {\n    override fun move() {\n        println(\"Bicycle pedals\")\n    }\n}\n\nfun startVehicle(vehicle: Vehicle) {\n    vehicle.move()\n}\n\nfun main() {\n    val bike = Bicycle()\n    startVehicle(bike)\n}",
            "output": "interface Movable {\n    fun move()\n}\n\nclass Car : Movable {\n    override fun move() {\n        println(\"Car drives\")\n    }\n}\n\nclass Bicycle : Movable {\n    override fun move() {\n        println(\"Bicycle pedals\")\n    }\n}\n\nclass Vehicle(private val movable: Movable) {\n    fun start() {\n        movable.move()\n    }\n}\n\nfun main() {\n    val bike = Vehicle(Bicycle())\n    bike.start()\n    val car = Vehicle(Car())\n    car.start()\n}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": "The original code violates the Open/Closed Principle (OCP) because the `Vehicle` class is not easily extendable for new types of vehicles without modifying existing code. By introducing a `Movable` interface, we allow for new vehicle types to be added without changing the `Vehicle` class. This adheres to OCP as the system can be extended with new implementations of `Movable` without altering existing code."
        },
        {
            "input": "interface Notification {\n    fun send(message: String)\n}\n\nclass EmailNotification : Notification {\n    override fun send(message: String) {\n        println(\"Email: $message\")\n    }\n}\n\nfun notifyUser(notification: Notification, message: String) {\n    notification.send(message)\n}\n\nfun main() {\n    val email = EmailNotification()\n    notifyUser(email, \"Hello\")\n}",
            "output": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"interface Notification {\\n    fun send(message: String)\\n}\\n\\nclass EmailNotification : Notification {\\n    override fun send(message: String) {\\n        println(\\\"Email: \\$message\\\")\\n    }\\n}\\n\\nclass SMSNotification : Notification {\\n    override fun send(message: String) {\\n        println(\\\"SMS: \\$message\\\")\\n    }\\n}\\n\\nclass NotificationService {\\n    fun notifyUser(notification: Notification, message: String) {\\n        notification.send(message)\\n    }\\n}\\n\\nfun main() {\\n    val email = EmailNotification()\\n    val sms = SMSNotification()\\n    val notificationService = NotificationService()\\n    notificationService.notifyUser(email, \\\"Hello via Email\\\")\\n    notificationService.notifyUser(sms, \\\"Hello via SMS\\\")\\n}\",\"explanation\":\"The original code adheres to most SOLID principles but can be improved in terms of the Single Responsibility Principle (SRP). The `notifyUser` function is responsible for both sending notifications and determining the type of notification to send. By introducing a `NotificationService` class, we separate the concerns of notification management from the notification types themselves. This allows for easier extension in the future, such as adding new notification types without modifying existing code.\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "interface Printer {\n    fun printDocument(document: String)\n}\n\nclass NetworkPrinter : Printer {\n    override fun printDocument(document: String) {\n        println(\"Printing over network: $document\")\n    }\n}\n\nfun print(printer: Printer, document: String) {\n    printer.printDocument(document)\n}\n\nfun main() {\n    val networkPrinter = NetworkPrinter()\n    print(networkPrinter, \"Test\")\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"interface Printer {\\n    fun printDocument(document: String)\\n}\\n\\nclass NetworkPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing over network: \\$document\\\")\\n    }\\n}\\n\\nclass LocalPrinter : Printer {\\n    override fun printDocument(document: String) {\\n        println(\\\"Printing locally: \\$document\\\")\\n    }\\n}\\n\\nclass PrintManager(private val printer: Printer) {\\n    fun print(document: String) {\\n        printer.printDocument(document)\\n    }\\n}\\n\\nfun main() {\\n    val networkPrinter = NetworkPrinter()\\n    val localPrinter = LocalPrinter()\\n    val printManager = PrintManager(networkPrinter)\\n    printManager.print(\\\"Test over network\\\")\\n    val localPrintManager = PrintManager(localPrinter)\\n    localPrintManager.print(\\\"Test locally\\\")\\n}\",\"explanation\":\"The refactored code introduces a `PrintManager` class that adheres to the Dependency Inversion Principle (DIP) by depending on the abstraction (Printer interface) rather than a concrete implementation. This allows for easier extension of the printing functionality without modifying existing code, thus adhering to the Open/Closed Principle (OCP). Additionally, it allows for multiple printer types to be used interchangeably, maintaining the Liskov Substitution Principle (LSP). The Single Responsibility Principle (SRP) is respected as each class has a clear responsibility. The Interface Segregation Principle (ISP) is not violated as the Printer interface remains focused on a single responsibility of printing documents. Overall, the refactored code is more flexible and maintainable.\"},\"violation_type\":\"Dependency Inversion Principle (DIP)\"}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "interface SimpleLogger {\n    fun log(message: String)\n}\n\nclass CountingLogger : SimpleLogger {\n    private var messagesLogged: Int = 0\n\n    fun getMessagesLoggedCount(): Int {\n        return messagesLogged\n    }\n\n    override fun log(message: String) {\n        println(\"[COUNTING LOG] $message\")\n        messagesLogged++\n    }\n}\n\nclass SilentLogger : SimpleLogger {\n    override fun log(message: String) {\n\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"interface Logger {\\n    fun log(message: String)\\n}\\n\\ninterface CountableLogger : Logger {\\n    fun getMessagesLoggedCount(): Int\\n}\\n\\nclass CountingLogger : CountableLogger {\\n    private var messagesLogged: Int = 0\\n\\n    override fun getMessagesLoggedCount(): Int {\\n        return messagesLogged\\n    }\\n\\n    override fun log(message: String) {\\n        println(\\\"[COUNTING LOG] \\$message\\\")\\n        messagesLogged++\\n    }\\n}\\n\\nclass SilentLogger : Logger {\\n    override fun log(message: String) {\\n        // No operation\\n    }\\n}\",\"explanation\":\"The refactored code introduces a new interface, CountableLogger, which extends the Logger interface. This adheres to the Interface Segregation Principle (ISP) by allowing clients to depend only on the methods they need. The CountingLogger now implements CountableLogger, which allows it to provide the message count functionality without forcing the SilentLogger to implement it. This change improves the design by ensuring that each logger type only implements the methods relevant to its functionality.\"},\"violation_type\":\"Interface Segregation Principle (ISP)\"}}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\nclass ThreadSafeLogger : Logger {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(\"[THREAD SAFE] $message\")\n        println(\"[THREAD SAFE CONSOLE] $message\")\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogger : Logger {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun log(message: String) {\n        logBuffer.add(\"[UNSAFE] $message\")\n        println(\"[UNSAFE CONSOLE] $message\")\n    }\n\n    fun getLogBufferContents(): List<String> = logBuffer.toList()\n}",
            "output": "import java.util.concurrent.CopyOnWriteArrayList\n\ninterface Logger {\n    fun log(message: String)\n}\n\ninterface LogBuffer {\n    fun addLog(message: String)\n    fun getLogContents(): List<String>\n}\n\nclass ThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = CopyOnWriteArrayList<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass NonThreadSafeLogBuffer : LogBuffer {\n    private val logBuffer = mutableListOf<String>()\n\n    override fun addLog(message: String) {\n        logBuffer.add(message)\n    }\n\n    override fun getLogContents(): List<String> = logBuffer.toList()\n}\n\nclass LoggerImpl(private val logBuffer: LogBuffer) : Logger {\n    override fun log(message: String) {\n        logBuffer.addLog(message)\n        println(message)\n    }\n}\n\nfun main() {\n    val threadSafeLogger = LoggerImpl(ThreadSafeLogBuffer())\n    threadSafeLogger.log(\"This is a thread-safe log message.\")\n\n    val nonThreadSafeLogger = LoggerImpl(NonThreadSafeLogBuffer())\n    nonThreadSafeLogger.log(\"This is a non-thread-safe log message.\")\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the logger classes are responsible for both logging messages and managing their own log buffers. In the refactored code, I introduced a separate interface `LogBuffer` and two implementations (`ThreadSafeLogBuffer` and `NonThreadSafeLogBuffer`) to handle the log storage. The `LoggerImpl` class now only handles logging messages and delegates the storage responsibility to the `LogBuffer` implementations. This separation of concerns makes the code more maintainable and adheres to the SRP."
        },
        {
            "input": "import kotlin.math.PI\n\ninterface IShape {\n    fun area(): Double\n}\n\nclass Circle(val radius: Double) : IShape {\n    override fun area(): Double {\n        val calculatedArea = PI * radius * radius\n        println(\"Circle Area: $calculatedArea\")\n        return calculatedArea\n    }\n}\n\nclass NullShape : IShape {\n    override fun area(): Double {\n        println(\"Null Shape Area: 0.0 (LSP Compliant)\")\n        return 0.0\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"kotlin\\nimport kotlin.math.PI\\n\\ninterface IShape {\\n    fun area(): Double\\n}\\n\\nclass Circle(val radius: Double) : IShape {\\n    override fun area(): Double {\\n        val calculatedArea = PI  radius  radius\\n        return calculatedArea\\n    }\\n}\\n\\nclass NullShape : IShape {\\n    override fun area(): Double {\\n        return 0.0\\n    }\\n}\\n\\nclass ShapeAreaPrinter(private val shape: IShape) {\\n    fun printArea() {\\n        val area = shape.area()\\n        println(\\\"Area: \\$area\\\")\\n    }\\n}\\n\\nfun main() {\\n    val circle = Circle(5.0)\\n    val nullShape = NullShape()\\n    val circlePrinter = ShapeAreaPrinter(circle)\\n    val nullShapePrinter = ShapeAreaPrinter(nullShape)\\n    circlePrinter.printArea()\\n    nullShapePrinter.printArea()\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The refactored code adheres to the SOLID principles more closely. The Single Responsibility Principle (SRP) is respected by separating the area calculation from the printing logic, which is now handled by the `ShapeAreaPrinter` class. The Open/Closed Principle (OCP) is also respected, as new shapes can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since `NullShape` can be used interchangeably with other shapes without breaking functionality. The Interface Segregation Principle (ISP) is not directly applicable here as the interface is simple and specific. The Dependency Inversion Principle (DIP) is respected by depending on abstractions (the `IShape` interface) rather than concrete implementations.\"},\"violation_type\":\"Liskov Substitution Principle (LSP)\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "import java.io.File\n\ninterface FileStatusProvider {\n    fun getStatus(filePath: String): String\n}\n\ninterface FileProcessor : FileStatusProvider {\n    fun processFile(filePath: String)\n}\n\nclass RealFileProcessor : FileProcessor {\n    override fun getStatus(filePath: String): String {\n        val file = File(filePath)\n        return if (file.exists()) {\n            println(\"RealProcessor: Checking status for $filePath - Ready.\")\n            \"Ready for processing\"\n        }\n        else {\n            println(\"RealProcessor: Checking status for $filePath - Not Found.\")\n            \"File not found\"\n        }\n    }\n\n    override fun processFile(filePath: String) {\n        println(\"RealProcessor: Processing file $filePath...\")\n        val file = File(filePath)\n        if (!file.exists()) {\n             println(\"RealProcessor: Error - File $filePath not found for processing.\")\n            return\n        }\n        println(\"RealProcessor: File $filePath processed successfully.\")\n    }\n}\n\nclass ReadOnlyFileStatusProvider : FileStatusProvider {\n    override fun getStatus(filePath: String): String {\n        println(\"ReadOnlyStatusProvider: Checking status for $filePath - Read-only access.\")\n        val file = File(filePath)\n        return if (file.exists()) {\n            \"Available (Read-only)\"\n        }\n        else {\n            \"File not found (Read-only)\"\n        }\n    }\n}",
            "output": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"import java.io.File\\n\\ninterface FileStatusProvider {\\n    fun getStatus(filePath: String): String\\n}\\n\\ninterface FileProcessor : FileStatusProvider {\\n    fun processFile(filePath: String)\\n}\\n\\nclass RealFileProcessor(private val fileStatusProvider: FileStatusProvider) : FileProcessor {\\n    override fun getStatus(filePath: String): String {\\n        return fileStatusProvider.getStatus(filePath)\\n    }\\n\\n    override fun processFile(filePath: String) {\\n        println(\\\"RealProcessor: Processing file \\$filePath...\\\")\\n        val file = File(filePath)\\n        if (!file.exists()) {\\n            println(\\\"RealProcessor: Error - File \\$filePath not found for processing.\\\")\\n            return\\n        }\\n        println(\\\"RealProcessor: File \\$filePath processed successfully.\\\")\\n    }\\n}\\n\\nclass ReadOnlyFileStatusProvider : FileStatusProvider {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"ReadOnlyStatusProvider: Checking status for \\$filePath - Read-only access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Available (Read-only)\\\"\\n        } else {\\n            \\\"File not found (Read-only)\\\"\\n        }\\n    }\\n}\\n\\nclass WritableFileStatusProvider : FileStatusProvider {\\n    override fun getStatus(filePath: String): String {\\n        println(\\\"WritableStatusProvider: Checking status for \\$filePath - Writable access.\\\")\\n        val file = File(filePath)\\n        return if (file.exists()) {\\n            \\\"Ready for processing\\\"\\n        } else {\\n            \\\"File not found\\\"\\n        }\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `RealFileProcessor` class is responsible for both processing files and checking their status. This has been refactored by introducing separate status provider classes (`ReadOnlyFileStatusProvider` and `WritableFileStatusProvider`) that handle the status checking independently. The `RealFileProcessor` now only processes files and delegates the status checking to the provided `FileStatusProvider`. This separation of concerns improves maintainability and adheres to the SRP.\"}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "class Bird { public virtual void Move() { } } class Ostrich : Bird { public override void Move() { } }",
            "output": "abstract class Bird { public abstract void Move(); } class Ostrich : Bird { public override void Move() { / Ostriches run instead of fly / } } class Sparrow : Bird { public override void Move() { / Sparrows fly / } }",
            "level": "EASY",
            "language": "C#",
            "violation": "Liskov Substitution Principle (LSP)",
            "explanation": "The original code violates the Liskov Substitution Principle because the `Move` method in the `Bird` class does not provide a meaningful implementation for all derived classes. By making `Bird` an abstract class and defining `Move` as an abstract method, we ensure that all subclasses must provide their own implementation of `Move`, which can be tailored to their specific movement behavior."
        },
        {
            "input": "abstract class Shape { public abstract int Area(); } class Rectangle : Shape { public int Width { get; set; } public int Height { get; set; } public override int Area() { return Width * Height; } } class Square : Shape { public int Side { get; set; } public override int Area() { return Side * Side; } }",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"\\\"\\\"\\\"c#\\nusing System;\\n\\ninterface IShape\\n{\\n    int Area();\\n}\\n\\nclass Rectangle : IShape\\n{\\n    public int Width { get; set; }\\n    public int Height { get; set; }\\n    public int Area() => Width  Height;\\n}\\n\\nclass Square : IShape\\n{\\n    public int Side { get; set; }\\n    public int Area() => Side  Side;\\n}\\n\\nclass ShapeAreaCalculator\\n{\\n    public static int CalculateArea(IShape shape)\\n    {\\n        return shape.Area();\\n    }\\n}\\n\\\"\\\"\\\"\",\"explanation\":\"The original code violates the Open/Closed Principle (OCP) because adding new shapes requires modifying the existing code. By introducing an interface (IShape), we allow for new shapes to be added without changing existing classes. This adheres to OCP as new implementations can be created without altering the existing codebase. Additionally, the code is now more flexible and adheres to the Dependency Inversion Principle (DIP) by depending on abstractions rather than concrete classes.\"},\"violation_type\":\"OCP\",\"total_duration\":4695350166}",
            "level": "EASY",
            "language": "C#",
            "violation": "OCP",
            "explanation": ""
        },
        {
            "input": "class Animal { public virtual void Move() { } } class Fish : Animal { public override void Move() { } }",
            "output": "abstract class Animal { public abstract void Move(); } class Fish : Animal { public override void Move() { Console.WriteLine(\"Fish swims\"); } } class Bird : Animal { public override void Move() { Console.WriteLine(\"Bird flies\"); } } class Dog : Animal { public override void Move() { Console.WriteLine(\"Dog runs\"); } }",
            "level": "EASY",
            "language": "C#",
            "violation": "LSP",
            "explanation": "The original code violates the Liskov Substitution Principle (LSP) because the Move method in the base class Animal is not clearly defined for all derived classes. By making Animal an abstract class and defining Move as an abstract method, we ensure that all derived classes must provide their own implementation of Move, thus adhering to LSP. Additionally, I added more animal types (Bird and Dog) to demonstrate the principle more clearly."
        },
        {
            "input": "interface IPayment { void Pay(); } class PaidPayment : IPayment { public void Pay() { } } class FreePayment : IPayment { public void Pay() { } }",
            "output": "interface IPayment { void Pay(); } class PaidPayment : IPayment { public void Pay() { / Logic for paid payment / } } class FreePayment : IPayment { public void Pay() { / Logic for free payment / } } class PaymentProcessor { public void ProcessPayment(IPayment payment) { payment.Pay(); } }",
            "level": "EASY",
            "language": "C#",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the payment types (PaidPayment and FreePayment) are responsible for both defining payment behavior and processing payments. By introducing a PaymentProcessor class, we separate the concerns of payment processing from the payment types themselves, adhering to SRP."
        },
        {
            "input": "interface IFileWriter { void Write(string data); } class FileWriter : IFileWriter { public void Write(string data) { } } class ReadOnlyFileWriter : IFileWriter { public void Write(string data) { } }",
            "output": "interface IFileWriter { void Write(string data); } class FileWriter : IFileWriter { public void Write(string data) { / Implementation for writing to a file / } } class ReadOnlyFileWriter : IFileWriter { public void Write(string data) { throw new InvalidOperationException(\"Cannot write to a read-only file.\"); } } class FileReader { public string Read(string filePath) { / Implementation for reading from a file / return \"\"; } }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the `ReadOnlyFileWriter` class is responsible for both writing and enforcing read-only behavior, which is not its primary responsibility. The refactored code separates the concerns by introducing a `FileReader` class that handles reading from files, while `FileWriter` and `ReadOnlyFileWriter` focus solely on writing behavior. This adheres to SRP by ensuring each class has a single reason to change."
        },
        {
            "input": "abstract class Vehicle { public abstract void Move(); } class Car : Vehicle { public override void Move() { } } class Bicycle : Vehicle { public override void Move() { } }",
            "output": "abstract class Vehicle { public abstract void Move(); } class Car : Vehicle { public override void Move() { / Implementation for Car movement / } } class Bicycle : Vehicle { public override void Move() { / Implementation for Bicycle movement / } } class VehicleMover { public void MoveVehicle(Vehicle vehicle) { vehicle.Move(); } }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the Vehicle class is responsible for both defining the vehicle type and its movement behavior. By introducing a separate VehicleMover class, we adhere to SRP by separating the concerns of vehicle definition and movement execution."
        },
        {
            "input": "interface IDocument { void Print(); } class PaperDocument : IDocument { public void Print() { } } class DigitalDocument : IDocument { public void Print() { } }",
            "output": "interface IDocument { void Print(); } class PaperDocument : IDocument { public void Print() { / Print logic for paper document / } } class DigitalDocument : IDocument { public void Print() { / Print logic for digital document / } } class DocumentPrinter { public void PrintDocument(IDocument document) { document.Print(); } }",
            "level": "MODERATE",
            "language": "C#",
            "violation": "Single Responsibility Principle (SRP)",
            "explanation": "The original code violates the Single Responsibility Principle (SRP) because the printing logic is tightly coupled with the document types. By introducing a separate `DocumentPrinter` class, we adhere to SRP by allowing the document classes to focus solely on their data and behavior, while the `DocumentPrinter` handles the printing functionality."
        },
        {
            "input": "interface ITimer { void Start(); void Stop(); } class RegularTimer : ITimer { public void Start() { } public void Stop() { } } class OneShotTimer : ITimer { public void Start() { } public void Stop() { } }",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"using System;using System.Collections.Generic;interface ITimer { void Start(); void Stop(); }abstract class TimerBase : ITimer { public abstract void Start(); public abstract void Stop(); }class RegularTimer : TimerBase { public override void Start() { Console.WriteLine(\\\"Regular Timer Started\\\"); } public override void Stop() { Console.WriteLine(\\\"Regular Timer Stopped\\\"); }}class OneShotTimer : TimerBase { public override void Start() { Console.WriteLine(\\\"One Shot Timer Started\\\"); } public override void Stop() { Console.WriteLine(\\\"One Shot Timer Stopped\\\"); }}class TimerManager { private List<ITimer> timers = new List<ITimer>(); public void AddTimer(ITimer timer) { timers.Add(timer); } public void StartAll() { foreach (var timer in timers) { timer.Start(); } } public void StopAll() { foreach (var timer in timers) { timer.Stop(); } }}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the ITimer interface does not encapsulate a single responsibility; it allows for different types of timers to be implemented without a clear distinction of their behaviors. The Open/Closed Principle (OCP) is also violated since adding new timer types requires modifying existing code. The refactored code introduces an abstract class TimerBase that provides a common base for all timers, allowing for extensibility without modifying existing code. This adheres to OCP. The refactored code also maintains the Liskov Substitution Principle (LSP) as all derived classes can be used interchangeably without altering the correctness of the program. The Interface Segregation Principle (ISP) is respected as the ITimer interface remains focused on timer functionalities. The Dependency Inversion Principle (DIP) is also respected as higher-level modules (like TimerManager) depend on abstractions (ITimer) rather than concrete implementations. Overall, the refactored code is more maintainable and adheres to SOLID principles better than the original.\"},\"violation_type\":\"Multiple SOLID Violations\",\"total_duration\":7991389750}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "Multiple SOLID Violations",
            "explanation": ""
        },
        {
            "input": "using System;\nusing System.IO;\n\nclass FileStatusProvider\n{\n    public virtual string GetStatus(string filePath)\n    {\n         if (File.Exists(filePath))\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Found.\");\n            return \"Ready for status check\";\n        }\n        else\n        {\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Not Found.\");\n            return \"File not found\";\n        }\n    }\n}\n\nclass FileProcessor : FileStatusProvider\n{\n    public void ProcessFile(string filePath)\n    {\n        Console.WriteLine($\"Processor: Processing file {filePath}...\");\n        if (!File.Exists(filePath))\n        {\n            Console.WriteLine($\"Processor: Error - File {filePath} not found for processing.\");\n            return;\n        }\n        Console.WriteLine($\"Processor: File {filePath} processed successfully.\");\n    }\n\n    public override string GetStatus(string filePath)\n    {\n        string baseStatus = base.GetStatus(filePath);\n        if(baseStatus == \"Ready for status check\") return \"Ready for processing\";\n        return baseStatus;\n    }\n}\n\nclass ReadOnlyFileStatusProvider : FileStatusProvider\n{\n    public override string GetStatus(string filePath)\n    {\n        Console.WriteLine($\"ReadOnlyStatus: Checking status for {filePath} - Read-only access.\");\n        if (File.Exists(filePath))\n        {\n            return \"Available (Read-only)\";\n        }\n        else\n        {\n            return \"File not found (Read-only)\";\n        }\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"using System;\\nusing System.IO;\\n\\ninterface IFileStatusProvider\\n{\\n    string GetStatus(string filePath);\\n}\\n\\nclass FileStatusProvider : IFileStatusProvider\\n{\\n    public virtual string GetStatus(string filePath)\\n    {\\n        if (File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Found.\");\\n            return \\\"Ready for status check\\\";\\n        }\\n        else\\n        {\\n            Console.WriteLine($\"StatusProvider: Checking status for {filePath} - Not Found.\");\\n            return \\\"File not found\\\";\\n        }\\n    }\\n}\\n\\nclass ReadOnlyFileStatusProvider : IFileStatusProvider\\n{\\n    public string GetStatus(string filePath)\\n    {\\n        Console.WriteLine($\"ReadOnlyStatus: Checking status for {filePath} - Read-only access.\");\\n        if (File.Exists(filePath))\\n        {\\n            return \\\"Available (Read-only)\\\";\\n        }\\n        else\\n        {\\n            return \\\"File not found (Read-only)\\\";\\n        }\\n    }\\n}\\n\\nclass FileProcessor\\n{\\n    private readonly IFileStatusProvider _fileStatusProvider;\\n\\n    public FileProcessor(IFileStatusProvider fileStatusProvider)\\n    {\\n        _fileStatusProvider = fileStatusProvider;\\n    }\\n\\n    public void ProcessFile(string filePath)\\n    {\\n        Console.WriteLine($\"Processor: Processing file {filePath}...\");\\n        if (!File.Exists(filePath))\\n        {\\n            Console.WriteLine($\"Processor: Error - File {filePath} not found for processing.\");\\n            return;\\n        }\\n        Console.WriteLine($\"Processor: File {filePath} processed successfully.\");\\n    }\\n\\n    public string GetStatus(string filePath)\\n    {\\n        string baseStatus = _fileStatusProvider.GetStatus(filePath);\\n        if (baseStatus == \\\"Ready for status check\\\") return \\\"Ready for processing\\\";\\n        return baseStatus;\\n    }\\n}\",\"explanation\":\"The refactored code separates the concerns of file status checking and file processing, adhering to the Single Responsibility Principle (SRP). The FileProcessor class now depends on an interface (IFileStatusProvider) rather than a concrete class, which adheres to the Dependency Inversion Principle (DIP). The Open/Closed Principle (OCP) is respected as new status providers can be added without modifying existing code. The Liskov Substitution Principle (LSP) is maintained since all implementations of IFileStatusProvider can be used interchangeably. The Interface Segregation Principle (ISP) is also respected as the interface is focused on a single responsibility.\"}}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\n\ninterface IAccount\n{\n    void Withdraw(decimal amount);\n    decimal GetBalance();\n}\n\nclass ActiveAccount : IAccount\n{\n    private decimal _balance = 1000m;\n\n    public decimal GetBalance()\n    {\n        return _balance;\n    }\n\n    public void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (_balance >= amount)\n        {\n            _balance -= amount;\n            Console.WriteLine($\"Active: Successfully withdrew {amount}. New Balance: {_balance}\");\n        }\n        else\n        {\n            Console.WriteLine($\"Active: Insufficient funds. Cannot withdraw {amount}. Balance: {_balance}\");\n        }\n    }\n}\n\nclass LimitedWithdrawalAccount : IAccount\n{\n    private decimal _balance = 1000m;\n    private const decimal MaxWithdrawalLimit = 50m;\n\n    public decimal GetBalance()\n    {\n        return _balance;\n    }\n\n    public void Withdraw(decimal amount)\n    {\n        if (amount <= 0) return;\n\n        if (amount > MaxWithdrawalLimit)\n        {\n            Console.WriteLine($\"Limited: Withdrawal request ({amount}) exceeds per-transaction limit ({MaxWithdrawalLimit}). No action taken. Balance remains: {_balance}\");\n        }\n        else if (_balance >= amount)\n        {\n            _balance -= amount;\n            Console.WriteLine($\"Limited: Successfully withdrew {amount}. New Balance: {_balance}\");\n        }\n        else\n        {\n             Console.WriteLine($\"Limited: Insufficient funds for withdrawal ({amount}). Balance: {_balance}\");\n        }\n    }\n}",
            "output": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\n\\ninterface IAccount\\n{\\n    void Withdraw(decimal amount);\\n    decimal GetBalance();\\n}\\n\\nabstract class AccountBase : IAccount\\n{\\n    protected decimal _balance;\\n\\n    public decimal GetBalance()\\n    {\\n        return _balance;\\n    }\\n}\\n\\nclass ActiveAccount : AccountBase\\n{\\n    public ActiveAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Active\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Active\\\");\\n        }\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds. Cannot withdraw {amount}. Balance: {_balance}\");\\n    }\\n}\\n\\nclass LimitedWithdrawalAccount : AccountBase\\n{\\n    private const decimal MaxWithdrawalLimit = 50m;\\n\\n    public LimitedWithdrawalAccount()\\n    {\\n        _balance = 1000m;\\n    }\\n\\n    public void Withdraw(decimal amount)\\n    {\\n        if (amount <= 0) return;\\n\\n        if (amount > MaxWithdrawalLimit)\\n        {\\n            LogExceedsLimit(amount, MaxWithdrawalLimit, \\\"Limited\\\");\\n        }\\n        else if (_balance >= amount)\\n        {\\n            _balance -= amount;\\n            LogWithdrawal(amount, \\\"Limited\\\");\\n        }\\n        else\\n        {\\n            LogInsufficientFunds(amount, \\\"Limited\\\");\\n        }\\n    }\\n\\n    private void LogExceedsLimit(decimal amount, decimal limit, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Withdrawal request ({amount}) exceeds per-transaction limit ({limit}). No action taken. Balance remains: {_balance}\");\\n    }\\n\\n    private void LogWithdrawal(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Successfully withdrew {amount}. New Balance: {_balance}\");\\n    }\\n\\n    private void LogInsufficientFunds(decimal amount, string accountType)\\n    {\\n        Console.WriteLine($\"{accountType}: Insufficient funds for withdrawal ({amount}). Balance: {_balance}\");\\n    }\\n}\",\"explanation\":\"The refactored code addresses the Single Responsibility Principle (SRP) violation by creating an abstract base class `AccountBase` that handles the common functionality of getting the balance. Each account type now only focuses on its specific withdrawal logic. Additionally, logging methods have been extracted to avoid code duplication and improve maintainability.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\n\nclass Logger\n{\n    public virtual void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}\n\nclass LoggerWithIncorrectTimestamp : Logger\n{\n    private readonly DateTime _creationTime = DateTime.Now;\n\n    public override void Log(string message)\n    {\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\n        Console.WriteLine(formattedMessage);\n    }\n}",
            "output": "{\"required\":[\"violation_type\",\"refactored_code\",\"explanation\"],\"type\":\"object\",\"properties\":{\"refactored_code\":\"using System;\\n\\ninterface ILogger\\n{\\n    void Log(string message);\\n}\\n\\nclass ConsoleLogger : ILogger\\n{\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        Console.WriteLine(formattedMessage);\\n    }\\n}\\n\\nclass LoggerWithIncorrectTimestamp : ILogger\\n{\\n    private readonly ILogger _logger;\\n    private readonly DateTime _creationTime = DateTime.Now;\\n\\n    public LoggerWithIncorrectTimestamp(ILogger logger)\\n    {\\n        _logger = logger;\\n    }\\n\\n    public void Log(string message)\\n    {\\n        string formattedMessage = $\"[{_creationTime:yyyy-MM-dd HH:mm:ss}] {message}\";\\n        _logger.Log(formattedMessage);\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the Logger class is responsible for both logging messages and formatting them with timestamps. It also violates the Dependency Inversion Principle (DIP) because the Logger class is tightly coupled to the Console output. The refactored code introduces an ILogger interface to decouple the logging functionality from the implementation, allowing for better adherence to SOLID principles. The ConsoleLogger class handles the actual logging to the console, while LoggerWithIncorrectTimestamp uses an ILogger instance to log messages with a fixed timestamp.\"},\"violation_type\":\"SRP, DIP\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        },
        {
            "input": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic interface ICollectionProcessor\n{\n    void ProcessCollection(IEnumerable<string> data);\n}\n\npublic class StandardCollectionProcessor : ICollectionProcessor\n{\n    public void ProcessCollection(IEnumerable<string> data)\n    {\n        Console.WriteLine(\"[StandardProcessor] Starting processing...\");\n        foreach (var item in data.ToList())\n        {\n            Console.WriteLine($\"[StandardProcessor] Processing item: {item}\");\n            System.Threading.Thread.Sleep(10);\n        }\n        Console.WriteLine(\"[StandardProcessor] Processing finished.\");\n    }\n}\n",
            "output": "{\"violation_type\":\"Single Responsibility Principle (SRP)\",\"refactored_code\":\"using System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\n\\npublic interface ICollectionProcessor\\n{\\n    void ProcessCollection(IEnumerable<string> data);\\n}\\n\\npublic class StandardCollectionProcessor : ICollectionProcessor\\n{\\n    public void ProcessCollection(IEnumerable<string> data)\\n    {\\n        Console.WriteLine(\\\"[StandardProcessor] Starting processing...\\\");\\n        foreach (var item in data.ToList())\\n        {\\n            ProcessItem(item);\\n        }\\n        Console.WriteLine(\\\"[StandardProcessor] Processing finished.\\\");\\n    }\\n\\n    private void ProcessItem(string item)\\n    {\\n        Console.WriteLine($\"[StandardProcessor] Processing item: {item}\");\\n        System.Threading.Thread.Sleep(10);\\n    }\\n}\\n\\npublic class LoggingCollectionProcessor : ICollectionProcessor\\n{\\n    private readonly ICollectionProcessor _innerProcessor;\\n\\n    public LoggingCollectionProcessor(ICollectionProcessor innerProcessor)\\n    {\\n        _innerProcessor = innerProcessor;\\n    }\\n\\n    public void ProcessCollection(IEnumerable<string> data)\\n    {\\n        Console.WriteLine(\\\"[LoggingProcessor] Starting logging...\\\");\\n        _innerProcessor.ProcessCollection(data);\\n        Console.WriteLine(\\\"[LoggingProcessor] Finished logging.\\\");\\n    }\\n}\",\"explanation\":\"The original code violates the Single Responsibility Principle (SRP) because the `StandardCollectionProcessor` class is responsible for both processing the collection and logging the processing steps. In the refactored code, I separated the logging functionality into a new class called `LoggingCollectionProcessor`, which wraps around the original processor. This way, each class has a single responsibility: `StandardCollectionProcessor` focuses on processing the collection, while `LoggingCollectionProcessor` handles logging. This adheres to the SRP and makes the code more maintainable and extensible.\"}",
            "level": "HARD",
            "language": "C#",
            "violation": "",
            "explanation": ""
        }
    ]
}