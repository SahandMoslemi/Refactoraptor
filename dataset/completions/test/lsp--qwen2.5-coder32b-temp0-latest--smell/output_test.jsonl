{"id": 0, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public class Bird {\n    public void fly() {\n        System.out.println(\"Flying high!\");\n    }\n}\n\npublic class Sparrow extends Bird {\n    @Override\n    public void fly() {\n        System.out.println(\"Sparrow flying fast!\");\n    }\n}\n\npublic class Penguin extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Penguins cannot fly!\");\n    }\n}\n\npublic class BirdWatcher {\n    public void watchBird(Bird bird) {\n        bird.fly();\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class Bird {\n    public void fly() {\n        System.out.println(\"Flying high!\");\n    }\n}\n\npublic class Sparrow extends Bird {\n    @Override\n    public void fly() {\n        System.out.println(\"Sparrow flying fast!\");\n    }\n}\n\npublic class Penguin extends Bird {\n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Penguins cannot fly!\");\n    }\n}\n\npublic class BirdWatcher {\n    public void watchBird(Bird bird) {\n        bird.fly();\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n```java\npublic class OrderProcessor {\n    private DatabaseConnection dbConnection;\n\n    public OrderProcessor(DatabaseConnection dbConnection) {\n        this.dbConnection = dbConnection;\n    }\n\n    public void placeOrder(Order order) {\n        validateOrder(order);\n        saveOrderToDatabase(order);\n        sendConfirmationEmail(order);\n        updateInventory(order);\n    }\n\n    private void validateOrder(Order order) {\n        // Validation logic\n    }\n\n    private void saveOrderToDatabase(Order order) {\n        // Database saving logic\n    }\n\n    private void sendConfirmationEmail(Order order) {\n        // Email sending logic\n    }\n\n    private void updateInventory(Order order) {\n        // Inventory updating logic\n    }\n}\n```\n\n**SRP**\n0  \n**OCP**\n2  \n**LSP**\n5  \n**ISP**\n5  \n**DIP**\n3\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 7.195033550262451}
{"id": 1, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "class Bird:\n    def fly(self):\n        print(\"Flying high!\")\n\nclass Sparrow(Bird):\n    def fly(self):\n        print(\"Sparrow flying fast!\")\n\nclass Penguin(Bird):\n    def fly(self):\n        raise NotImplementedError(\"Penguins cannot fly!\")\n\nclass BirdWatcher:\n    def watch_bird(self, bird):\n        bird.fly()", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nclass Bird:\n    def fly(self):\n        print(\"Flying high!\")\n\nclass Sparrow(Bird):\n    def fly(self):\n        print(\"Sparrow flying fast!\")\n\nclass Penguin(Bird):\n    def fly(self):\n        raise NotImplementedError(\"Penguins cannot fly!\")\n\nclass BirdWatcher:\n    def watch_bird(self, bird):\n        bird.fly()", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n```python\nclass UserManager:\n    def __init__(self, database_connection):\n        self.db = database_connection\n\n    def add_user(self, user_data):\n        # Code to add a user to the database\n        pass\n\n    def remove_user(self, user_id):\n        # Code to remove a user from the database\n        pass\n\n    def update_user(self, user_id, new_data):\n        # Code to update user data in the database\n        pass\n\n    def send_welcome_email(self, user_email):\n        # Code to send a welcome email to the user\n        pass\n\n    def calculate_discount(self, user_id):\n        # Code to calculate discount for the user based on their purchase history\n        pass\n\n    def log_user_activity(self, user_id, activity):\n        # Code to log user activity in the system\n        pass\n```\n\nSRP 1  \nOCP 2  \nLSP 3  \nISP 4  \nDIP 5  \n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 8.030795097351074}
{"id": 2, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "open class Bird {\n    open fun fly() {\n        println(\"Flying high!\")\n    }\n}\n\nclass Sparrow : Bird() {\n    override fun fly() {\n        println(\"Sparrow flying fast!\")\n    }\n}\n\nclass Penguin : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException(\"Penguins cannot fly!\")\n    }\n}\n\nclass BirdWatcher {\n    fun watchBird(bird: Bird) {\n        bird.fly()\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nopen class Bird {\n    open fun fly() {\n        println(\"Flying high!\")\n    }\n}\n\nclass Sparrow : Bird() {\n    override fun fly() {\n        println(\"Sparrow flying fast!\")\n    }\n}\n\nclass Penguin : Bird() {\n    override fun fly() {\n        throw UnsupportedOperationException(\"Penguins cannot fly!\")\n    }\n}\n\nclass BirdWatcher {\n    fun watchBird(bird: Bird) {\n        bird.fly()\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n```kotlin\nclass UserManagement {\n    private val users = mutableListOf<User>()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun removeUser(user: User) {\n        users.remove(user)\n    }\n\n    fun sendEmailToAllUsers(subject: String, message: String) {\n        for (user in users) {\n            EmailService.sendEmail(user.email, subject, message)\n        }\n    }\n\n    fun calculateTotalActiveUsers(): Int {\n        return users.count { it.isActive }\n    }\n\n    fun saveUserToFile(user: User, filePath: String) {\n        File(filePath).writeText(Gson().toJson(user))\n    }\n\n    fun loadUserFromFile(filePath: String): User? {\n        return Gson().fromJson(File(filePath).readText(), User::class.java)\n    }\n}\n```", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 6.40451717376709}
{"id": 3, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "public class Bird\n{\n    public virtual void Fly()\n    {\n        Console.WriteLine(\"Flying high!\");\n    }\n}\n\npublic class Sparrow : Bird\n{\n    public override void Fly()\n    {\n        Console.WriteLine(\"Sparrow flying fast!\");\n    }\n}\n\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        throw new NotSupportedException(\"Penguins cannot fly!\");\n    }\n}\n\npublic class BirdWatcher\n{\n    public void WatchBird(Bird bird)\n    {\n        bird.Fly();\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class Bird\n{\n    public virtual void Fly()\n    {\n        Console.WriteLine(\"Flying high!\");\n    }\n}\n\npublic class Sparrow : Bird\n{\n    public override void Fly()\n    {\n        Console.WriteLine(\"Sparrow flying fast!\");\n    }\n}\n\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        throw new NotSupportedException(\"Penguins cannot fly!\");\n    }\n}\n\npublic class BirdWatcher\n{\n    public void WatchBird(Bird bird)\n    {\n        bird.Fly();\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n```csharp\npublic class OrderProcessor\n{\n    public void ProcessOrder(Order order)\n    {\n        ValidateOrder(order);\n        CalculateTotal(order);\n        ApplyDiscounts(order);\n        SaveOrderToDatabase(order);\n        SendConfirmationEmail(order);\n        UpdateInventory(order);\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic here\n    }\n\n    private void CalculateTotal(Order order)\n    {\n        // Calculation logic here\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount logic here\n    }\n\n    private void SaveOrderToDatabase(Order order)\n    {\n        // Database save logic here\n    }\n\n    private void SendConfirmationEmail(Order order)\n    {\n        // Email sending logic here\n    }\n\n    private void UpdateInventory(Order order)\n    {\n        // Inventory update logic here\n    }\n}\n```\n\n**SRP**\n0  \n**OCP**\n2  \n**LSP**\n5  \n**ISP**\n5  \n**DIP**\n3\n\n**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 8.148781538009644}
{"id": 4, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public abstract class Bird {\n    protected String species;\n    protected double wingSpan;\n    \n    public Bird(String species, double wingSpan) {\n        this.species = species;\n        this.wingSpan = wingSpan;\n    }\n    \n    public abstract void fly();\n    public abstract double getFlightSpeed();\n    \n    public String getSpecies() {\n        return species;\n    }\n    \n    public double getWingSpan() {\n        return wingSpan;\n    }\n}\n\npublic class Eagle extends Bird {\n    public Eagle(double wingSpan) {\n        super(\"Eagle\", wingSpan);\n    }\n    \n    @Override\n    public void fly() {\n        System.out.println(\"Eagle soaring at high altitude with \" + wingSpan + \"m wingspan\");\n    }\n    \n    @Override\n    public double getFlightSpeed() {\n        return 80.0 + (wingSpan * 10);\n    }\n}\n\npublic class Hummingbird extends Bird {\n    public Hummingbird(double wingSpan) {\n        super(\"Hummingbird\", wingSpan);\n    }\n    \n    @Override\n    public void fly() {\n        System.out.println(\"Hummingbird hovering with rapid wing beats\");\n    }\n    \n    @Override\n    public double getFlightSpeed() {\n        return 50.0;\n    }\n}\n\npublic class Ostrich extends Bird {\n    private double runningSpeed;\n    \n    public Ostrich(double wingSpan, double runningSpeed) {\n        super(\"Ostrich\", wingSpan);\n        this.runningSpeed = runningSpeed;\n    }\n    \n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Ostriches are flightless birds!\");\n    }\n    \n    @Override\n    public double getFlightSpeed() {\n        return 0.0;\n    }\n    \n    public void run() {\n        System.out.println(\"Ostrich running at \" + runningSpeed + \" km/h\");\n    }\n}\n\npublic class FlightSimulator {\n    public void simulateFlight(Bird bird, double distance) {\n        System.out.println(\"Starting flight simulation for \" + bird.getSpecies());\n        bird.fly();\n        double speed = bird.getFlightSpeed();\n        double time = distance / speed;\n        System.out.println(\"Flight time: \" + time + \" hours for \" + distance + \" km\");\n    }\n    \n    public void compareFlightCapabilities(Bird[] birds, double testDistance) {\n        for (Bird bird : birds) {\n            simulateFlight(bird, testDistance);\n            System.out.println(\"---\");\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic abstract class Bird {\n    protected String species;\n    protected double wingSpan;\n    \n    public Bird(String species, double wingSpan) {\n        this.species = species;\n        this.wingSpan = wingSpan;\n    }\n    \n    public abstract void fly();\n    public abstract double getFlightSpeed();\n    \n    public String getSpecies() {\n        return species;\n    }\n    \n    public double getWingSpan() {\n        return wingSpan;\n    }\n}\n\npublic class Eagle extends Bird {\n    public Eagle(double wingSpan) {\n        super(\"Eagle\", wingSpan);\n    }\n    \n    @Override\n    public void fly() {\n        System.out.println(\"Eagle soaring at high altitude with \" + wingSpan + \"m wingspan\");\n    }\n    \n    @Override\n    public double getFlightSpeed() {\n        return 80.0 + (wingSpan * 10);\n    }\n}\n\npublic class Hummingbird extends Bird {\n    public Hummingbird(double wingSpan) {\n        super(\"Hummingbird\", wingSpan);\n    }\n    \n    @Override\n    public void fly() {\n        System.out.println(\"Hummingbird hovering with rapid wing beats\");\n    }\n    \n    @Override\n    public double getFlightSpeed() {\n        return 50.0;\n    }\n}\n\npublic class Ostrich extends Bird {\n    private double runningSpeed;\n    \n    public Ostrich(double wingSpan, double runningSpeed) {\n        super(\"Ostrich\", wingSpan);\n        this.runningSpeed = runningSpeed;\n    }\n    \n    @Override\n    public void fly() {\n        throw new UnsupportedOperationException(\"Ostriches are flightless birds!\");\n    }\n    \n    @Override\n    public double getFlightSpeed() {\n        return 0.0;\n    }\n    \n    public void run() {\n        System.out.println(\"Ostrich running at \" + runningSpeed + \" km/h\");\n    }\n}\n\npublic class FlightSimulator {\n    public void simulateFlight(Bird bird, double distance) {\n        System.out.println(\"Starting flight simulation for \" + bird.getSpecies());\n        bird.fly();\n        double speed = bird.getFlightSpeed();\n        double time = distance / speed;\n        System.out.println(\"Flight time: \" + time + \" hours for \" + distance + \" km\");\n    }\n    \n    public void compareFlightCapabilities(Bird[] birds, double testDistance) {\n        for (Bird bird : birds) {\n            simulateFlight(bird, testDistance);\n            System.out.println(\"---\");\n        }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor {\n    private DatabaseConnection db;\n    \n    public OrderProcessor(DatabaseConnection db) {\n        this.db = db;\n    }\n    \n    public void processOrder(Order order) {\n        validateOrder(order);\n        calculateTotal(order);\n        saveOrderToDatabase(order);\n        sendConfirmationEmail(order);\n        updateInventory(order);\n    }\n    \n    private void validateOrder(Order order) {\n        // Validation logic\n    }\n    \n    private void calculateTotal(Order order) {\n        // Calculation logic\n    }\n    \n    private void saveOrderToDatabase(Order order) {\n        db.save(order);\n    }\n    \n    private void sendConfirmationEmail(Order order) {\n        // Email sending logic\n    }\n    \n    private void updateInventory(Order order) {\n        // Inventory update logic\n    }\n}\n\n**SRP: 1**\n**OCP: 2**\n**LSP: 5**\n**ISP: 5**\n**DIP: 3**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor {\n    private DatabaseConnection db;\n    \n    public OrderProcessor(DatabaseConnection db) {\n        this.db = db;\n    }\n    \n    public void processOrder(Order order) {\n        validateOrder(order);\n        calculateTotal(order);\n        saveOrderToDatabase(order);\n        sendConfirmationEmail(order);\n        updateInventory(order);\n    }\n    \n    private void validateOrder(Order order) {\n        // Validation logic\n    }\n    \n    private void calculateTotal(Order order) {\n        // Calculation logic\n    }\n    \n    private void saveOrderToDatabase(Order order) {\n        db.save(order);\n    }\n    \n    private void sendConfirmationEmail(Order order) {\n        // Email sending logic\n    }\n    \n    private void updateInventory(Order order) {\n        // Inventory update logic\n    }\n}\n\n**SRP: 1**\n**OCP: 2**\n**LSP: 5**\n**ISP: 5**\n**DIP: 3**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 8.250348091125488}
{"id": 5, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\n\nclass Bird(ABC):\n    def __init__(self, species, wing_span):\n        self.species = species\n        self.wing_span = wing_span\n    \n    @abstractmethod\n    def fly(self):\n        pass\n    \n    @abstractmethod\n    def get_flight_speed(self):\n        pass\n    \n    def get_species(self):\n        return self.species\n    \n    def get_wing_span(self):\n        return self.wing_span\n\nclass Eagle(Bird):\n    def __init__(self, wing_span):\n        super().__init__(\"Eagle\", wing_span)\n    \n    def fly(self):\n        print(f\"Eagle soaring at high altitude with {self.wing_span}m wingspan\")\n    \n    def get_flight_speed(self):\n        return 80.0 + (self.wing_span * 10)\n\nclass Hummingbird(Bird):\n    def __init__(self, wing_span):\n        super().__init__(\"Hummingbird\", wing_span)\n    \n    def fly(self):\n        print(\"Hummingbird hovering with rapid wing beats\")\n    \n    def get_flight_speed(self):\n        return 50.0\n\nclass Ostrich(Bird):\n    def __init__(self, wing_span, running_speed):\n        super().__init__(\"Ostrich\", wing_span)\n        self.running_speed = running_speed\n    \n    def fly(self):\n        raise NotImplementedError(\"Ostriches are flightless birds!\")\n    \n    def get_flight_speed(self):\n        return 0.0\n    \n    def run(self):\n        print(f\"Ostrich running at {self.running_speed} km/h\")\n\nclass FlightSimulator:\n    def simulate_flight(self, bird, distance):\n        print(f\"Starting flight simulation for {bird.get_species()}\")\n        bird.fly()\n        speed = bird.get_flight_speed()\n        time = distance / speed if speed > 0 else 0\n        print(f\"Flight time: {time} hours for {distance} km\")\n    \n    def compare_flight_capabilities(self, birds, test_distance):\n        for bird in birds:\n            self.simulate_flight(bird, test_distance)\n            print(\"---\")", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\n\nclass Bird(ABC):\n    def __init__(self, species, wing_span):\n        self.species = species\n        self.wing_span = wing_span\n    \n    @abstractmethod\n    def fly(self):\n        pass\n    \n    @abstractmethod\n    def get_flight_speed(self):\n        pass\n    \n    def get_species(self):\n        return self.species\n    \n    def get_wing_span(self):\n        return self.wing_span\n\nclass Eagle(Bird):\n    def __init__(self, wing_span):\n        super().__init__(\"Eagle\", wing_span)\n    \n    def fly(self):\n        print(f\"Eagle soaring at high altitude with {self.wing_span}m wingspan\")\n    \n    def get_flight_speed(self):\n        return 80.0 + (self.wing_span * 10)\n\nclass Hummingbird(Bird):\n    def __init__(self, wing_span):\n        super().__init__(\"Hummingbird\", wing_span)\n    \n    def fly(self):\n        print(\"Hummingbird hovering with rapid wing beats\")\n    \n    def get_flight_speed(self):\n        return 50.0\n\nclass Ostrich(Bird):\n    def __init__(self, wing_span, running_speed):\n        super().__init__(\"Ostrich\", wing_span)\n        self.running_speed = running_speed\n    \n    def fly(self):\n        raise NotImplementedError(\"Ostriches are flightless birds!\")\n    \n    def get_flight_speed(self):\n        return 0.0\n    \n    def run(self):\n        print(f\"Ostrich running at {self.running_speed} km/h\")\n\nclass FlightSimulator:\n    def simulate_flight(self, bird, distance):\n        print(f\"Starting flight simulation for {bird.get_species()}\")\n        bird.fly()\n        speed = bird.get_flight_speed()\n        time = distance / speed if speed > 0 else 0\n        print(f\"Flight time: {time} hours for {distance} km\")\n    \n    def compare_flight_capabilities(self, birds, test_distance):\n        for bird in birds:\n            self.simulate_flight(bird, test_distance)\n            print(\"---\")", "raw_response": "**LSP**\nThis class violates the Liskov Substitution Principle because the `Ostrich` class raises a `NotImplementedError` when its `fly` method is called. This breaks the expectation that all `Bird` objects can fly, as defined by the abstract method in the `Bird` class.", "violation": "LSP", "violation_list": ["LSP"], "explanation": "**LSP**\nThis class violates the Liskov Substitution Principle because the `Ostrich` class raises a `NotImplementedError` when its `fly` method is called. This breaks the expectation that all `Bird` objects can fly, as defined by the abstract method in the `Bird` class.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.711538553237915}
{"id": 6, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "abstract class Bird(val species: String, val wingSpan: Double) {\n    abstract fun fly()\n    abstract fun getFlightSpeed(): Double\n    \n    fun getSpecies(): String = species\n    fun getWingSpan(): Double = wingSpan\n}\n\nclass Eagle(wingSpan: Double) : Bird(\"Eagle\", wingSpan) {\n    override fun fly() {\n        println(\"Eagle soaring at high altitude with ${wingSpan}m wingspan\")\n    }\n    \n    override fun getFlightSpeed(): Double {\n        return 80.0 + (wingSpan * 10)\n    }\n}\n\nclass Hummingbird(wingSpan: Double) : Bird(\"Hummingbird\", wingSpan) {\n    override fun fly() {\n        println(\"Hummingbird hovering with rapid wing beats\")\n    }\n    \n    override fun getFlightSpeed(): Double {\n        return 50.0\n    }\n}\n\nclass Ostrich(wingSpan: Double, private val runningSpeed: Double) : Bird(\"Ostrich\", wingSpan) {\n    override fun fly() {\n        throw UnsupportedOperationException(\"Ostriches are flightless birds!\")\n    }\n    \n    override fun getFlightSpeed(): Double {\n        return 0.0\n    }\n    \n    fun run() {\n        println(\"Ostrich running at $runningSpeed km/h\")\n    }\n}\n\nclass FlightSimulator {\n    fun simulateFlight(bird: Bird, distance: Double) {\n        println(\"Starting flight simulation for ${bird.getSpecies()}\")\n        bird.fly()\n        val speed = bird.getFlightSpeed()\n        val time = if (speed > 0) distance / speed else 0.0\n        println(\"Flight time: $time hours for $distance km\")\n    }\n    \n    fun compareFlightCapabilities(birds: Array<Bird>, testDistance: Double) {\n        birds.forEach { bird ->\n            simulateFlight(bird, testDistance)\n            println(\"---\")\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nabstract class Bird(val species: String, val wingSpan: Double) {\n    abstract fun fly()\n    abstract fun getFlightSpeed(): Double\n    \n    fun getSpecies(): String = species\n    fun getWingSpan(): Double = wingSpan\n}\n\nclass Eagle(wingSpan: Double) : Bird(\"Eagle\", wingSpan) {\n    override fun fly() {\n        println(\"Eagle soaring at high altitude with ${wingSpan}m wingspan\")\n    }\n    \n    override fun getFlightSpeed(): Double {\n        return 80.0 + (wingSpan * 10)\n    }\n}\n\nclass Hummingbird(wingSpan: Double) : Bird(\"Hummingbird\", wingSpan) {\n    override fun fly() {\n        println(\"Hummingbird hovering with rapid wing beats\")\n    }\n    \n    override fun getFlightSpeed(): Double {\n        return 50.0\n    }\n}\n\nclass Ostrich(wingSpan: Double, private val runningSpeed: Double) : Bird(\"Ostrich\", wingSpan) {\n    override fun fly() {\n        throw UnsupportedOperationException(\"Ostriches are flightless birds!\")\n    }\n    \n    override fun getFlightSpeed(): Double {\n        return 0.0\n    }\n    \n    fun run() {\n        println(\"Ostrich running at $runningSpeed km/h\")\n    }\n}\n\nclass FlightSimulator {\n    fun simulateFlight(bird: Bird, distance: Double) {\n        println(\"Starting flight simulation for ${bird.getSpecies()}\")\n        bird.fly()\n        val speed = bird.getFlightSpeed()\n        val time = if (speed > 0) distance / speed else 0.0\n        println(\"Flight time: $time hours for $distance km\")\n    }\n    \n    fun compareFlightCapabilities(birds: Array<Bird>, testDistance: Double) {\n        birds.forEach { bird ->\n            simulateFlight(bird, testDistance)\n            println(\"---\")\n        }\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nclass OrderProcessor {\n    fun placeOrder(orderId: String, items: List<Item>, customer: Customer) {\n        validateOrder(items)\n        calculateTotal(items)\n        applyDiscounts(customer, items)\n        saveOrderToDatabase(orderId, items, customer)\n        sendConfirmationEmail(customer.email)\n        updateInventory(items)\n        logTransaction(orderId, customer.id)\n    }\n\n    private fun validateOrder(items: List<Item>) {\n        // Validation logic\n    }\n\n    private fun calculateTotal(items: List<Item>): Double {\n        // Calculation logic\n        return 0.0\n    }\n\n    private fun applyDiscounts(customer: Customer, items: List<Item>) {\n        // Discount logic\n    }\n\n    private fun saveOrderToDatabase(orderId: String, items: List<Item>, customer: Customer) {\n        // Database interaction logic\n    }\n\n    private fun sendConfirmationEmail(email: String) {\n        // Email sending logic\n    }\n\n    private fun updateInventory(items: List<Item>) {\n        // Inventory update logic\n    }\n\n    private fun logTransaction(orderId: String, customerId: String) {\n        // Logging logic\n    }\n}\n\n**SRP**\n0\n**OCP**\n1\n**LSP**\n5\n**ISP**\n5\n**DIP**\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nclass OrderProcessor {\n    fun placeOrder(orderId: String, items: List<Item>, customer: Customer) {\n        validateOrder(items)\n        calculateTotal(items)\n        applyDiscounts(customer, items)\n        saveOrderToDatabase(orderId, items, customer)\n        sendConfirmationEmail(customer.email)\n        updateInventory(items)\n        logTransaction(orderId, customer.id)\n    }\n\n    private fun validateOrder(items: List<Item>) {\n        // Validation logic\n    }\n\n    private fun calculateTotal(items: List<Item>): Double {\n        // Calculation logic\n        return 0.0\n    }\n\n    private fun applyDiscounts(customer: Customer, items: List<Item>) {\n        // Discount logic\n    }\n\n    private fun saveOrderToDatabase(orderId: String, items: List<Item>, customer: Customer) {\n        // Database interaction logic\n    }\n\n    private fun sendConfirmationEmail(email: String) {\n        // Email sending logic\n    }\n\n    private fun updateInventory(items: List<Item>) {\n        // Inventory update logic\n    }\n\n    private fun logTransaction(orderId: String, customerId: String) {\n        // Logging logic\n    }\n}\n\n**SRP**\n0\n**OCP**\n1\n**LSP**\n5\n**ISP**\n5\n**DIP**\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 10.4236581325531}
{"id": 7, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "public abstract class Bird\n{\n    protected string species;\n    protected double wingSpan;\n    \n    public Bird(string species, double wingSpan)\n    {\n        this.species = species;\n        this.wingSpan = wingSpan;\n    }\n    \n    public abstract void Fly();\n    public abstract double GetFlightSpeed();\n    \n    public string GetSpecies() => species;\n    public double GetWingSpan() => wingSpan;\n}\n\npublic class Eagle : Bird\n{\n    public Eagle(double wingSpan) : base(\"Eagle\", wingSpan) { }\n    \n    public override void Fly()\n    {\n        Console.WriteLine($\"Eagle soaring at high altitude with {wingSpan}m wingspan\");\n    }\n    \n    public override double GetFlightSpeed()\n    {\n        return 80.0 + (wingSpan * 10);\n    }\n}\n\npublic class Hummingbird : Bird\n{\n    public Hummingbird(double wingSpan) : base(\"Hummingbird\", wingSpan) { }\n    \n    public override void Fly()\n    {\n        Console.WriteLine(\"Hummingbird hovering with rapid wing beats\");\n    }\n    \n    public override double GetFlightSpeed()\n    {\n        return 50.0;\n    }\n}\n\npublic class Ostrich : Bird\n{\n    private double runningSpeed;\n    \n    public Ostrich(double wingSpan, double runningSpeed) : base(\"Ostrich\", wingSpan)\n    {\n        this.runningSpeed = runningSpeed;\n    }\n    \n    public override void Fly()\n    {\n        throw new NotSupportedException(\"Ostriches are flightless birds!\");\n    }\n    \n    public override double GetFlightSpeed()\n    {\n        return 0.0;\n    }\n    \n    public void Run()\n    {\n        Console.WriteLine($\"Ostrich running at {runningSpeed} km/h\");\n    }\n}\n\npublic class FlightSimulator\n{\n    public void SimulateFlight(Bird bird, double distance)\n    {\n        Console.WriteLine($\"Starting flight simulation for {bird.GetSpecies()}\");\n        bird.Fly();\n        double speed = bird.GetFlightSpeed();\n        double time = speed > 0 ? distance / speed : 0;\n        Console.WriteLine($\"Flight time: {time} hours for {distance} km\");\n    }\n    \n    public void CompareFlightCapabilities(Bird[] birds, double testDistance)\n    {\n        foreach (var bird in birds)\n        {\n            SimulateFlight(bird, testDistance);\n            Console.WriteLine(\"---\");\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic abstract class Bird\n{\n    protected string species;\n    protected double wingSpan;\n    \n    public Bird(string species, double wingSpan)\n    {\n        this.species = species;\n        this.wingSpan = wingSpan;\n    }\n    \n    public abstract void Fly();\n    public abstract double GetFlightSpeed();\n    \n    public string GetSpecies() => species;\n    public double GetWingSpan() => wingSpan;\n}\n\npublic class Eagle : Bird\n{\n    public Eagle(double wingSpan) : base(\"Eagle\", wingSpan) { }\n    \n    public override void Fly()\n    {\n        Console.WriteLine($\"Eagle soaring at high altitude with {wingSpan}m wingspan\");\n    }\n    \n    public override double GetFlightSpeed()\n    {\n        return 80.0 + (wingSpan * 10);\n    }\n}\n\npublic class Hummingbird : Bird\n{\n    public Hummingbird(double wingSpan) : base(\"Hummingbird\", wingSpan) { }\n    \n    public override void Fly()\n    {\n        Console.WriteLine(\"Hummingbird hovering with rapid wing beats\");\n    }\n    \n    public override double GetFlightSpeed()\n    {\n        return 50.0;\n    }\n}\n\npublic class Ostrich : Bird\n{\n    private double runningSpeed;\n    \n    public Ostrich(double wingSpan, double runningSpeed) : base(\"Ostrich\", wingSpan)\n    {\n        this.runningSpeed = runningSpeed;\n    }\n    \n    public override void Fly()\n    {\n        throw new NotSupportedException(\"Ostriches are flightless birds!\");\n    }\n    \n    public override double GetFlightSpeed()\n    {\n        return 0.0;\n    }\n    \n    public void Run()\n    {\n        Console.WriteLine($\"Ostrich running at {runningSpeed} km/h\");\n    }\n}\n\npublic class FlightSimulator\n{\n    public void SimulateFlight(Bird bird, double distance)\n    {\n        Console.WriteLine($\"Starting flight simulation for {bird.GetSpecies()}\");\n        bird.Fly();\n        double speed = bird.GetFlightSpeed();\n        double time = speed > 0 ? distance / speed : 0;\n        Console.WriteLine($\"Flight time: {time} hours for {distance} km\");\n    }\n    \n    public void CompareFlightCapabilities(Bird[] birds, double testDistance)\n    {\n        foreach (var bird in birds)\n        {\n            SimulateFlight(bird, testDistance);\n            Console.WriteLine(\"---\");\n        }\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor\n{\n    public void ProcessOrder(Order order)\n    {\n        ValidateOrder(order);\n        CalculateTotal(order);\n        ApplyDiscounts(order);\n        SaveOrderToDatabase(order);\n        SendConfirmationEmail(order);\n        UpdateInventory(order);\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic here\n    }\n\n    private void CalculateTotal(Order order)\n    {\n        // Calculation logic here\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount logic here\n    }\n\n    private void SaveOrderToDatabase(Order order)\n    {\n        // Database saving logic here\n    }\n\n    private void SendConfirmationEmail(Order order)\n    {\n        // Email sending logic here\n    }\n\n    private void UpdateInventory(Order order)\n    {\n        // Inventory update logic here\n    }\n}\n\n**SRP**\n0\n**OCP**\n1\n**LSP**\n5\n**ISP**\n5\n**DIP**\n2", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor\n{\n    public void ProcessOrder(Order order)\n    {\n        ValidateOrder(order);\n        CalculateTotal(order);\n        ApplyDiscounts(order);\n        SaveOrderToDatabase(order);\n        SendConfirmationEmail(order);\n        UpdateInventory(order);\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic here\n    }\n\n    private void CalculateTotal(Order order)\n    {\n        // Calculation logic here\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount logic here\n    }\n\n    private void SaveOrderToDatabase(Order order)\n    {\n        // Database saving logic here\n    }\n\n    private void SendConfirmationEmail(Order order)\n    {\n        // Email sending logic here\n    }\n\n    private void UpdateInventory(Order order)\n    {\n        // Inventory update logic here\n    }\n}\n\n**SRP**\n0\n**OCP**\n1\n**LSP**\n5\n**ISP**\n5\n**DIP**\n2", "solution_code": "NO FIX VERSION", "duration_seconds": 7.712708473205566}
{"id": 8, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "import java.util.*;\nimport java.util.concurrent.*;\n\npublic abstract class Bird {\n    protected String species;\n    protected String habitat;\n    protected double wingSpan;\n    protected double weight;\n    protected int maxAltitude;\n    protected boolean isMigratory;\n    \n    public Bird(String species, String habitat, double wingSpan, double weight, int maxAltitude, boolean isMigratory) {\n        this.species = species;\n        this.habitat = habitat;\n        this.wingSpan = wingSpan;\n        this.weight = weight;\n        this.maxAltitude = maxAltitude;\n        this.isMigratory = isMigratory;\n    }\n    \n    public abstract FlightResult performFlight(FlightPlan plan);\n    public abstract double getMaxFlightSpeed();\n    public abstract double getFlightEfficiency();\n    public abstract int getMaxFlightDuration();\n    public abstract boolean canFlyAtAltitude(int altitude);\n    \n    public String getSpecies() { return species; }\n    public String getHabitat() { return habitat; }\n    public double getWingSpan() { return wingSpan; }\n    public double getWeight() { return weight; }\n    public int getMaxAltitude() { return maxAltitude; }\n    public boolean isMigratory() { return isMigratory; }\n}\n\npublic class FlightPlan {\n    private double distance;\n    private int altitude;\n    private String direction;\n    private int plannedDuration;\n    \n    public FlightPlan(double distance, int altitude, String direction, int plannedDuration) {\n        this.distance = distance;\n        this.altitude = altitude;\n        this.direction = direction;\n        this.plannedDuration = plannedDuration;\n    }\n    \n    public double getDistance() { return distance; }\n    public int getAltitude() { return altitude; }\n    public String getDirection() { return direction; }\n    public int getPlannedDuration() { return plannedDuration; }\n}\n\npublic class FlightResult {\n    private boolean successful;\n    private double actualDistance;\n    private int actualDuration;\n    private String status;\n    \n    public FlightResult(boolean successful, double actualDistance, int actualDuration, String status) {\n        this.successful = successful;\n        this.actualDistance = actualDistance;\n        this.actualDuration = actualDuration;\n        this.status = status;\n    }\n    \n    public boolean isSuccessful() { return successful; }\n    public double getActualDistance() { return actualDistance; }\n    public int getActualDuration() { return actualDuration; }\n    public String getStatus() { return status; }\n}\n\npublic class Albatross extends Bird {\n    public Albatross() {\n        super(\"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, true);\n    }\n    \n    @Override\n    public FlightResult performFlight(FlightPlan plan) {\n        if (!canFlyAtAltitude(plan.getAltitude())) {\n            return new FlightResult(false, 0, 0, \"Altitude too high for sustained flight\");\n        }\n        \n        double efficiency = getFlightEfficiency();\n        double actualDistance = plan.getDistance() * efficiency;\n        int actualDuration = (int) (plan.getPlannedDuration() / efficiency);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"Long-distance flight completed successfully\");\n    }\n    \n    @Override\n    public double getMaxFlightSpeed() { return 120.0; }\n    \n    @Override\n    public double getFlightEfficiency() { return 1.2; }\n    \n    @Override\n    public int getMaxFlightDuration() { return 1440; }\n    \n    @Override\n    public boolean canFlyAtAltitude(int altitude) { return altitude <= maxAltitude; }\n}\n\npublic class Falcon extends Bird {\n    public Falcon() {\n        super(\"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, false);\n    }\n    \n    @Override\n    public FlightResult performFlight(FlightPlan plan) {\n        if (!canFlyAtAltitude(plan.getAltitude())) {\n            return new FlightResult(false, 0, 0, \"Altitude exceeds maximum capability\");\n        }\n        \n        double speed = getMaxFlightSpeed();\n        double actualDistance = Math.min(plan.getDistance(), speed * (plan.getPlannedDuration() / 60.0));\n        int actualDuration = (int) (actualDistance / speed * 60);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"High-speed flight completed\");\n    }\n    \n    @Override\n    public double getMaxFlightSpeed() { return 300.0; }\n    \n    @Override\n    public double getFlightEfficiency() { return 0.8; }\n    \n    @Override\n    public int getMaxFlightDuration() { return 180; }\n    \n    @Override\n    public boolean canFlyAtAltitude(int altitude) { return altitude <= maxAltitude; }\n}\n\npublic class Emperor extends Bird {\n    private double swimSpeed;\n    \n    public Emperor() {\n        super(\"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, false);\n        this.swimSpeed = 15.0;\n    }\n    \n    @Override\n    public FlightResult performFlight(FlightPlan plan) {\n        throw new UnsupportedOperationException(\"Emperor penguins are flightless! They can only swim and walk.\");\n    }\n    \n    @Override\n    public double getMaxFlightSpeed() {\n        return 0.0;\n    }\n    \n    @Override\n    public double getFlightEfficiency() {\n        return 0.0;\n    }\n    \n    @Override\n    public int getMaxFlightDuration() {\n        return 0;\n    }\n    \n    @Override\n    public boolean canFlyAtAltitude(int altitude) {\n        return false;\n    }\n    \n    public double getSwimSpeed() { return swimSpeed; }\n    \n    public String swim(double distance) {\n        double time = distance / swimSpeed;\n        return String.format(\"Swimming %.2f km in %.2f hours\", distance, time);\n    }\n}\n\npublic class AdvancedFlightManager {\n    private List<Bird> flock;\n    private ExecutorService flightExecutor;\n    \n    public AdvancedFlightManager() {\n        this.flock = new ArrayList<>();\n        this.flightExecutor = Executors.newFixedThreadPool(10);\n    }\n    \n    public void addBird(Bird bird) {\n        flock.add(bird);\n    }\n    \n    public void executeFormationFlight(FlightPlan plan) {\n        System.out.println(\"=== Formation Flight Execution ===\");\n        System.out.println(\"Flight Plan: \" + plan.getDistance() + \"km at \" + plan.getAltitude() + \"m altitude\");\n        \n        List<Future<FlightResult>> futures = new ArrayList<>();\n        \n        for (Bird bird : flock) {\n            Future<FlightResult> future = flightExecutor.submit(() -> {\n                System.out.println(\"Starting flight for \" + bird.getSpecies());\n                return bird.performFlight(plan);\n            });\n            futures.add(future);\n        }\n        \n        for (int i = 0; i < futures.size(); i++) {\n            try {\n                FlightResult result = futures.get(i).get();\n                Bird bird = flock.get(i);\n                System.out.println(bird.getSpecies() + \": \" + result.getStatus());\n                if (result.isSuccessful()) {\n                    System.out.println(\"  Distance: \" + result.getActualDistance() + \"km, Duration: \" + result.getActualDuration() + \"min\");\n                }\n            } catch (Exception e) {\n                System.out.println(flock.get(i).getSpecies() + \": Flight failed - \" + e.getMessage());\n            }\n            System.out.println(\"---\");\n        }\n    }\n    \n    public void performFlightCapabilityAnalysis() {\n        System.out.println(\"=== Flight Capability Analysis ===\");\n        for (Bird bird : flock) {\n            System.out.println(bird.getSpecies() + \":\");\n            System.out.println(\"  Max Speed: \" + bird.getMaxFlightSpeed() + \" km/h\");\n            System.out.println(\"  Efficiency: \" + bird.getFlightEfficiency());\n            System.out.println(\"  Max Duration: \" + bird.getMaxFlightDuration() + \" minutes\");\n            System.out.println(\"  Max Altitude: \" + bird.getMaxAltitude() + \"m\");\n            System.out.println();\n        }\n    }\n    \n    public void shutdown() {\n        flightExecutor.shutdown();\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic abstract class Bird {\n    protected String species;\n    protected String habitat;\n    protected double wingSpan;\n    protected double weight;\n    protected int maxAltitude;\n    protected boolean isMigratory;\n    \n    public Bird(String species, String habitat, double wingSpan, double weight, int maxAltitude, boolean isMigratory) {\n        this.species = species;\n        this.habitat = habitat;\n        this.wingSpan = wingSpan;\n        this.weight = weight;\n        this.maxAltitude = maxAltitude;\n        this.isMigratory = isMigratory;\n    }\n    \n    public abstract FlightResult performFlight(FlightPlan plan);\n    public abstract double getMaxFlightSpeed();\n    public abstract double getFlightEfficiency();\n    public abstract int getMaxFlightDuration();\n    public abstract boolean canFlyAtAltitude(int altitude);\n    \n    public String getSpecies() { return species; }\n    public String getHabitat() { return habitat; }\n    public double getWingSpan() { return wingSpan; }\n    public double getWeight() { return weight; }\n    public int getMaxAltitude() { return maxAltitude; }\n    public boolean isMigratory() { return isMigratory; }\n}\n\npublic class FlightPlan {\n    private double distance;\n    private int altitude;\n    private String direction;\n    private int plannedDuration;\n    \n    public FlightPlan(double distance, int altitude, String direction, int plannedDuration) {\n        this.distance = distance;\n        this.altitude = altitude;\n        this.direction = direction;\n        this.plannedDuration = plannedDuration;\n    }\n    \n    public double getDistance() { return distance; }\n    public int getAltitude() { return altitude; }\n    public String getDirection() { return direction; }\n    public int getPlannedDuration() { return plannedDuration; }\n}\n\npublic class FlightResult {\n    private boolean successful;\n    private double actualDistance;\n    private int actualDuration;\n    private String status;\n    \n    public FlightResult(boolean successful, double actualDistance, int actualDuration, String status) {\n        this.successful = successful;\n        this.actualDistance = actualDistance;\n        this.actualDuration = actualDuration;\n        this.status = status;\n    }\n    \n    public boolean isSuccessful() { return successful; }\n    public double getActualDistance() { return actualDistance; }\n    public int getActualDuration() { return actualDuration; }\n    public String getStatus() { return status; }\n}\n\npublic class Albatross extends Bird {\n    public Albatross() {\n        super(\"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, true);\n    }\n    \n    @Override\n    public FlightResult performFlight(FlightPlan plan) {\n        if (!canFlyAtAltitude(plan.getAltitude())) {\n            return new FlightResult(false, 0, 0, \"Altitude too high for sustained flight\");\n        }\n        \n        double efficiency = getFlightEfficiency();\n        double actualDistance = plan.getDistance() * efficiency;\n        int actualDuration = (int) (plan.getPlannedDuration() / efficiency);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"Long-distance flight completed successfully\");\n    }\n    \n    @Override\n    public double getMaxFlightSpeed() { return 120.0; }\n    \n    @Override\n    public double getFlightEfficiency() { return 1.2; }\n    \n    @Override\n    public int getMaxFlightDuration() { return 1440; }\n    \n    @Override\n    public boolean canFlyAtAltitude(int altitude) { return altitude <= maxAltitude; }\n}\n\npublic class Falcon extends Bird {\n    public Falcon() {\n        super(\"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, false);\n    }\n    \n    @Override\n    public FlightResult performFlight(FlightPlan plan) {\n        if (!canFlyAtAltitude(plan.getAltitude())) {\n            return new FlightResult(false, 0, 0, \"Altitude exceeds maximum capability\");\n        }\n        \n        double speed = getMaxFlightSpeed();\n        double actualDistance = Math.min(plan.getDistance(), speed * (plan.getPlannedDuration() / 60.0));\n        int actualDuration = (int) (actualDistance / speed * 60);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"High-speed flight completed\");\n    }\n    \n    @Override\n    public double getMaxFlightSpeed() { return 300.0; }\n    \n    @Override\n    public double getFlightEfficiency() { return 0.8; }\n    \n    @Override\n    public int getMaxFlightDuration() { return 180; }\n    \n    @Override\n    public boolean canFlyAtAltitude(int altitude) { return altitude <= maxAltitude; }\n}\n\npublic class Emperor extends Bird {\n    private double swimSpeed;\n    \n    public Emperor() {\n        super(\"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, false);\n        this.swimSpeed = 15.0;\n    }\n    \n    @Override\n    public FlightResult performFlight(FlightPlan plan) {\n        throw new UnsupportedOperationException(\"Emperor penguins are flightless! They can only swim and walk.\");\n    }\n    \n    @Override\n    public double getMaxFlightSpeed() {\n        return 0.0;\n    }\n    \n    @Override\n    public double getFlightEfficiency() {\n        return 0.0;\n    }\n    \n    @Override\n    public int getMaxFlightDuration() {\n        return 0;\n    }\n    \n    @Override\n    public boolean canFlyAtAltitude(int altitude) {\n        return false;\n    }\n    \n    public double getSwimSpeed() { return swimSpeed; }\n    \n    public String swim(double distance) {\n        double time = distance / swimSpeed;\n        return String.format(\"Swimming %.2f km in %.2f hours\", distance, time);\n    }\n}\n\npublic class AdvancedFlightManager {\n    private List<Bird> flock;\n    private ExecutorService flightExecutor;\n    \n    public AdvancedFlightManager() {\n        this.flock = new ArrayList<>();\n        this.flightExecutor = Executors.newFixedThreadPool(10);\n    }\n    \n    public void addBird(Bird bird) {\n        flock.add(bird);\n    }\n    \n    public void executeFormationFlight(FlightPlan plan) {\n        System.out.println(\"=== Formation Flight Execution ===\");\n        System.out.println(\"Flight Plan: \" + plan.getDistance() + \"km at \" + plan.getAltitude() + \"m altitude\");\n        \n        List<Future<FlightResult>> futures = new ArrayList<>();\n        \n        for (Bird bird : flock) {\n            Future<FlightResult> future = flightExecutor.submit(() -> {\n                System.out.println(\"Starting flight for \" + bird.getSpecies());\n                return bird.performFlight(plan);\n            });\n            futures.add(future);\n        }\n        \n        for (int i = 0; i < futures.size(); i++) {\n            try {\n                FlightResult result = futures.get(i).get();\n                Bird bird = flock.get(i);\n                System.out.println(bird.getSpecies() + \": \" + result.getStatus());\n                if (result.isSuccessful()) {\n                    System.out.println(\"  Distance: \" + result.getActualDistance() + \"km, Duration: \" + result.getActualDuration() + \"min\");\n                }\n            } catch (Exception e) {\n                System.out.println(flock.get(i).getSpecies() + \": Flight failed - \" + e.getMessage());\n            }\n            System.out.println(\"---\");\n        }\n    }\n    \n    public void performFlightCapabilityAnalysis() {\n        System.out.println(\"=== Flight Capability Analysis ===\");\n        for (Bird bird : flock) {\n            System.out.println(bird.getSpecies() + \":\");\n            System.out.println(\"  Max Speed: \" + bird.getMaxFlightSpeed() + \" km/h\");\n            System.out.println(\"  Efficiency: \" + bird.getFlightEfficiency());\n            System.out.println(\"  Max Duration: \" + bird.getMaxFlightDuration() + \" minutes\");\n            System.out.println(\"  Max Altitude: \" + bird.getMaxAltitude() + \"m\");\n            System.out.println();\n        }\n    }\n    \n    public void shutdown() {\n        flightExecutor.shutdown();\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing a flock of birds and executing flight plans.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing a flock of birds and executing flight plans.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.6127045154571533}
{"id": 9, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor, Future\nimport threading\nimport time\n\nclass Bird(ABC):\n    def __init__(self, species: str, habitat: str, wing_span: float, weight: float, max_altitude: int, is_migratory: bool):\n        self._species = species\n        self._habitat = habitat\n        self._wing_span = wing_span\n        self._weight = weight\n        self._max_altitude = max_altitude\n        self._is_migratory = is_migratory\n    \n    @abstractmethod\n    def perform_flight(self, plan: 'FlightPlan') -> 'FlightResult':\n        pass\n    \n    @abstractmethod\n    def get_max_flight_speed(self) -> float:\n        pass\n    \n    @abstractmethod\n    def get_flight_efficiency(self) -> float:\n        pass\n    \n    @abstractmethod\n    def get_max_flight_duration(self) -> int:\n        pass\n    \n    @abstractmethod\n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        pass\n    \n    @property\n    def species(self) -> str:\n        return self._species\n    \n    @property\n    def habitat(self) -> str:\n        return self._habitat\n    \n    @property\n    def wing_span(self) -> float:\n        return self._wing_span\n    \n    @property\n    def weight(self) -> float:\n        return self._weight\n    \n    @property\n    def max_altitude(self) -> int:\n        return self._max_altitude\n    \n    @property\n    def is_migratory(self) -> bool:\n        return self._is_migratory\n\nclass FlightPlan:\n    def __init__(self, distance: float, altitude: int, direction: str, planned_duration: int):\n        self._distance = distance\n        self._altitude = altitude\n        self._direction = direction\n        self._planned_duration = planned_duration\n    \n    @property\n    def distance(self) -> float:\n        return self._distance\n    \n    @property\n    def altitude(self) -> int:\n        return self._altitude\n    \n    @property\n    def direction(self) -> str:\n        return self._direction\n    \n    @property\n    def planned_duration(self) -> int:\n        return self._planned_duration\n\nclass FlightResult:\n    def __init__(self, successful: bool, actual_distance: float, actual_duration: int, status: str):\n        self._successful = successful\n        self._actual_distance = actual_distance\n        self._actual_duration = actual_duration\n        self._status = status\n    \n    @property\n    def successful(self) -> bool:\n        return self._successful\n    \n    @property\n    def actual_distance(self) -> float:\n        return self._actual_distance\n    \n    @property\n    def actual_duration(self) -> int:\n        return self._actual_duration\n    \n    @property\n    def status(self) -> str:\n        return self._status\n\nclass Albatross(Bird):\n    def __init__(self):\n        super().__init__(\"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, True)\n    \n    def perform_flight(self, plan: FlightPlan) -> FlightResult:\n        if not self.can_fly_at_altitude(plan.altitude):\n            return FlightResult(False, 0, 0, \"Altitude too high for sustained flight\")\n        \n        efficiency = self.get_flight_efficiency()\n        actual_distance = plan.distance * efficiency\n        actual_duration = int(plan.planned_duration / efficiency)\n        \n        return FlightResult(True, actual_distance, actual_duration, \"Long-distance flight completed successfully\")\n    \n    def get_max_flight_speed(self) -> float:\n        return 120.0\n    \n    def get_flight_efficiency(self) -> float:\n        return 1.2\n    \n    def get_max_flight_duration(self) -> int:\n        return 1440\n    \n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        return altitude <= self.max_altitude\n\nclass Falcon(Bird):\n    def __init__(self):\n        super().__init__(\"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, False)\n    \n    def perform_flight(self, plan: FlightPlan) -> FlightResult:\n        if not self.can_fly_at_altitude(plan.altitude):\n            return FlightResult(False, 0, 0, \"Altitude exceeds maximum capability\")\n        \n        speed = self.get_max_flight_speed()\n        actual_distance = min(plan.distance, speed * (plan.planned_duration / 60.0))\n        actual_duration = int(actual_distance / speed * 60)\n        \n        return FlightResult(True, actual_distance, actual_duration, \"High-speed flight completed\")\n    \n    def get_max_flight_speed(self) -> float:\n        return 300.0\n    \n    def get_flight_efficiency(self) -> float:\n        return 0.8\n    \n    def get_max_flight_duration(self) -> int:\n        return 180\n    \n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        return altitude <= self.max_altitude\n\nclass Emperor(Bird):\n    def __init__(self):\n        super().__init__(\"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, False)\n        self._swim_speed = 15.0\n    \n    def perform_flight(self, plan: FlightPlan) -> FlightResult:\n        raise NotImplementedError(\"Emperor penguins are flightless! They can only swim and walk.\")\n    \n    def get_max_flight_speed(self) -> float:\n        return 0.0\n    \n    def get_flight_efficiency(self) -> float:\n        return 0.0\n    \n    def get_max_flight_duration(self) -> int:\n        return 0\n    \n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        return False\n    \n    @property\n    def swim_speed(self) -> float:\n        return self._swim_speed\n    \n    def swim(self, distance: float) -> str:\n        time_hours = distance / self._swim_speed\n        return f\"Swimming {distance:.2f} km in {time_hours:.2f} hours\"\n\nclass AdvancedFlightManager:\n    def __init__(self):\n        self._flock: List[Bird] = []\n        self._flight_executor = ThreadPoolExecutor(max_workers=10)\n    \n    def add_bird(self, bird: Bird) -> None:\n        self._flock.append(bird)\n    \n    def execute_formation_flight(self, plan: FlightPlan) -> None:\n        print(\"=== Formation Flight Execution ===\")\n        print(f\"Flight Plan: {plan.distance}km at {plan.altitude}m altitude\")\n        \n        futures: List[Future[FlightResult]] = []\n        \n        for bird in self._flock:\n            future = self._flight_executor.submit(self._execute_bird_flight, bird, plan)\n            futures.append(future)\n        \n        for i, future in enumerate(futures):\n            try:\n                result = future.result()\n                bird = self._flock[i]\n                print(f\"{bird.species}: {result.status}\")\n                if result.successful:\n                    print(f\"  Distance: {result.actual_distance}km, Duration: {result.actual_duration}min\")\n            except Exception as e:\n                print(f\"{self._flock[i].species}: Flight failed - {str(e)}\")\n            print(\"---\")\n    \n    def _execute_bird_flight(self, bird: Bird, plan: FlightPlan) -> FlightResult:\n        print(f\"Starting flight for {bird.species}\")\n        return bird.perform_flight(plan)\n    \n    def perform_flight_capability_analysis(self) -> None:\n        print(\"=== Flight Capability Analysis ===\")\n        for bird in self._flock:\n            print(f\"{bird.species}:\")\n            print(f\"  Max Speed: {bird.get_max_flight_speed()} km/h\")\n            print(f\"  Efficiency: {bird.get_flight_efficiency()}\")\n            print(f\"  Max Duration: {bird.get_max_flight_duration()} minutes\")\n            print(f\"  Max Altitude: {bird.max_altitude}m\")\n            print()\n    \n    def shutdown(self) -> None:\n        self._flight_executor.shutdown()", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor, Future\nimport threading\nimport time\n\nclass Bird(ABC):\n    def __init__(self, species: str, habitat: str, wing_span: float, weight: float, max_altitude: int, is_migratory: bool):\n        self._species = species\n        self._habitat = habitat\n        self._wing_span = wing_span\n        self._weight = weight\n        self._max_altitude = max_altitude\n        self._is_migratory = is_migratory\n    \n    @abstractmethod\n    def perform_flight(self, plan: 'FlightPlan') -> 'FlightResult':\n        pass\n    \n    @abstractmethod\n    def get_max_flight_speed(self) -> float:\n        pass\n    \n    @abstractmethod\n    def get_flight_efficiency(self) -> float:\n        pass\n    \n    @abstractmethod\n    def get_max_flight_duration(self) -> int:\n        pass\n    \n    @abstractmethod\n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        pass\n    \n    @property\n    def species(self) -> str:\n        return self._species\n    \n    @property\n    def habitat(self) -> str:\n        return self._habitat\n    \n    @property\n    def wing_span(self) -> float:\n        return self._wing_span\n    \n    @property\n    def weight(self) -> float:\n        return self._weight\n    \n    @property\n    def max_altitude(self) -> int:\n        return self._max_altitude\n    \n    @property\n    def is_migratory(self) -> bool:\n        return self._is_migratory\n\nclass FlightPlan:\n    def __init__(self, distance: float, altitude: int, direction: str, planned_duration: int):\n        self._distance = distance\n        self._altitude = altitude\n        self._direction = direction\n        self._planned_duration = planned_duration\n    \n    @property\n    def distance(self) -> float:\n        return self._distance\n    \n    @property\n    def altitude(self) -> int:\n        return self._altitude\n    \n    @property\n    def direction(self) -> str:\n        return self._direction\n    \n    @property\n    def planned_duration(self) -> int:\n        return self._planned_duration\n\nclass FlightResult:\n    def __init__(self, successful: bool, actual_distance: float, actual_duration: int, status: str):\n        self._successful = successful\n        self._actual_distance = actual_distance\n        self._actual_duration = actual_duration\n        self._status = status\n    \n    @property\n    def successful(self) -> bool:\n        return self._successful\n    \n    @property\n    def actual_distance(self) -> float:\n        return self._actual_distance\n    \n    @property\n    def actual_duration(self) -> int:\n        return self._actual_duration\n    \n    @property\n    def status(self) -> str:\n        return self._status\n\nclass Albatross(Bird):\n    def __init__(self):\n        super().__init__(\"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, True)\n    \n    def perform_flight(self, plan: FlightPlan) -> FlightResult:\n        if not self.can_fly_at_altitude(plan.altitude):\n            return FlightResult(False, 0, 0, \"Altitude too high for sustained flight\")\n        \n        efficiency = self.get_flight_efficiency()\n        actual_distance = plan.distance * efficiency\n        actual_duration = int(plan.planned_duration / efficiency)\n        \n        return FlightResult(True, actual_distance, actual_duration, \"Long-distance flight completed successfully\")\n    \n    def get_max_flight_speed(self) -> float:\n        return 120.0\n    \n    def get_flight_efficiency(self) -> float:\n        return 1.2\n    \n    def get_max_flight_duration(self) -> int:\n        return 1440\n    \n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        return altitude <= self.max_altitude\n\nclass Falcon(Bird):\n    def __init__(self):\n        super().__init__(\"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, False)\n    \n    def perform_flight(self, plan: FlightPlan) -> FlightResult:\n        if not self.can_fly_at_altitude(plan.altitude):\n            return FlightResult(False, 0, 0, \"Altitude exceeds maximum capability\")\n        \n        speed = self.get_max_flight_speed()\n        actual_distance = min(plan.distance, speed * (plan.planned_duration / 60.0))\n        actual_duration = int(actual_distance / speed * 60)\n        \n        return FlightResult(True, actual_distance, actual_duration, \"High-speed flight completed\")\n    \n    def get_max_flight_speed(self) -> float:\n        return 300.0\n    \n    def get_flight_efficiency(self) -> float:\n        return 0.8\n    \n    def get_max_flight_duration(self) -> int:\n        return 180\n    \n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        return altitude <= self.max_altitude\n\nclass Emperor(Bird):\n    def __init__(self):\n        super().__init__(\"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, False)\n        self._swim_speed = 15.0\n    \n    def perform_flight(self, plan: FlightPlan) -> FlightResult:\n        raise NotImplementedError(\"Emperor penguins are flightless! They can only swim and walk.\")\n    \n    def get_max_flight_speed(self) -> float:\n        return 0.0\n    \n    def get_flight_efficiency(self) -> float:\n        return 0.0\n    \n    def get_max_flight_duration(self) -> int:\n        return 0\n    \n    def can_fly_at_altitude(self, altitude: int) -> bool:\n        return False\n    \n    @property\n    def swim_speed(self) -> float:\n        return self._swim_speed\n    \n    def swim(self, distance: float) -> str:\n        time_hours = distance / self._swim_speed\n        return f\"Swimming {distance:.2f} km in {time_hours:.2f} hours\"\n\nclass AdvancedFlightManager:\n    def __init__(self):\n        self._flock: List[Bird] = []\n        self._flight_executor = ThreadPoolExecutor(max_workers=10)\n    \n    def add_bird(self, bird: Bird) -> None:\n        self._flock.append(bird)\n    \n    def execute_formation_flight(self, plan: FlightPlan) -> None:\n        print(\"=== Formation Flight Execution ===\")\n        print(f\"Flight Plan: {plan.distance}km at {plan.altitude}m altitude\")\n        \n        futures: List[Future[FlightResult]] = []\n        \n        for bird in self._flock:\n            future = self._flight_executor.submit(self._execute_bird_flight, bird, plan)\n            futures.append(future)\n        \n        for i, future in enumerate(futures):\n            try:\n                result = future.result()\n                bird = self._flock[i]\n                print(f\"{bird.species}: {result.status}\")\n                if result.successful:\n                    print(f\"  Distance: {result.actual_distance}km, Duration: {result.actual_duration}min\")\n            except Exception as e:\n                print(f\"{self._flock[i].species}: Flight failed - {str(e)}\")\n            print(\"---\")\n    \n    def _execute_bird_flight(self, bird: Bird, plan: FlightPlan) -> FlightResult:\n        print(f\"Starting flight for {bird.species}\")\n        return bird.perform_flight(plan)\n    \n    def perform_flight_capability_analysis(self) -> None:\n        print(\"=== Flight Capability Analysis ===\")\n        for bird in self._flock:\n            print(f\"{bird.species}:\")\n            print(f\"  Max Speed: {bird.get_max_flight_speed()} km/h\")\n            print(f\"  Efficiency: {bird.get_flight_efficiency()}\")\n            print(f\"  Max Duration: {bird.get_max_flight_duration()} minutes\")\n            print(f\"  Max Altitude: {bird.max_altitude}m\")\n            print()\n    \n    def shutdown(self) -> None:\n        self._flight_executor.shutdown()", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing a flock of birds and executing flight plans.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing a flock of birds and executing flight plans.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.608112096786499}
{"id": 10, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "import java.util.concurrent.Executors\nimport java.util.concurrent.Future\nimport java.util.concurrent.ExecutorService\nimport kotlin.math.min\nimport kotlin.math.PI\n\nabstract class Bird(\n    protected val species: String,\n    protected val habitat: String,\n    protected val wingSpan: Double,\n    protected val weight: Double,\n    protected val maxAltitude: Int,\n    protected val isMigratory: Boolean\n) {\n    abstract fun performFlight(plan: FlightPlan): FlightResult\n    abstract fun getMaxFlightSpeed(): Double\n    abstract fun getFlightEfficiency(): Double\n    abstract fun getMaxFlightDuration(): Int\n    abstract fun canFlyAtAltitude(altitude: Int): Boolean\n    \n    fun getSpecies(): String = species\n    fun getHabitat(): String = habitat\n    fun getWingSpan(): Double = wingSpan\n    fun getWeight(): Double = weight\n    fun getMaxAltitude(): Int = maxAltitude\n    fun getIsMigratory(): Boolean = isMigratory\n}\n\ndata class FlightPlan(\n    val distance: Double,\n    val altitude: Int,\n    val direction: String,\n    val plannedDuration: Int\n)\n\ndata class FlightResult(\n    val successful: Boolean,\n    val actualDistance: Double,\n    val actualDuration: Int,\n    val status: String\n)\n\nclass Albatross : Bird(\n    \"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, true\n) {\n    override fun performFlight(plan: FlightPlan): FlightResult {\n        if (!canFlyAtAltitude(plan.altitude)) {\n            return FlightResult(false, 0.0, 0, \"Altitude too high for sustained flight\")\n        }\n        \n        val efficiency = getFlightEfficiency()\n        val actualDistance = plan.distance * efficiency\n        val actualDuration = (plan.plannedDuration / efficiency).toInt()\n        \n        return FlightResult(true, actualDistance, actualDuration, \"Long-distance flight completed successfully\")\n    }\n    \n    override fun getMaxFlightSpeed(): Double = 120.0\n    \n    override fun getFlightEfficiency(): Double = 1.2\n    \n    override fun getMaxFlightDuration(): Int = 1440\n    \n    override fun canFlyAtAltitude(altitude: Int): Boolean = altitude <= maxAltitude\n}\n\nclass Falcon : Bird(\n    \"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, false\n) {\n    override fun performFlight(plan: FlightPlan): FlightResult {\n        if (!canFlyAtAltitude(plan.altitude)) {\n            return FlightResult(false, 0.0, 0, \"Altitude exceeds maximum capability\")\n        }\n        \n        val speed = getMaxFlightSpeed()\n        val actualDistance = min(plan.distance, speed * (plan.plannedDuration / 60.0))\n        val actualDuration = (actualDistance / speed * 60).toInt()\n        \n        return FlightResult(true, actualDistance, actualDuration, \"High-speed flight completed\")\n    }\n    \n    override fun getMaxFlightSpeed(): Double = 300.0\n    \n    override fun getFlightEfficiency(): Double = 0.8\n    \n    override fun getMaxFlightDuration(): Int = 180\n    \n    override fun canFlyAtAltitude(altitude: Int): Boolean = altitude <= maxAltitude\n}\n\nclass Emperor : Bird(\n    \"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, false\n) {\n    private val swimSpeed: Double = 15.0\n    \n    override fun performFlight(plan: FlightPlan): FlightResult {\n        throw UnsupportedOperationException(\"Emperor penguins are flightless! They can only swim and walk.\")\n    }\n    \n    override fun getMaxFlightSpeed(): Double {\n        return 0.0\n    }\n    \n    override fun getFlightEfficiency(): Double {\n        return 0.0\n    }\n    \n    override fun getMaxFlightDuration(): Int {\n        return 0\n    }\n    \n    override fun canFlyAtAltitude(altitude: Int): Boolean {\n        return false\n    }\n    \n    fun getSwimSpeed(): Double = swimSpeed\n    \n    fun swim(distance: Double): String {\n        val time = distance / swimSpeed\n        return \"Swimming %.2f km in %.2f hours\".format(distance, time)\n    }\n}\n\nclass AdvancedFlightManager {\n    private val flock: MutableList<Bird> = mutableListOf()\n    private val flightExecutor: ExecutorService = Executors.newFixedThreadPool(10)\n    \n    fun addBird(bird: Bird) {\n        flock.add(bird)\n    }\n    \n    fun executeFormationFlight(plan: FlightPlan) {\n        println(\"=== Formation Flight Execution ===\")\n        println(\"Flight Plan: ${plan.distance}km at ${plan.altitude}m altitude\")\n        \n        val futures = mutableListOf<Future<FlightResult>>()\n        \n        for (bird in flock) {\n            val future = flightExecutor.submit<FlightResult> {\n                println(\"Starting flight for ${bird.getSpecies()}\")\n                bird.performFlight(plan)\n            }\n            futures.add(future)\n        }\n        \n        for (i in futures.indices) {\n            try {\n                val result = futures[i].get()\n                val bird = flock[i]\n                println(\"${bird.getSpecies()}: ${result.status}\")\n                if (result.successful) {\n                    println(\"  Distance: ${result.actualDistance}km, Duration: ${result.actualDuration}min\")\n                }\n            } catch (e: Exception) {\n                println(\"${flock[i].getSpecies()}: Flight failed - ${e.message}\")\n            }\n            println(\"---\")\n        }\n    }\n    \n    fun performFlightCapabilityAnalysis() {\n        println(\"=== Flight Capability Analysis ===\")\n        for (bird in flock) {\n            println(\"${bird.getSpecies()}:\")\n            println(\"  Max Speed: ${bird.getMaxFlightSpeed()} km/h\")\n            println(\"  Efficiency: ${bird.getFlightEfficiency()}\")\n            println(\"  Max Duration: ${bird.getMaxFlightDuration()} minutes\")\n            println(\"  Max Altitude: ${bird.getMaxAltitude()}m\")\n            println()\n        }\n    }\n    \n    fun shutdown() {\n        flightExecutor.shutdown()\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport java.util.concurrent.Executors\nimport java.util.concurrent.Future\nimport java.util.concurrent.ExecutorService\nimport kotlin.math.min\nimport kotlin.math.PI\n\nabstract class Bird(\n    protected val species: String,\n    protected val habitat: String,\n    protected val wingSpan: Double,\n    protected val weight: Double,\n    protected val maxAltitude: Int,\n    protected val isMigratory: Boolean\n) {\n    abstract fun performFlight(plan: FlightPlan): FlightResult\n    abstract fun getMaxFlightSpeed(): Double\n    abstract fun getFlightEfficiency(): Double\n    abstract fun getMaxFlightDuration(): Int\n    abstract fun canFlyAtAltitude(altitude: Int): Boolean\n    \n    fun getSpecies(): String = species\n    fun getHabitat(): String = habitat\n    fun getWingSpan(): Double = wingSpan\n    fun getWeight(): Double = weight\n    fun getMaxAltitude(): Int = maxAltitude\n    fun getIsMigratory(): Boolean = isMigratory\n}\n\ndata class FlightPlan(\n    val distance: Double,\n    val altitude: Int,\n    val direction: String,\n    val plannedDuration: Int\n)\n\ndata class FlightResult(\n    val successful: Boolean,\n    val actualDistance: Double,\n    val actualDuration: Int,\n    val status: String\n)\n\nclass Albatross : Bird(\n    \"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, true\n) {\n    override fun performFlight(plan: FlightPlan): FlightResult {\n        if (!canFlyAtAltitude(plan.altitude)) {\n            return FlightResult(false, 0.0, 0, \"Altitude too high for sustained flight\")\n        }\n        \n        val efficiency = getFlightEfficiency()\n        val actualDistance = plan.distance * efficiency\n        val actualDuration = (plan.plannedDuration / efficiency).toInt()\n        \n        return FlightResult(true, actualDistance, actualDuration, \"Long-distance flight completed successfully\")\n    }\n    \n    override fun getMaxFlightSpeed(): Double = 120.0\n    \n    override fun getFlightEfficiency(): Double = 1.2\n    \n    override fun getMaxFlightDuration(): Int = 1440\n    \n    override fun canFlyAtAltitude(altitude: Int): Boolean = altitude <= maxAltitude\n}\n\nclass Falcon : Bird(\n    \"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, false\n) {\n    override fun performFlight(plan: FlightPlan): FlightResult {\n        if (!canFlyAtAltitude(plan.altitude)) {\n            return FlightResult(false, 0.0, 0, \"Altitude exceeds maximum capability\")\n        }\n        \n        val speed = getMaxFlightSpeed()\n        val actualDistance = min(plan.distance, speed * (plan.plannedDuration / 60.0))\n        val actualDuration = (actualDistance / speed * 60).toInt()\n        \n        return FlightResult(true, actualDistance, actualDuration, \"High-speed flight completed\")\n    }\n    \n    override fun getMaxFlightSpeed(): Double = 300.0\n    \n    override fun getFlightEfficiency(): Double = 0.8\n    \n    override fun getMaxFlightDuration(): Int = 180\n    \n    override fun canFlyAtAltitude(altitude: Int): Boolean = altitude <= maxAltitude\n}\n\nclass Emperor : Bird(\n    \"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, false\n) {\n    private val swimSpeed: Double = 15.0\n    \n    override fun performFlight(plan: FlightPlan): FlightResult {\n        throw UnsupportedOperationException(\"Emperor penguins are flightless! They can only swim and walk.\")\n    }\n    \n    override fun getMaxFlightSpeed(): Double {\n        return 0.0\n    }\n    \n    override fun getFlightEfficiency(): Double {\n        return 0.0\n    }\n    \n    override fun getMaxFlightDuration(): Int {\n        return 0\n    }\n    \n    override fun canFlyAtAltitude(altitude: Int): Boolean {\n        return false\n    }\n    \n    fun getSwimSpeed(): Double = swimSpeed\n    \n    fun swim(distance: Double): String {\n        val time = distance / swimSpeed\n        return \"Swimming %.2f km in %.2f hours\".format(distance, time)\n    }\n}\n\nclass AdvancedFlightManager {\n    private val flock: MutableList<Bird> = mutableListOf()\n    private val flightExecutor: ExecutorService = Executors.newFixedThreadPool(10)\n    \n    fun addBird(bird: Bird) {\n        flock.add(bird)\n    }\n    \n    fun executeFormationFlight(plan: FlightPlan) {\n        println(\"=== Formation Flight Execution ===\")\n        println(\"Flight Plan: ${plan.distance}km at ${plan.altitude}m altitude\")\n        \n        val futures = mutableListOf<Future<FlightResult>>()\n        \n        for (bird in flock) {\n            val future = flightExecutor.submit<FlightResult> {\n                println(\"Starting flight for ${bird.getSpecies()}\")\n                bird.performFlight(plan)\n            }\n            futures.add(future)\n        }\n        \n        for (i in futures.indices) {\n            try {\n                val result = futures[i].get()\n                val bird = flock[i]\n                println(\"${bird.getSpecies()}: ${result.status}\")\n                if (result.successful) {\n                    println(\"  Distance: ${result.actualDistance}km, Duration: ${result.actualDuration}min\")\n                }\n            } catch (e: Exception) {\n                println(\"${flock[i].getSpecies()}: Flight failed - ${e.message}\")\n            }\n            println(\"---\")\n        }\n    }\n    \n    fun performFlightCapabilityAnalysis() {\n        println(\"=== Flight Capability Analysis ===\")\n        for (bird in flock) {\n            println(\"${bird.getSpecies()}:\")\n            println(\"  Max Speed: ${bird.getMaxFlightSpeed()} km/h\")\n            println(\"  Efficiency: ${bird.getFlightEfficiency()}\")\n            println(\"  Max Duration: ${bird.getMaxFlightDuration()} minutes\")\n            println(\"  Max Altitude: ${bird.getMaxAltitude()}m\")\n            println()\n        }\n    }\n    \n    fun shutdown() {\n        flightExecutor.shutdown()\n    }\n}", "raw_response": "**Interface Bloat**\nThe `Bird` class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.\n\nSRP: 4  \nOCP: 3  \nLSP: 5  \nISP: 2  \nDIP: 5  \n\n**ISP**\nThe `Bird` class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.", "violation": "ISP, SRP, OCP, LSP, DIP", "violation_list": ["ISP", "SRP", "OCP", "LSP", "DIP"], "explanation": "**Interface Bloat**\nThe `Bird` class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.\n\nSRP: 4  \nOCP: 3  \nLSP: 5  \nISP: 2  \nDIP: 5  \n\n**ISP**\nThe `Bird` class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.412291049957275}
{"id": 11, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing System.Threading;\n\npublic abstract class Bird\n{\n    protected string species;\n    protected string habitat;\n    protected double wingSpan;\n    protected double weight;\n    protected int maxAltitude;\n    protected bool isMigratory;\n    \n    public Bird(string species, string habitat, double wingSpan, double weight, int maxAltitude, bool isMigratory)\n    {\n        this.species = species;\n        this.habitat = habitat;\n        this.wingSpan = wingSpan;\n        this.weight = weight;\n        this.maxAltitude = maxAltitude;\n        this.isMigratory = isMigratory;\n    }\n    \n    public abstract FlightResult PerformFlight(FlightPlan plan);\n    public abstract double GetMaxFlightSpeed();\n    public abstract double GetFlightEfficiency();\n    public abstract int GetMaxFlightDuration();\n    public abstract bool CanFlyAtAltitude(int altitude);\n    \n    public string Species => species;\n    public string Habitat => habitat;\n    public double WingSpan => wingSpan;\n    public double Weight => weight;\n    public int MaxAltitude => maxAltitude;\n    public bool IsMigratory => isMigratory;\n}\n\npublic class FlightPlan\n{\n    public double Distance { get; private set; }\n    public int Altitude { get; private set; }\n    public string Direction { get; private set; }\n    public int PlannedDuration { get; private set; }\n    \n    public FlightPlan(double distance, int altitude, string direction, int plannedDuration)\n    {\n        Distance = distance;\n        Altitude = altitude;\n        Direction = direction;\n        PlannedDuration = plannedDuration;\n    }\n}\n\npublic class FlightResult\n{\n    public bool Successful { get; private set; }\n    public double ActualDistance { get; private set; }\n    public int ActualDuration { get; private set; }\n    public string Status { get; private set; }\n    \n    public FlightResult(bool successful, double actualDistance, int actualDuration, string status)\n    {\n        Successful = successful;\n        ActualDistance = actualDistance;\n        ActualDuration = actualDuration;\n        Status = status;\n    }\n}\n\npublic class Albatross : Bird\n{\n    public Albatross() : base(\"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, true)\n    {\n    }\n    \n    public override FlightResult PerformFlight(FlightPlan plan)\n    {\n        if (!CanFlyAtAltitude(plan.Altitude))\n        {\n            return new FlightResult(false, 0, 0, \"Altitude too high for sustained flight\");\n        }\n        \n        double efficiency = GetFlightEfficiency();\n        double actualDistance = plan.Distance * efficiency;\n        int actualDuration = (int)(plan.PlannedDuration / efficiency);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"Long-distance flight completed successfully\");\n    }\n    \n    public override double GetMaxFlightSpeed() => 120.0;\n    \n    public override double GetFlightEfficiency() => 1.2;\n    \n    public override int GetMaxFlightDuration() => 1440;\n    \n    public override bool CanFlyAtAltitude(int altitude) => altitude <= maxAltitude;\n}\n\npublic class Falcon : Bird\n{\n    public Falcon() : base(\"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, false)\n    {\n    }\n    \n    public override FlightResult PerformFlight(FlightPlan plan)\n    {\n        if (!CanFlyAtAltitude(plan.Altitude))\n        {\n            return new FlightResult(false, 0, 0, \"Altitude exceeds maximum capability\");\n        }\n        \n        double speed = GetMaxFlightSpeed();\n        double actualDistance = Math.Min(plan.Distance, speed * (plan.PlannedDuration / 60.0));\n        int actualDuration = (int)(actualDistance / speed * 60);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"High-speed flight completed\");\n    }\n    \n    public override double GetMaxFlightSpeed() => 300.0;\n    \n    public override double GetFlightEfficiency() => 0.8;\n    \n    public override int GetMaxFlightDuration() => 180;\n    \n    public override bool CanFlyAtAltitude(int altitude) => altitude <= maxAltitude;\n}\n\npublic class Emperor : Bird\n{\n    private double swimSpeed;\n    \n    public Emperor() : base(\"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, false)\n    {\n        this.swimSpeed = 15.0;\n    }\n    \n    public override FlightResult PerformFlight(FlightPlan plan)\n    {\n        throw new NotSupportedException(\"Emperor penguins are flightless! They can only swim and walk.\");\n    }\n    \n    public override double GetMaxFlightSpeed()\n    {\n        return 0.0;\n    }\n    \n    public override double GetFlightEfficiency()\n    {\n        return 0.0;\n    }\n    \n    public override int GetMaxFlightDuration()\n    {\n        return 0;\n    }\n    \n    public override bool CanFlyAtAltitude(int altitude)\n    {\n        return false;\n    }\n    \n    public double SwimSpeed => swimSpeed;\n    \n    public string Swim(double distance)\n    {\n        double time = distance / swimSpeed;\n        return $\"Swimming {distance:F2} km in {time:F2} hours\";\n    }\n}\n\npublic class AdvancedFlightManager\n{\n    private List<Bird> flock;\n    private SemaphoreSlim flightSemaphore;\n    \n    public AdvancedFlightManager()\n    {\n        this.flock = new List<Bird>();\n        this.flightSemaphore = new SemaphoreSlim(10, 10);\n    }\n    \n    public void AddBird(Bird bird)\n    {\n        flock.Add(bird);\n    }\n    \n    public async Task ExecuteFormationFlightAsync(FlightPlan plan)\n    {\n        Console.WriteLine(\"=== Formation Flight Execution ===\");\n        Console.WriteLine($\"Flight Plan: {plan.Distance}km at {plan.Altitude}m altitude\");\n        \n        var tasks = new List<Task<FlightResult>>();\n        \n        foreach (var bird in flock)\n        {\n            var task = ExecuteBirdFlightAsync(bird, plan);\n            tasks.Add(task);\n        }\n        \n        for (int i = 0; i < tasks.Count; i++)\n        {\n            try\n            {\n                var result = await tasks[i];\n                var bird = flock[i];\n                Console.WriteLine($\"{bird.Species}: {result.Status}\");\n                if (result.Successful)\n                {\n                    Console.WriteLine($\"  Distance: {result.ActualDistance}km, Duration: {result.ActualDuration}min\");\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine($\"{flock[i].Species}: Flight failed - {e.Message}\");\n            }\n            Console.WriteLine(\"---\");\n        }\n    }\n    \n    private async Task<FlightResult> ExecuteBirdFlightAsync(Bird bird, FlightPlan plan)\n    {\n        await flightSemaphore.WaitAsync();\n        try\n        {\n            Console.WriteLine($\"Starting flight for {bird.Species}\");\n            return await Task.Run(() => bird.PerformFlight(plan));\n        }\n        finally\n        {\n            flightSemaphore.Release();\n        }\n    }\n    \n    public void PerformFlightCapabilityAnalysis()\n    {\n        Console.WriteLine(\"=== Flight Capability Analysis ===\");\n        foreach (var bird in flock)\n        {\n            Console.WriteLine($\"{bird.Species}:\");\n            Console.WriteLine($\"  Max Speed: {bird.GetMaxFlightSpeed()} km/h\");\n            Console.WriteLine($\"  Efficiency: {bird.GetFlightEfficiency()}\");\n            Console.WriteLine($\"  Max Duration: {bird.GetMaxFlightDuration()} minutes\");\n            Console.WriteLine($\"  Max Altitude: {bird.MaxAltitude}m\");\n            Console.WriteLine();\n        }\n    }\n    \n    public void Dispose()\n    {\n        flightSemaphore?.Dispose();\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing System.Threading;\n\npublic abstract class Bird\n{\n    protected string species;\n    protected string habitat;\n    protected double wingSpan;\n    protected double weight;\n    protected int maxAltitude;\n    protected bool isMigratory;\n    \n    public Bird(string species, string habitat, double wingSpan, double weight, int maxAltitude, bool isMigratory)\n    {\n        this.species = species;\n        this.habitat = habitat;\n        this.wingSpan = wingSpan;\n        this.weight = weight;\n        this.maxAltitude = maxAltitude;\n        this.isMigratory = isMigratory;\n    }\n    \n    public abstract FlightResult PerformFlight(FlightPlan plan);\n    public abstract double GetMaxFlightSpeed();\n    public abstract double GetFlightEfficiency();\n    public abstract int GetMaxFlightDuration();\n    public abstract bool CanFlyAtAltitude(int altitude);\n    \n    public string Species => species;\n    public string Habitat => habitat;\n    public double WingSpan => wingSpan;\n    public double Weight => weight;\n    public int MaxAltitude => maxAltitude;\n    public bool IsMigratory => isMigratory;\n}\n\npublic class FlightPlan\n{\n    public double Distance { get; private set; }\n    public int Altitude { get; private set; }\n    public string Direction { get; private set; }\n    public int PlannedDuration { get; private set; }\n    \n    public FlightPlan(double distance, int altitude, string direction, int plannedDuration)\n    {\n        Distance = distance;\n        Altitude = altitude;\n        Direction = direction;\n        PlannedDuration = plannedDuration;\n    }\n}\n\npublic class FlightResult\n{\n    public bool Successful { get; private set; }\n    public double ActualDistance { get; private set; }\n    public int ActualDuration { get; private set; }\n    public string Status { get; private set; }\n    \n    public FlightResult(bool successful, double actualDistance, int actualDuration, string status)\n    {\n        Successful = successful;\n        ActualDistance = actualDistance;\n        ActualDuration = actualDuration;\n        Status = status;\n    }\n}\n\npublic class Albatross : Bird\n{\n    public Albatross() : base(\"Wandering Albatross\", \"Ocean\", 3.5, 8.5, 15000, true)\n    {\n    }\n    \n    public override FlightResult PerformFlight(FlightPlan plan)\n    {\n        if (!CanFlyAtAltitude(plan.Altitude))\n        {\n            return new FlightResult(false, 0, 0, \"Altitude too high for sustained flight\");\n        }\n        \n        double efficiency = GetFlightEfficiency();\n        double actualDistance = plan.Distance * efficiency;\n        int actualDuration = (int)(plan.PlannedDuration / efficiency);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"Long-distance flight completed successfully\");\n    }\n    \n    public override double GetMaxFlightSpeed() => 120.0;\n    \n    public override double GetFlightEfficiency() => 1.2;\n    \n    public override int GetMaxFlightDuration() => 1440;\n    \n    public override bool CanFlyAtAltitude(int altitude) => altitude <= maxAltitude;\n}\n\npublic class Falcon : Bird\n{\n    public Falcon() : base(\"Peregrine Falcon\", \"Cliffs\", 1.2, 1.5, 20000, false)\n    {\n    }\n    \n    public override FlightResult PerformFlight(FlightPlan plan)\n    {\n        if (!CanFlyAtAltitude(plan.Altitude))\n        {\n            return new FlightResult(false, 0, 0, \"Altitude exceeds maximum capability\");\n        }\n        \n        double speed = GetMaxFlightSpeed();\n        double actualDistance = Math.Min(plan.Distance, speed * (plan.PlannedDuration / 60.0));\n        int actualDuration = (int)(actualDistance / speed * 60);\n        \n        return new FlightResult(true, actualDistance, actualDuration, \"High-speed flight completed\");\n    }\n    \n    public override double GetMaxFlightSpeed() => 300.0;\n    \n    public override double GetFlightEfficiency() => 0.8;\n    \n    public override int GetMaxFlightDuration() => 180;\n    \n    public override bool CanFlyAtAltitude(int altitude) => altitude <= maxAltitude;\n}\n\npublic class Emperor : Bird\n{\n    private double swimSpeed;\n    \n    public Emperor() : base(\"Emperor Penguin\", \"Antarctica\", 0.8, 30.0, 0, false)\n    {\n        this.swimSpeed = 15.0;\n    }\n    \n    public override FlightResult PerformFlight(FlightPlan plan)\n    {\n        throw new NotSupportedException(\"Emperor penguins are flightless! They can only swim and walk.\");\n    }\n    \n    public override double GetMaxFlightSpeed()\n    {\n        return 0.0;\n    }\n    \n    public override double GetFlightEfficiency()\n    {\n        return 0.0;\n    }\n    \n    public override int GetMaxFlightDuration()\n    {\n        return 0;\n    }\n    \n    public override bool CanFlyAtAltitude(int altitude)\n    {\n        return false;\n    }\n    \n    public double SwimSpeed => swimSpeed;\n    \n    public string Swim(double distance)\n    {\n        double time = distance / swimSpeed;\n        return $\"Swimming {distance:F2} km in {time:F2} hours\";\n    }\n}\n\npublic class AdvancedFlightManager\n{\n    private List<Bird> flock;\n    private SemaphoreSlim flightSemaphore;\n    \n    public AdvancedFlightManager()\n    {\n        this.flock = new List<Bird>();\n        this.flightSemaphore = new SemaphoreSlim(10, 10);\n    }\n    \n    public void AddBird(Bird bird)\n    {\n        flock.Add(bird);\n    }\n    \n    public async Task ExecuteFormationFlightAsync(FlightPlan plan)\n    {\n        Console.WriteLine(\"=== Formation Flight Execution ===\");\n        Console.WriteLine($\"Flight Plan: {plan.Distance}km at {plan.Altitude}m altitude\");\n        \n        var tasks = new List<Task<FlightResult>>();\n        \n        foreach (var bird in flock)\n        {\n            var task = ExecuteBirdFlightAsync(bird, plan);\n            tasks.Add(task);\n        }\n        \n        for (int i = 0; i < tasks.Count; i++)\n        {\n            try\n            {\n                var result = await tasks[i];\n                var bird = flock[i];\n                Console.WriteLine($\"{bird.Species}: {result.Status}\");\n                if (result.Successful)\n                {\n                    Console.WriteLine($\"  Distance: {result.ActualDistance}km, Duration: {result.ActualDuration}min\");\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine($\"{flock[i].Species}: Flight failed - {e.Message}\");\n            }\n            Console.WriteLine(\"---\");\n        }\n    }\n    \n    private async Task<FlightResult> ExecuteBirdFlightAsync(Bird bird, FlightPlan plan)\n    {\n        await flightSemaphore.WaitAsync();\n        try\n        {\n            Console.WriteLine($\"Starting flight for {bird.Species}\");\n            return await Task.Run(() => bird.PerformFlight(plan));\n        }\n        finally\n        {\n            flightSemaphore.Release();\n        }\n    }\n    \n    public void PerformFlightCapabilityAnalysis()\n    {\n        Console.WriteLine(\"=== Flight Capability Analysis ===\");\n        foreach (var bird in flock)\n        {\n            Console.WriteLine($\"{bird.Species}:\");\n            Console.WriteLine($\"  Max Speed: {bird.GetMaxFlightSpeed()} km/h\");\n            Console.WriteLine($\"  Efficiency: {bird.GetFlightEfficiency()}\");\n            Console.WriteLine($\"  Max Duration: {bird.GetMaxFlightDuration()} minutes\");\n            Console.WriteLine($\"  Max Altitude: {bird.MaxAltitude}m\");\n            Console.WriteLine();\n        }\n    }\n    \n    public void Dispose()\n    {\n        flightSemaphore?.Dispose();\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing a flock of birds and executing flight plans.\n\n0\n1\n2\n3\n4", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing a flock of birds and executing flight plans.\n\n0\n1\n2\n3\n4", "solution_code": "NO FIX VERSION", "duration_seconds": 2.852280378341675}
{"id": 12, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public class PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Processing payment of $\" + amount);\n    }\n}\n\npublic class CreditCardProcessor extends PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n    }\n}\n\npublic class CashProcessor extends PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        if (amount > 1000) {\n            throw new IllegalArgumentException(\"Cash payments over $1000 not allowed\");\n        }\n        System.out.println(\"Processing cash payment of $\" + amount);\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class PaymentProcessor {\n    public void processPayment(double amount) {\n        System.out.println(\"Processing payment of $\" + amount);\n    }\n}\n\npublic class CreditCardProcessor extends PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        System.out.println(\"Processing credit card payment of $\" + amount);\n    }\n}\n\npublic class CashProcessor extends PaymentProcessor {\n    @Override\n    public void processPayment(double amount) {\n        if (amount > 1000) {\n            throw new IllegalArgumentException(\"Cash payments over $1000 not allowed\");\n        }\n        System.out.println(\"Processing cash payment of $\" + amount);\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.\n\npublic class UserManager {\n    private String username;\n    private String password;\n    private int userId;\n\n    public void authenticate(String username, String password) {\n        if (this.username.equals(username) && this.password.equals(password)) {\n            System.out.println(\"Authentication successful\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    public void logUserActivity(String activity) {\n        System.out.println(\"User \" + userId + \" performed: \" + activity);\n    }\n\n    public void updateUserData(String username, String password) {\n        this.username = username;\n        this.password = password;\n        System.out.println(\"User data updated\");\n    }\n}\n\n**SRP 1**\n**OCP 2**\n**LSP 3**\n**ISP 4**\n**DIP 5**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.\n\npublic class UserManager {\n    private String username;\n    private String password;\n    private int userId;\n\n    public void authenticate(String username, String password) {\n        if (this.username.equals(username) && this.password.equals(password)) {\n            System.out.println(\"Authentication successful\");\n        } else {\n            System.out.println(\"Authentication failed\");\n        }\n    }\n\n    public void logUserActivity(String activity) {\n        System.out.println(\"User \" + userId + \" performed: \" + activity);\n    }\n\n    public void updateUserData(String username, String password) {\n        this.username = username;\n        this.password = password;\n        System.out.println(\"User data updated\");\n    }\n}\n\n**SRP 1**\n**OCP 2**\n**LSP 3**\n**ISP 4**\n**DIP 5**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.", "solution_code": "NO FIX VERSION", "duration_seconds": 7.699932813644409}
{"id": 13, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "class PaymentProcessor:\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount}\")\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing credit card payment of ${amount}\")\n\nclass CashProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 1000:\n            raise ValueError(\"Cash payments over $1000 not allowed\")\n        print(f\"Processing cash payment of ${amount}\")", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nclass PaymentProcessor:\n    def process_payment(self, amount):\n        print(f\"Processing payment of ${amount}\")\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        print(f\"Processing credit card payment of ${amount}\")\n\nclass CashProcessor(PaymentProcessor):\n    def process_payment(self, amount):\n        if amount > 1000:\n            raise ValueError(\"Cash payments over $1000 not allowed\")\n        print(f\"Processing cash payment of ${amount}\")", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n```python\nclass OrderProcessor:\n    def calculate_total(self, order):\n        total = 0\n        for item in order.items:\n            total += item.price * item.quantity\n        return total\n\n    def apply_discount(self, total, discount_code):\n        if discount_code == \"SAVE10\":\n            return total * 0.9\n        elif discount_code == \"SAVE20\":\n            return total * 0.8\n        else:\n            return total\n\n    def save_order_to_db(self, order):\n        # Simulate saving to database\n        print(f\"Order {order.id} saved to database\")\n\n    def send_confirmation_email(self, order):\n        # Simulate sending email\n        print(f\"Confirmation email sent for order {order.id}\")\n\n    def process_payment(self, order, payment_method):\n        if payment_method == \"credit_card\":\n            self.process_credit_card(order)\n        elif payment_method == \"paypal\":\n            self.process_paypal(order)\n\n    def process_credit_card(self, order):\n        # Simulate credit card processing\n        print(f\"Processing credit card for order {order.id}\")\n\n    def process_paypal(self, order):\n        # Simulate PayPal processing\n        print(f\"Processing PayPal for order {order.id}\")\n```\n\nSRP: 1  \nOCP: 2  \nLSP: 5  \nISP: 5  \nDIP: 3\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 10.967029333114624}
{"id": 14, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "open class PaymentProcessor {\n    open fun processPayment(amount: Double) {\n        println(\"Processing payment of $$amount\")\n    }\n}\n\nclass CreditCardProcessor : PaymentProcessor() {\n    override fun processPayment(amount: Double) {\n        println(\"Processing credit card payment of $$amount\")\n    }\n}\n\nclass CashProcessor : PaymentProcessor() {\n    override fun processPayment(amount: Double) {\n        if (amount > 1000) {\n            throw IllegalArgumentException(\"Cash payments over $1000 not allowed\")\n        }\n        println(\"Processing cash payment of $$amount\")\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nopen class PaymentProcessor {\n    open fun processPayment(amount: Double) {\n        println(\"Processing payment of $$amount\")\n    }\n}\n\nclass CreditCardProcessor : PaymentProcessor() {\n    override fun processPayment(amount: Double) {\n        println(\"Processing credit card payment of $$amount\")\n    }\n}\n\nclass CashProcessor : PaymentProcessor() {\n    override fun processPayment(amount: Double) {\n        if (amount > 1000) {\n            throw IllegalArgumentException(\"Cash payments over $1000 not allowed\")\n        }\n        println(\"Processing cash payment of $$amount\")\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.\n\nclass UserManager {\n    private var users = mutableListOf<User>()\n\n    fun addUser(user: User) {\n        users.add(user)\n        log(\"User added: ${user.name}\")\n    }\n\n    fun removeUser(user: User) {\n        users.remove(user)\n        log(\"User removed: ${user.name}\")\n    }\n\n    fun authenticate(username: String, password: String): Boolean {\n        val user = users.find { it.username == username }\n        return if (user != null && user.password == password) {\n            log(\"Authentication successful for $username\")\n            true\n        } else {\n            log(\"Authentication failed for $username\")\n            false\n        }\n    }\n\n    private fun log(message: String) {\n        println(\"Log: $message\")\n    }\n}\n\n**SRP 1**\n**OCP 2**\n**LSP 3**\n**ISP 4**\n**DIP 5**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.\n\nclass UserManager {\n    private var users = mutableListOf<User>()\n\n    fun addUser(user: User) {\n        users.add(user)\n        log(\"User added: ${user.name}\")\n    }\n\n    fun removeUser(user: User) {\n        users.remove(user)\n        log(\"User removed: ${user.name}\")\n    }\n\n    fun authenticate(username: String, password: String): Boolean {\n        val user = users.find { it.username == username }\n        return if (user != null && user.password == password) {\n            log(\"Authentication successful for $username\")\n            true\n        } else {\n            log(\"Authentication failed for $username\")\n            false\n        }\n    }\n\n    private fun log(message: String) {\n        println(\"Log: $message\")\n    }\n}\n\n**SRP 1**\n**OCP 2**\n**LSP 3**\n**ISP 4**\n**DIP 5**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.", "solution_code": "NO FIX VERSION", "duration_seconds": 8.309526205062866}
{"id": 15, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "public class PaymentProcessor\n{\n    public virtual void ProcessPayment(double amount)\n    {\n        Console.WriteLine($\"Processing payment of ${amount}\");\n    }\n}\n\npublic class CreditCardProcessor : PaymentProcessor\n{\n    public override void ProcessPayment(double amount)\n    {\n        Console.WriteLine($\"Processing credit card payment of ${amount}\");\n    }\n}\n\npublic class CashProcessor : PaymentProcessor\n{\n    public override void ProcessPayment(double amount)\n    {\n    {\n        if (amount > 1000)\n        {\n            throw new ArgumentException(\"Cash payments over $1000 not allowed\");\n        }\n        Console.WriteLine($\"Processing cash payment of ${amount}\");\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class PaymentProcessor\n{\n    public virtual void ProcessPayment(double amount)\n    {\n        Console.WriteLine($\"Processing payment of ${amount}\");\n    }\n}\n\npublic class CreditCardProcessor : PaymentProcessor\n{\n    public override void ProcessPayment(double amount)\n    {\n        Console.WriteLine($\"Processing credit card payment of ${amount}\");\n    }\n}\n\npublic class CashProcessor : PaymentProcessor\n{\n    public override void ProcessPayment(double amount)\n    {\n    {\n        if (amount > 1000)\n        {\n            throw new ArgumentException(\"Cash payments over $1000 not allowed\");\n        }\n        Console.WriteLine($\"Processing cash payment of ${amount}\");\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.\n\npublic class UserManager\n{\n    public void RegisterUser(string username, string password)\n    {\n        // Code to register a new user\n        Console.WriteLine($\"Registering user: {username}\");\n        LogActivity(\"User registered\");\n    }\n\n    public bool AuthenticateUser(string username, string password)\n    {\n        // Code to authenticate a user\n        Console.WriteLine($\"Authenticating user: {username}\");\n        LogActivity(\"User authenticated\");\n        return true;\n    }\n\n    private void LogActivity(string activity)\n    {\n        // Code to log an activity\n        Console.WriteLine($\"Logging activity: {activity}\");\n    }\n}\n\n**SRP**: 1  \n**OCP**: 2  \n**LSP**: 5  \n**ISP**: 5  \n**DIP**: 3", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data, handling authentication, and performing logging.\n\npublic class UserManager\n{\n    public void RegisterUser(string username, string password)\n    {\n        // Code to register a new user\n        Console.WriteLine($\"Registering user: {username}\");\n        LogActivity(\"User registered\");\n    }\n\n    public bool AuthenticateUser(string username, string password)\n    {\n        // Code to authenticate a user\n        Console.WriteLine($\"Authenticating user: {username}\");\n        LogActivity(\"User authenticated\");\n        return true;\n    }\n\n    private void LogActivity(string activity)\n    {\n        // Code to log an activity\n        Console.WriteLine($\"Logging activity: {activity}\");\n    }\n}\n\n**SRP**: 1  \n**OCP**: 2  \n**LSP**: 5  \n**ISP**: 5  \n**DIP**: 3", "solution_code": "NO FIX VERSION", "duration_seconds": 6.532504081726074}
{"id": 16, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public abstract class PaymentProcessor {\n    public abstract void processPayment(double amount);\n    public abstract boolean validatePayment(double amount);\n    public abstract String getPaymentMethod();\n}\n\npublic class CreditCardProcessor extends PaymentProcessor {\n    private String cardNumber;\n    private String expiryDate;\n    \n    public CreditCardProcessor(String cardNumber, String expiryDate) {\n        this.cardNumber = cardNumber;\n        this.expiryDate = expiryDate;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        if (!validatePayment(amount)) {\n            throw new RuntimeException(\"Invalid credit card payment\");\n        }\n        System.out.println(\"Processing credit card payment of $\" + amount);\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    @Override\n    public boolean validatePayment(double amount) {\n        return cardNumber != null && cardNumber.length() == 16 && amount > 0;\n    }\n    \n    @Override\n    public String getPaymentMethod() {\n        return \"Credit Card\";\n    }\n}\n\npublic class BankTransferProcessor extends PaymentProcessor {\n    private String accountNumber;\n    private String routingNumber;\n    \n    public BankTransferProcessor(String accountNumber, String routingNumber) {\n        this.accountNumber = accountNumber;\n        this.routingNumber = routingNumber;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        if (amount < 100) {\n            throw new IllegalArgumentException(\"Bank transfers must be at least $100\");\n        }\n        if (!validatePayment(amount)) {\n            throw new RuntimeException(\"Invalid bank transfer\");\n        }\n        System.out.println(\"Processing bank transfer of $\" + amount);\n    }\n    \n    @Override\n    public boolean validatePayment(double amount) {\n        return accountNumber != null && routingNumber != null && amount >= 100;\n    }\n    \n    @Override\n    public String getPaymentMethod() {\n        return \"Bank Transfer\";\n    }\n}\n\npublic class DigitalWalletProcessor extends PaymentProcessor {\n    private String walletId;\n    private double balance;\n    \n    public DigitalWalletProcessor(String walletId, double balance) {\n        this.walletId = walletId;\n        this.balance = balance;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        if (balance < amount) {\n            throw new InsufficientFundsException(\"Insufficient wallet balance\");\n        }\n        if (!validatePayment(amount)) {\n            throw new RuntimeException(\"Invalid wallet payment\");\n        }\n        balance -= amount;\n        System.out.println(\"Processing wallet payment of $\" + amount + \". Remaining balance: $\" + balance);\n    }\n    \n    @Override\n    public boolean validatePayment(double amount) {\n        return walletId != null && balance >= amount && amount > 0;\n    }\n    \n    @Override\n    public String getPaymentMethod() {\n        return \"Digital Wallet\";\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}\n\nclass InsufficientFundsException extends RuntimeException {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic abstract class PaymentProcessor {\n    public abstract void processPayment(double amount);\n    public abstract boolean validatePayment(double amount);\n    public abstract String getPaymentMethod();\n}\n\npublic class CreditCardProcessor extends PaymentProcessor {\n    private String cardNumber;\n    private String expiryDate;\n    \n    public CreditCardProcessor(String cardNumber, String expiryDate) {\n        this.cardNumber = cardNumber;\n        this.expiryDate = expiryDate;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        if (!validatePayment(amount)) {\n            throw new RuntimeException(\"Invalid credit card payment\");\n        }\n        System.out.println(\"Processing credit card payment of $\" + amount);\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n    \n    @Override\n    public boolean validatePayment(double amount) {\n        return cardNumber != null && cardNumber.length() == 16 && amount > 0;\n    }\n    \n    @Override\n    public String getPaymentMethod() {\n        return \"Credit Card\";\n    }\n}\n\npublic class BankTransferProcessor extends PaymentProcessor {\n    private String accountNumber;\n    private String routingNumber;\n    \n    public BankTransferProcessor(String accountNumber, String routingNumber) {\n        this.accountNumber = accountNumber;\n        this.routingNumber = routingNumber;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        if (amount < 100) {\n            throw new IllegalArgumentException(\"Bank transfers must be at least $100\");\n        }\n        if (!validatePayment(amount)) {\n            throw new RuntimeException(\"Invalid bank transfer\");\n        }\n        System.out.println(\"Processing bank transfer of $\" + amount);\n    }\n    \n    @Override\n    public boolean validatePayment(double amount) {\n        return accountNumber != null && routingNumber != null && amount >= 100;\n    }\n    \n    @Override\n    public String getPaymentMethod() {\n        return \"Bank Transfer\";\n    }\n}\n\npublic class DigitalWalletProcessor extends PaymentProcessor {\n    private String walletId;\n    private double balance;\n    \n    public DigitalWalletProcessor(String walletId, double balance) {\n        this.walletId = walletId;\n        this.balance = balance;\n    }\n    \n    @Override\n    public void processPayment(double amount) {\n        if (balance < amount) {\n            throw new InsufficientFundsException(\"Insufficient wallet balance\");\n        }\n        if (!validatePayment(amount)) {\n            throw new RuntimeException(\"Invalid wallet payment\");\n        }\n        balance -= amount;\n        System.out.println(\"Processing wallet payment of $\" + amount + \". Remaining balance: $\" + balance);\n    }\n    \n    @Override\n    public boolean validatePayment(double amount) {\n        return walletId != null && balance >= amount && amount > 0;\n    }\n    \n    @Override\n    public String getPaymentMethod() {\n        return \"Digital Wallet\";\n    }\n    \n    public double getBalance() {\n        return balance;\n    }\n}\n\nclass InsufficientFundsException extends RuntimeException {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor {\n    private List<Order> orders;\n\n    public OrderProcessor() {\n        this.orders = new ArrayList<>();\n    }\n\n    public void addOrder(Order order) {\n        orders.add(order);\n    }\n\n    public void removeOrder(Order order) {\n        orders.remove(order);\n    }\n\n    public double calculateTotalPrice() {\n        return orders.stream().mapToDouble(Order::getPrice).sum();\n    }\n\n    public void sendEmailNotification(String email, String message) {\n        // Code to send an email\n        System.out.println(\"Sending email to \" + email + \": \" + message);\n    }\n\n    public void saveOrderToDatabase(Order order) {\n        // Code to save order to database\n        System.out.println(\"Saving order to database: \" + order.getId());\n    }\n}\n\nclass Order {\n    private String id;\n    private double price;\n\n    public Order(String id, double price) {\n        this.id = id;\n        this.price = price;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n}\n\n**SRP: 2**\n**OCP: 3**\n**LSP: 5**\n**ISP: 5**\n**DIP: 4**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor {\n    private List<Order> orders;\n\n    public OrderProcessor() {\n        this.orders = new ArrayList<>();\n    }\n\n    public void addOrder(Order order) {\n        orders.add(order);\n    }\n\n    public void removeOrder(Order order) {\n        orders.remove(order);\n    }\n\n    public double calculateTotalPrice() {\n        return orders.stream().mapToDouble(Order::getPrice).sum();\n    }\n\n    public void sendEmailNotification(String email, String message) {\n        // Code to send an email\n        System.out.println(\"Sending email to \" + email + \": \" + message);\n    }\n\n    public void saveOrderToDatabase(Order order) {\n        // Code to save order to database\n        System.out.println(\"Saving order to database: \" + order.getId());\n    }\n}\n\nclass Order {\n    private String id;\n    private double price;\n\n    public Order(String id, double price) {\n        this.id = id;\n        this.price = price;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n}\n\n**SRP: 2**\n**OCP: 3**\n**LSP: 5**\n**ISP: 5**\n**DIP: 4**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 10.496612787246704}
{"id": 17, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\nimport time\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n    \n    @abstractmethod\n    def validate_payment(self, amount):\n        pass\n    \n    @abstractmethod\n    def get_payment_method(self):\n        pass\n\nclass CreditCardProcessor(PaymentProcessor):\n    def __init__(self, card_number, expiry_date):\n        self.card_number = card_number\n        self.expiry_date = expiry_date\n    \n    def process_payment(self, amount):\n        if not self.validate_payment(amount):\n            raise RuntimeError(\"Invalid credit card payment\")\n        print(f\"Processing credit card payment of ${amount}\")\n        time.sleep(2)\n    \n    def validate_payment(self, amount):\n        return self.card_number and len(self.card_number) == 16 and amount > 0\n    \n    def get_payment_method(self):\n        return \"Credit Card\"\n\nclass BankTransferProcessor(PaymentProcessor):\n    def __init__(self, account_number, routing_number):\n        self.account_number = account_number\n        self.routing_number = routing_number\n    \n    def process_payment(self, amount):\n        if amount < 100:\n            raise ValueError(\"Bank transfers must be at least $100\")\n        if not self.validate_payment(amount):\n            raise RuntimeError(\"Invalid bank transfer\")\n        print(f\"Processing bank transfer of ${amount}\")\n    \n    def validate_payment(self, amount):\n        return self.account_number and self.routing_number and amount >= 100\n    \n    def get_payment_method(self):\n        return \"Bank Transfer\"\n\nclass DigitalWalletProcessor(PaymentProcessor):\n    def __init__(self, wallet_id, balance):\n        self.wallet_id = wallet_id\n        self.balance = balance\n    \n    def process_payment(self, amount):\n        if self.balance < amount:\n            raise InsufficientFundsError(\"Insufficient wallet balance\")\n        if not self.validate_payment(amount):\n            raise RuntimeError(\"Invalid wallet payment\")\n        self.balance -= amount\n        print(f\"Processing wallet payment of ${amount}. Remaining balance: ${self.balance}\")\n    \n    def validate_payment(self, amount):\n        return self.wallet_id and self.balance >= amount and amount > 0\n    \n    def get_payment_method(self):\n        return \"Digital Wallet\"\n    \n    def get_balance(self):\n        return self.balance\n\nclass InsufficientFundsError(Exception):\n    pass", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\nimport time\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process_payment(self, amount):\n        pass\n    \n    @abstractmethod\n    def validate_payment(self, amount):\n        pass\n    \n    @abstractmethod\n    def get_payment_method(self):\n        pass\n\nclass CreditCardProcessor(PaymentProcessor):\n    def __init__(self, card_number, expiry_date):\n        self.card_number = card_number\n        self.expiry_date = expiry_date\n    \n    def process_payment(self, amount):\n        if not self.validate_payment(amount):\n            raise RuntimeError(\"Invalid credit card payment\")\n        print(f\"Processing credit card payment of ${amount}\")\n        time.sleep(2)\n    \n    def validate_payment(self, amount):\n        return self.card_number and len(self.card_number) == 16 and amount > 0\n    \n    def get_payment_method(self):\n        return \"Credit Card\"\n\nclass BankTransferProcessor(PaymentProcessor):\n    def __init__(self, account_number, routing_number):\n        self.account_number = account_number\n        self.routing_number = routing_number\n    \n    def process_payment(self, amount):\n        if amount < 100:\n            raise ValueError(\"Bank transfers must be at least $100\")\n        if not self.validate_payment(amount):\n            raise RuntimeError(\"Invalid bank transfer\")\n        print(f\"Processing bank transfer of ${amount}\")\n    \n    def validate_payment(self, amount):\n        return self.account_number and self.routing_number and amount >= 100\n    \n    def get_payment_method(self):\n        return \"Bank Transfer\"\n\nclass DigitalWalletProcessor(PaymentProcessor):\n    def __init__(self, wallet_id, balance):\n        self.wallet_id = wallet_id\n        self.balance = balance\n    \n    def process_payment(self, amount):\n        if self.balance < amount:\n            raise InsufficientFundsError(\"Insufficient wallet balance\")\n        if not self.validate_payment(amount):\n            raise RuntimeError(\"Invalid wallet payment\")\n        self.balance -= amount\n        print(f\"Processing wallet payment of ${amount}. Remaining balance: ${self.balance}\")\n    \n    def validate_payment(self, amount):\n        return self.wallet_id and self.balance >= amount and amount > 0\n    \n    def get_payment_method(self):\n        return \"Digital Wallet\"\n    \n    def get_balance(self):\n        return self.balance\n\nclass InsufficientFundsError(Exception):\n    pass", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DigitalWalletProcessor` class not only processes payments but also manages wallet balance, which could be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DigitalWalletProcessor` class not only processes payments but also manages wallet balance, which could be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.8996388912200928}
{"id": 18, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "import kotlinx.coroutines.delay\n\nabstract class PaymentProcessor {\n    abstract suspend fun processPayment(amount: Double)\n    abstract fun validatePayment(amount: Double): Boolean\n    abstract fun getPaymentMethod(): String\n}\n\nclass CreditCardProcessor(private val cardNumber: String, private val expiryDate: String) : PaymentProcessor() {\n    override suspend fun processPayment(amount: Double) {\n        if (!validatePayment(amount)) {\n            throw RuntimeException(\"Invalid credit card payment\")\n        }\n        println(\"Processing credit card payment of $$amount\")\n        delay(2000)\n    }\n    \n    override fun validatePayment(amount: Double): Boolean {\n        return cardNumber.isNotEmpty() && cardNumber.length == 16 && amount > 0\n    }\n    \n    override fun getPaymentMethod(): String = \"Credit Card\"\n}\n\nclass BankTransferProcessor(private val accountNumber: String, private val routingNumber: String) : PaymentProcessor() {\n    override suspend fun processPayment(amount: Double) {\n        if (amount < 100) {\n            throw IllegalArgumentException(\"Bank transfers must be at least $100\")\n        }\n        if (!validatePayment(amount)) {\n            throw RuntimeException(\"Invalid bank transfer\")\n        }\n        println(\"Processing bank transfer of $$amount\")\n    }\n    \n    override fun validatePayment(amount: Double): Boolean {\n        return accountNumber.isNotEmpty() && routingNumber.isNotEmpty() && amount >= 100\n    }\n    \n    override fun getPaymentMethod(): String = \"Bank Transfer\"\n}\n\nclass DigitalWalletProcessor(private val walletId: String, private var balance: Double) : PaymentProcessor() {\n    override suspend fun processPayment(amount: Double) {\n        if (balance < amount) {\n            throw InsufficientFundsException(\"Insufficient wallet balance\")\n        }\n        if (!validatePayment(amount)) {\n            throw RuntimeException(\"Invalid wallet payment\")\n        }\n        balance -= amount\n        println(\"Processing wallet payment of $$amount. Remaining balance: $$balance\")\n    }\n    \n    override fun validatePayment(amount: Double): Boolean {\n        return walletId.isNotEmpty() && balance >= amount && amount > 0\n    }\n    \n    override fun getPaymentMethod(): String = \"Digital Wallet\"\n    \n    fun getBalance(): Double = balance\n}\n\nclass InsufficientFundsException(message: String) : Exception(message)", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport kotlinx.coroutines.delay\n\nabstract class PaymentProcessor {\n    abstract suspend fun processPayment(amount: Double)\n    abstract fun validatePayment(amount: Double): Boolean\n    abstract fun getPaymentMethod(): String\n}\n\nclass CreditCardProcessor(private val cardNumber: String, private val expiryDate: String) : PaymentProcessor() {\n    override suspend fun processPayment(amount: Double) {\n        if (!validatePayment(amount)) {\n            throw RuntimeException(\"Invalid credit card payment\")\n        }\n        println(\"Processing credit card payment of $$amount\")\n        delay(2000)\n    }\n    \n    override fun validatePayment(amount: Double): Boolean {\n        return cardNumber.isNotEmpty() && cardNumber.length == 16 && amount > 0\n    }\n    \n    override fun getPaymentMethod(): String = \"Credit Card\"\n}\n\nclass BankTransferProcessor(private val accountNumber: String, private val routingNumber: String) : PaymentProcessor() {\n    override suspend fun processPayment(amount: Double) {\n        if (amount < 100) {\n            throw IllegalArgumentException(\"Bank transfers must be at least $100\")\n        }\n        if (!validatePayment(amount)) {\n            throw RuntimeException(\"Invalid bank transfer\")\n        }\n        println(\"Processing bank transfer of $$amount\")\n    }\n    \n    override fun validatePayment(amount: Double): Boolean {\n        return accountNumber.isNotEmpty() && routingNumber.isNotEmpty() && amount >= 100\n    }\n    \n    override fun getPaymentMethod(): String = \"Bank Transfer\"\n}\n\nclass DigitalWalletProcessor(private val walletId: String, private var balance: Double) : PaymentProcessor() {\n    override suspend fun processPayment(amount: Double) {\n        if (balance < amount) {\n            throw InsufficientFundsException(\"Insufficient wallet balance\")\n        }\n        if (!validatePayment(amount)) {\n            throw RuntimeException(\"Invalid wallet payment\")\n        }\n        balance -= amount\n        println(\"Processing wallet payment of $$amount. Remaining balance: $$balance\")\n    }\n    \n    override fun validatePayment(amount: Double): Boolean {\n        return walletId.isNotEmpty() && balance >= amount && amount > 0\n    }\n    \n    override fun getPaymentMethod(): String = \"Digital Wallet\"\n    \n    fun getBalance(): Double = balance\n}\n\nclass InsufficientFundsException(message: String) : Exception(message)", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. Each payment processor class is responsible for processing payments, validating payments, and providing payment method details. These should be separated into different classes or modules.\n\n0\n2\n3\n4\n1\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. Each payment processor class is responsible for processing payments, validating payments, and providing payment method details. These should be separated into different classes or modules.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. Each payment processor class is responsible for processing payments, validating payments, and providing payment method details. These should be separated into different classes or modules.\n\n0\n2\n3\n4\n1\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. Each payment processor class is responsible for processing payments, validating payments, and providing payment method details. These should be separated into different classes or modules.", "solution_code": "NO FIX VERSION", "duration_seconds": 3.9957468509674072}
{"id": 19, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Threading.Tasks;\n\npublic abstract class PaymentProcessor\n{\n    public abstract Task ProcessPaymentAsync(double amount);\n    public abstract bool ValidatePayment(double amount);\n    public abstract string GetPaymentMethod();\n}\n\npublic class CreditCardProcessor : PaymentProcessor\n{\n    private readonly string cardNumber;\n    private readonly string expiryDate;\n    \n    public CreditCardProcessor(string cardNumber, string expiryDate)\n    {\n        this.cardNumber = cardNumber;\n        this.expiryDate = expiryDate;\n    }\n    \n    public override async Task ProcessPaymentAsync(double amount)\n    {\n        if (!ValidatePayment(amount))\n        {\n            throw new InvalidOperationException(\"Invalid credit card payment\");\n        }\n        Console.WriteLine($\"Processing credit card payment of ${amount}\");\n        await Task.Delay(2000);\n    }\n    \n    public override bool ValidatePayment(double amount)\n    {\n        return !string.IsNullOrEmpty(cardNumber) && cardNumber.Length == 16 && amount > 0;\n    }\n    \n    public override string GetPaymentMethod()\n    {\n        return \"Credit Card\";\n    }\n}\n\npublic class BankTransferProcessor : PaymentProcessor\n{\n    private readonly string accountNumber;\n    private readonly string routingNumber;\n    \n    public BankTransferProcessor(string accountNumber, string routingNumber)\n    {\n        this.accountNumber = accountNumber;\n        this.routingNumber = routingNumber;\n    }\n    \n    public override async Task ProcessPaymentAsync(double amount)\n    {\n        if (amount < 100)\n        {\n            throw new ArgumentException(\"Bank transfers must be at least $100\");\n        }\n        if (!ValidatePayment(amount))\n        {\n            throw new InvalidOperationException(\"Invalid bank transfer\");\n        }\n        Console.WriteLine($\"Processing bank transfer of ${amount}\");\n        await Task.CompletedTask;\n    }\n    \n    public override bool ValidatePayment(double amount)\n    {\n        return !string.IsNullOrEmpty(accountNumber) && !string.IsNullOrEmpty(routingNumber) && amount >= 100;\n    }\n    \n    public override string GetPaymentMethod()\n    {\n        return \"Bank Transfer\";\n    }\n}\n\npublic class DigitalWalletProcessor : PaymentProcessor\n{\n    private readonly string walletId;\n    private double balance;\n    \n    public DigitalWalletProcessor(string walletId, double balance)\n    {\n        this.walletId = walletId;\n        this.balance = balance;\n    }\n    \n    public override async Task ProcessPaymentAsync(double amount)\n    {\n        if (balance < amount)\n        {\n            throw new InsufficientFundsException(\"Insufficient wallet balance\");\n        }\n        if (!ValidatePayment(amount))\n        {\n            throw new InvalidOperationException(\"Invalid wallet payment\");\n        }\n        balance -= amount;\n        Console.WriteLine($\"Processing wallet payment of ${amount}. Remaining balance: ${balance}\");\n        await Task.CompletedTask;\n    }\n    \n    public override bool ValidatePayment(double amount)\n    {\n        return !string.IsNullOrEmpty(walletId) && balance >= amount && amount > 0;\n    }\n    \n    public override string GetPaymentMethod()\n    {\n        return \"Digital Wallet\";\n    }\n    \n    public double GetBalance()\n    {\n        return balance;\n    }\n}\n\npublic class InsufficientFundsException : Exception\n{\n    public InsufficientFundsException(string message) : base(message)\n    {\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Threading.Tasks;\n\npublic abstract class PaymentProcessor\n{\n    public abstract Task ProcessPaymentAsync(double amount);\n    public abstract bool ValidatePayment(double amount);\n    public abstract string GetPaymentMethod();\n}\n\npublic class CreditCardProcessor : PaymentProcessor\n{\n    private readonly string cardNumber;\n    private readonly string expiryDate;\n    \n    public CreditCardProcessor(string cardNumber, string expiryDate)\n    {\n        this.cardNumber = cardNumber;\n        this.expiryDate = expiryDate;\n    }\n    \n    public override async Task ProcessPaymentAsync(double amount)\n    {\n        if (!ValidatePayment(amount))\n        {\n            throw new InvalidOperationException(\"Invalid credit card payment\");\n        }\n        Console.WriteLine($\"Processing credit card payment of ${amount}\");\n        await Task.Delay(2000);\n    }\n    \n    public override bool ValidatePayment(double amount)\n    {\n        return !string.IsNullOrEmpty(cardNumber) && cardNumber.Length == 16 && amount > 0;\n    }\n    \n    public override string GetPaymentMethod()\n    {\n        return \"Credit Card\";\n    }\n}\n\npublic class BankTransferProcessor : PaymentProcessor\n{\n    private readonly string accountNumber;\n    private readonly string routingNumber;\n    \n    public BankTransferProcessor(string accountNumber, string routingNumber)\n    {\n        this.accountNumber = accountNumber;\n        this.routingNumber = routingNumber;\n    }\n    \n    public override async Task ProcessPaymentAsync(double amount)\n    {\n        if (amount < 100)\n        {\n            throw new ArgumentException(\"Bank transfers must be at least $100\");\n        }\n        if (!ValidatePayment(amount))\n        {\n            throw new InvalidOperationException(\"Invalid bank transfer\");\n        }\n        Console.WriteLine($\"Processing bank transfer of ${amount}\");\n        await Task.CompletedTask;\n    }\n    \n    public override bool ValidatePayment(double amount)\n    {\n        return !string.IsNullOrEmpty(accountNumber) && !string.IsNullOrEmpty(routingNumber) && amount >= 100;\n    }\n    \n    public override string GetPaymentMethod()\n    {\n        return \"Bank Transfer\";\n    }\n}\n\npublic class DigitalWalletProcessor : PaymentProcessor\n{\n    private readonly string walletId;\n    private double balance;\n    \n    public DigitalWalletProcessor(string walletId, double balance)\n    {\n        this.walletId = walletId;\n        this.balance = balance;\n    }\n    \n    public override async Task ProcessPaymentAsync(double amount)\n    {\n        if (balance < amount)\n        {\n            throw new InsufficientFundsException(\"Insufficient wallet balance\");\n        }\n        if (!ValidatePayment(amount))\n        {\n            throw new InvalidOperationException(\"Invalid wallet payment\");\n        }\n        balance -= amount;\n        Console.WriteLine($\"Processing wallet payment of ${amount}. Remaining balance: ${balance}\");\n        await Task.CompletedTask;\n    }\n    \n    public override bool ValidatePayment(double amount)\n    {\n        return !string.IsNullOrEmpty(walletId) && balance >= amount && amount > 0;\n    }\n    \n    public override string GetPaymentMethod()\n    {\n        return \"Digital Wallet\";\n    }\n    \n    public double GetBalance()\n    {\n        return balance;\n    }\n}\n\npublic class InsufficientFundsException : Exception\n{\n    public InsufficientFundsException(string message) : base(message)\n    {\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DigitalWalletProcessor` class not only processes payments but also manages the balance of the digital wallet, which is a separate concern.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DigitalWalletProcessor` class not only processes payments but also manages the balance of the digital wallet, which is a separate concern.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DigitalWalletProcessor` class not only processes payments but also manages the balance of the digital wallet, which is a separate concern.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DigitalWalletProcessor` class not only processes payments but also manages the balance of the digital wallet, which is a separate concern.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.050553798675537}
{"id": 20, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "import java.math.BigDecimal;\nimport java.time.LocalDateTime;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.logging.Logger;\n\npublic abstract class FinancialInstrument {\n    protected String instrumentId;\n    protected BigDecimal faceValue;\n    protected LocalDateTime creationTime;\n    protected static final Logger logger = Logger.getLogger(FinancialInstrument.class.getName());\n    \n    public FinancialInstrument(String instrumentId, BigDecimal faceValue) {\n        this.instrumentId = instrumentId;\n        this.faceValue = faceValue;\n        this.creationTime = LocalDateTime.now();\n    }\n    \n    public abstract BigDecimal calculateCurrentValue(LocalDateTime asOfDate);\n    public abstract CompletableFuture<Boolean> executeTransaction(BigDecimal amount, String counterparty);\n    public abstract List<String> getRequiredDocuments();\n    public abstract boolean validateInstrument();\n    public abstract Map<String, Object> getRiskMetrics();\n    \n    public String getInstrumentId() { return instrumentId; }\n    public BigDecimal getFaceValue() { return faceValue; }\n    public LocalDateTime getCreationTime() { return creationTime; }\n}\n\npublic class CorporateBond extends FinancialInstrument {\n    private final BigDecimal couponRate;\n    private final LocalDateTime maturityDate;\n    private final String creditRating;\n    private final List<LocalDateTime> couponPaymentDates;\n    \n    public CorporateBond(String instrumentId, BigDecimal faceValue, BigDecimal couponRate, \n                        LocalDateTime maturityDate, String creditRating) {\n        super(instrumentId, faceValue);\n        this.couponRate = couponRate;\n        this.maturityDate = maturityDate;\n        this.creditRating = creditRating;\n        this.couponPaymentDates = generateCouponDates();\n    }\n    \n    @Override\n    public BigDecimal calculateCurrentValue(LocalDateTime asOfDate) {\n        if (asOfDate.isAfter(maturityDate)) {\n            return BigDecimal.ZERO;\n        }\n        BigDecimal presentValue = faceValue;\n        for (LocalDateTime paymentDate : couponPaymentDates) {\n            if (paymentDate.isAfter(asOfDate)) {\n                BigDecimal couponPayment = faceValue.multiply(couponRate);\n                presentValue = presentValue.add(couponPayment);\n            }\n        }\n        return presentValue;\n    }\n    \n    @Override\n    public CompletableFuture<Boolean> executeTransaction(BigDecimal amount, String counterparty) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (amount.compareTo(faceValue) != 0) {\n                throw new IllegalArgumentException(\"Corporate bonds must be traded at face value\");\n            }\n            if (!validateCounterparty(counterparty)) {\n                return false;\n            }\n            logger.info(\"Executing bond transaction: \" + instrumentId);\n            return true;\n        });\n    }\n    \n    @Override\n    public List<String> getRequiredDocuments() {\n        return Arrays.asList(\"Bond Certificate\", \"Credit Rating Report\", \"Indenture Agreement\");\n    }\n    \n    @Override\n    public boolean validateInstrument() {\n        return creditRating != null && !creditRating.isEmpty() && \n               maturityDate.isAfter(LocalDateTime.now()) && \n               couponRate.compareTo(BigDecimal.ZERO) > 0;\n    }\n    \n    @Override\n    public Map<String, Object> getRiskMetrics() {\n        Map<String, Object> metrics = new HashMap<>();\n        metrics.put(\"creditRisk\", creditRating);\n        metrics.put(\"duration\", calculateDuration());\n        metrics.put(\"yieldToMaturity\", calculateYTM());\n        return metrics;\n    }\n    \n    private List<LocalDateTime> generateCouponDates() {\n        List<LocalDateTime> dates = new ArrayList<>();\n        LocalDateTime current = creationTime.plusMonths(6);\n        while (current.isBefore(maturityDate)) {\n            dates.add(current);\n            current = current.plusMonths(6);\n        }\n        return dates;\n    }\n    \n    private boolean validateCounterparty(String counterparty) {\n        return counterparty != null && counterparty.length() > 5;\n    }\n    \n    private BigDecimal calculateDuration() {\n        return BigDecimal.valueOf(2.5);\n    }\n    \n    private BigDecimal calculateYTM() {\n        return couponRate.multiply(BigDecimal.valueOf(1.1));\n    }\n}\n\npublic class DerivativeContract extends FinancialInstrument {\n    private final String underlyingAsset;\n    private final LocalDateTime expirationDate;\n    private final BigDecimal strikePrice;\n    private final String contractType;\n    private volatile boolean isMarkedToMarket = false;\n    \n    public DerivativeContract(String instrumentId, BigDecimal notionalValue, String underlyingAsset,\n                             LocalDateTime expirationDate, BigDecimal strikePrice, String contractType) {\n        super(instrumentId, notionalValue);\n        this.underlyingAsset = underlyingAsset;\n        this.expirationDate = expirationDate;\n        this.strikePrice = strikePrice;\n        this.contractType = contractType;\n    }\n    \n    @Override\n    public BigDecimal calculateCurrentValue(LocalDateTime asOfDate) {\n        if (!isMarkedToMarket) {\n            throw new IllegalStateException(\"Derivative must be marked to market before valuation\");\n        }\n        if (asOfDate.isAfter(expirationDate)) {\n            return calculateExpirationValue();\n        }\n        return calculateTimeValue().add(calculateIntrinsicValue());\n    }\n    \n    @Override\n    public CompletableFuture<Boolean> executeTransaction(BigDecimal amount, String counterparty) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (!isMarkedToMarket) {\n                throw new IllegalStateException(\"Cannot trade unmarked derivative\");\n            }\n            if (LocalDateTime.now().isAfter(expirationDate)) {\n                throw new IllegalStateException(\"Cannot trade expired derivative\");\n            }\n            if (amount.compareTo(BigDecimal.ZERO) <= 0) {\n                throw new IllegalArgumentException(\"Transaction amount must be positive\");\n            }\n            logger.info(\"Executing derivative transaction: \" + instrumentId);\n            return performComplexSettlement(amount, counterparty);\n        });\n    }\n    \n    @Override\n    public List<String> getRequiredDocuments() {\n        if (\"SWAP\".equals(contractType)) {\n            return Arrays.asList(\"ISDA Master Agreement\", \"Confirmation\", \"Collateral Agreement\", \"Risk Disclosure\");\n        }\n        return Arrays.asList(\"Derivative Confirmation\", \"Risk Disclosure\", \"Margin Agreement\");\n    }\n    \n    @Override\n    public boolean validateInstrument() {\n        boolean baseValidation = underlyingAsset != null && !underlyingAsset.isEmpty() &&\n                               expirationDate.isAfter(LocalDateTime.now()) &&\n                               strikePrice.compareTo(BigDecimal.ZERO) > 0;\n        \n        if (\"SWAP\".equals(contractType) && !isMarkedToMarket) {\n            return false;\n        }\n        return baseValidation;\n    }\n    \n    @Override\n    public Map<String, Object> getRiskMetrics() {\n        Map<String, Object> metrics = new HashMap<>();\n        metrics.put(\"delta\", calculateDelta());\n        metrics.put(\"gamma\", calculateGamma());\n        metrics.put(\"vega\", calculateVega());\n        metrics.put(\"theta\", calculateTheta());\n        metrics.put(\"counterpartyRisk\", \"HIGH\");\n        if (!isMarkedToMarket) {\n            metrics.put(\"valuationRisk\", \"EXTREME\");\n        }\n        return metrics;\n    }\n    \n    public void markToMarket() {\n        this.isMarkedToMarket = true;\n    }\n    \n    private BigDecimal calculateExpirationValue() {\n        return strikePrice.subtract(faceValue).max(BigDecimal.ZERO);\n    }\n    \n    private BigDecimal calculateTimeValue() {\n        return BigDecimal.valueOf(100);\n    }\n    \n    private BigDecimal calculateIntrinsicValue() {\n        return BigDecimal.valueOf(50);\n    }\n    \n    private boolean performComplexSettlement(BigDecimal amount, String counterparty) {\n        try {\n            Thread.sleep(3000);\n            return true;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n    }\n    \n    private BigDecimal calculateDelta() { return BigDecimal.valueOf(0.6); }\n    private BigDecimal calculateGamma() { return BigDecimal.valueOf(0.05); }\n    private BigDecimal calculateVega() { return BigDecimal.valueOf(0.3); }\n    private BigDecimal calculateTheta() { return BigDecimal.valueOf(-0.02); }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport java.math.BigDecimal;\nimport java.time.LocalDateTime;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.logging.Logger;\n\npublic abstract class FinancialInstrument {\n    protected String instrumentId;\n    protected BigDecimal faceValue;\n    protected LocalDateTime creationTime;\n    protected static final Logger logger = Logger.getLogger(FinancialInstrument.class.getName());\n    \n    public FinancialInstrument(String instrumentId, BigDecimal faceValue) {\n        this.instrumentId = instrumentId;\n        this.faceValue = faceValue;\n        this.creationTime = LocalDateTime.now();\n    }\n    \n    public abstract BigDecimal calculateCurrentValue(LocalDateTime asOfDate);\n    public abstract CompletableFuture<Boolean> executeTransaction(BigDecimal amount, String counterparty);\n    public abstract List<String> getRequiredDocuments();\n    public abstract boolean validateInstrument();\n    public abstract Map<String, Object> getRiskMetrics();\n    \n    public String getInstrumentId() { return instrumentId; }\n    public BigDecimal getFaceValue() { return faceValue; }\n    public LocalDateTime getCreationTime() { return creationTime; }\n}\n\npublic class CorporateBond extends FinancialInstrument {\n    private final BigDecimal couponRate;\n    private final LocalDateTime maturityDate;\n    private final String creditRating;\n    private final List<LocalDateTime> couponPaymentDates;\n    \n    public CorporateBond(String instrumentId, BigDecimal faceValue, BigDecimal couponRate, \n                        LocalDateTime maturityDate, String creditRating) {\n        super(instrumentId, faceValue);\n        this.couponRate = couponRate;\n        this.maturityDate = maturityDate;\n        this.creditRating = creditRating;\n        this.couponPaymentDates = generateCouponDates();\n    }\n    \n    @Override\n    public BigDecimal calculateCurrentValue(LocalDateTime asOfDate) {\n        if (asOfDate.isAfter(maturityDate)) {\n            return BigDecimal.ZERO;\n        }\n        BigDecimal presentValue = faceValue;\n        for (LocalDateTime paymentDate : couponPaymentDates) {\n            if (paymentDate.isAfter(asOfDate)) {\n                BigDecimal couponPayment = faceValue.multiply(couponRate);\n                presentValue = presentValue.add(couponPayment);\n            }\n        }\n        return presentValue;\n    }\n    \n    @Override\n    public CompletableFuture<Boolean> executeTransaction(BigDecimal amount, String counterparty) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (amount.compareTo(faceValue) != 0) {\n                throw new IllegalArgumentException(\"Corporate bonds must be traded at face value\");\n            }\n            if (!validateCounterparty(counterparty)) {\n                return false;\n            }\n            logger.info(\"Executing bond transaction: \" + instrumentId);\n            return true;\n        });\n    }\n    \n    @Override\n    public List<String> getRequiredDocuments() {\n        return Arrays.asList(\"Bond Certificate\", \"Credit Rating Report\", \"Indenture Agreement\");\n    }\n    \n    @Override\n    public boolean validateInstrument() {\n        return creditRating != null && !creditRating.isEmpty() && \n               maturityDate.isAfter(LocalDateTime.now()) && \n               couponRate.compareTo(BigDecimal.ZERO) > 0;\n    }\n    \n    @Override\n    public Map<String, Object> getRiskMetrics() {\n        Map<String, Object> metrics = new HashMap<>();\n        metrics.put(\"creditRisk\", creditRating);\n        metrics.put(\"duration\", calculateDuration());\n        metrics.put(\"yieldToMaturity\", calculateYTM());\n        return metrics;\n    }\n    \n    private List<LocalDateTime> generateCouponDates() {\n        List<LocalDateTime> dates = new ArrayList<>();\n        LocalDateTime current = creationTime.plusMonths(6);\n        while (current.isBefore(maturityDate)) {\n            dates.add(current);\n            current = current.plusMonths(6);\n        }\n        return dates;\n    }\n    \n    private boolean validateCounterparty(String counterparty) {\n        return counterparty != null && counterparty.length() > 5;\n    }\n    \n    private BigDecimal calculateDuration() {\n        return BigDecimal.valueOf(2.5);\n    }\n    \n    private BigDecimal calculateYTM() {\n        return couponRate.multiply(BigDecimal.valueOf(1.1));\n    }\n}\n\npublic class DerivativeContract extends FinancialInstrument {\n    private final String underlyingAsset;\n    private final LocalDateTime expirationDate;\n    private final BigDecimal strikePrice;\n    private final String contractType;\n    private volatile boolean isMarkedToMarket = false;\n    \n    public DerivativeContract(String instrumentId, BigDecimal notionalValue, String underlyingAsset,\n                             LocalDateTime expirationDate, BigDecimal strikePrice, String contractType) {\n        super(instrumentId, notionalValue);\n        this.underlyingAsset = underlyingAsset;\n        this.expirationDate = expirationDate;\n        this.strikePrice = strikePrice;\n        this.contractType = contractType;\n    }\n    \n    @Override\n    public BigDecimal calculateCurrentValue(LocalDateTime asOfDate) {\n        if (!isMarkedToMarket) {\n            throw new IllegalStateException(\"Derivative must be marked to market before valuation\");\n        }\n        if (asOfDate.isAfter(expirationDate)) {\n            return calculateExpirationValue();\n        }\n        return calculateTimeValue().add(calculateIntrinsicValue());\n    }\n    \n    @Override\n    public CompletableFuture<Boolean> executeTransaction(BigDecimal amount, String counterparty) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (!isMarkedToMarket) {\n                throw new IllegalStateException(\"Cannot trade unmarked derivative\");\n            }\n            if (LocalDateTime.now().isAfter(expirationDate)) {\n                throw new IllegalStateException(\"Cannot trade expired derivative\");\n            }\n            if (amount.compareTo(BigDecimal.ZERO) <= 0) {\n                throw new IllegalArgumentException(\"Transaction amount must be positive\");\n            }\n            logger.info(\"Executing derivative transaction: \" + instrumentId);\n            return performComplexSettlement(amount, counterparty);\n        });\n    }\n    \n    @Override\n    public List<String> getRequiredDocuments() {\n        if (\"SWAP\".equals(contractType)) {\n            return Arrays.asList(\"ISDA Master Agreement\", \"Confirmation\", \"Collateral Agreement\", \"Risk Disclosure\");\n        }\n        return Arrays.asList(\"Derivative Confirmation\", \"Risk Disclosure\", \"Margin Agreement\");\n    }\n    \n    @Override\n    public boolean validateInstrument() {\n        boolean baseValidation = underlyingAsset != null && !underlyingAsset.isEmpty() &&\n                               expirationDate.isAfter(LocalDateTime.now()) &&\n                               strikePrice.compareTo(BigDecimal.ZERO) > 0;\n        \n        if (\"SWAP\".equals(contractType) && !isMarkedToMarket) {\n            return false;\n        }\n        return baseValidation;\n    }\n    \n    @Override\n    public Map<String, Object> getRiskMetrics() {\n        Map<String, Object> metrics = new HashMap<>();\n        metrics.put(\"delta\", calculateDelta());\n        metrics.put(\"gamma\", calculateGamma());\n        metrics.put(\"vega\", calculateVega());\n        metrics.put(\"theta\", calculateTheta());\n        metrics.put(\"counterpartyRisk\", \"HIGH\");\n        if (!isMarkedToMarket) {\n            metrics.put(\"valuationRisk\", \"EXTREME\");\n        }\n        return metrics;\n    }\n    \n    public void markToMarket() {\n        this.isMarkedToMarket = true;\n    }\n    \n    private BigDecimal calculateExpirationValue() {\n        return strikePrice.subtract(faceValue).max(BigDecimal.ZERO);\n    }\n    \n    private BigDecimal calculateTimeValue() {\n        return BigDecimal.valueOf(100);\n    }\n    \n    private BigDecimal calculateIntrinsicValue() {\n        return BigDecimal.valueOf(50);\n    }\n    \n    private boolean performComplexSettlement(BigDecimal amount, String counterparty) {\n        try {\n            Thread.sleep(3000);\n            return true;\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return false;\n        }\n    }\n    \n    private BigDecimal calculateDelta() { return BigDecimal.valueOf(0.6); }\n    private BigDecimal calculateGamma() { return BigDecimal.valueOf(0.05); }\n    private BigDecimal calculateVega() { return BigDecimal.valueOf(0.3); }\n    private BigDecimal calculateTheta() { return BigDecimal.valueOf(-0.02); }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including calculating current value, executing transactions, validating instruments, and managing risk metrics. Each of these should be handled by separate classes or modules.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including calculating current value, executing transactions, validating instruments, and managing risk metrics. Each of these should be handled by separate classes or modules.", "solution_code": "NO FIX VERSION", "duration_seconds": 3.0743014812469482}
{"id": 21, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional\nimport asyncio\nimport logging\nfrom enum import Enum\n\nclass InstrumentType(Enum):\n    BOND = \"BOND\"\n    DERIVATIVE = \"DERIVATIVE\"\n    EQUITY = \"EQUITY\"\n\nclass FinancialInstrument(ABC):\n    def __init__(self, instrument_id: str, face_value: Decimal):\n        self.instrument_id = instrument_id\n        self.face_value = face_value\n        self.creation_time = datetime.now()\n        self.logger = logging.getLogger(self.__class__.__name__)\n    \n    @abstractmethod\n    def calculate_current_value(self, as_of_date: datetime) -> Decimal:\n        pass\n    \n    @abstractmethod\n    async def execute_transaction(self, amount: Decimal, counterparty: str) -> bool:\n        pass\n    \n    @abstractmethod\n    def get_required_documents(self) -> List[str]:\n        pass\n    \n    @abstractmethod\n    def validate_instrument(self) -> bool:\n        pass\n    \n    @abstractmethod\n    def get_risk_metrics(self) -> Dict[str, Any]:\n        pass\n\nclass CorporateBond(FinancialInstrument):\n    def __init__(self, instrument_id: str, face_value: Decimal, coupon_rate: Decimal,\n                 maturity_date: datetime, credit_rating: str):\n        super().__init__(instrument_id, face_value)\n        self.coupon_rate = coupon_rate\n        self.maturity_date = maturity_date\n        self.credit_rating = credit_rating\n        self.coupon_payment_dates = self._generate_coupon_dates()\n    \n    def calculate_current_value(self, as_of_date: datetime) -> Decimal:\n        if as_of_date > self.maturity_date:\n            return Decimal('0')\n        \n        present_value = self.face_value\n        for payment_date in self.coupon_payment_dates:\n            if payment_date > as_of_date:\n                coupon_payment = self.face_value * self.coupon_rate\n                present_value += coupon_payment\n        \n        return present_value\n    \n    async def execute_transaction(self, amount: Decimal, counterparty: str) -> bool:\n        if amount != self.face_value:\n            raise ValueError(\"Corporate bonds must be traded at face value\")\n        \n        if not self._validate_counterparty(counterparty):\n            return False\n        \n        self.logger.info(f\"Executing bond transaction: {self.instrument_id}\")\n        await asyncio.sleep(1)\n        return True\n    \n    def get_required_documents(self) -> List[str]:\n        return [\"Bond Certificate\", \"Credit Rating Report\", \"Indenture Agreement\"]\n    \n    def validate_instrument(self) -> bool:\n        return (self.credit_rating and \n                self.maturity_date > datetime.now() and \n                self.coupon_rate > Decimal('0'))\n    \n    def get_risk_metrics(self) -> Dict[str, Any]:\n        return {\n            \"credit_risk\": self.credit_rating,\n            \"duration\": self._calculate_duration(),\n            \"yield_to_maturity\": self._calculate_ytm()\n        }\n    \n    def _generate_coupon_dates(self) -> List[datetime]:\n        dates = []\n        current = self.creation_time + timedelta(days=180)\n        while current < self.maturity_date:\n            dates.append(current)\n            current += timedelta(days=180)\n        return dates\n    \n    def _validate_counterparty(self, counterparty: str) -> bool:\n        return counterparty and len(counterparty) > 5\n    \n    def _calculate_duration(self) -> Decimal:\n        return Decimal('2.5')\n    \n    def _calculate_ytm(self) -> Decimal:\n        return self.coupon_rate * Decimal('1.1')\n\nclass DerivativeContract(FinancialInstrument):\n    def __init__(self, instrument_id: str, notional_value: Decimal, underlying_asset: str,\n                 expiration_date: datetime, strike_price: Decimal, contract_type: str):\n        super().__init__(instrument_id, notional_value)\n        self.underlying_asset = underlying_asset\n        self.expiration_date = expiration_date\n        self.strike_price = strike_price\n        self.contract_type = contract_type\n        self._is_marked_to_market = False\n    \n    def calculate_current_value(self, as_of_date: datetime) -> Decimal:\n        if not self._is_marked_to_market:\n            raise RuntimeError(\"Derivative must be marked to market before valuation\")\n        \n        if as_of_date > self.expiration_date:\n            return self._calculate_expiration_value()\n        \n        return self._calculate_time_value() + self._calculate_intrinsic_value()\n    \n    async def execute_transaction(self, amount: Decimal, counterparty: str) -> bool:\n        if not self._is_marked_to_market:\n            raise RuntimeError(\"Cannot trade unmarked derivative\")\n        \n        if datetime.now() > self.expiration_date:\n            raise RuntimeError(\"Cannot trade expired derivative\")\n        \n        if amount <= Decimal('0'):\n            raise ValueError(\"Transaction amount must be positive\")\n        \n        self.logger.info(f\"Executing derivative transaction: {self.instrument_id}\")\n        return await self._perform_complex_settlement(amount, counterparty)\n    \n    def get_required_documents(self) -> List[str]:\n        if self.contract_type == \"SWAP\":\n            return [\"ISDA Master Agreement\", \"Confirmation\", \"Collateral Agreement\", \"Risk Disclosure\"]\n        return [\"Derivative Confirmation\", \"Risk Disclosure\", \"Margin Agreement\"]\n    \n    def validate_instrument(self) -> bool:\n        base_validation = (self.underlying_asset and \n                          self.expiration_date > datetime.now() and \n                          self.strike_price > Decimal('0'))\n        \n        if self.contract_type == \"SWAP\" and not self._is_marked_to_market:\n            return False\n        \n        return base_validation\n    \n    def get_risk_metrics(self) -> Dict[str, Any]:\n        metrics = {\n            \"delta\": self._calculate_delta(),\n            \"gamma\": self._calculate_gamma(),\n            \"vega\": self._calculate_vega(),\n            \"theta\": self._calculate_theta(),\n            \"counterparty_risk\": \"HIGH\"\n        }\n        \n        if not self._is_marked_to_market:\n            metrics[\"valuation_risk\"] = \"EXTREME\"\n        \n        return metrics\n    \n    def mark_to_market(self):\n        self._is_marked_to_market = True\n    \n    def _calculate_expiration_value(self) -> Decimal:\n        return max(self.strike_price - self.face_value, Decimal('0'))\n    \n    def _calculate_time_value(self) -> Decimal:\n        return Decimal('100')\n    \n    def _calculate_intrinsic_value(self) -> Decimal:\n        return Decimal('50')\n    \n    async def _perform_complex_settlement(self, amount: Decimal, counterparty: str) -> bool:\n        await asyncio.sleep(3)\n        return True\n    \n    def _calculate_delta(self) -> Decimal:\n        return Decimal('0.6')\n    \n    def _calculate_gamma(self) -> Decimal:\n        return Decimal('0.05')\n    \n    def _calculate_vega(self) -> Decimal:\n        return Decimal('0.3')\n    \n    def _calculate_theta(self) -> Decimal:\n        return Decimal('-0.02')", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\nfrom decimal import Decimal\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional\nimport asyncio\nimport logging\nfrom enum import Enum\n\nclass InstrumentType(Enum):\n    BOND = \"BOND\"\n    DERIVATIVE = \"DERIVATIVE\"\n    EQUITY = \"EQUITY\"\n\nclass FinancialInstrument(ABC):\n    def __init__(self, instrument_id: str, face_value: Decimal):\n        self.instrument_id = instrument_id\n        self.face_value = face_value\n        self.creation_time = datetime.now()\n        self.logger = logging.getLogger(self.__class__.__name__)\n    \n    @abstractmethod\n    def calculate_current_value(self, as_of_date: datetime) -> Decimal:\n        pass\n    \n    @abstractmethod\n    async def execute_transaction(self, amount: Decimal, counterparty: str) -> bool:\n        pass\n    \n    @abstractmethod\n    def get_required_documents(self) -> List[str]:\n        pass\n    \n    @abstractmethod\n    def validate_instrument(self) -> bool:\n        pass\n    \n    @abstractmethod\n    def get_risk_metrics(self) -> Dict[str, Any]:\n        pass\n\nclass CorporateBond(FinancialInstrument):\n    def __init__(self, instrument_id: str, face_value: Decimal, coupon_rate: Decimal,\n                 maturity_date: datetime, credit_rating: str):\n        super().__init__(instrument_id, face_value)\n        self.coupon_rate = coupon_rate\n        self.maturity_date = maturity_date\n        self.credit_rating = credit_rating\n        self.coupon_payment_dates = self._generate_coupon_dates()\n    \n    def calculate_current_value(self, as_of_date: datetime) -> Decimal:\n        if as_of_date > self.maturity_date:\n            return Decimal('0')\n        \n        present_value = self.face_value\n        for payment_date in self.coupon_payment_dates:\n            if payment_date > as_of_date:\n                coupon_payment = self.face_value * self.coupon_rate\n                present_value += coupon_payment\n        \n        return present_value\n    \n    async def execute_transaction(self, amount: Decimal, counterparty: str) -> bool:\n        if amount != self.face_value:\n            raise ValueError(\"Corporate bonds must be traded at face value\")\n        \n        if not self._validate_counterparty(counterparty):\n            return False\n        \n        self.logger.info(f\"Executing bond transaction: {self.instrument_id}\")\n        await asyncio.sleep(1)\n        return True\n    \n    def get_required_documents(self) -> List[str]:\n        return [\"Bond Certificate\", \"Credit Rating Report\", \"Indenture Agreement\"]\n    \n    def validate_instrument(self) -> bool:\n        return (self.credit_rating and \n                self.maturity_date > datetime.now() and \n                self.coupon_rate > Decimal('0'))\n    \n    def get_risk_metrics(self) -> Dict[str, Any]:\n        return {\n            \"credit_risk\": self.credit_rating,\n            \"duration\": self._calculate_duration(),\n            \"yield_to_maturity\": self._calculate_ytm()\n        }\n    \n    def _generate_coupon_dates(self) -> List[datetime]:\n        dates = []\n        current = self.creation_time + timedelta(days=180)\n        while current < self.maturity_date:\n            dates.append(current)\n            current += timedelta(days=180)\n        return dates\n    \n    def _validate_counterparty(self, counterparty: str) -> bool:\n        return counterparty and len(counterparty) > 5\n    \n    def _calculate_duration(self) -> Decimal:\n        return Decimal('2.5')\n    \n    def _calculate_ytm(self) -> Decimal:\n        return self.coupon_rate * Decimal('1.1')\n\nclass DerivativeContract(FinancialInstrument):\n    def __init__(self, instrument_id: str, notional_value: Decimal, underlying_asset: str,\n                 expiration_date: datetime, strike_price: Decimal, contract_type: str):\n        super().__init__(instrument_id, notional_value)\n        self.underlying_asset = underlying_asset\n        self.expiration_date = expiration_date\n        self.strike_price = strike_price\n        self.contract_type = contract_type\n        self._is_marked_to_market = False\n    \n    def calculate_current_value(self, as_of_date: datetime) -> Decimal:\n        if not self._is_marked_to_market:\n            raise RuntimeError(\"Derivative must be marked to market before valuation\")\n        \n        if as_of_date > self.expiration_date:\n            return self._calculate_expiration_value()\n        \n        return self._calculate_time_value() + self._calculate_intrinsic_value()\n    \n    async def execute_transaction(self, amount: Decimal, counterparty: str) -> bool:\n        if not self._is_marked_to_market:\n            raise RuntimeError(\"Cannot trade unmarked derivative\")\n        \n        if datetime.now() > self.expiration_date:\n            raise RuntimeError(\"Cannot trade expired derivative\")\n        \n        if amount <= Decimal('0'):\n            raise ValueError(\"Transaction amount must be positive\")\n        \n        self.logger.info(f\"Executing derivative transaction: {self.instrument_id}\")\n        return await self._perform_complex_settlement(amount, counterparty)\n    \n    def get_required_documents(self) -> List[str]:\n        if self.contract_type == \"SWAP\":\n            return [\"ISDA Master Agreement\", \"Confirmation\", \"Collateral Agreement\", \"Risk Disclosure\"]\n        return [\"Derivative Confirmation\", \"Risk Disclosure\", \"Margin Agreement\"]\n    \n    def validate_instrument(self) -> bool:\n        base_validation = (self.underlying_asset and \n                          self.expiration_date > datetime.now() and \n                          self.strike_price > Decimal('0'))\n        \n        if self.contract_type == \"SWAP\" and not self._is_marked_to_market:\n            return False\n        \n        return base_validation\n    \n    def get_risk_metrics(self) -> Dict[str, Any]:\n        metrics = {\n            \"delta\": self._calculate_delta(),\n            \"gamma\": self._calculate_gamma(),\n            \"vega\": self._calculate_vega(),\n            \"theta\": self._calculate_theta(),\n            \"counterparty_risk\": \"HIGH\"\n        }\n        \n        if not self._is_marked_to_market:\n            metrics[\"valuation_risk\"] = \"EXTREME\"\n        \n        return metrics\n    \n    def mark_to_market(self):\n        self._is_marked_to_market = True\n    \n    def _calculate_expiration_value(self) -> Decimal:\n        return max(self.strike_price - self.face_value, Decimal('0'))\n    \n    def _calculate_time_value(self) -> Decimal:\n        return Decimal('100')\n    \n    def _calculate_intrinsic_value(self) -> Decimal:\n        return Decimal('50')\n    \n    async def _perform_complex_settlement(self, amount: Decimal, counterparty: str) -> bool:\n        await asyncio.sleep(3)\n        return True\n    \n    def _calculate_delta(self) -> Decimal:\n        return Decimal('0.6')\n    \n    def _calculate_gamma(self) -> Decimal:\n        return Decimal('0.05')\n    \n    def _calculate_vega(self) -> Decimal:\n        return Decimal('0.3')\n    \n    def _calculate_theta(self) -> Decimal:\n        return Decimal('-0.02')", "raw_response": "**Interface Bloat**\nThe `FinancialInstrument` interface is bloated with too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.\n\nSRP: 3  \nOCP: 4  \nLSP: 5  \nISP: 1  \nDIP: 5\n\n**Interface Bloat**\nThe `FinancialInstrument` interface is bloated with too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.", "violation": "ISP, SRP, OCP, LSP, DIP", "violation_list": ["ISP", "SRP", "OCP", "LSP", "DIP"], "explanation": "**Interface Bloat**\nThe `FinancialInstrument` interface is bloated with too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.\n\nSRP: 3  \nOCP: 4  \nLSP: 5  \nISP: 1  \nDIP: 5\n\n**Interface Bloat**\nThe `FinancialInstrument` interface is bloated with too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they may not need.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.9099743366241455}
{"id": 22, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "import kotlinx.coroutines.*\nimport java.math.BigDecimal\nimport java.time.LocalDateTime\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.logging.Logger\n\nenum class InstrumentType {\n    BOND, DERIVATIVE, EQUITY\n}\n\nenum class RiskLevel {\n    LOW, MEDIUM, HIGH, EXTREME\n}\n\nabstract class FinancialInstrument(\n    protected val instrumentId: String,\n    protected val faceValue: BigDecimal\n) {\n    protected val creationTime: LocalDateTime = LocalDateTime.now()\n    protected val logger: Logger = Logger.getLogger(this::class.java.name)\n    \n    abstract suspend fun calculateCurrentValue(asOfDate: LocalDateTime): BigDecimal\n    abstract suspend fun executeTransaction(amount: BigDecimal, counterparty: String): Boolean\n    abstract fun getRequiredDocuments(): List<String>\n    abstract fun validateInstrument(): Boolean\n    abstract fun getRiskMetrics(): Map<String, Any>\n    \n    fun getInstrumentId(): String = instrumentId\n    fun getFaceValue(): BigDecimal = faceValue\n    fun getCreationTime(): LocalDateTime = creationTime\n}\n\nclass CorporateBond(\n    instrumentId: String,\n    faceValue: BigDecimal,\n    private val couponRate: BigDecimal,\n    private val maturityDate: LocalDateTime,\n    private val creditRating: String\n) : FinancialInstrument(instrumentId, faceValue) {\n    \n    private val couponPaymentDates: List<LocalDateTime> = generateCouponDates()\n    private val bondMetrics = ConcurrentHashMap<String, BigDecimal>()\n    \n    override suspend fun calculateCurrentValue(asOfDate: LocalDateTime): BigDecimal {\n        if (asOfDate.isAfter(maturityDate)) {\n            return BigDecimal.ZERO\n        }\n        \n        var presentValue = faceValue\n        couponPaymentDates.filter { it.isAfter(asOfDate) }\n            .forEach { _ ->\n                val couponPayment = faceValue.multiply(couponRate)\n                presentValue = presentValue.add(couponPayment)\n            }\n        \n        return presentValue\n    }\n    \n    override suspend fun executeTransaction(amount: BigDecimal, counterparty: String): Boolean {\n        if (amount.compareTo(faceValue) != 0) {\n            throw IllegalArgumentException(\"Corporate bonds must be traded at face value\")\n        }\n        \n        if (!validateCounterparty(counterparty)) {\n            return false\n        }\n        \n        logger.info(\"Executing bond transaction: $instrumentId\")\n        delay(1000)\n        return true\n    }\n    \n    override fun getRequiredDocuments(): List<String> {\n        return listOf(\"Bond Certificate\", \"Credit Rating Report\", \"Indenture Agreement\")\n    }\n    \n    override fun validateInstrument(): Boolean {\n        return creditRating.isNotEmpty() && \n               maturityDate.isAfter(LocalDateTime.now()) && \n               couponRate > BigDecimal.ZERO\n    }\n    \n    override fun getRiskMetrics(): Map<String, Any> {\n        return mapOf(\n            \"creditRisk\" to creditRating,\n            \"duration\" to calculateDuration(),\n            \"yieldToMaturity\" to calculateYTM(),\n            \"interestRateRisk\" to RiskLevel.MEDIUM\n        )\n    }\n    \n    private fun generateCouponDates(): List<LocalDateTime> {\n        val dates = mutableListOf<LocalDateTime>()\n        var current = creationTime.plusMonths(6)\n        \n        while (current.isBefore(maturityDate)) {\n            dates.add(current)\n            current = current.plusMonths(6)\n        }\n        \n        return dates\n    }\n    \n    private fun validateCounterparty(counterparty: String): Boolean {\n        return counterparty.isNotEmpty() && counterparty.length > 5\n    }\n    \n    private fun calculateDuration(): BigDecimal {\n        return bondMetrics.computeIfAbsent(\"duration\") { BigDecimal(\"2.5\") }\n    }\n    \n    private fun calculateYTM(): BigDecimal {\n        return bondMetrics.computeIfAbsent(\"ytm\") { \n            couponRate.multiply(BigDecimal(\"1.1\")) \n        }\n    }\n}\n\nclass DerivativeContract(\n    instrumentId: String,\n    notionalValue: BigDecimal,\n    private val underlyingAsset: String,\n    private val expirationDate: LocalDateTime,\n    private val strikePrice: BigDecimal,\n    private val contractType: String\n) : FinancialInstrument(instrumentId, notionalValue) {\n    \n    @Volatile\n    private var isMarkedToMarket = false\n    private val greeks = ConcurrentHashMap<String, BigDecimal>()\n    private val settlementCache = ConcurrentHashMap<String, Boolean>()\n    \n    override suspend fun calculateCurrentValue(asOfDate: LocalDateTime): BigDecimal {\n        if (!isMarkedToMarket) {\n            throw IllegalStateException(\"Derivative must be marked to market before valuation\")\n        }\n        \n        if (asOfDate.isAfter(expirationDate)) {\n            return calculateExpirationValue()\n        }\n        \n        return calculateTimeValue().add(calculateIntrinsicValue())\n    }\n    \n    override suspend fun executeTransaction(amount: BigDecimal, counterparty: String): Boolean {\n        if (!isMarkedToMarket) {\n            throw IllegalStateException(\"Cannot trade unmarked derivative\")\n        }\n        \n        if (LocalDateTime.now().isAfter(expirationDate)) {\n            throw IllegalStateException(\"Cannot trade expired derivative\")\n        }\n        \n        if (amount <= BigDecimal.ZERO) {\n            throw IllegalArgumentException(\"Transaction amount must be positive\")\n        }\n        \n        logger.info(\"Executing derivative transaction: $instrumentId\")\n        return performComplexSettlement(amount, counterparty)\n    }\n    \n    override fun getRequiredDocuments(): List<String> {\n        return when (contractType) {\n            \"SWAP\" -> listOf(\n                \"ISDA Master Agreement\", \n                \"Confirmation\", \n                \"Collateral Agreement\", \n                \"Risk Disclosure\"\n            )\n            else -> listOf(\n                \"Derivative Confirmation\", \n                \"Risk Disclosure\", \n                \"Margin Agreement\"\n            )\n        }\n    }\n    \n    override fun validateInstrument(): Boolean {\n        val baseValidation = underlyingAsset.isNotEmpty() &&\n                           expirationDate.isAfter(LocalDateTime.now()) &&\n                           strikePrice > BigDecimal.ZERO\n        \n        return if (contractType == \"SWAP\" && !isMarkedToMarket) {\n            false\n        } else {\n            baseValidation\n        }\n    }\n    \n    override fun getRiskMetrics(): Map<String, Any> {\n        val metrics = mutableMapOf<String, Any>(\n            \"delta\" to calculateDelta(),\n            \"gamma\" to calculateGamma(),\n            \"vega\" to calculateVega(),\n            \"theta\" to calculateTheta(),\n            \"counterpartyRisk\" to RiskLevel.HIGH\n        )\n        \n        if (!isMarkedToMarket) {\n            metrics[\"valuationRisk\"] = RiskLevel.EXTREME\n        }\n        \n        return metrics\n    }\n    \n    fun markToMarket() {\n        isMarkedToMarket = true\n        greeks.clear()\n    }\n    \n    private fun calculateExpirationValue(): BigDecimal {\n        return strikePrice.subtract(faceValue).max(BigDecimal.ZERO)\n    }\n    \n    private fun calculateTimeValue(): BigDecimal {\n        return BigDecimal(\"100\")\n    }\n    \n    private fun calculateIntrinsicValue(): BigDecimal {\n        return BigDecimal(\"50\")\n    }\n    \n    private suspend fun performComplexSettlement(amount: BigDecimal, counterparty: String): Boolean {\n        val cacheKey = \"$counterparty-$amount\"\n        \n        return settlementCache.computeIfAbsent(cacheKey) {\n            runBlocking {\n                delay(3000)\n                true\n            }\n        }\n    }\n    \n    private fun calculateDelta(): BigDecimal {\n        return greeks.computeIfAbsent(\"delta\") { BigDecimal(\"0.6\") }\n    }\n    \n    private fun calculateGamma(): BigDecimal {\n        return greeks.computeIfAbsent(\"gamma\") { BigDecimal(\"0.05\") }\n    }\n    \n    private fun calculateVega(): BigDecimal {\n        return greeks.computeIfAbsent(\"vega\") { BigDecimal(\"0.3\") }\n    }\n    \n    private fun calculateTheta(): BigDecimal {\n        return greeks.computeIfAbsent(\"theta\") { BigDecimal(\"-0.02\") }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport kotlinx.coroutines.*\nimport java.math.BigDecimal\nimport java.time.LocalDateTime\nimport java.util.concurrent.ConcurrentHashMap\nimport java.util.logging.Logger\n\nenum class InstrumentType {\n    BOND, DERIVATIVE, EQUITY\n}\n\nenum class RiskLevel {\n    LOW, MEDIUM, HIGH, EXTREME\n}\n\nabstract class FinancialInstrument(\n    protected val instrumentId: String,\n    protected val faceValue: BigDecimal\n) {\n    protected val creationTime: LocalDateTime = LocalDateTime.now()\n    protected val logger: Logger = Logger.getLogger(this::class.java.name)\n    \n    abstract suspend fun calculateCurrentValue(asOfDate: LocalDateTime): BigDecimal\n    abstract suspend fun executeTransaction(amount: BigDecimal, counterparty: String): Boolean\n    abstract fun getRequiredDocuments(): List<String>\n    abstract fun validateInstrument(): Boolean\n    abstract fun getRiskMetrics(): Map<String, Any>\n    \n    fun getInstrumentId(): String = instrumentId\n    fun getFaceValue(): BigDecimal = faceValue\n    fun getCreationTime(): LocalDateTime = creationTime\n}\n\nclass CorporateBond(\n    instrumentId: String,\n    faceValue: BigDecimal,\n    private val couponRate: BigDecimal,\n    private val maturityDate: LocalDateTime,\n    private val creditRating: String\n) : FinancialInstrument(instrumentId, faceValue) {\n    \n    private val couponPaymentDates: List<LocalDateTime> = generateCouponDates()\n    private val bondMetrics = ConcurrentHashMap<String, BigDecimal>()\n    \n    override suspend fun calculateCurrentValue(asOfDate: LocalDateTime): BigDecimal {\n        if (asOfDate.isAfter(maturityDate)) {\n            return BigDecimal.ZERO\n        }\n        \n        var presentValue = faceValue\n        couponPaymentDates.filter { it.isAfter(asOfDate) }\n            .forEach { _ ->\n                val couponPayment = faceValue.multiply(couponRate)\n                presentValue = presentValue.add(couponPayment)\n            }\n        \n        return presentValue\n    }\n    \n    override suspend fun executeTransaction(amount: BigDecimal, counterparty: String): Boolean {\n        if (amount.compareTo(faceValue) != 0) {\n            throw IllegalArgumentException(\"Corporate bonds must be traded at face value\")\n        }\n        \n        if (!validateCounterparty(counterparty)) {\n            return false\n        }\n        \n        logger.info(\"Executing bond transaction: $instrumentId\")\n        delay(1000)\n        return true\n    }\n    \n    override fun getRequiredDocuments(): List<String> {\n        return listOf(\"Bond Certificate\", \"Credit Rating Report\", \"Indenture Agreement\")\n    }\n    \n    override fun validateInstrument(): Boolean {\n        return creditRating.isNotEmpty() && \n               maturityDate.isAfter(LocalDateTime.now()) && \n               couponRate > BigDecimal.ZERO\n    }\n    \n    override fun getRiskMetrics(): Map<String, Any> {\n        return mapOf(\n            \"creditRisk\" to creditRating,\n            \"duration\" to calculateDuration(),\n            \"yieldToMaturity\" to calculateYTM(),\n            \"interestRateRisk\" to RiskLevel.MEDIUM\n        )\n    }\n    \n    private fun generateCouponDates(): List<LocalDateTime> {\n        val dates = mutableListOf<LocalDateTime>()\n        var current = creationTime.plusMonths(6)\n        \n        while (current.isBefore(maturityDate)) {\n            dates.add(current)\n            current = current.plusMonths(6)\n        }\n        \n        return dates\n    }\n    \n    private fun validateCounterparty(counterparty: String): Boolean {\n        return counterparty.isNotEmpty() && counterparty.length > 5\n    }\n    \n    private fun calculateDuration(): BigDecimal {\n        return bondMetrics.computeIfAbsent(\"duration\") { BigDecimal(\"2.5\") }\n    }\n    \n    private fun calculateYTM(): BigDecimal {\n        return bondMetrics.computeIfAbsent(\"ytm\") { \n            couponRate.multiply(BigDecimal(\"1.1\")) \n        }\n    }\n}\n\nclass DerivativeContract(\n    instrumentId: String,\n    notionalValue: BigDecimal,\n    private val underlyingAsset: String,\n    private val expirationDate: LocalDateTime,\n    private val strikePrice: BigDecimal,\n    private val contractType: String\n) : FinancialInstrument(instrumentId, notionalValue) {\n    \n    @Volatile\n    private var isMarkedToMarket = false\n    private val greeks = ConcurrentHashMap<String, BigDecimal>()\n    private val settlementCache = ConcurrentHashMap<String, Boolean>()\n    \n    override suspend fun calculateCurrentValue(asOfDate: LocalDateTime): BigDecimal {\n        if (!isMarkedToMarket) {\n            throw IllegalStateException(\"Derivative must be marked to market before valuation\")\n        }\n        \n        if (asOfDate.isAfter(expirationDate)) {\n            return calculateExpirationValue()\n        }\n        \n        return calculateTimeValue().add(calculateIntrinsicValue())\n    }\n    \n    override suspend fun executeTransaction(amount: BigDecimal, counterparty: String): Boolean {\n        if (!isMarkedToMarket) {\n            throw IllegalStateException(\"Cannot trade unmarked derivative\")\n        }\n        \n        if (LocalDateTime.now().isAfter(expirationDate)) {\n            throw IllegalStateException(\"Cannot trade expired derivative\")\n        }\n        \n        if (amount <= BigDecimal.ZERO) {\n            throw IllegalArgumentException(\"Transaction amount must be positive\")\n        }\n        \n        logger.info(\"Executing derivative transaction: $instrumentId\")\n        return performComplexSettlement(amount, counterparty)\n    }\n    \n    override fun getRequiredDocuments(): List<String> {\n        return when (contractType) {\n            \"SWAP\" -> listOf(\n                \"ISDA Master Agreement\", \n                \"Confirmation\", \n                \"Collateral Agreement\", \n                \"Risk Disclosure\"\n            )\n            else -> listOf(\n                \"Derivative Confirmation\", \n                \"Risk Disclosure\", \n                \"Margin Agreement\"\n            )\n        }\n    }\n    \n    override fun validateInstrument(): Boolean {\n        val baseValidation = underlyingAsset.isNotEmpty() &&\n                           expirationDate.isAfter(LocalDateTime.now()) &&\n                           strikePrice > BigDecimal.ZERO\n        \n        return if (contractType == \"SWAP\" && !isMarkedToMarket) {\n            false\n        } else {\n            baseValidation\n        }\n    }\n    \n    override fun getRiskMetrics(): Map<String, Any> {\n        val metrics = mutableMapOf<String, Any>(\n            \"delta\" to calculateDelta(),\n            \"gamma\" to calculateGamma(),\n            \"vega\" to calculateVega(),\n            \"theta\" to calculateTheta(),\n            \"counterpartyRisk\" to RiskLevel.HIGH\n        )\n        \n        if (!isMarkedToMarket) {\n            metrics[\"valuationRisk\"] = RiskLevel.EXTREME\n        }\n        \n        return metrics\n    }\n    \n    fun markToMarket() {\n        isMarkedToMarket = true\n        greeks.clear()\n    }\n    \n    private fun calculateExpirationValue(): BigDecimal {\n        return strikePrice.subtract(faceValue).max(BigDecimal.ZERO)\n    }\n    \n    private fun calculateTimeValue(): BigDecimal {\n        return BigDecimal(\"100\")\n    }\n    \n    private fun calculateIntrinsicValue(): BigDecimal {\n        return BigDecimal(\"50\")\n    }\n    \n    private suspend fun performComplexSettlement(amount: BigDecimal, counterparty: String): Boolean {\n        val cacheKey = \"$counterparty-$amount\"\n        \n        return settlementCache.computeIfAbsent(cacheKey) {\n            runBlocking {\n                delay(3000)\n                true\n            }\n        }\n    }\n    \n    private fun calculateDelta(): BigDecimal {\n        return greeks.computeIfAbsent(\"delta\") { BigDecimal(\"0.6\") }\n    }\n    \n    private fun calculateGamma(): BigDecimal {\n        return greeks.computeIfAbsent(\"gamma\") { BigDecimal(\"0.05\") }\n    }\n    \n    private fun calculateVega(): BigDecimal {\n        return greeks.computeIfAbsent(\"vega\") { BigDecimal(\"0.3\") }\n    }\n    \n    private fun calculateTheta(): BigDecimal {\n        return greeks.computeIfAbsent(\"theta\") { BigDecimal(\"-0.02\") }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as calculating current value, executing transactions, validating instruments, and managing risk metrics.\n\n5\n3\n4\n3\n3\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as calculating current value, executing transactions, validating instruments, and managing risk metrics.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as calculating current value, executing transactions, validating instruments, and managing risk metrics.\n\n5\n3\n4\n3\n3\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as calculating current value, executing transactions, validating instruments, and managing risk metrics.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.183987617492676}
{"id": 23, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Threading.Tasks;\nusing System.Numerics;\nusing Microsoft.Extensions.Logging;\n\npublic enum InstrumentType\n{\n    Bond, Derivative, Equity\n}\n\npublic enum RiskLevel\n{\n    Low, Medium, High, Extreme\n}\n\npublic abstract class FinancialInstrument\n{\n    protected readonly string InstrumentId;\n    protected readonly decimal FaceValue;\n    protected readonly DateTime CreationTime;\n    protected readonly ILogger Logger;\n    \n    protected FinancialInstrument(string instrumentId, decimal faceValue, ILogger logger)\n    {\n        InstrumentId = instrumentId;\n        FaceValue = faceValue;\n        CreationTime = DateTime.Now;\n        Logger = logger;\n    }\n    \n    public abstract Task<decimal> CalculateCurrentValueAsync(DateTime asOfDate);\n    public abstract Task<bool> ExecuteTransactionAsync(decimal amount, string counterparty);\n    public abstract List<string> GetRequiredDocuments();\n    public abstract bool ValidateInstrument();\n    public abstract Dictionary<string, object> GetRiskMetrics();\n    \n    public string GetInstrumentId() => InstrumentId;\n    public decimal GetFaceValue() => FaceValue;\n    public DateTime GetCreationTime() => CreationTime;\n}\n\npublic class CorporateBond : FinancialInstrument\n{\n    private readonly decimal _couponRate;\n    private readonly DateTime _maturityDate;\n    private readonly string _creditRating;\n    private readonly List<DateTime> _couponPaymentDates;\n    private readonly ConcurrentDictionary<string, decimal> _bondMetrics;\n    \n    public CorporateBond(string instrumentId, decimal faceValue, decimal couponRate, \n                        DateTime maturityDate, string creditRating, ILogger logger) \n        : base(instrumentId, faceValue, logger)\n    {\n        _couponRate = couponRate;\n        _maturityDate = maturityDate;\n        _creditRating = creditRating;\n        _couponPaymentDates = GenerateCouponDates();\n        _bondMetrics = new ConcurrentDictionary<string, decimal>();\n    }\n    \n    public override async Task<decimal> CalculateCurrentValueAsync(DateTime asOfDate)\n    {\n        if (asOfDate > _maturityDate)\n        {\n            return 0m;\n        }\n        \n        var presentValue = FaceValue;\n        \n        foreach (var paymentDate in _couponPaymentDates.Where(d => d > asOfDate))\n        {\n            var couponPayment = FaceValue * _couponRate;\n            presentValue += couponPayment;\n        }\n        \n        await Task.Delay(100);\n        return presentValue;\n    }\n    \n    public override async Task<bool> ExecuteTransactionAsync(decimal amount, string counterparty)\n    {\n        if (amount != FaceValue)\n        {\n            throw new ArgumentException(\"Corporate bonds must be traded at face value\");\n        }\n        \n        if (!ValidateCounterparty(counterparty))\n        {\n            return false;\n        }\n        \n        Logger.LogInformation($\"Executing bond transaction: {InstrumentId}\");\n        await Task.Delay(1000);\n        return true;\n    }\n    \n    public override List<string> GetRequiredDocuments()\n    {\n        return new List<string>\n        {\n            \"Bond Certificate\",\n            \"Credit Rating Report\",\n            \"Indenture Agreement\"\n        };\n    }\n    \n    public override bool ValidateInstrument()\n    {\n        return !string.IsNullOrEmpty(_creditRating) &&\n               _maturityDate > DateTime.Now &&\n               _couponRate > 0;\n    }\n    \n    public override Dictionary<string, object> GetRiskMetrics()\n    {\n        return new Dictionary<string, object>\n        {\n            [\"creditRisk\"] = _creditRating,\n            [\"duration\"] = CalculateDuration(),\n            [\"yieldToMaturity\"] = CalculateYTM(),\n            [\"interestRateRisk\"] = RiskLevel.Medium\n        };\n    }\n    \n    private List<DateTime> GenerateCouponDates()\n    {\n        var dates = new List<DateTime>();\n        var current = CreationTime.AddMonths(6);\n        \n        while (current < _maturityDate)\n        {\n            dates.Add(current);\n            current = current.AddMonths(6);\n        }\n        \n        return dates;\n    }\n    \n    private bool ValidateCounterparty(string counterparty)\n    {\n        return !string.IsNullOrEmpty(counterparty) && counterparty.Length > 5;\n    }\n    \n    private decimal CalculateDuration()\n    {\n        return _bondMetrics.GetOrAdd(\"duration\", _ => 2.5m);\n    }\n    \n    private decimal CalculateYTM()\n    {\n        return _bondMetrics.GetOrAdd(\"ytm\", _ => _couponRate * 1.1m);\n    }\n}\n\npublic class DerivativeContract : FinancialInstrument\n{\n    private readonly string _underlyingAsset;\n    private readonly DateTime _expirationDate;\n    private readonly decimal _strikePrice;\n    private readonly string _contractType;\n    private volatile bool _isMarkedToMarket;\n    private readonly ConcurrentDictionary<string, decimal> _greeks;\n    private readonly ConcurrentDictionary<string, bool> _settlementCache;\n    \n    public DerivativeContract(string instrumentId, decimal notionalValue, string underlyingAsset,\n                            DateTime expirationDate, decimal strikePrice, string contractType, ILogger logger)\n        : base(instrumentId, notionalValue, logger)\n    {\n        _underlyingAsset = underlyingAsset;\n        _expirationDate = expirationDate;\n        _strikePrice = strikePrice;\n        _contractType = contractType;\n        _isMarkedToMarket = false;\n        _greeks = new ConcurrentDictionary<string, decimal>();\n        _settlementCache = new ConcurrentDictionary<string, bool>();\n    }\n    \n    public override async Task<decimal> CalculateCurrentValueAsync(DateTime asOfDate)\n    {\n        if (!_isMarkedToMarket)\n        {\n            throw new InvalidOperationException(\"Derivative must be marked to market before valuation\");\n        }\n        \n        if (asOfDate > _expirationDate)\n        {\n            return CalculateExpirationValue();\n        }\n        \n        var timeValue = await CalculateTimeValueAsync();\n        var intrinsicValue = CalculateIntrinsicValue();\n        \n        return timeValue + intrinsicValue;\n    }\n    \n    public override async Task<bool> ExecuteTransactionAsync(decimal amount, string counterparty)\n    {\n        if (!_isMarkedToMarket)\n        {\n            throw new InvalidOperationException(\"Cannot trade unmarked derivative\");\n        }\n        \n        if (DateTime.Now > _expirationDate)\n        {\n            throw new InvalidOperationException(\"Cannot trade expired derivative\");\n        }\n        \n        if (amount <= 0)\n        {\n            throw new ArgumentException(\"Transaction amount must be positive\");\n        }\n        \n        Logger.LogInformation($\"Executing derivative transaction: {InstrumentId}\");\n        return await PerformComplexSettlementAsync(amount, counterparty);\n    }\n    \n    public override List<string> GetRequiredDocuments()\n    {\n        return _contractType switch\n        {\n            \"SWAP\" => new List<string>\n            {\n                \"ISDA Master Agreement\",\n                \"Confirmation\",\n                \"Collateral Agreement\",\n                \"Risk Disclosure\"\n            },\n            _ => new List<string>\n            {\n                \"Derivative Confirmation\",\n                \"Risk Disclosure\",\n                \"Margin Agreement\"\n            }\n        };\n    }\n    \n    public override bool ValidateInstrument()\n    {\n        var baseValidation = !string.IsNullOrEmpty(_underlyingAsset) &&\n                           _expirationDate > DateTime.Now &&\n                           _strikePrice > 0;\n        \n        if (_contractType == \"SWAP\" && !_isMarkedToMarket)\n        {\n            return false;\n        }\n        \n        return baseValidation;\n    }\n    \n    public override Dictionary<string, object> GetRiskMetrics()\n    {\n        var metrics = new Dictionary<string, object>\n        {\n            [\"delta\"] = CalculateDelta(),\n            [\"gamma\"] = CalculateGamma(),\n            [\"vega\"] = CalculateVega(),\n            [\"theta\"] = CalculateTheta(),\n            [\"counterpartyRisk\"] = RiskLevel.High\n        };\n        \n        if (!_isMarkedToMarket)\n        {\n            metrics[\"valuationRisk\"] = RiskLevel.Extreme;\n        }\n        \n        return metrics;\n    }\n    \n    public void MarkToMarket()\n    {\n        _isMarkedToMarket = true;\n        _greeks.Clear();\n    }\n    \n    private decimal CalculateExpirationValue()\n    {\n        return Math.Max(_strikePrice - FaceValue, 0);\n    }\n    \n    private async Task<decimal> CalculateTimeValueAsync()\n    {\n        await Task.Delay(50);\n        return 100m;\n    }\n    \n    private decimal CalculateIntrinsicValue()\n    {\n        return 50m;\n    }\n    \n    private async Task<bool> PerformComplexSettlementAsync(decimal amount, string counterparty)\n    {\n        var cacheKey = $\"{counterparty}-{amount}\";\n        \n        return _settlementCache.GetOrAdd(cacheKey, async key =>\n        {\n            await Task.Delay(3000);\n            return true;\n        });\n    }\n    \n    private decimal CalculateDelta()\n    {\n        return _greeks.GetOrAdd(\"delta\", _ => 0.6m);\n    }\n    \n    private decimal CalculateGamma()\n    {\n        return _greeks.GetOrAdd(\"gamma\", _ => 0.05m);\n    }\n    \n    private decimal CalculateVega()\n    {\n        return _greeks.GetOrAdd(\"vega\", _ => 0.3m);\n    }\n    \n    private decimal CalculateTheta()\n    {\n        return _greeks.GetOrAdd(\"theta\", _ => -0.02m);\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.Threading.Tasks;\nusing System.Numerics;\nusing Microsoft.Extensions.Logging;\n\npublic enum InstrumentType\n{\n    Bond, Derivative, Equity\n}\n\npublic enum RiskLevel\n{\n    Low, Medium, High, Extreme\n}\n\npublic abstract class FinancialInstrument\n{\n    protected readonly string InstrumentId;\n    protected readonly decimal FaceValue;\n    protected readonly DateTime CreationTime;\n    protected readonly ILogger Logger;\n    \n    protected FinancialInstrument(string instrumentId, decimal faceValue, ILogger logger)\n    {\n        InstrumentId = instrumentId;\n        FaceValue = faceValue;\n        CreationTime = DateTime.Now;\n        Logger = logger;\n    }\n    \n    public abstract Task<decimal> CalculateCurrentValueAsync(DateTime asOfDate);\n    public abstract Task<bool> ExecuteTransactionAsync(decimal amount, string counterparty);\n    public abstract List<string> GetRequiredDocuments();\n    public abstract bool ValidateInstrument();\n    public abstract Dictionary<string, object> GetRiskMetrics();\n    \n    public string GetInstrumentId() => InstrumentId;\n    public decimal GetFaceValue() => FaceValue;\n    public DateTime GetCreationTime() => CreationTime;\n}\n\npublic class CorporateBond : FinancialInstrument\n{\n    private readonly decimal _couponRate;\n    private readonly DateTime _maturityDate;\n    private readonly string _creditRating;\n    private readonly List<DateTime> _couponPaymentDates;\n    private readonly ConcurrentDictionary<string, decimal> _bondMetrics;\n    \n    public CorporateBond(string instrumentId, decimal faceValue, decimal couponRate, \n                        DateTime maturityDate, string creditRating, ILogger logger) \n        : base(instrumentId, faceValue, logger)\n    {\n        _couponRate = couponRate;\n        _maturityDate = maturityDate;\n        _creditRating = creditRating;\n        _couponPaymentDates = GenerateCouponDates();\n        _bondMetrics = new ConcurrentDictionary<string, decimal>();\n    }\n    \n    public override async Task<decimal> CalculateCurrentValueAsync(DateTime asOfDate)\n    {\n        if (asOfDate > _maturityDate)\n        {\n            return 0m;\n        }\n        \n        var presentValue = FaceValue;\n        \n        foreach (var paymentDate in _couponPaymentDates.Where(d => d > asOfDate))\n        {\n            var couponPayment = FaceValue * _couponRate;\n            presentValue += couponPayment;\n        }\n        \n        await Task.Delay(100);\n        return presentValue;\n    }\n    \n    public override async Task<bool> ExecuteTransactionAsync(decimal amount, string counterparty)\n    {\n        if (amount != FaceValue)\n        {\n            throw new ArgumentException(\"Corporate bonds must be traded at face value\");\n        }\n        \n        if (!ValidateCounterparty(counterparty))\n        {\n            return false;\n        }\n        \n        Logger.LogInformation($\"Executing bond transaction: {InstrumentId}\");\n        await Task.Delay(1000);\n        return true;\n    }\n    \n    public override List<string> GetRequiredDocuments()\n    {\n        return new List<string>\n        {\n            \"Bond Certificate\",\n            \"Credit Rating Report\",\n            \"Indenture Agreement\"\n        };\n    }\n    \n    public override bool ValidateInstrument()\n    {\n        return !string.IsNullOrEmpty(_creditRating) &&\n               _maturityDate > DateTime.Now &&\n               _couponRate > 0;\n    }\n    \n    public override Dictionary<string, object> GetRiskMetrics()\n    {\n        return new Dictionary<string, object>\n        {\n            [\"creditRisk\"] = _creditRating,\n            [\"duration\"] = CalculateDuration(),\n            [\"yieldToMaturity\"] = CalculateYTM(),\n            [\"interestRateRisk\"] = RiskLevel.Medium\n        };\n    }\n    \n    private List<DateTime> GenerateCouponDates()\n    {\n        var dates = new List<DateTime>();\n        var current = CreationTime.AddMonths(6);\n        \n        while (current < _maturityDate)\n        {\n            dates.Add(current);\n            current = current.AddMonths(6);\n        }\n        \n        return dates;\n    }\n    \n    private bool ValidateCounterparty(string counterparty)\n    {\n        return !string.IsNullOrEmpty(counterparty) && counterparty.Length > 5;\n    }\n    \n    private decimal CalculateDuration()\n    {\n        return _bondMetrics.GetOrAdd(\"duration\", _ => 2.5m);\n    }\n    \n    private decimal CalculateYTM()\n    {\n        return _bondMetrics.GetOrAdd(\"ytm\", _ => _couponRate * 1.1m);\n    }\n}\n\npublic class DerivativeContract : FinancialInstrument\n{\n    private readonly string _underlyingAsset;\n    private readonly DateTime _expirationDate;\n    private readonly decimal _strikePrice;\n    private readonly string _contractType;\n    private volatile bool _isMarkedToMarket;\n    private readonly ConcurrentDictionary<string, decimal> _greeks;\n    private readonly ConcurrentDictionary<string, bool> _settlementCache;\n    \n    public DerivativeContract(string instrumentId, decimal notionalValue, string underlyingAsset,\n                            DateTime expirationDate, decimal strikePrice, string contractType, ILogger logger)\n        : base(instrumentId, notionalValue, logger)\n    {\n        _underlyingAsset = underlyingAsset;\n        _expirationDate = expirationDate;\n        _strikePrice = strikePrice;\n        _contractType = contractType;\n        _isMarkedToMarket = false;\n        _greeks = new ConcurrentDictionary<string, decimal>();\n        _settlementCache = new ConcurrentDictionary<string, bool>();\n    }\n    \n    public override async Task<decimal> CalculateCurrentValueAsync(DateTime asOfDate)\n    {\n        if (!_isMarkedToMarket)\n        {\n            throw new InvalidOperationException(\"Derivative must be marked to market before valuation\");\n        }\n        \n        if (asOfDate > _expirationDate)\n        {\n            return CalculateExpirationValue();\n        }\n        \n        var timeValue = await CalculateTimeValueAsync();\n        var intrinsicValue = CalculateIntrinsicValue();\n        \n        return timeValue + intrinsicValue;\n    }\n    \n    public override async Task<bool> ExecuteTransactionAsync(decimal amount, string counterparty)\n    {\n        if (!_isMarkedToMarket)\n        {\n            throw new InvalidOperationException(\"Cannot trade unmarked derivative\");\n        }\n        \n        if (DateTime.Now > _expirationDate)\n        {\n            throw new InvalidOperationException(\"Cannot trade expired derivative\");\n        }\n        \n        if (amount <= 0)\n        {\n            throw new ArgumentException(\"Transaction amount must be positive\");\n        }\n        \n        Logger.LogInformation($\"Executing derivative transaction: {InstrumentId}\");\n        return await PerformComplexSettlementAsync(amount, counterparty);\n    }\n    \n    public override List<string> GetRequiredDocuments()\n    {\n        return _contractType switch\n        {\n            \"SWAP\" => new List<string>\n            {\n                \"ISDA Master Agreement\",\n                \"Confirmation\",\n                \"Collateral Agreement\",\n                \"Risk Disclosure\"\n            },\n            _ => new List<string>\n            {\n                \"Derivative Confirmation\",\n                \"Risk Disclosure\",\n                \"Margin Agreement\"\n            }\n        };\n    }\n    \n    public override bool ValidateInstrument()\n    {\n        var baseValidation = !string.IsNullOrEmpty(_underlyingAsset) &&\n                           _expirationDate > DateTime.Now &&\n                           _strikePrice > 0;\n        \n        if (_contractType == \"SWAP\" && !_isMarkedToMarket)\n        {\n            return false;\n        }\n        \n        return baseValidation;\n    }\n    \n    public override Dictionary<string, object> GetRiskMetrics()\n    {\n        var metrics = new Dictionary<string, object>\n        {\n            [\"delta\"] = CalculateDelta(),\n            [\"gamma\"] = CalculateGamma(),\n            [\"vega\"] = CalculateVega(),\n            [\"theta\"] = CalculateTheta(),\n            [\"counterpartyRisk\"] = RiskLevel.High\n        };\n        \n        if (!_isMarkedToMarket)\n        {\n            metrics[\"valuationRisk\"] = RiskLevel.Extreme;\n        }\n        \n        return metrics;\n    }\n    \n    public void MarkToMarket()\n    {\n        _isMarkedToMarket = true;\n        _greeks.Clear();\n    }\n    \n    private decimal CalculateExpirationValue()\n    {\n        return Math.Max(_strikePrice - FaceValue, 0);\n    }\n    \n    private async Task<decimal> CalculateTimeValueAsync()\n    {\n        await Task.Delay(50);\n        return 100m;\n    }\n    \n    private decimal CalculateIntrinsicValue()\n    {\n        return 50m;\n    }\n    \n    private async Task<bool> PerformComplexSettlementAsync(decimal amount, string counterparty)\n    {\n        var cacheKey = $\"{counterparty}-{amount}\";\n        \n        return _settlementCache.GetOrAdd(cacheKey, async key =>\n        {\n            await Task.Delay(3000);\n            return true;\n        });\n    }\n    \n    private decimal CalculateDelta()\n    {\n        return _greeks.GetOrAdd(\"delta\", _ => 0.6m);\n    }\n    \n    private decimal CalculateGamma()\n    {\n        return _greeks.GetOrAdd(\"gamma\", _ => 0.05m);\n    }\n    \n    private decimal CalculateVega()\n    {\n        return _greeks.GetOrAdd(\"vega\", _ => 0.3m);\n    }\n    \n    private decimal CalculateTheta()\n    {\n        return _greeks.GetOrAdd(\"theta\", _ => -0.02m);\n    }\n}", "raw_response": "**SRP Violation:**\n\nThe `FinancialInstrument` class and its subclasses (`CorporateBond`, `EquityShare`, etc.) violate the Single Responsibility Principle (SRP) because they are responsible for multiple aspects of a financial instrument, such as valuation, risk management, transaction execution, and document management. Each of these responsibilities should ideally be handled by separate classes or modules.\n\n**Example:**\n\nIn the provided code snippet, `FinancialInstrument` has methods like `CalculateCurrentValueAsync`, `ExecuteTransactionAsync`, `GetRequiredDocuments`, and `ValidateInstrument`. These methods cover different aspects of a financial instrument's lifecycle and functionality. \n\n**Refactoring Suggestion:**\n\n1. **Valuation Module:** Create a separate class or module responsible for calculating the value of financial instruments.\n2. **Risk Management Module:** Create another class or module to handle risk-related functionalities such as getting risk metrics.\n3. **Transaction Execution Module:** Implement a class or module that deals with executing transactions and managing settlements.\n4. **Document Management Module:** Develop a class or module to manage documents required for different types of financial instruments.\n\n**Refactored Code Example:**\n\n```csharp\npublic abstract class FinancialInstrument\n{\n    public string InstrumentId { get; set; }\n    public decimal FaceValue { get; set; }\n\n    // Common properties and methods\n\n    public abstract bool ValidateInstrument();\n}\n\npublic interface IValuationService\n{\n    Task<decimal> CalculateCurrentValueAsync(FinancialInstrument instrument, DateTime asOfDate);\n}\n\npublic interface IRiskManagementService\n{\n    Dictionary<string, object> GetRiskMetrics(FinancialInstrument instrument);\n}\n\npublic interface ITransactionExecutionService\n{\n    Task<bool> ExecuteTransactionAsync(FinancialInstrument instrument, decimal amount, string counterparty);\n}\n\npublic interface IDocumentManagementService\n{\n    List<string> GetRequiredDocuments(FinancialInstrument instrument);\n}\n\n// Example implementation for CorporateBond\npublic class CorporateBond : FinancialInstrument\n{\n    public DateTime MaturityDate { get; set; }\n    public double CouponRate { get; set; }\n\n    public override bool ValidateInstrument()\n    {\n        // Validation logic specific to Corporate Bond\n        return MaturityDate > DateTime.Now && CouponRate >= 0;\n    }\n}\n\npublic class CorporateBondValuationService : IValuationService\n{\n    public async Task<decimal> CalculateCurrentValueAsync(FinancialInstrument instrument, DateTime asOfDate)\n    {\n        var bond = (CorporateBond)instrument;\n        // Valuation logic specific to Corporate Bond\n        return await Task.FromResult(100m); // Placeholder value\n    }\n}\n\npublic class CorporateBondRiskManagementService : IRiskManagementService\n{\n    public Dictionary<string, object> GetRiskMetrics(FinancialInstrument instrument)\n    {\n        var bond = (CorporateBond)instrument;\n        // Risk metrics calculation specific to Corporate Bond\n        return new Dictionary<string, object>\n        {\n            { \"CreditRating\", \"AAA\" },\n            { \"InterestRateRisk\", 0.5m }\n        };\n    }\n}\n\npublic class CorporateBondTransactionExecutionService : ITransactionExecutionService\n{\n    public async Task<bool> ExecuteTransactionAsync(FinancialInstrument instrument, decimal amount, string counterparty)\n    {\n        var bond = (CorporateBond)instrument;\n        // Transaction execution logic specific to Corporate Bond\n        return await Task.FromResult(true); // Placeholder value\n    }\n}\n\npublic class CorporateBondDocumentManagementService : IDocumentManagementService\n{\n    public List<string> GetRequiredDocuments(FinancialInstrument instrument)\n    {\n        // Document management logic specific to Corporate Bond\n        return new List<string>\n        {\n            \"Indenture\",\n            \"Offering Circular\"\n        };\n    }\n}\n```\n\nIn this refactored example, each financial instrument class (`CorporateBond`, `EquityShare`, etc.) is responsible only for its core properties and validation. The other functionalities are handled by separate services that adhere to the Single Responsibility Principle.\n\n**SRP Benefits:**\n\n- **Maintainability:** Easier to maintain and update individual components without affecting others.\n- **Testability:** Unit tests can be written more effectively since each class has a single responsibility.\n- **Scalability:** New functionalities can be added with minimal impact on existing codebase.\n- **Reusability:** Services can be reused across different types of financial instruments.\n\nBy adhering to the Single Responsibility Principle, the code becomes cleaner, more modular, and easier to manage.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP Violation:**\n\nThe `FinancialInstrument` class and its subclasses (`CorporateBond`, `EquityShare`, etc.) violate the Single Responsibility Principle (SRP) because they are responsible for multiple aspects of a financial instrument, such as valuation, risk management, transaction execution, and document management. Each of these responsibilities should ideally be handled by separate classes or modules.\n\n**Example:**\n\nIn the provided code snippet, `FinancialInstrument` has methods like `CalculateCurrentValueAsync`, `ExecuteTransactionAsync`, `GetRequiredDocuments`, and `ValidateInstrument`. These methods cover different aspects of a financial instrument's lifecycle and functionality. \n\n**Refactoring Suggestion:**\n\n1. **Valuation Module:** Create a separate class or module responsible for calculating the value of financial instruments.\n2. **Risk Management Module:** Create another class or module to handle risk-related functionalities such as getting risk metrics.\n3. **Transaction Execution Module:** Implement a class or module that deals with executing transactions and managing settlements.\n4. **Document Management Module:** Develop a class or module to manage documents required for different types of financial instruments.\n\n**Refactored Code Example:**", "solution_code": "NO FIX VERSION", "duration_seconds": 32.328012466430664}
{"id": 24, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public interface FuelService {\n    void refuel(String fuelType);\n}\n\npublic class GasolineFuelService implements FuelService {\n    @Override\n    public void refuel(String fuelType) {\n        System.out.println(\"Filling gas tank with \" + fuelType);\n    }\n}\n\npublic class ElectricityFuelService implements FuelService {\n    @Override\n    public void refuel(String fuelType) {\n        System.out.println(\"Charging battery with \" + fuelType);\n    }\n}\n\npublic class Vehicle {\n    private GasolineFuelService gasolineFuelService;\n    private ElectricityFuelService electricityFuelService;\n    \n    public Vehicle() {\n        this.gasolineFuelService = new GasolineFuelService();\n        this.electricityFuelService = new ElectricityFuelService();\n    }\n    \n    public void refuelWithGasoline() {\n        gasolineFuelService.refuel(\"gasoline\");\n    }\n    \n    public void refuelWithElectricity() {\n        electricityFuelService.refuel(\"electricity\");\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic interface FuelService {\n    void refuel(String fuelType);\n}\n\npublic class GasolineFuelService implements FuelService {\n    @Override\n    public void refuel(String fuelType) {\n        System.out.println(\"Filling gas tank with \" + fuelType);\n    }\n}\n\npublic class ElectricityFuelService implements FuelService {\n    @Override\n    public void refuel(String fuelType) {\n        System.out.println(\"Charging battery with \" + fuelType);\n    }\n}\n\npublic class Vehicle {\n    private GasolineFuelService gasolineFuelService;\n    private ElectricityFuelService electricityFuelService;\n    \n    public Vehicle() {\n        this.gasolineFuelService = new GasolineFuelService();\n        this.electricityFuelService = new ElectricityFuelService();\n    }\n    \n    public void refuelWithGasoline() {\n        gasolineFuelService.refuel(\"gasoline\");\n    }\n    \n    public void refuelWithElectricity() {\n        electricityFuelService.refuel(\"electricity\");\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing fuel services and handling vehicle operations.\n\n0\n1\n2\n3\n4\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing fuel services and handling vehicle operations.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing fuel services and handling vehicle operations.\n\n0\n1\n2\n3\n4\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing fuel services and handling vehicle operations.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.766080379486084}
{"id": 25, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "class DatabaseConnection:\n    def connect(self):\n        print(\"Connecting to MySQL database\")\n    \n    def execute_query(self, query):\n        print(f\"Executing query: {query}\")\n    \n    def close(self):\n        print(\"Closing MySQL connection\")\n\nclass UserService:\n    def __init__(self):\n        self.db_connection = DatabaseConnection()\n    \n    def get_user(self, user_id):\n        self.db_connection.connect()\n        result = self.db_connection.execute_query(f\"SELECT * FROM users WHERE id = {user_id}\")\n        self.db_connection.close()\n        return result\n    \n    def save_user(self, user_data):\n        self.db_connection.connect()\n        self.db_connection.execute_query(f\"INSERT INTO users VALUES {user_data}\")\n        self.db_connection.close()", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nclass DatabaseConnection:\n    def connect(self):\n        print(\"Connecting to MySQL database\")\n    \n    def execute_query(self, query):\n        print(f\"Executing query: {query}\")\n    \n    def close(self):\n        print(\"Closing MySQL connection\")\n\nclass UserService:\n    def __init__(self):\n        self.db_connection = DatabaseConnection()\n    \n    def get_user(self, user_id):\n        self.db_connection.connect()\n        result = self.db_connection.execute_query(f\"SELECT * FROM users WHERE id = {user_id}\")\n        self.db_connection.close()\n        return result\n    \n    def save_user(self, user_data):\n        self.db_connection.connect()\n        self.db_connection.execute_query(f\"INSERT INTO users VALUES {user_data}\")\n        self.db_connection.close()", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it handles both data processing and file operations.\n\n```python\nclass DataHandler:\n    def __init__(self, filename):\n        self.filename = filename\n\n    def read_data(self):\n        with open(self.filename, 'r') as file:\n            return file.read()\n\n    def write_data(self, data):\n        with open(self.filename, 'w') as file:\n            file.write(data)\n\n    def process_data(self, data):\n        # Some complex data processing logic\n        processed_data = data.upper()  # Example transformation\n        return processed_data\n\n    def save_processed_data(self, processed_data):\n        self.write_data(processed_data)\n```", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it handles both data processing and file operations.", "solution_code": "NO FIX VERSION", "duration_seconds": 5.173093795776367}
{"id": 26, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "interface PaymentProcessor {\n    fun processPayment(amount: Double): Boolean\n}\n\nclass CreditCardProcessor : PaymentProcessor {\n    override fun processPayment(amount: Double): Boolean {\n        println(\"Processing credit card payment of $$amount\")\n        return true\n    }\n}\n\nclass PayPalProcessor : PaymentProcessor {\n    override fun processPayment(amount: Double): Boolean {\n        println(\"Processing PayPal payment of $$amount\")\n        return true\n    }\n}\n\nclass OrderService {\n    private val creditCardProcessor = CreditCardProcessor()\n    private val payPalProcessor = PayPalProcessor()\n    \n    fun processOrder(amount: Double, paymentMethod: String): Boolean {\n        return when (paymentMethod) {\n            \"credit_card\" -> creditCardProcessor.processPayment(amount)\n            \"paypal\" -> payPalProcessor.processPayment(amount)\n            else -> false\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\ninterface PaymentProcessor {\n    fun processPayment(amount: Double): Boolean\n}\n\nclass CreditCardProcessor : PaymentProcessor {\n    override fun processPayment(amount: Double): Boolean {\n        println(\"Processing credit card payment of $$amount\")\n        return true\n    }\n}\n\nclass PayPalProcessor : PaymentProcessor {\n    override fun processPayment(amount: Double): Boolean {\n        println(\"Processing PayPal payment of $$amount\")\n        return true\n    }\n}\n\nclass OrderService {\n    private val creditCardProcessor = CreditCardProcessor()\n    private val payPalProcessor = PayPalProcessor()\n    \n    fun processOrder(amount: Double, paymentMethod: String): Boolean {\n        return when (paymentMethod) {\n            \"credit_card\" -> creditCardProcessor.processPayment(amount)\n            \"paypal\" -> payPalProcessor.processPayment(amount)\n            else -> false\n        }\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data and handling business logic.\n\nclass UserManager {\n    private var users = mutableListOf<User>()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun removeUser(userId: Int) {\n        users.removeIf { it.id == userId }\n    }\n\n    fun getUserById(userId: Int): User? {\n        return users.find { it.id == userId }\n    }\n\n    fun calculateTotalRevenue(): Double {\n        var total = 0.0\n        for (user in users) {\n            if (user.isPremium) {\n                total += user.revenue * 1.2\n            } else {\n                total += user.revenue\n            }\n        }\n        return total\n    }\n\n    fun sendEmailToAllUsers(message: String) {\n        for (user in users) {\n            println(\"Sending email to ${user.email}: $message\")\n        }\n    }\n}\n\n**SRP 1**\n**OCP 2**\n**LSP 3**\n**ISP 4**\n**DIP 5**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data and handling business logic.", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data and handling business logic.\n\nclass UserManager {\n    private var users = mutableListOf<User>()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun removeUser(userId: Int) {\n        users.removeIf { it.id == userId }\n    }\n\n    fun getUserById(userId: Int): User? {\n        return users.find { it.id == userId }\n    }\n\n    fun calculateTotalRevenue(): Double {\n        var total = 0.0\n        for (user in users) {\n            if (user.isPremium) {\n                total += user.revenue * 1.2\n            } else {\n                total += user.revenue\n            }\n        }\n        return total\n    }\n\n    fun sendEmailToAllUsers(message: String) {\n        for (user in users) {\n            println(\"Sending email to ${user.email}: $message\")\n        }\n    }\n}\n\n**SRP 1**\n**OCP 2**\n**LSP 3**\n**ISP 4**\n**DIP 5**\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including managing user data and handling business logic.", "solution_code": "NO FIX VERSION", "duration_seconds": 8.865288496017456}
{"id": 27, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "public interface IEmailService\n{\n    void SendEmail(string to, string subject, string body);\n}\n\npublic class SmtpEmailService : IEmailService\n{\n    public void SendEmail(string to, string subject, string body)\n    {\n        Console.WriteLine($\"Sending SMTP email to {to}: {subject}\");\n    }\n}\n\npublic class SendGridEmailService : IEmailService\n{\n    public void SendEmail(string to, string subject, string body)\n    {\n        Console.WriteLine($\"Sending SendGrid email to {to}: {subject}\");\n    }\n}\n\npublic class NotificationService\n{\n    private SmtpEmailService smtpEmailService;\n    private SendGridEmailService sendGridEmailService;\n    \n    public NotificationService()\n    {\n        smtpEmailService = new SmtpEmailService();\n        sendGridEmailService = new SendGridEmailService();\n    }\n    \n    public void SendWelcomeEmail(string userEmail)\n    {\n        smtpEmailService.SendEmail(userEmail, \"Welcome\", \"Welcome to our platform!\");\n    }\n    \n    public void SendPromotionalEmail(string userEmail)\n    {\n        sendGridEmailService.SendEmail(userEmail, \"Special Offer\", \"Check out our latest deals!\");\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic interface IEmailService\n{\n    void SendEmail(string to, string subject, string body);\n}\n\npublic class SmtpEmailService : IEmailService\n{\n    public void SendEmail(string to, string subject, string body)\n    {\n        Console.WriteLine($\"Sending SMTP email to {to}: {subject}\");\n    }\n}\n\npublic class SendGridEmailService : IEmailService\n{\n    public void SendEmail(string to, string subject, string body)\n    {\n        Console.WriteLine($\"Sending SendGrid email to {to}: {subject}\");\n    }\n}\n\npublic class NotificationService\n{\n    private SmtpEmailService smtpEmailService;\n    private SendGridEmailService sendGridEmailService;\n    \n    public NotificationService()\n    {\n        smtpEmailService = new SmtpEmailService();\n        sendGridEmailService = new SendGridEmailService();\n    }\n    \n    public void SendWelcomeEmail(string userEmail)\n    {\n        smtpEmailService.SendEmail(userEmail, \"Welcome\", \"Welcome to our platform!\");\n    }\n    \n    public void SendPromotionalEmail(string userEmail)\n    {\n        sendGridEmailService.SendEmail(userEmail, \"Special Offer\", \"Check out our latest deals!\");\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities related to different types of email services.\n\npublic class OrderProcessor\n{\n    public void ProcessOrder(Order order)\n    {\n        ValidateOrder(order);\n        CalculateTotal(order);\n        ApplyDiscounts(order);\n        SaveOrderToDatabase(order);\n        SendConfirmationEmail(order);\n        LogOrderProcessing(order);\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic here\n    }\n\n    private void CalculateTotal(Order order)\n    {\n        // Calculation logic here\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount logic here\n    }\n\n    private void SaveOrderToDatabase(Order order)\n    {\n        // Database saving logic here\n    }\n\n    private void SendConfirmationEmail(Order order)\n    {\n        // Email sending logic here\n    }\n\n    private void LogOrderProcessing(Order order)\n    {\n        // Logging logic here\n    }\n}\n\n**SRP: 1**\n**OCP: 2**\n**LSP: 5**\n**ISP: 5**\n**DIP: 3**", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities related to different types of email services.\n\npublic class OrderProcessor\n{\n    public void ProcessOrder(Order order)\n    {\n        ValidateOrder(order);\n        CalculateTotal(order);\n        ApplyDiscounts(order);\n        SaveOrderToDatabase(order);\n        SendConfirmationEmail(order);\n        LogOrderProcessing(order);\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic here\n    }\n\n    private void CalculateTotal(Order order)\n    {\n        // Calculation logic here\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount logic here\n    }\n\n    private void SaveOrderToDatabase(Order order)\n    {\n        // Database saving logic here\n    }\n\n    private void SendConfirmationEmail(Order order)\n    {\n        // Email sending logic here\n    }\n\n    private void LogOrderProcessing(Order order)\n    {\n        // Logging logic here\n    }\n}\n\n**SRP: 1**\n**OCP: 2**\n**LSP: 5**\n**ISP: 5**\n**DIP: 3**", "solution_code": "NO FIX VERSION", "duration_seconds": 7.985969066619873}
{"id": 28, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public interface Logger {\n    void log(String level, String message);\n    void logError(String message, Exception exception);\n}\n\npublic class FileLogger implements Logger {\n    private String logFilePath;\n    \n    public FileLogger(String logFilePath) {\n        this.logFilePath = logFilePath;\n    }\n    \n    @Override\n    public void log(String level, String message) {\n        System.out.println(\"[FILE LOG] [\" + level + \"] \" + message + \" -> \" + logFilePath);\n    }\n    \n    @Override\n    public void logError(String message, Exception exception) {\n        System.out.println(\"[FILE ERROR] \" + message + \": \" + exception.getMessage() + \" -> \" + logFilePath);\n    }\n}\n\npublic class DatabaseLogger implements Logger {\n    private String connectionString;\n    \n    public DatabaseLogger(String connectionString) {\n        this.connectionString = connectionString;\n    }\n    \n    @Override\n    public void log(String level, String message) {\n        System.out.println(\"[DB LOG] [\" + level + \"] \" + message + \" -> \" + connectionString);\n    }\n    \n    @Override\n    public void logError(String message, Exception exception) {\n        System.out.println(\"[DB ERROR] \" + message + \": \" + exception.getMessage() + \" -> \" + connectionString);\n    }\n}\n\npublic class CloudLogger implements Logger {\n    private String apiEndpoint;\n    private String apiKey;\n    \n    public CloudLogger(String apiEndpoint, String apiKey) {\n        this.apiEndpoint = apiEndpoint;\n        this.apiKey = apiKey;\n    }\n    \n    @Override\n    public void log(String level, String message) {\n        System.out.println(\"[CLOUD LOG] [\" + level + \"] \" + message + \" -> \" + apiEndpoint);\n    }\n    \n    @Override\n    public void logError(String message, Exception exception) {\n        System.out.println(\"[CLOUD ERROR] \" + message + \": \" + exception.getMessage() + \" -> \" + apiEndpoint);\n    }\n}\n\npublic class OrderProcessor {\n    private FileLogger fileLogger;\n    private DatabaseLogger databaseLogger;\n    private CloudLogger cloudLogger;\n    \n    public OrderProcessor() {\n        this.fileLogger = new FileLogger(\"/var/log/orders.log\");\n        this.databaseLogger = new DatabaseLogger(\"jdbc:mysql://localhost:3306/logs\");\n        this.cloudLogger = new CloudLogger(\"https://api.cloudlogs.com\", \"secret-key\");\n    }\n    \n    public void processOrder(String orderId, double amount) {\n        try {\n            fileLogger.log(\"INFO\", \"Processing order: \" + orderId + \" for amount: $\" + amount);\n            \n            validateOrder(orderId, amount);\n            \n            databaseLogger.log(\"INFO\", \"Order validation successful for: \" + orderId);\n            \n            chargePayment(amount);\n            \n            cloudLogger.log(\"INFO\", \"Payment processed successfully for order: \" + orderId);\n            \n            updateInventory(orderId);\n            \n            fileLogger.log(\"SUCCESS\", \"Order completed: \" + orderId);\n            \n        } catch (Exception e) {\n            fileLogger.logError(\"Order processing failed for: \" + orderId, e);\n            databaseLogger.logError(\"Database error during order: \" + orderId, e);\n            cloudLogger.logError(\"Critical failure for order: \" + orderId, e);\n            throw e;\n        }\n    }\n    \n    private void validateOrder(String orderId, double amount) throws Exception {\n        if (amount <= 0) {\n            throw new Exception(\"Invalid order amount\");\n        }\n        fileLogger.log(\"DEBUG\", \"Order validation passed for: \" + orderId);\n    }\n    \n    private void chargePayment(double amount) throws Exception {\n        databaseLogger.log(\"INFO\", \"Attempting to charge payment: $\" + amount);\n        if (amount > 10000) {\n            throw new Exception(\"Payment amount exceeds limit\");\n        }\n    }\n    \n    private void updateInventory(String orderId) {\n        cloudLogger.log(\"INFO\", \"Updating inventory for order: \" + orderId);\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic interface Logger {\n    void log(String level, String message);\n    void logError(String message, Exception exception);\n}\n\npublic class FileLogger implements Logger {\n    private String logFilePath;\n    \n    public FileLogger(String logFilePath) {\n        this.logFilePath = logFilePath;\n    }\n    \n    @Override\n    public void log(String level, String message) {\n        System.out.println(\"[FILE LOG] [\" + level + \"] \" + message + \" -> \" + logFilePath);\n    }\n    \n    @Override\n    public void logError(String message, Exception exception) {\n        System.out.println(\"[FILE ERROR] \" + message + \": \" + exception.getMessage() + \" -> \" + logFilePath);\n    }\n}\n\npublic class DatabaseLogger implements Logger {\n    private String connectionString;\n    \n    public DatabaseLogger(String connectionString) {\n        this.connectionString = connectionString;\n    }\n    \n    @Override\n    public void log(String level, String message) {\n        System.out.println(\"[DB LOG] [\" + level + \"] \" + message + \" -> \" + connectionString);\n    }\n    \n    @Override\n    public void logError(String message, Exception exception) {\n        System.out.println(\"[DB ERROR] \" + message + \": \" + exception.getMessage() + \" -> \" + connectionString);\n    }\n}\n\npublic class CloudLogger implements Logger {\n    private String apiEndpoint;\n    private String apiKey;\n    \n    public CloudLogger(String apiEndpoint, String apiKey) {\n        this.apiEndpoint = apiEndpoint;\n        this.apiKey = apiKey;\n    }\n    \n    @Override\n    public void log(String level, String message) {\n        System.out.println(\"[CLOUD LOG] [\" + level + \"] \" + message + \" -> \" + apiEndpoint);\n    }\n    \n    @Override\n    public void logError(String message, Exception exception) {\n        System.out.println(\"[CLOUD ERROR] \" + message + \": \" + exception.getMessage() + \" -> \" + apiEndpoint);\n    }\n}\n\npublic class OrderProcessor {\n    private FileLogger fileLogger;\n    private DatabaseLogger databaseLogger;\n    private CloudLogger cloudLogger;\n    \n    public OrderProcessor() {\n        this.fileLogger = new FileLogger(\"/var/log/orders.log\");\n        this.databaseLogger = new DatabaseLogger(\"jdbc:mysql://localhost:3306/logs\");\n        this.cloudLogger = new CloudLogger(\"https://api.cloudlogs.com\", \"secret-key\");\n    }\n    \n    public void processOrder(String orderId, double amount) {\n        try {\n            fileLogger.log(\"INFO\", \"Processing order: \" + orderId + \" for amount: $\" + amount);\n            \n            validateOrder(orderId, amount);\n            \n            databaseLogger.log(\"INFO\", \"Order validation successful for: \" + orderId);\n            \n            chargePayment(amount);\n            \n            cloudLogger.log(\"INFO\", \"Payment processed successfully for order: \" + orderId);\n            \n            updateInventory(orderId);\n            \n            fileLogger.log(\"SUCCESS\", \"Order completed: \" + orderId);\n            \n        } catch (Exception e) {\n            fileLogger.logError(\"Order processing failed for: \" + orderId, e);\n            databaseLogger.logError(\"Database error during order: \" + orderId, e);\n            cloudLogger.logError(\"Critical failure for order: \" + orderId, e);\n            throw e;\n        }\n    }\n    \n    private void validateOrder(String orderId, double amount) throws Exception {\n        if (amount <= 0) {\n            throw new Exception(\"Invalid order amount\");\n        }\n        fileLogger.log(\"DEBUG\", \"Order validation passed for: \" + orderId);\n    }\n    \n    private void chargePayment(double amount) throws Exception {\n        databaseLogger.log(\"INFO\", \"Attempting to charge payment: $\" + amount);\n        if (amount > 10000) {\n            throw new Exception(\"Payment amount exceeds limit\");\n        }\n    }\n    \n    private void updateInventory(String orderId) {\n        cloudLogger.log(\"INFO\", \"Updating inventory for order: \" + orderId);\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including processing orders and logging.\n\n0\n1\n2\n3\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including processing orders and logging.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including processing orders and logging.\n\n0\n1\n2\n3\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including processing orders and logging.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.7357072830200195}
{"id": 29, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\nfrom typing import List\n\nclass Vehicle(ABC):\n    def __init__(self, brand: str, fuel_capacity: float):\n        self.brand = brand\n        self.fuel_capacity = fuel_capacity\n        self.current_fuel_level = 0.0\n    \n    @abstractmethod\n    def refuel(self, fuel_type: str, amount: float) -> None:\n        pass\n    \n    @abstractmethod\n    def get_remaining_range(self) -> float:\n        pass\n    \n    @property\n    def fuel_level(self) -> float:\n        return self.current_fuel_level\n\nclass GasCar(Vehicle):\n    def __init__(self, brand: str, tank_capacity: float, mpg: float):\n        super().__init__(brand, tank_capacity)\n        self.miles_per_gallon = mpg\n    \n    def refuel(self, fuel_type: str, amount: float) -> None:\n        if fuel_type not in [\"gasoline\", \"premium\", \"regular\"]:\n            raise ValueError(f\"Gas vehicles cannot use {fuel_type}. Only gasoline types allowed.\")\n        if amount < 0:\n            raise ValueError(\"Cannot refuel negative amount\")\n        \n        new_level = min(self.current_fuel_level + amount, self.fuel_capacity)\n        self.current_fuel_level = new_level\n        print(f\"Added {amount} gallons of {fuel_type} to {self.brand}\")\n    \n    def get_remaining_range(self) -> float:\n        return self.current_fuel_level * self.miles_per_gallon\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand: str, battery_capacity: float, efficiency: float):\n        super().__init__(brand, battery_capacity)\n        self.battery_efficiency = efficiency\n    \n    def refuel(self, fuel_type: str, amount: float) -> None:\n        if fuel_type != \"electricity\":\n            raise NotImplementedError(f\"Electric vehicles cannot be refueled with {fuel_type}. Use charging station instead.\")\n        if amount < 0:\n            raise ValueError(\"Cannot charge negative amount\")\n        \n        new_level = min(self.current_fuel_level + amount, self.fuel_capacity)\n        self.current_fuel_level = new_level\n        print(f\"Charged {amount} kWh to {self.brand} battery\")\n    \n    def get_remaining_range(self) -> float:\n        return self.current_fuel_level * self.battery_efficiency\n    \n    def charge_battery(self, kwh: float) -> None:\n        self.refuel(\"electricity\", kwh)\n\nclass HybridCar(Vehicle):\n    def __init__(self, brand: str, tank_capacity: float, mpg: float, electric_range: float):\n        super().__init__(brand, tank_capacity)\n        self.miles_per_gallon = mpg\n        self.electric_range = electric_range\n    \n    def refuel(self, fuel_type: str, amount: float) -> None:\n        if fuel_type in [\"gasoline\", \"premium\", \"regular\"]:\n            new_level = min(self.current_fuel_level + amount, self.fuel_capacity)\n            self.current_fuel_level = new_level\n            print(f\"Added {amount} gallons of gasoline to {self.brand}\")\n        elif fuel_type == \"electricity\":\n            print(f\"Charging electric component of {self.brand}\")\n        else:\n            raise ValueError(f\"Hybrid vehicle cannot use {fuel_type}\")\n    \n    def get_remaining_range(self) -> float:\n        return (self.current_fuel_level * self.miles_per_gallon) + self.electric_range\n\nclass FleetManager:\n    def perform_maintenance_refuel(self, fleet: List[Vehicle], standard_fuel: str, standard_amount: float) -> None:\n        print(f\"Starting fleet refueling with {standard_fuel}\")\n        for vehicle in fleet:\n            try:\n                vehicle.refuel(standard_fuel, standard_amount)\n                print(f\"{vehicle.brand} range: {vehicle.get_remaining_range()} miles\")\n            except Exception as e:\n                print(f\"Failed to refuel {vehicle.brand}: {str(e)}\")", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass Vehicle(ABC):\n    def __init__(self, brand: str, fuel_capacity: float):\n        self.brand = brand\n        self.fuel_capacity = fuel_capacity\n        self.current_fuel_level = 0.0\n    \n    @abstractmethod\n    def refuel(self, fuel_type: str, amount: float) -> None:\n        pass\n    \n    @abstractmethod\n    def get_remaining_range(self) -> float:\n        pass\n    \n    @property\n    def fuel_level(self) -> float:\n        return self.current_fuel_level\n\nclass GasCar(Vehicle):\n    def __init__(self, brand: str, tank_capacity: float, mpg: float):\n        super().__init__(brand, tank_capacity)\n        self.miles_per_gallon = mpg\n    \n    def refuel(self, fuel_type: str, amount: float) -> None:\n        if fuel_type not in [\"gasoline\", \"premium\", \"regular\"]:\n            raise ValueError(f\"Gas vehicles cannot use {fuel_type}. Only gasoline types allowed.\")\n        if amount < 0:\n            raise ValueError(\"Cannot refuel negative amount\")\n        \n        new_level = min(self.current_fuel_level + amount, self.fuel_capacity)\n        self.current_fuel_level = new_level\n        print(f\"Added {amount} gallons of {fuel_type} to {self.brand}\")\n    \n    def get_remaining_range(self) -> float:\n        return self.current_fuel_level * self.miles_per_gallon\n\nclass ElectricCar(Vehicle):\n    def __init__(self, brand: str, battery_capacity: float, efficiency: float):\n        super().__init__(brand, battery_capacity)\n        self.battery_efficiency = efficiency\n    \n    def refuel(self, fuel_type: str, amount: float) -> None:\n        if fuel_type != \"electricity\":\n            raise NotImplementedError(f\"Electric vehicles cannot be refueled with {fuel_type}. Use charging station instead.\")\n        if amount < 0:\n            raise ValueError(\"Cannot charge negative amount\")\n        \n        new_level = min(self.current_fuel_level + amount, self.fuel_capacity)\n        self.current_fuel_level = new_level\n        print(f\"Charged {amount} kWh to {self.brand} battery\")\n    \n    def get_remaining_range(self) -> float:\n        return self.current_fuel_level * self.battery_efficiency\n    \n    def charge_battery(self, kwh: float) -> None:\n        self.refuel(\"electricity\", kwh)\n\nclass HybridCar(Vehicle):\n    def __init__(self, brand: str, tank_capacity: float, mpg: float, electric_range: float):\n        super().__init__(brand, tank_capacity)\n        self.miles_per_gallon = mpg\n        self.electric_range = electric_range\n    \n    def refuel(self, fuel_type: str, amount: float) -> None:\n        if fuel_type in [\"gasoline\", \"premium\", \"regular\"]:\n            new_level = min(self.current_fuel_level + amount, self.fuel_capacity)\n            self.current_fuel_level = new_level\n            print(f\"Added {amount} gallons of gasoline to {self.brand}\")\n        elif fuel_type == \"electricity\":\n            print(f\"Charging electric component of {self.brand}\")\n        else:\n            raise ValueError(f\"Hybrid vehicle cannot use {fuel_type}\")\n    \n    def get_remaining_range(self) -> float:\n        return (self.current_fuel_level * self.miles_per_gallon) + self.electric_range\n\nclass FleetManager:\n    def perform_maintenance_refuel(self, fleet: List[Vehicle], standard_fuel: str, standard_amount: float) -> None:\n        print(f\"Starting fleet refueling with {standard_fuel}\")\n        for vehicle in fleet:\n            try:\n                vehicle.refuel(standard_fuel, standard_amount)\n                print(f\"{vehicle.brand} range: {vehicle.get_remaining_range()} miles\")\n            except Exception as e:\n                print(f\"Failed to refuel {vehicle.brand}: {str(e)}\")", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both performing maintenance and refueling, which can be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both performing maintenance and refueling, which can be separated into different classes.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both performing maintenance and refueling, which can be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both performing maintenance and refueling, which can be separated into different classes.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.0467753410339355}
{"id": 30, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "import kotlin.math.min\n\nabstract class Vehicle(protected val brand: String, protected val fuelCapacity: Double) {\n    protected var currentFuelLevel: Double = 0.0\n    \n    abstract fun refuel(fuelType: String, amount: Double)\n    abstract fun getRemainingRange(): Double\n    \n    fun getBrand(): String = brand\n    fun getFuelCapacity(): Double = fuelCapacity\n    fun getCurrentFuelLevel(): Double = currentFuelLevel\n}\n\nclass GasCar(brand: String, tankCapacity: Double, private val milesPerGallon: Double) : \n    Vehicle(brand, tankCapacity) {\n    \n    override fun refuel(fuelType: String, amount: Double) {\n        if (fuelType !in listOf(\"gasoline\", \"premium\", \"regular\")) {\n            throw IllegalStateException(\"Gas vehicles cannot use $fuelType. Only gasoline types allowed.\")\n        }\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Cannot refuel negative amount\")\n        }\n        val newLevel = min(currentFuelLevel + amount, fuelCapacity)\n        currentFuelLevel = newLevel\n        println(\"Added $amount gallons of $fuelType to $brand\")\n    }\n    \n    override fun getRemainingRange(): Double {\n        return currentFuelLevel * milesPerGallon\n    }\n}\n\nclass ElectricCar(brand: String, batteryCapacity: Double, private val batteryEfficiency: Double) :\n    Vehicle(brand, batteryCapacity) {\n    \n    override fun refuel(fuelType: String, amount: Double) {\n        if (fuelType != \"electricity\") {\n            throw UnsupportedOperationException(\"Electric vehicles cannot be refueled with $fuelType. Use charging station instead.\")\n        }\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Cannot charge negative amount\")\n        }\n        val newLevel = min(currentFuelLevel + amount, fuelCapacity)\n        currentFuelLevel = newLevel\n        println(\"Charged $amount kWh to $brand battery\")\n    }\n    \n    override fun getRemainingRange(): Double {\n        return currentFuelLevel * batteryEfficiency\n    }\n    \n    fun chargeBattery(kWh: Double) {\n        refuel(\"electricity\", kWh)\n    }\n}\n\nclass HybridCar(brand: String, tankCapacity: Double, private val milesPerGallon: Double, \n                private val electricRange: Double) : Vehicle(brand, tankCapacity) {\n    \n    override fun refuel(fuelType: String, amount: Double) {\n        when (fuelType) {\n            in listOf(\"gasoline\", \"premium\", \"regular\") -> {\n                val newLevel = min(currentFuelLevel + amount, fuelCapacity)\n                currentFuelLevel = newLevel\n                println(\"Added $amount gallons of gasoline to $brand\")\n            }\n            \"electricity\" -> {\n                println(\"Charging electric component of $brand\")\n            }\n            else -> {\n                throw IllegalArgumentException(\"Hybrid vehicle cannot use $fuelType\")\n            }\n        }\n    }\n    \n    override fun getRemainingRange(): Double {\n        return (currentFuelLevel * milesPerGallon) + electricRange\n    }\n}\n\nclass FleetManager {\n    fun performMaintenanceRefuel(fleet: Array<Vehicle>, standardFuel: String, standardAmount: Double) {\n        println(\"Starting fleet refueling with $standardFuel\")\n        fleet.forEach { vehicle ->\n            try {\n                vehicle.refuel(standardFuel, standardAmount)\n                println(\"${vehicle.getBrand()} range: ${vehicle.getRemainingRange()} miles\")\n            } catch (e: Exception) {\n                println(\"Failed to refuel ${vehicle.getBrand()}: ${e.message}\")\n            }\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport kotlin.math.min\n\nabstract class Vehicle(protected val brand: String, protected val fuelCapacity: Double) {\n    protected var currentFuelLevel: Double = 0.0\n    \n    abstract fun refuel(fuelType: String, amount: Double)\n    abstract fun getRemainingRange(): Double\n    \n    fun getBrand(): String = brand\n    fun getFuelCapacity(): Double = fuelCapacity\n    fun getCurrentFuelLevel(): Double = currentFuelLevel\n}\n\nclass GasCar(brand: String, tankCapacity: Double, private val milesPerGallon: Double) : \n    Vehicle(brand, tankCapacity) {\n    \n    override fun refuel(fuelType: String, amount: Double) {\n        if (fuelType !in listOf(\"gasoline\", \"premium\", \"regular\")) {\n            throw IllegalStateException(\"Gas vehicles cannot use $fuelType. Only gasoline types allowed.\")\n        }\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Cannot refuel negative amount\")\n        }\n        val newLevel = min(currentFuelLevel + amount, fuelCapacity)\n        currentFuelLevel = newLevel\n        println(\"Added $amount gallons of $fuelType to $brand\")\n    }\n    \n    override fun getRemainingRange(): Double {\n        return currentFuelLevel * milesPerGallon\n    }\n}\n\nclass ElectricCar(brand: String, batteryCapacity: Double, private val batteryEfficiency: Double) :\n    Vehicle(brand, batteryCapacity) {\n    \n    override fun refuel(fuelType: String, amount: Double) {\n        if (fuelType != \"electricity\") {\n            throw UnsupportedOperationException(\"Electric vehicles cannot be refueled with $fuelType. Use charging station instead.\")\n        }\n        if (amount < 0) {\n            throw IllegalArgumentException(\"Cannot charge negative amount\")\n        }\n        val newLevel = min(currentFuelLevel + amount, fuelCapacity)\n        currentFuelLevel = newLevel\n        println(\"Charged $amount kWh to $brand battery\")\n    }\n    \n    override fun getRemainingRange(): Double {\n        return currentFuelLevel * batteryEfficiency\n    }\n    \n    fun chargeBattery(kWh: Double) {\n        refuel(\"electricity\", kWh)\n    }\n}\n\nclass HybridCar(brand: String, tankCapacity: Double, private val milesPerGallon: Double, \n                private val electricRange: Double) : Vehicle(brand, tankCapacity) {\n    \n    override fun refuel(fuelType: String, amount: Double) {\n        when (fuelType) {\n            in listOf(\"gasoline\", \"premium\", \"regular\") -> {\n                val newLevel = min(currentFuelLevel + amount, fuelCapacity)\n                currentFuelLevel = newLevel\n                println(\"Added $amount gallons of gasoline to $brand\")\n            }\n            \"electricity\" -> {\n                println(\"Charging electric component of $brand\")\n            }\n            else -> {\n                throw IllegalArgumentException(\"Hybrid vehicle cannot use $fuelType\")\n            }\n        }\n    }\n    \n    override fun getRemainingRange(): Double {\n        return (currentFuelLevel * milesPerGallon) + electricRange\n    }\n}\n\nclass FleetManager {\n    fun performMaintenanceRefuel(fleet: Array<Vehicle>, standardFuel: String, standardAmount: Double) {\n        println(\"Starting fleet refueling with $standardFuel\")\n        fleet.forEach { vehicle ->\n            try {\n                vehicle.refuel(standardFuel, standardAmount)\n                println(\"${vehicle.getBrand()} range: ${vehicle.getRemainingRange()} miles\")\n            } catch (e: Exception) {\n                println(\"Failed to refuel ${vehicle.getBrand()}: ${e.message}\")\n            }\n        }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.198190212249756}
{"id": 31, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Collections.Generic;\n\npublic abstract class Vehicle\n{\n    protected string brand;\n    protected double fuelCapacity;\n    protected double currentFuelLevel;\n    \n    public Vehicle(string brand, double fuelCapacity)\n    {\n        this.brand = brand;\n        this.fuelCapacity = fuelCapacity;\n        this.currentFuelLevel = 0;\n    }\n    \n    public abstract void Refuel(string fuelType, double amount);\n    public abstract double GetRemainingRange();\n    \n    public string Brand => brand;\n    public double FuelCapacity => fuelCapacity;\n    public double CurrentFuelLevel => currentFuelLevel;\n}\n\npublic class GasCar : Vehicle\n{\n    private double milesPerGallon;\n    \n    public GasCar(string brand, double tankCapacity, double mpg) : base(brand, tankCapacity)\n    {\n        this.milesPerGallon = mpg;\n    }\n    \n    public override void Refuel(string fuelType, double amount)\n    {\n        var acceptedFuels = new[] { \"gasoline\", \"premium\", \"regular\" };\n        if (Array.IndexOf(acceptedFuels, fuelType) == -1)\n        {\n            throw new InvalidOperationException($\"Gas vehicles cannot use {fuelType}. Only gasoline types allowed.\");\n        }\n        if (amount < 0)\n        {\n            throw new ArgumentException(\"Cannot refuel negative amount\");\n        }\n        double newLevel = Math.Min(currentFuelLevel + amount, fuelCapacity);\n        this.currentFuelLevel = newLevel;\n        Console.WriteLine($\"Added {amount} gallons of {fuelType} to {brand}\");\n    }\n    \n    public override double GetRemainingRange()\n    {\n        return currentFuelLevel * milesPerGallon;\n    }\n}\n\npublic class ElectricCar : Vehicle\n{\n    private double batteryEfficiency;\n    \n    public ElectricCar(string brand, double batteryCapacity, double efficiency) : base(brand, batteryCapacity)\n    {\n        this.batteryEfficiency = efficiency;\n    }\n    \n    public override void Refuel(string fuelType, double amount)\n    {\n        if (fuelType != \"electricity\")\n        {\n            throw new NotSupportedException($\"Electric vehicles cannot be refueled with {fuelType}. Use charging station instead.\");\n        }\n        if (amount < 0)\n        {\n            throw new ArgumentException(\"Cannot charge negative amount\");\n        }\n        double newLevel = Math.Min(currentFuelLevel + amount, fuelCapacity);\n        this.currentFuelLevel = newLevel;\n        Console.WriteLine($\"Charged {amount} kWh to {brand} battery\");\n    }\n    \n    public override double GetRemainingRange()\n    {\n        return currentFuelLevel * batteryEfficiency;\n    }\n    \n    public void ChargeBattery(double kWh)\n    {\n        Refuel(\"electricity\", kWh);\n    }\n}\n\npublic class HybridCar : Vehicle\n{\n    private double milesPerGallon;\n    private double electricRange;\n    \n    public HybridCar(string brand, double tankCapacity, double mpg, double electricRange) : base(brand, tankCapacity)\n    {\n        this.milesPerGallon = mpg;\n        this.electricRange = electricRange;\n    }\n    \n    public override void Refuel(string fuelType, double amount)\n    {\n        var gasolineTypes = new[] { \"gasoline\", \"premium\", \"regular\" };\n        if (Array.IndexOf(gasolineTypes, fuelType) != -1)\n        {\n            double newLevel = Math.Min(currentFuelLevel + amount, fuelCapacity);\n            this.currentFuelLevel = newLevel;\n            Console.WriteLine($\"Added {amount} gallons of gasoline to {brand}\");\n        }\n        else if (fuelType == \"electricity\")\n        {\n            Console.WriteLine($\"Charging electric component of {brand}\");\n        }\n        else\n        {\n            throw new ArgumentException($\"Hybrid vehicle cannot use {fuelType}\");\n        }\n    }\n    \n    public override double GetRemainingRange()\n    {\n        return (currentFuelLevel * milesPerGallon) + electricRange;\n    }\n}\n\npublic class FleetManager\n{\n    public void PerformMaintenanceRefuel(Vehicle[] fleet, string standardFuel, double standardAmount)\n    {\n        Console.WriteLine($\"Starting fleet refueling with {standardFuel}\");\n        foreach (var vehicle in fleet)\n        {\n            try\n            {\n                vehicle.Refuel(standardFuel, standardAmount);\n                Console.WriteLine($\"{vehicle.Brand} range: {vehicle.GetRemainingRange()} miles\");\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine($\"Failed to refuel {vehicle.Brand}: {e.Message}\");\n            }\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Collections.Generic;\n\npublic abstract class Vehicle\n{\n    protected string brand;\n    protected double fuelCapacity;\n    protected double currentFuelLevel;\n    \n    public Vehicle(string brand, double fuelCapacity)\n    {\n        this.brand = brand;\n        this.fuelCapacity = fuelCapacity;\n        this.currentFuelLevel = 0;\n    }\n    \n    public abstract void Refuel(string fuelType, double amount);\n    public abstract double GetRemainingRange();\n    \n    public string Brand => brand;\n    public double FuelCapacity => fuelCapacity;\n    public double CurrentFuelLevel => currentFuelLevel;\n}\n\npublic class GasCar : Vehicle\n{\n    private double milesPerGallon;\n    \n    public GasCar(string brand, double tankCapacity, double mpg) : base(brand, tankCapacity)\n    {\n        this.milesPerGallon = mpg;\n    }\n    \n    public override void Refuel(string fuelType, double amount)\n    {\n        var acceptedFuels = new[] { \"gasoline\", \"premium\", \"regular\" };\n        if (Array.IndexOf(acceptedFuels, fuelType) == -1)\n        {\n            throw new InvalidOperationException($\"Gas vehicles cannot use {fuelType}. Only gasoline types allowed.\");\n        }\n        if (amount < 0)\n        {\n            throw new ArgumentException(\"Cannot refuel negative amount\");\n        }\n        double newLevel = Math.Min(currentFuelLevel + amount, fuelCapacity);\n        this.currentFuelLevel = newLevel;\n        Console.WriteLine($\"Added {amount} gallons of {fuelType} to {brand}\");\n    }\n    \n    public override double GetRemainingRange()\n    {\n        return currentFuelLevel * milesPerGallon;\n    }\n}\n\npublic class ElectricCar : Vehicle\n{\n    private double batteryEfficiency;\n    \n    public ElectricCar(string brand, double batteryCapacity, double efficiency) : base(brand, batteryCapacity)\n    {\n        this.batteryEfficiency = efficiency;\n    }\n    \n    public override void Refuel(string fuelType, double amount)\n    {\n        if (fuelType != \"electricity\")\n        {\n            throw new NotSupportedException($\"Electric vehicles cannot be refueled with {fuelType}. Use charging station instead.\");\n        }\n        if (amount < 0)\n        {\n            throw new ArgumentException(\"Cannot charge negative amount\");\n        }\n        double newLevel = Math.Min(currentFuelLevel + amount, fuelCapacity);\n        this.currentFuelLevel = newLevel;\n        Console.WriteLine($\"Charged {amount} kWh to {brand} battery\");\n    }\n    \n    public override double GetRemainingRange()\n    {\n        return currentFuelLevel * batteryEfficiency;\n    }\n    \n    public void ChargeBattery(double kWh)\n    {\n        Refuel(\"electricity\", kWh);\n    }\n}\n\npublic class HybridCar : Vehicle\n{\n    private double milesPerGallon;\n    private double electricRange;\n    \n    public HybridCar(string brand, double tankCapacity, double mpg, double electricRange) : base(brand, tankCapacity)\n    {\n        this.milesPerGallon = mpg;\n        this.electricRange = electricRange;\n    }\n    \n    public override void Refuel(string fuelType, double amount)\n    {\n        var gasolineTypes = new[] { \"gasoline\", \"premium\", \"regular\" };\n        if (Array.IndexOf(gasolineTypes, fuelType) != -1)\n        {\n            double newLevel = Math.Min(currentFuelLevel + amount, fuelCapacity);\n            this.currentFuelLevel = newLevel;\n            Console.WriteLine($\"Added {amount} gallons of gasoline to {brand}\");\n        }\n        else if (fuelType == \"electricity\")\n        {\n            Console.WriteLine($\"Charging electric component of {brand}\");\n        }\n        else\n        {\n            throw new ArgumentException($\"Hybrid vehicle cannot use {fuelType}\");\n        }\n    }\n    \n    public override double GetRemainingRange()\n    {\n        return (currentFuelLevel * milesPerGallon) + electricRange;\n    }\n}\n\npublic class FleetManager\n{\n    public void PerformMaintenanceRefuel(Vehicle[] fleet, string standardFuel, double standardAmount)\n    {\n        Console.WriteLine($\"Starting fleet refueling with {standardFuel}\");\n        foreach (var vehicle in fleet)\n        {\n            try\n            {\n                vehicle.Refuel(standardFuel, standardAmount);\n                Console.WriteLine($\"{vehicle.Brand} range: {vehicle.GetRemainingRange()} miles\");\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine($\"Failed to refuel {vehicle.Brand}: {e.Message}\");\n            }\n        }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.\n\n0\n5\n5\n5\n5\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `FleetManager` class is responsible for both managing a fleet and performing maintenance/refueling, which can be separated into different classes.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.345086336135864}
{"id": 32, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "import java.util.*;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.io.*;\nimport java.nio.file.*;\n\npublic abstract class DataProcessor {\n    protected String processorId;\n    protected Map<String, Object> configuration;\n    protected List<String> supportedFormats;\n    protected volatile boolean isProcessing;\n    \n    public DataProcessor(String processorId, Map<String, Object> config) {\n        this.processorId = processorId;\n        this.configuration = new HashMap<>(config);\n        this.supportedFormats = new ArrayList<>();\n        this.isProcessing = false;\n    }\n    \n    public abstract CompletableFuture<ProcessingResult> processData(DataInput input, ProcessingOptions options);\n    public abstract void validateInput(DataInput input) throws ValidationException;\n    public abstract boolean canProcess(String format);\n    public abstract void cleanup();\n    \n    public String getProcessorId() { return processorId; }\n    public List<String> getSupportedFormats() { return new ArrayList<>(supportedFormats); }\n    public boolean isCurrentlyProcessing() { return isProcessing; }\n}\n\npublic class StreamProcessor extends DataProcessor {\n    private BufferedReader currentReader;\n    private PrintWriter outputWriter;\n    \n    public StreamProcessor(String id, Map<String, Object> config) {\n        super(id, config);\n        this.supportedFormats.addAll(Arrays.asList(\"csv\", \"txt\", \"json\", \"xml\"));\n    }\n    \n    @Override\n    public CompletableFuture<ProcessingResult> processData(DataInput input, ProcessingOptions options) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                isProcessing = true;\n                validateInput(input);\n                \n                currentReader = new BufferedReader(new FileReader(input.getFilePath()));\n                String outputPath = options.getOutputPath();\n                outputWriter = new PrintWriter(new FileWriter(outputPath));\n                \n                String line;\n                int lineCount = 0;\n                while ((line = currentReader.readLine()) != null) {\n                    String processed = processLine(line, options);\n                    outputWriter.println(processed);\n                    lineCount++;\n                    \n                    if (lineCount % 1000 == 0) {\n                        System.out.println(\"Processed \" + lineCount + \" lines\");\n                    }\n                }\n                \n                return new ProcessingResult(lineCount, outputPath, \"SUCCESS\");\n            } catch (Exception e) {\n                return new ProcessingResult(0, null, \"ERROR: \" + e.getMessage());\n            } finally {\n                isProcessing = false;\n                cleanup();\n            }\n        });\n    }\n    \n    private String processLine(String line, ProcessingOptions options) {\n        if (options.shouldTransform()) {\n            return line.toUpperCase().trim();\n        }\n        return line.trim();\n    }\n    \n    @Override\n    public void validateInput(DataInput input) throws ValidationException {\n        if (input == null || input.getFilePath() == null) {\n            throw new ValidationException(\"Input file path cannot be null\");\n        }\n        if (!Files.exists(Paths.get(input.getFilePath()))) {\n            throw new ValidationException(\"Input file does not exist: \" + input.getFilePath());\n        }\n        if (!canProcess(input.getFormat())) {\n            throw new ValidationException(\"Unsupported format: \" + input.getFormat());\n        }\n    }\n    \n    @Override\n    public boolean canProcess(String format) {\n        return supportedFormats.contains(format.toLowerCase());\n    }\n    \n    @Override\n    public void cleanup() {\n        try {\n            if (currentReader != null) currentReader.close();\n            if (outputWriter != null) outputWriter.close();\n        } catch (IOException e) {\n            System.err.println(\"Error during cleanup: \" + e.getMessage());\n        }\n    }\n}\n\npublic class DatabaseProcessor extends DataProcessor {\n    private Connection dbConnection;\n    private PreparedStatement currentStatement;\n    \n    public DatabaseProcessor(String id, Map<String, Object> config) {\n        super(id, config);\n        this.supportedFormats.addAll(Arrays.asList(\"sql\", \"query\"));\n    }\n    \n    @Override\n    public CompletableFuture<ProcessingResult> processData(DataInput input, ProcessingOptions options) {\n        return CompletableFuture.supplyAsync(() -> {\n            throw new UnsupportedOperationException(\"DatabaseProcessor requires synchronous processing for transaction integrity. Use processDatabaseSync() instead.\");\n        });\n    }\n    \n    public ProcessingResult processDatabaseSync(DataInput input, ProcessingOptions options) throws Exception {\n        isProcessing = true;\n        validateInput(input);\n        \n        try {\n            establishConnection();\n            String query = Files.readString(Paths.get(input.getFilePath()));\n            currentStatement = dbConnection.prepareStatement(query);\n            \n            boolean hasResults = currentStatement.execute();\n            int updateCount = hasResults ? 0 : currentStatement.getUpdateCount();\n            \n            dbConnection.commit();\n            return new ProcessingResult(updateCount, null, \"DATABASE_SUCCESS\");\n        } catch (Exception e) {\n            if (dbConnection != null) dbConnection.rollback();\n            throw new RuntimeException(\"Database processing failed: \" + e.getMessage());\n        } finally {\n            isProcessing = false;\n            cleanup();\n        }\n    }\n    \n    private void establishConnection() throws Exception {\n        String url = (String) configuration.get(\"db.url\");\n        String user = (String) configuration.get(\"db.user\");\n        String password = (String) configuration.get(\"db.password\");\n        \n        if (url == null) throw new IllegalStateException(\"Database URL not configured\");\n        \n        Thread.sleep(100);\n    }\n    \n    @Override\n    public void validateInput(DataInput input) throws ValidationException {\n        if (input == null) throw new ValidationException(\"Input cannot be null for database processing\");\n        if (!canProcess(input.getFormat())) {\n            throw new ValidationException(\"Database processor only supports SQL queries\");\n        }\n        if (configuration.get(\"db.url\") == null) {\n            throw new ValidationException(\"Database processor requires connection configuration\");\n        }\n    }\n    \n    @Override\n    public boolean canProcess(String format) {\n        return supportedFormats.contains(format.toLowerCase());\n    }\n    \n    @Override\n    public void cleanup() {\n        try {\n            if (currentStatement != null) currentStatement.close();\n            if (dbConnection != null) dbConnection.close();\n        } catch (Exception e) {\n            System.err.println(\"Database cleanup error: \" + e.getMessage());\n        }\n    }\n}\n\npublic class ProcessingOrchestrator {\n    private List<DataProcessor> processors;\n    private ExecutorService executorService;\n    \n    public ProcessingOrchestrator() {\n        this.processors = new ArrayList<>();\n        this.executorService = Executors.newFixedThreadPool(4);\n    }\n    \n    public void addProcessor(DataProcessor processor) {\n        processors.add(processor);\n    }\n    \n    public List<ProcessingResult> processAllData(List<DataInput> inputs, ProcessingOptions options) {\n        List<ProcessingResult> results = new ArrayList<>();\n        \n        for (DataInput input : inputs) {\n            DataProcessor processor = findProcessorForFormat(input.getFormat());\n            if (processor != null) {\n                try {\n                    CompletableFuture<ProcessingResult> future = processor.processData(input, options);\n                    ProcessingResult result = future.get(30, TimeUnit.SECONDS);\n                    results.add(result);\n                } catch (Exception e) {\n                    results.add(new ProcessingResult(0, null, \"ORCHESTRATOR_ERROR: \" + e.getMessage()));\n                }\n            }\n        }\n        \n        return results;\n    }\n    \n    private DataProcessor findProcessorForFormat(String format) {\n        return processors.stream()\n                .filter(p -> p.canProcess(format))\n                .findFirst()\n                .orElse(null);\n    }\n    \n    public void shutdown() {\n        processors.forEach(DataProcessor::cleanup);\n        executorService.shutdown();\n    }\n}\n\nclass DataInput {\n    private String filePath;\n    private String format;\n    \n    public DataInput(String filePath, String format) {\n        this.filePath = filePath;\n        this.format = format;\n    }\n    \n    public String getFilePath() { return filePath; }\n    public String getFormat() { return format; }\n}\n\nclass ProcessingOptions {\n    private String outputPath;\n    private boolean transform;\n    \n    public ProcessingOptions(String outputPath, boolean transform) {\n        this.outputPath = outputPath;\n        this.transform = transform;\n    }\n    \n    public String getOutputPath() { return outputPath; }\n    public boolean shouldTransform() { return transform; }\n}\n\nclass ProcessingResult {\n    private int recordsProcessed;\n    private String outputPath;\n    private String status;\n    \n    public ProcessingResult(int recordsProcessed, String outputPath, String status) {\n        this.recordsProcessed = recordsProcessed;\n        this.outputPath = outputPath;\n        this.status = status;\n    }\n    \n    public int getRecordsProcessed() { return recordsProcessed; }\n    public String getOutputPath() { return outputPath; }\n    public String getStatus() { return status; }\n}\n\nclass ValidationException extends Exception {\n    public ValidationException(String message) {\n        super(message);\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport java.util.*;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.io.*;\nimport java.nio.file.*;\n\npublic abstract class DataProcessor {\n    protected String processorId;\n    protected Map<String, Object> configuration;\n    protected List<String> supportedFormats;\n    protected volatile boolean isProcessing;\n    \n    public DataProcessor(String processorId, Map<String, Object> config) {\n        this.processorId = processorId;\n        this.configuration = new HashMap<>(config);\n        this.supportedFormats = new ArrayList<>();\n        this.isProcessing = false;\n    }\n    \n    public abstract CompletableFuture<ProcessingResult> processData(DataInput input, ProcessingOptions options);\n    public abstract void validateInput(DataInput input) throws ValidationException;\n    public abstract boolean canProcess(String format);\n    public abstract void cleanup();\n    \n    public String getProcessorId() { return processorId; }\n    public List<String> getSupportedFormats() { return new ArrayList<>(supportedFormats); }\n    public boolean isCurrentlyProcessing() { return isProcessing; }\n}\n\npublic class StreamProcessor extends DataProcessor {\n    private BufferedReader currentReader;\n    private PrintWriter outputWriter;\n    \n    public StreamProcessor(String id, Map<String, Object> config) {\n        super(id, config);\n        this.supportedFormats.addAll(Arrays.asList(\"csv\", \"txt\", \"json\", \"xml\"));\n    }\n    \n    @Override\n    public CompletableFuture<ProcessingResult> processData(DataInput input, ProcessingOptions options) {\n        return CompletableFuture.supplyAsync(() -> {\n            try {\n                isProcessing = true;\n                validateInput(input);\n                \n                currentReader = new BufferedReader(new FileReader(input.getFilePath()));\n                String outputPath = options.getOutputPath();\n                outputWriter = new PrintWriter(new FileWriter(outputPath));\n                \n                String line;\n                int lineCount = 0;\n                while ((line = currentReader.readLine()) != null) {\n                    String processed = processLine(line, options);\n                    outputWriter.println(processed);\n                    lineCount++;\n                    \n                    if (lineCount % 1000 == 0) {\n                        System.out.println(\"Processed \" + lineCount + \" lines\");\n                    }\n                }\n                \n                return new ProcessingResult(lineCount, outputPath, \"SUCCESS\");\n            } catch (Exception e) {\n                return new ProcessingResult(0, null, \"ERROR: \" + e.getMessage());\n            } finally {\n                isProcessing = false;\n                cleanup();\n            }\n        });\n    }\n    \n    private String processLine(String line, ProcessingOptions options) {\n        if (options.shouldTransform()) {\n            return line.toUpperCase().trim();\n        }\n        return line.trim();\n    }\n    \n    @Override\n    public void validateInput(DataInput input) throws ValidationException {\n        if (input == null || input.getFilePath() == null) {\n            throw new ValidationException(\"Input file path cannot be null\");\n        }\n        if (!Files.exists(Paths.get(input.getFilePath()))) {\n            throw new ValidationException(\"Input file does not exist: \" + input.getFilePath());\n        }\n        if (!canProcess(input.getFormat())) {\n            throw new ValidationException(\"Unsupported format: \" + input.getFormat());\n        }\n    }\n    \n    @Override\n    public boolean canProcess(String format) {\n        return supportedFormats.contains(format.toLowerCase());\n    }\n    \n    @Override\n    public void cleanup() {\n        try {\n            if (currentReader != null) currentReader.close();\n            if (outputWriter != null) outputWriter.close();\n        } catch (IOException e) {\n            System.err.println(\"Error during cleanup: \" + e.getMessage());\n        }\n    }\n}\n\npublic class DatabaseProcessor extends DataProcessor {\n    private Connection dbConnection;\n    private PreparedStatement currentStatement;\n    \n    public DatabaseProcessor(String id, Map<String, Object> config) {\n        super(id, config);\n        this.supportedFormats.addAll(Arrays.asList(\"sql\", \"query\"));\n    }\n    \n    @Override\n    public CompletableFuture<ProcessingResult> processData(DataInput input, ProcessingOptions options) {\n        return CompletableFuture.supplyAsync(() -> {\n            throw new UnsupportedOperationException(\"DatabaseProcessor requires synchronous processing for transaction integrity. Use processDatabaseSync() instead.\");\n        });\n    }\n    \n    public ProcessingResult processDatabaseSync(DataInput input, ProcessingOptions options) throws Exception {\n        isProcessing = true;\n        validateInput(input);\n        \n        try {\n            establishConnection();\n            String query = Files.readString(Paths.get(input.getFilePath()));\n            currentStatement = dbConnection.prepareStatement(query);\n            \n            boolean hasResults = currentStatement.execute();\n            int updateCount = hasResults ? 0 : currentStatement.getUpdateCount();\n            \n            dbConnection.commit();\n            return new ProcessingResult(updateCount, null, \"DATABASE_SUCCESS\");\n        } catch (Exception e) {\n            if (dbConnection != null) dbConnection.rollback();\n            throw new RuntimeException(\"Database processing failed: \" + e.getMessage());\n        } finally {\n            isProcessing = false;\n            cleanup();\n        }\n    }\n    \n    private void establishConnection() throws Exception {\n        String url = (String) configuration.get(\"db.url\");\n        String user = (String) configuration.get(\"db.user\");\n        String password = (String) configuration.get(\"db.password\");\n        \n        if (url == null) throw new IllegalStateException(\"Database URL not configured\");\n        \n        Thread.sleep(100);\n    }\n    \n    @Override\n    public void validateInput(DataInput input) throws ValidationException {\n        if (input == null) throw new ValidationException(\"Input cannot be null for database processing\");\n        if (!canProcess(input.getFormat())) {\n            throw new ValidationException(\"Database processor only supports SQL queries\");\n        }\n        if (configuration.get(\"db.url\") == null) {\n            throw new ValidationException(\"Database processor requires connection configuration\");\n        }\n    }\n    \n    @Override\n    public boolean canProcess(String format) {\n        return supportedFormats.contains(format.toLowerCase());\n    }\n    \n    @Override\n    public void cleanup() {\n        try {\n            if (currentStatement != null) currentStatement.close();\n            if (dbConnection != null) dbConnection.close();\n        } catch (Exception e) {\n            System.err.println(\"Database cleanup error: \" + e.getMessage());\n        }\n    }\n}\n\npublic class ProcessingOrchestrator {\n    private List<DataProcessor> processors;\n    private ExecutorService executorService;\n    \n    public ProcessingOrchestrator() {\n        this.processors = new ArrayList<>();\n        this.executorService = Executors.newFixedThreadPool(4);\n    }\n    \n    public void addProcessor(DataProcessor processor) {\n        processors.add(processor);\n    }\n    \n    public List<ProcessingResult> processAllData(List<DataInput> inputs, ProcessingOptions options) {\n        List<ProcessingResult> results = new ArrayList<>();\n        \n        for (DataInput input : inputs) {\n            DataProcessor processor = findProcessorForFormat(input.getFormat());\n            if (processor != null) {\n                try {\n                    CompletableFuture<ProcessingResult> future = processor.processData(input, options);\n                    ProcessingResult result = future.get(30, TimeUnit.SECONDS);\n                    results.add(result);\n                } catch (Exception e) {\n                    results.add(new ProcessingResult(0, null, \"ORCHESTRATOR_ERROR: \" + e.getMessage()));\n                }\n            }\n        }\n        \n        return results;\n    }\n    \n    private DataProcessor findProcessorForFormat(String format) {\n        return processors.stream()\n                .filter(p -> p.canProcess(format))\n                .findFirst()\n                .orElse(null);\n    }\n    \n    public void shutdown() {\n        processors.forEach(DataProcessor::cleanup);\n        executorService.shutdown();\n    }\n}\n\nclass DataInput {\n    private String filePath;\n    private String format;\n    \n    public DataInput(String filePath, String format) {\n        this.filePath = filePath;\n        this.format = format;\n    }\n    \n    public String getFilePath() { return filePath; }\n    public String getFormat() { return format; }\n}\n\nclass ProcessingOptions {\n    private String outputPath;\n    private boolean transform;\n    \n    public ProcessingOptions(String outputPath, boolean transform) {\n        this.outputPath = outputPath;\n        this.transform = transform;\n    }\n    \n    public String getOutputPath() { return outputPath; }\n    public boolean shouldTransform() { return transform; }\n}\n\nclass ProcessingResult {\n    private int recordsProcessed;\n    private String outputPath;\n    private String status;\n    \n    public ProcessingResult(int recordsProcessed, String outputPath, String status) {\n        this.recordsProcessed = recordsProcessed;\n        this.outputPath = outputPath;\n        this.status = status;\n    }\n    \n    public int getRecordsProcessed() { return recordsProcessed; }\n    public String getOutputPath() { return outputPath; }\n    public String getStatus() { return status; }\n}\n\nclass ValidationException extends Exception {\n    public ValidationException(String message) {\n        super(message);\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DatabaseProcessor` class not only processes data but also manages database connections and transactions, which are separate concerns.\n\n0\n5\n5\n5\n3", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities. The `DatabaseProcessor` class not only processes data but also manages database connections and transactions, which are separate concerns.\n\n0\n5\n5\n5\n3", "solution_code": "NO FIX VERSION", "duration_seconds": 3.3840818405151367}
{"id": 33, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "import asyncio\nimport abc\nfrom typing import Dict, List, Any, Optional, Union\nfrom concurrent.futures import ThreadPoolExecutor\nimport json\nimport sqlite3\nimport aiofiles\nfrom pathlib import Path\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport threading\nimport time\n\n@dataclass\nclass DataInput:\n    file_path: str\n    format_type: str\n    metadata: Optional[Dict[str, Any]] = None\n\n@dataclass\nclass ProcessingOptions:\n    output_path: str\n    transform_data: bool = False\n    batch_size: int = 1000\n    timeout_seconds: int = 30\n    additional_params: Optional[Dict[str, Any]] = None\n\n@dataclass\nclass ProcessingResult:\n    records_processed: int\n    output_location: Optional[str]\n    status_message: str\n    processing_time: float\n    errors: List[str] = None\n\nclass ValidationError(Exception):\n    pass\n\nclass DataProcessor(abc.ABC):\n    def __init__(self, processor_id: str, configuration: Dict[str, Any]):\n        self.processor_id = processor_id\n        self.configuration = configuration.copy()\n        self.supported_formats: List[str] = []\n        self._is_processing = False\n        self._processing_lock = threading.Lock()\n        \n    @abc.abstractmethod\n    async def process_data(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        pass\n        \n    @abc.abstractmethod\n    def validate_input(self, input_data: DataInput) -> None:\n        pass\n        \n    @abc.abstractmethod\n    def can_process(self, format_type: str) -> bool:\n        pass\n        \n    @abc.abstractmethod\n    def cleanup(self) -> None:\n        pass\n    \n    @property\n    def is_processing(self) -> bool:\n        return self._is_processing\n        \n    @property\n    def processor_info(self) -> Dict[str, Any]:\n        return {\n            'id': self.processor_id,\n            'supported_formats': self.supported_formats.copy(),\n            'is_busy': self._is_processing\n        }\n\nclass StreamProcessor(DataProcessor):\n    def __init__(self, processor_id: str, configuration: Dict[str, Any]):\n        super().__init__(processor_id, configuration)\n        self.supported_formats = ['csv', 'txt', 'json', 'xml', 'log']\n        self._current_files: List[Any] = []\n        self._executor = ThreadPoolExecutor(max_workers=2)\n        \n    async def process_data(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        start_time = time.time()\n        \n        with self._processing_lock:\n            if self._is_processing:\n                raise RuntimeError(f\"Processor {self.processor_id} is already processing data\")\n            self._is_processing = True\n            \n        try:\n            self.validate_input(input_data)\n            \n            input_path = Path(input_data.file_path)\n            output_path = Path(options.output_path)\n            \n            async with aiofiles.open(input_path, 'r') as input_file:\n                async with aiofiles.open(output_path, 'w') as output_file:\n                    line_count = 0\n                    batch = []\n                    \n                    async for line in input_file:\n                        processed_line = await self._process_line(line, options)\n                        batch.append(processed_line)\n                        line_count += 1\n                        \n                        if len(batch) >= options.batch_size:\n                            await output_file.write(''.join(batch))\n                            batch.clear()\n                            \n                        if line_count % 5000 == 0:\n                            print(f\"Stream processor: {line_count} lines processed\")\n                            \n                    if batch:\n                        await output_file.write(''.join(batch))\n                        \n            processing_time = time.time() - start_time\n            return ProcessingResult(\n                records_processed=line_count,\n                output_location=str(output_path),\n                status_message=\"STREAM_SUCCESS\",\n                processing_time=processing_time\n            )\n            \n        except Exception as e:\n            processing_time = time.time() - start_time\n            return ProcessingResult(\n                records_processed=0,\n                output_location=None,\n                status_message=f\"STREAM_ERROR: {str(e)}\",\n                processing_time=processing_time,\n                errors=[str(e)]\n            )\n        finally:\n            self._is_processing = False\n            \n    async def _process_line(self, line: str, options: ProcessingOptions) -> str:\n        if options.transform_data:\n            return line.upper().strip() + '\\n'\n        return line.strip() + '\\n'\n        \n    def validate_input(self, input_data: DataInput) -> None:\n        if not input_data or not input_data.file_path:\n            raise ValidationError(\"Input file path cannot be empty\")\n            \n        input_path = Path(input_data.file_path)\n        if not input_path.exists():\n            raise ValidationError(f\"Input file does not exist: {input_data.file_path}\")\n            \n        if not self.can_process(input_data.format_type):\n            raise ValidationError(f\"Unsupported format for stream processing: {input_data.format_type}\")\n            \n        if input_path.stat().st_size > self.configuration.get('max_file_size', 100 * 1024 * 1024):\n            raise ValidationError(\"File too large for stream processing\")\n            \n    def can_process(self, format_type: str) -> bool:\n        return format_type.lower() in self.supported_formats\n        \n    def cleanup(self) -> None:\n        self._executor.shutdown(wait=True)\n        for file_handle in self._current_files:\n            try:\n                if hasattr(file_handle, 'close'):\n                    file_handle.close()\n            except Exception as e:\n                print(f\"Cleanup error: {e}\")\n        self._current_files.clear()\n\nclass DatabaseProcessor(DataProcessor):\n    def __init__(self, processor_id: str, configuration: Dict[str, Any]):\n        super().__init__(processor_id, configuration)\n        self.supported_formats = ['sql', 'query', 'dml']\n        self._connection: Optional[sqlite3.Connection] = None\n        self._current_cursor: Optional[sqlite3.Cursor] = None\n        \n    async def process_data(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        raise NotImplementedError(\n            \"DatabaseProcessor cannot use async processing due to transaction requirements. \"\n            \"Use process_database_sync() method instead for proper transaction handling.\"\n        )\n        \n    def process_database_sync(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        start_time = time.time()\n        \n        with self._processing_lock:\n            if self._is_processing:\n                raise RuntimeError(f\"Database processor {self.processor_id} is already processing\")\n            self._is_processing = True\n            \n        try:\n            self.validate_input(input_data)\n            self._establish_connection()\n            \n            with open(input_data.file_path, 'r') as sql_file:\n                sql_content = sql_file.read()\n                \n            statements = [stmt.strip() for stmt in sql_content.split(';') if stmt.strip()]\n            executed_statements = 0\n            \n            self._connection.execute('BEGIN TRANSACTION')\n            \n            try:\n                for statement in statements:\n                    self._current_cursor = self._connection.cursor()\n                    self._current_cursor.execute(statement)\n                    executed_statements += 1\n                    \n                self._connection.commit()\n                \n                processing_time = time.time() - start_time\n                return ProcessingResult(\n                    records_processed=executed_statements,\n                    output_location=None,\n                    status_message=\"DATABASE_SUCCESS\",\n                    processing_time=processing_time\n                )\n                \n            except Exception as e:\n                self._connection.rollback()\n                raise RuntimeError(f\"Database transaction failed: {str(e)}\")\n                \n        except Exception as e:\n            processing_time = time.time() - start_time\n            return ProcessingResult(\n                records_processed=0,\n                output_location=None,\n                status_message=f\"DATABASE_ERROR: {str(e)}\",\n                processing_time=processing_time,\n                errors=[str(e)]\n            )\n        finally:\n            self._is_processing = False\n            self.cleanup()\n            \n    def _establish_connection(self) -> None:\n        db_path = self.configuration.get('db_path', ':memory:')\n        self._connection = sqlite3.connect(db_path)\n        self._connection.isolation_level = None\n        \n    def validate_input(self, input_data: DataInput) -> None:\n        if not input_data or not input_data.file_path:\n            raise ValidationError(\"Database processor requires valid SQL file path\")\n            \n        if not self.can_process(input_data.format_type):\n            raise ValidationError(f\"Database processor cannot handle format: {input_data.format_type}\")\n            \n        if 'db_path' not in self.configuration:\n            raise ValidationError(\"Database processor requires database configuration\")\n            \n        sql_path = Path(input_data.file_path)\n        if not sql_path.exists():\n            raise ValidationError(f\"SQL file not found: {input_data.file_path}\")\n            \n    def can_process(self, format_type: str) -> bool:\n        return format_type.lower() in self.supported_formats\n        \n    def cleanup(self) -> None:\n        try:\n            if self._current_cursor:\n                self._current_cursor.close()\n            if self._connection:\n                self._connection.close()\n        except Exception as e:\n            print(f\"Database cleanup error: {e}\")\n        finally:\n            self._current_cursor = None\n            self._connection = None\n\nclass ProcessingOrchestrator:\n    def __init__(self):\n        self.processors: List[DataProcessor] = []\n        self._processing_semaphore = asyncio.Semaphore(4)\n        \n    def add_processor(self, processor: DataProcessor) -> None:\n        self.processors.append(processor)\n        \n    async def process_all_data(self, inputs: List[DataInput], options: ProcessingOptions) -> List[ProcessingResult]:\n        results = []\n        \n        for input_data in inputs:\n            processor = self._find_processor_for_format(input_data.format_type)\n            if not processor:\n                results.append(ProcessingResult(\n                    records_processed=0,\n                    output_location=None,\n                    status_message=f\"No processor found for format: {input_data.format_type}\",\n                    processing_time=0.0,\n                    errors=[f\"Unsupported format: {input_data.format_type}\"]\n                ))\n                continue\n                \n            try:\n                async with self._processing_semaphore:\n                    result = await asyncio.wait_for(\n                        processor.process_data(input_data, options),\n                        timeout=options.timeout_seconds\n                    )\n                    results.append(result)\n            except Exception as e:\n                results.append(ProcessingResult(\n                    records_processed=0,\n                    output_location=None,\n                    status_message=f\"ORCHESTRATOR_ERROR: {str(e)}\",\n                    processing_time=0.0,\n                    errors=[str(e)]\n                ))\n                \n        return results\n        \n    def _find_processor_for_format(self, format_type: str) -> Optional[DataProcessor]:\n        for processor in self.processors:\n            if processor.can_process(format_type):\n                return processor\n        return None\n        \n    def shutdown(self) -> None:\n        for processor in self.processors:\n            processor.cleanup()", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport asyncio\nimport abc\nfrom typing import Dict, List, Any, Optional, Union\nfrom concurrent.futures import ThreadPoolExecutor\nimport json\nimport sqlite3\nimport aiofiles\nfrom pathlib import Path\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport threading\nimport time\n\n@dataclass\nclass DataInput:\n    file_path: str\n    format_type: str\n    metadata: Optional[Dict[str, Any]] = None\n\n@dataclass\nclass ProcessingOptions:\n    output_path: str\n    transform_data: bool = False\n    batch_size: int = 1000\n    timeout_seconds: int = 30\n    additional_params: Optional[Dict[str, Any]] = None\n\n@dataclass\nclass ProcessingResult:\n    records_processed: int\n    output_location: Optional[str]\n    status_message: str\n    processing_time: float\n    errors: List[str] = None\n\nclass ValidationError(Exception):\n    pass\n\nclass DataProcessor(abc.ABC):\n    def __init__(self, processor_id: str, configuration: Dict[str, Any]):\n        self.processor_id = processor_id\n        self.configuration = configuration.copy()\n        self.supported_formats: List[str] = []\n        self._is_processing = False\n        self._processing_lock = threading.Lock()\n        \n    @abc.abstractmethod\n    async def process_data(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        pass\n        \n    @abc.abstractmethod\n    def validate_input(self, input_data: DataInput) -> None:\n        pass\n        \n    @abc.abstractmethod\n    def can_process(self, format_type: str) -> bool:\n        pass\n        \n    @abc.abstractmethod\n    def cleanup(self) -> None:\n        pass\n    \n    @property\n    def is_processing(self) -> bool:\n        return self._is_processing\n        \n    @property\n    def processor_info(self) -> Dict[str, Any]:\n        return {\n            'id': self.processor_id,\n            'supported_formats': self.supported_formats.copy(),\n            'is_busy': self._is_processing\n        }\n\nclass StreamProcessor(DataProcessor):\n    def __init__(self, processor_id: str, configuration: Dict[str, Any]):\n        super().__init__(processor_id, configuration)\n        self.supported_formats = ['csv', 'txt', 'json', 'xml', 'log']\n        self._current_files: List[Any] = []\n        self._executor = ThreadPoolExecutor(max_workers=2)\n        \n    async def process_data(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        start_time = time.time()\n        \n        with self._processing_lock:\n            if self._is_processing:\n                raise RuntimeError(f\"Processor {self.processor_id} is already processing data\")\n            self._is_processing = True\n            \n        try:\n            self.validate_input(input_data)\n            \n            input_path = Path(input_data.file_path)\n            output_path = Path(options.output_path)\n            \n            async with aiofiles.open(input_path, 'r') as input_file:\n                async with aiofiles.open(output_path, 'w') as output_file:\n                    line_count = 0\n                    batch = []\n                    \n                    async for line in input_file:\n                        processed_line = await self._process_line(line, options)\n                        batch.append(processed_line)\n                        line_count += 1\n                        \n                        if len(batch) >= options.batch_size:\n                            await output_file.write(''.join(batch))\n                            batch.clear()\n                            \n                        if line_count % 5000 == 0:\n                            print(f\"Stream processor: {line_count} lines processed\")\n                            \n                    if batch:\n                        await output_file.write(''.join(batch))\n                        \n            processing_time = time.time() - start_time\n            return ProcessingResult(\n                records_processed=line_count,\n                output_location=str(output_path),\n                status_message=\"STREAM_SUCCESS\",\n                processing_time=processing_time\n            )\n            \n        except Exception as e:\n            processing_time = time.time() - start_time\n            return ProcessingResult(\n                records_processed=0,\n                output_location=None,\n                status_message=f\"STREAM_ERROR: {str(e)}\",\n                processing_time=processing_time,\n                errors=[str(e)]\n            )\n        finally:\n            self._is_processing = False\n            \n    async def _process_line(self, line: str, options: ProcessingOptions) -> str:\n        if options.transform_data:\n            return line.upper().strip() + '\\n'\n        return line.strip() + '\\n'\n        \n    def validate_input(self, input_data: DataInput) -> None:\n        if not input_data or not input_data.file_path:\n            raise ValidationError(\"Input file path cannot be empty\")\n            \n        input_path = Path(input_data.file_path)\n        if not input_path.exists():\n            raise ValidationError(f\"Input file does not exist: {input_data.file_path}\")\n            \n        if not self.can_process(input_data.format_type):\n            raise ValidationError(f\"Unsupported format for stream processing: {input_data.format_type}\")\n            \n        if input_path.stat().st_size > self.configuration.get('max_file_size', 100 * 1024 * 1024):\n            raise ValidationError(\"File too large for stream processing\")\n            \n    def can_process(self, format_type: str) -> bool:\n        return format_type.lower() in self.supported_formats\n        \n    def cleanup(self) -> None:\n        self._executor.shutdown(wait=True)\n        for file_handle in self._current_files:\n            try:\n                if hasattr(file_handle, 'close'):\n                    file_handle.close()\n            except Exception as e:\n                print(f\"Cleanup error: {e}\")\n        self._current_files.clear()\n\nclass DatabaseProcessor(DataProcessor):\n    def __init__(self, processor_id: str, configuration: Dict[str, Any]):\n        super().__init__(processor_id, configuration)\n        self.supported_formats = ['sql', 'query', 'dml']\n        self._connection: Optional[sqlite3.Connection] = None\n        self._current_cursor: Optional[sqlite3.Cursor] = None\n        \n    async def process_data(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        raise NotImplementedError(\n            \"DatabaseProcessor cannot use async processing due to transaction requirements. \"\n            \"Use process_database_sync() method instead for proper transaction handling.\"\n        )\n        \n    def process_database_sync(self, input_data: DataInput, options: ProcessingOptions) -> ProcessingResult:\n        start_time = time.time()\n        \n        with self._processing_lock:\n            if self._is_processing:\n                raise RuntimeError(f\"Database processor {self.processor_id} is already processing\")\n            self._is_processing = True\n            \n        try:\n            self.validate_input(input_data)\n            self._establish_connection()\n            \n            with open(input_data.file_path, 'r') as sql_file:\n                sql_content = sql_file.read()\n                \n            statements = [stmt.strip() for stmt in sql_content.split(';') if stmt.strip()]\n            executed_statements = 0\n            \n            self._connection.execute('BEGIN TRANSACTION')\n            \n            try:\n                for statement in statements:\n                    self._current_cursor = self._connection.cursor()\n                    self._current_cursor.execute(statement)\n                    executed_statements += 1\n                    \n                self._connection.commit()\n                \n                processing_time = time.time() - start_time\n                return ProcessingResult(\n                    records_processed=executed_statements,\n                    output_location=None,\n                    status_message=\"DATABASE_SUCCESS\",\n                    processing_time=processing_time\n                )\n                \n            except Exception as e:\n                self._connection.rollback()\n                raise RuntimeError(f\"Database transaction failed: {str(e)}\")\n                \n        except Exception as e:\n            processing_time = time.time() - start_time\n            return ProcessingResult(\n                records_processed=0,\n                output_location=None,\n                status_message=f\"DATABASE_ERROR: {str(e)}\",\n                processing_time=processing_time,\n                errors=[str(e)]\n            )\n        finally:\n            self._is_processing = False\n            self.cleanup()\n            \n    def _establish_connection(self) -> None:\n        db_path = self.configuration.get('db_path', ':memory:')\n        self._connection = sqlite3.connect(db_path)\n        self._connection.isolation_level = None\n        \n    def validate_input(self, input_data: DataInput) -> None:\n        if not input_data or not input_data.file_path:\n            raise ValidationError(\"Database processor requires valid SQL file path\")\n            \n        if not self.can_process(input_data.format_type):\n            raise ValidationError(f\"Database processor cannot handle format: {input_data.format_type}\")\n            \n        if 'db_path' not in self.configuration:\n            raise ValidationError(\"Database processor requires database configuration\")\n            \n        sql_path = Path(input_data.file_path)\n        if not sql_path.exists():\n            raise ValidationError(f\"SQL file not found: {input_data.file_path}\")\n            \n    def can_process(self, format_type: str) -> bool:\n        return format_type.lower() in self.supported_formats\n        \n    def cleanup(self) -> None:\n        try:\n            if self._current_cursor:\n                self._current_cursor.close()\n            if self._connection:\n                self._connection.close()\n        except Exception as e:\n            print(f\"Database cleanup error: {e}\")\n        finally:\n            self._current_cursor = None\n            self._connection = None\n\nclass ProcessingOrchestrator:\n    def __init__(self):\n        self.processors: List[DataProcessor] = []\n        self._processing_semaphore = asyncio.Semaphore(4)\n        \n    def add_processor(self, processor: DataProcessor) -> None:\n        self.processors.append(processor)\n        \n    async def process_all_data(self, inputs: List[DataInput], options: ProcessingOptions) -> List[ProcessingResult]:\n        results = []\n        \n        for input_data in inputs:\n            processor = self._find_processor_for_format(input_data.format_type)\n            if not processor:\n                results.append(ProcessingResult(\n                    records_processed=0,\n                    output_location=None,\n                    status_message=f\"No processor found for format: {input_data.format_type}\",\n                    processing_time=0.0,\n                    errors=[f\"Unsupported format: {input_data.format_type}\"]\n                ))\n                continue\n                \n            try:\n                async with self._processing_semaphore:\n                    result = await asyncio.wait_for(\n                        processor.process_data(input_data, options),\n                        timeout=options.timeout_seconds\n                    )\n                    results.append(result)\n            except Exception as e:\n                results.append(ProcessingResult(\n                    records_processed=0,\n                    output_location=None,\n                    status_message=f\"ORCHESTRATOR_ERROR: {str(e)}\",\n                    processing_time=0.0,\n                    errors=[str(e)]\n                ))\n                \n        return results\n        \n    def _find_processor_for_format(self, format_type: str) -> Optional[DataProcessor]:\n        for processor in self.processors:\n            if processor.can_process(format_type):\n                return processor\n        return None\n        \n    def shutdown(self) -> None:\n        for processor in self.processors:\n            processor.cleanup()", "raw_response": "The provided code defines a robust system for processing data using different types of processors, such as `StreamProcessor` and `DatabaseProcessor`, managed by an orchestrator. Here's a detailed breakdown of the components and their functionalities:\n\n### Components\n\n1. **DataInput**:\n   - Represents the input data to be processed.\n   - Contains attributes like `file_path` (path to the file) and `format_type` (type of data format).\n\n2. **ProcessingOptions**:\n   - Defines options for processing, such as `timeout_seconds` (maximum time allowed for processing a task) and `transform_function` (a function to transform data during processing).\n\n3. **ValidationError**:\n   - A custom exception class used to handle validation errors.\n\n4. **ProcessingResult**:\n   - Represents the result of a processing operation.\n   - Contains attributes like `records_processed`, `output_location`, `status_message`, `processing_time`, and `errors`.\n\n5. **DataProcessor (Abstract Base Class)**:\n   - An abstract base class for all processors.\n   - Defines methods that must be implemented by subclasses, such as `process_data` and `can_process`.\n\n6. **StreamProcessor**:\n   - A concrete implementation of `DataProcessor`.\n   - Processes data from a file stream, applying transformations if specified.\n\n7. **DatabaseProcessor**:\n   - Another concrete implementation of `DataProcessor`.\n   - Executes SQL statements from a file against a database.\n   - Note: This processor uses synchronous methods due to transaction requirements and does not support asynchronous processing.\n\n8. **ProcessingOrchestrator**:\n   - Manages multiple processors and orchestrates the processing of data inputs.\n   - Uses a semaphore to limit concurrent processing tasks.\n   - Provides methods to add processors, process all data, and shut down the system.\n\n### Key Functionalities\n\n- **Processor Management**: The `ProcessingOrchestrator` can manage multiple processors and find the appropriate processor for a given data format using `_find_processor_for_format`.\n  \n- **Concurrency Control**: Uses an asyncio semaphore (`_processing_semaphore`) to limit the number of concurrent processing tasks, preventing resource exhaustion.\n\n- **Error Handling**: Implements error handling at various levels, including validation errors and processing errors, ensuring that failures are reported appropriately.\n\n- **Data Transformation**: Supports optional data transformation using a `transform_function` provided in `ProcessingOptions`.\n\n### Example Usage\n\nHere's an example of how you might use the `ProcessingOrchestrator` to process some data:\n\n```python\nimport asyncio\n\n# Define input data\ninputs = [\n    DataInput(file_path='data.csv', format_type='csv'),\n    DataInput(file_path='script.sql', format_type='sql')\n]\n\n# Define processing options\noptions = ProcessingOptions(timeout_seconds=30)\n\n# Create processors\nstream_processor = StreamProcessor()\ndatabase_processor = DatabaseProcessor(configuration={'db_path': 'example.db'})\n\n# Create orchestrator and add processors\norchestrator = ProcessingOrchestrator()\norchestrator.add_processor(stream_processor)\norchestrator.add_processor(database_processor)\n\n# Process data\nasync def main():\n    results = await orchestrator.process_all_data(inputs, options)\n    for result in results:\n        print(result.status_message)\n\n# Run the async main function\nasyncio.run(main())\n\n# Shutdown the orchestrator\norchestrator.shutdown()\n```\n\n### Notes\n\n- **DatabaseProcessor**: This processor is designed to handle SQL scripts synchronously due to transaction requirements. If you need asynchronous database operations, consider using an asynchronous library like `aiosqlite` or `asyncpg`.\n\n- **Concurrency**: The semaphore in `ProcessingOrchestrator` limits the number of concurrent tasks. Adjust this limit based on your system's capabilities and resource constraints.\n\nThis design provides a flexible and scalable framework for processing various types of data with different processors, managed by an orchestrator that handles concurrency and error management.", "violation": "Unknown", "violation_list": [], "explanation": "The provided code defines a robust system for processing data using different types of processors, such as `StreamProcessor` and `DatabaseProcessor`, managed by an orchestrator. Here's a detailed breakdown of the components and their functionalities:\n\n### Components\n\n1. **DataInput**:\n   - Represents the input data to be processed.\n   - Contains attributes like `file_path` (path to the file) and `format_type` (type of data format).\n\n2. **ProcessingOptions**:\n   - Defines options for processing, such as `timeout_seconds` (maximum time allowed for processing a task) and `transform_function` (a function to transform data during processing).\n\n3. **ValidationError**:\n   - A custom exception class used to handle validation errors.\n\n4. **ProcessingResult**:\n   - Represents the result of a processing operation.\n   - Contains attributes like `records_processed`, `output_location`, `status_message`, `processing_time`, and `errors`.\n\n5. **DataProcessor (Abstract Base Class)**:\n   - An abstract base class for all processors.\n   - Defines methods that must be implemented by subclasses, such as `process_data` and `can_process`.\n\n6. **StreamProcessor**:\n   - A concrete implementation of `DataProcessor`.\n   - Processes data from a file stream, applying transformations if specified.\n\n7. **DatabaseProcessor**:\n   - Another concrete implementation of `DataProcessor`.\n   - Executes SQL statements from a file against a database.\n   - Note: This processor uses synchronous methods due to transaction requirements and does not support asynchronous processing.\n\n8. **ProcessingOrchestrator**:\n   - Manages multiple processors and orchestrates the processing of data inputs.\n   - Uses a semaphore to limit concurrent processing tasks.\n   - Provides methods to add processors, process all data, and shut down the system.\n\n### Key Functionalities\n\n- **Processor Management**: The `ProcessingOrchestrator` can manage multiple processors and find the appropriate processor for a given data format using `_find_processor_for_format`.\n  \n- **Concurrency Control**: Uses an asyncio semaphore (`_processing_semaphore`) to limit the number of concurrent processing tasks, preventing resource exhaustion.\n\n- **Error Handling**: Implements error handling at various levels, including validation errors and processing errors, ensuring that failures are reported appropriately.\n\n- **Data Transformation**: Supports optional data transformation using a `transform_function` provided in `ProcessingOptions`.\n\n### Example Usage\n\nHere's an example of how you might use the `ProcessingOrchestrator` to process some data:", "solution_code": "NO FIX VERSION", "duration_seconds": 28.56008005142212}
{"id": 34, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport java.io.*\nimport java.nio.file.*\nimport java.sql.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicBoolean\nimport kotlin.time.Duration\nimport kotlin.time.Duration.Companion.seconds\n\ndata class DataInput(\n    val filePath: String,\n    val formatType: String,\n    val metadata: Map<String, Any> = emptyMap()\n)\n\ndata class ProcessingOptions(\n    val outputPath: String,\n    val transformData: Boolean = false,\n    val batchSize: Int = 1000,\n    val timeoutSeconds: Long = 30,\n    val additionalParams: Map<String, Any> = emptyMap()\n)\n\ndata class ProcessingResult(\n    val recordsProcessed: Int,\n    val outputLocation: String?,\n    val statusMessage: String,\n    val processingTimeMs: Long,\n    val errors: List<String> = emptyList()\n)\n\nclass ValidationException(message: String) : Exception(message)\n\nabstract class DataProcessor(\n    protected val processorId: String,\n    protected val configuration: Map<String, Any>\n) {\n    protected val supportedFormats = mutableListOf<String>()\n    private val _isProcessing = AtomicBoolean(false)\n    protected val processingMutex = Mutex()\n    \n    abstract suspend fun processData(inputData: DataInput, options: ProcessingOptions): ProcessingResult\n    abstract fun validateInput(inputData: DataInput)\n    abstract fun canProcess(formatType: String): Boolean\n    abstract fun cleanup()\n    \n    val isProcessing: Boolean get() = _isProcessing.get()\n    val processorInfo: Map<String, Any> get() = mapOf(\n        \"id\" to processorId,\n        \"supportedFormats\" to supportedFormats.toList(),\n        \"isBusy\" to _isProcessing.get()\n    )\n    \n    protected fun setProcessing(processing: Boolean) {\n        _isProcessing.set(processing)\n    }\n}\n\nclass StreamProcessor(\n    processorId: String,\n    configuration: Map<String, Any>\n) : DataProcessor(processorId, configuration) {\n    \n    private val executorService = Executors.newFixedThreadPool(2)\n    private val activeFiles = mutableListOf<Closeable>()\n    \n    init {\n        supportedFormats.addAll(listOf(\"csv\", \"txt\", \"json\", \"xml\", \"log\"))\n    }\n    \n    override suspend fun processData(inputData: DataInput, options: ProcessingOptions): ProcessingResult {\n        val startTime = System.currentTimeMillis()\n        \n        processingMutex.withLock {\n            if (isProcessing) {\n                throw IllegalStateException(\"Processor $processorId is already processing data\")\n            }\n            setProcessing(true)\n        }\n        \n        return try {\n            validateInput(inputData)\n            \n            val inputPath = Paths.get(inputData.filePath)\n            val outputPath = Paths.get(options.outputPath)\n            \n            withContext(Dispatchers.IO) {\n                val inputReader = Files.newBufferedReader(inputPath).also { activeFiles.add(it) }\n                val outputWriter = Files.newBufferedWriter(outputPath).also { activeFiles.add(it) }\n                \n                var lineCount = 0\n                val batchBuffer = mutableListOf<String>()\n                \n                inputReader.useLines { lines ->\n                    lines.forEach { line ->\n                        val processedLine = processLine(line, options)\n                        batchBuffer.add(processedLine)\n                        lineCount++\n                        \n                        if (batchBuffer.size >= options.batchSize) {\n                            batchBuffer.forEach { outputWriter.write(it) }\n                            batchBuffer.clear()\n                        }\n                        \n                        if (lineCount % 5000 == 0) {\n                            println(\"Stream processor: $lineCount lines processed\")\n                        }\n                    }\n                }\n                \n                if (batchBuffer.isNotEmpty()) {\n                    batchBuffer.forEach { outputWriter.write(it) }\n                }\n                \n                outputWriter.flush()\n                \n                val processingTime = System.currentTimeMillis() - startTime\n                ProcessingResult(\n                    recordsProcessed = lineCount,\n                    outputLocation = outputPath.toString(),\n                    statusMessage = \"STREAM_SUCCESS\",\n                    processingTimeMs = processingTime\n                )\n            }\n        } catch (e: Exception) {\n            val processingTime = System.currentTimeMillis() - startTime\n            ProcessingResult(\n                recordsProcessed = 0,\n                outputLocation = null,\n                statusMessage = \"STREAM_ERROR: ${e.message}\",\n                processingTimeMs = processingTime,\n                errors = listOf(e.message ?: \"Unknown error\")\n            )\n        } finally {\n            setProcessing(false)\n            cleanup()\n        }\n    }\n    \n    private fun processLine(line: String, options: ProcessingOptions): String {\n        return if (options.transformData) {\n            line.uppercase().trim() + \"\\n\"\n        } else {\n            line.trim() + \"\\n\"\n        }\n    }\n    \n    override fun validateInput(inputData: DataInput) {\n        if (inputData.filePath.isBlank()) {\n            throw ValidationException(\"Input file path cannot be empty\")\n        }\n        \n        val inputPath = Paths.get(inputData.filePath)\n        if (!Files.exists(inputPath)) {\n            throw ValidationException(\"Input file does not exist: ${inputData.filePath}\")\n        }\n        \n        if (!canProcess(inputData.formatType)) {\n            throw ValidationException(\"Unsupported format for stream processing: ${inputData.formatType}\")\n        }\n        \n        val maxFileSize = (configuration[\"maxFileSize\"] as? Long) ?: (100 * 1024 * 1024)\n        if (Files.size(inputPath) > maxFileSize) {\n            throw ValidationException(\"File too large for stream processing\")\n        }\n    }\n    \n    override fun canProcess(formatType: String): Boolean {\n        return supportedFormats.contains(formatType.lowercase())\n    }\n    \n    override fun cleanup() {\n        activeFiles.forEach { closeable ->\n            try {\n                closeable.close()\n            } catch (e: Exception) {\n                println(\"Cleanup error: ${e.message}\")\n            }\n        }\n        activeFiles.clear()\n        executorService.shutdown()\n    }\n}\n\nclass DatabaseProcessor(\n    processorId: String,\n    configuration: Map<String, Any>\n) : DataProcessor(processorId, configuration) {\n    \n    private var connection: Connection? = null\n    private var currentStatement: Statement? = null\n    \n    init {\n        supportedFormats.addAll(listOf(\"sql\", \"query\", \"dml\"))\n    }\n    \n    override suspend fun processData(inputData: DataInput, options: ProcessingOptions): ProcessingResult {\n        throw UnsupportedOperationException(\n            \"DatabaseProcessor cannot use async processing due to transaction requirements. \" +\n            \"Use processDatabaseSync() method instead for proper transaction handling.\"\n        )\n    }\n    \n    fun processDatabaseSync(inputData: DataInput, options: ProcessingOptions): ProcessingResult {\n        val startTime = System.currentTimeMillis()\n        \n        runBlocking {\n            processingMutex.withLock {\n                if (isProcessing) {\n                    throw IllegalStateException(\"Database processor $processorId is already processing\")\n                }\n                setProcessing(true)\n            }\n        }\n        \n        return try {\n            validateInput(inputData)\n            establishConnection()\n            \n            val sqlContent = File(inputData.filePath).readText()\n            val statements = sqlContent.split(';').map { it.trim() }.filter { it.isNotEmpty() }\n            var executedStatements = 0\n            \n            connection?.autoCommit = false\n            connection?.let { conn ->\n                try {\n                    statements.forEach { statement ->\n                        currentStatement = conn.createStatement()\n                        currentStatement?.execute(statement)\n                        executedStatements++\n                    }\n                    conn.commit()\n                    \n                    val processingTime = System.currentTimeMillis() - startTime\n                    ProcessingResult(\n                        recordsProcessed = executedStatements,\n                        outputLocation = null,\n                        statusMessage = \"DATABASE_SUCCESS\",\n                        processingTimeMs = processingTime\n                    )\n                } catch (e: Exception) {\n                    conn.rollback()\n                    throw RuntimeException(\"Database transaction failed: ${e.message}\")\n                }\n            } ?: throw RuntimeException(\"Failed to establish database connection\")\n            \n        } catch (e: Exception) {\n            val processingTime = System.currentTimeMillis() - startTime\n            ProcessingResult(\n                recordsProcessed = 0,\n                outputLocation = null,\n                statusMessage = \"DATABASE_ERROR: ${e.message}\",\n                processingTimeMs = processingTime,\n                errors = listOf(e.message ?: \"Unknown error\")\n            )\n        } finally {\n            setProcessing(false)\n            cleanup()\n        }\n    }\n    \n    private fun establishConnection() {\n        val dbPath = configuration[\"dbPath\"] as? String ?: \":memory:\"\n        connection = DriverManager.getConnection(\"jdbc:sqlite:$dbPath\")\n        connection?.autoCommit = true\n    }\n    \n    override fun validateInput(inputData: DataInput) {\n        if (inputData.filePath.isBlank()) {\n            throw ValidationException(\"Database processor requires valid SQL file path\")\n        }\n        \n        if (!canProcess(inputData.formatType)) {\n            throw ValidationException(\"Database processor cannot handle format: ${inputData.formatType}\")\n        }\n        \n        if (!configuration.containsKey(\"dbPath\")) {\n            throw ValidationException(\"Database processor requires database configuration\")\n        }\n        \n        val sqlPath = Paths.get(inputData.filePath)\n        if (!Files.exists(sqlPath)) {\n            throw ValidationException(\"SQL file not found: ${inputData.filePath}\")\n        }\n    }\n    \n    override fun canProcess(formatType: String): Boolean {\n        return supportedFormats.contains(formatType.lowercase())\n    }\n    \n    override fun cleanup() {\n        try {\n            currentStatement?.close()\n            connection?.close()\n        } catch (e: Exception) {\n            println(\"Database cleanup error: ${e.message}\")\n        } finally {\n            currentStatement = null\n            connection = null\n        }\n    }\n}\n\nclass ProcessingOrchestrator {\n    private val processors = mutableListOf<DataProcessor>()\n    private val processingSemaphore = Semaphore(4)\n    \n    fun addProcessor(processor: DataProcessor) {\n        processors.add(processor)\n    }\n    \n    suspend fun processAllData(inputs: List<DataInput>, options: ProcessingOptions): List<ProcessingResult> {\n        val results = mutableListOf<ProcessingResult>()\n        \n        inputs.forEach { inputData ->\n            val processor = findProcessorForFormat(inputData.formatType)\n            if (processor == null) {\n                results.add(ProcessingResult(\n                    recordsProcessed = 0,\n                    outputLocation = null,\n                    statusMessage = \"No processor found for format: ${inputData.formatType}\",\n                    processingTimeMs = 0L,\n                    errors = listOf(\"Unsupported format: ${inputData.formatType}\")\n                ))\n                return@forEach\n            }\n            \n            try {\n                processingSemaphore.acquire()\n                val result = withTimeout(options.timeoutSeconds.seconds) {\n                    processor.processData(inputData, options)\n                }\n                results.add(result)\n            } catch (e: Exception) {\n                results.add(ProcessingResult(\n                    recordsProcessed = 0,\n                    outputLocation = null,\n                    statusMessage = \"ORCHESTRATOR_ERROR: ${e.message}\",\n                    processingTimeMs = 0L,\n                    errors = listOf(e.message ?: \"Unknown error\")\n                ))\n            } finally {\n                processingSemaphore.release()\n            }\n        }\n        \n        return results\n    }\n    \n    private fun findProcessorForFormat(formatType: String): DataProcessor? {\n        return processors.find { it.canProcess(formatType) }\n    }\n    \n    fun shutdown() {\n        processors.forEach { it.cleanup() }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.*\nimport java.io.*\nimport java.nio.file.*\nimport java.sql.*\nimport java.util.concurrent.*\nimport java.util.concurrent.atomic.AtomicBoolean\nimport kotlin.time.Duration\nimport kotlin.time.Duration.Companion.seconds\n\ndata class DataInput(\n    val filePath: String,\n    val formatType: String,\n    val metadata: Map<String, Any> = emptyMap()\n)\n\ndata class ProcessingOptions(\n    val outputPath: String,\n    val transformData: Boolean = false,\n    val batchSize: Int = 1000,\n    val timeoutSeconds: Long = 30,\n    val additionalParams: Map<String, Any> = emptyMap()\n)\n\ndata class ProcessingResult(\n    val recordsProcessed: Int,\n    val outputLocation: String?,\n    val statusMessage: String,\n    val processingTimeMs: Long,\n    val errors: List<String> = emptyList()\n)\n\nclass ValidationException(message: String) : Exception(message)\n\nabstract class DataProcessor(\n    protected val processorId: String,\n    protected val configuration: Map<String, Any>\n) {\n    protected val supportedFormats = mutableListOf<String>()\n    private val _isProcessing = AtomicBoolean(false)\n    protected val processingMutex = Mutex()\n    \n    abstract suspend fun processData(inputData: DataInput, options: ProcessingOptions): ProcessingResult\n    abstract fun validateInput(inputData: DataInput)\n    abstract fun canProcess(formatType: String): Boolean\n    abstract fun cleanup()\n    \n    val isProcessing: Boolean get() = _isProcessing.get()\n    val processorInfo: Map<String, Any> get() = mapOf(\n        \"id\" to processorId,\n        \"supportedFormats\" to supportedFormats.toList(),\n        \"isBusy\" to _isProcessing.get()\n    )\n    \n    protected fun setProcessing(processing: Boolean) {\n        _isProcessing.set(processing)\n    }\n}\n\nclass StreamProcessor(\n    processorId: String,\n    configuration: Map<String, Any>\n) : DataProcessor(processorId, configuration) {\n    \n    private val executorService = Executors.newFixedThreadPool(2)\n    private val activeFiles = mutableListOf<Closeable>()\n    \n    init {\n        supportedFormats.addAll(listOf(\"csv\", \"txt\", \"json\", \"xml\", \"log\"))\n    }\n    \n    override suspend fun processData(inputData: DataInput, options: ProcessingOptions): ProcessingResult {\n        val startTime = System.currentTimeMillis()\n        \n        processingMutex.withLock {\n            if (isProcessing) {\n                throw IllegalStateException(\"Processor $processorId is already processing data\")\n            }\n            setProcessing(true)\n        }\n        \n        return try {\n            validateInput(inputData)\n            \n            val inputPath = Paths.get(inputData.filePath)\n            val outputPath = Paths.get(options.outputPath)\n            \n            withContext(Dispatchers.IO) {\n                val inputReader = Files.newBufferedReader(inputPath).also { activeFiles.add(it) }\n                val outputWriter = Files.newBufferedWriter(outputPath).also { activeFiles.add(it) }\n                \n                var lineCount = 0\n                val batchBuffer = mutableListOf<String>()\n                \n                inputReader.useLines { lines ->\n                    lines.forEach { line ->\n                        val processedLine = processLine(line, options)\n                        batchBuffer.add(processedLine)\n                        lineCount++\n                        \n                        if (batchBuffer.size >= options.batchSize) {\n                            batchBuffer.forEach { outputWriter.write(it) }\n                            batchBuffer.clear()\n                        }\n                        \n                        if (lineCount % 5000 == 0) {\n                            println(\"Stream processor: $lineCount lines processed\")\n                        }\n                    }\n                }\n                \n                if (batchBuffer.isNotEmpty()) {\n                    batchBuffer.forEach { outputWriter.write(it) }\n                }\n                \n                outputWriter.flush()\n                \n                val processingTime = System.currentTimeMillis() - startTime\n                ProcessingResult(\n                    recordsProcessed = lineCount,\n                    outputLocation = outputPath.toString(),\n                    statusMessage = \"STREAM_SUCCESS\",\n                    processingTimeMs = processingTime\n                )\n            }\n        } catch (e: Exception) {\n            val processingTime = System.currentTimeMillis() - startTime\n            ProcessingResult(\n                recordsProcessed = 0,\n                outputLocation = null,\n                statusMessage = \"STREAM_ERROR: ${e.message}\",\n                processingTimeMs = processingTime,\n                errors = listOf(e.message ?: \"Unknown error\")\n            )\n        } finally {\n            setProcessing(false)\n            cleanup()\n        }\n    }\n    \n    private fun processLine(line: String, options: ProcessingOptions): String {\n        return if (options.transformData) {\n            line.uppercase().trim() + \"\\n\"\n        } else {\n            line.trim() + \"\\n\"\n        }\n    }\n    \n    override fun validateInput(inputData: DataInput) {\n        if (inputData.filePath.isBlank()) {\n            throw ValidationException(\"Input file path cannot be empty\")\n        }\n        \n        val inputPath = Paths.get(inputData.filePath)\n        if (!Files.exists(inputPath)) {\n            throw ValidationException(\"Input file does not exist: ${inputData.filePath}\")\n        }\n        \n        if (!canProcess(inputData.formatType)) {\n            throw ValidationException(\"Unsupported format for stream processing: ${inputData.formatType}\")\n        }\n        \n        val maxFileSize = (configuration[\"maxFileSize\"] as? Long) ?: (100 * 1024 * 1024)\n        if (Files.size(inputPath) > maxFileSize) {\n            throw ValidationException(\"File too large for stream processing\")\n        }\n    }\n    \n    override fun canProcess(formatType: String): Boolean {\n        return supportedFormats.contains(formatType.lowercase())\n    }\n    \n    override fun cleanup() {\n        activeFiles.forEach { closeable ->\n            try {\n                closeable.close()\n            } catch (e: Exception) {\n                println(\"Cleanup error: ${e.message}\")\n            }\n        }\n        activeFiles.clear()\n        executorService.shutdown()\n    }\n}\n\nclass DatabaseProcessor(\n    processorId: String,\n    configuration: Map<String, Any>\n) : DataProcessor(processorId, configuration) {\n    \n    private var connection: Connection? = null\n    private var currentStatement: Statement? = null\n    \n    init {\n        supportedFormats.addAll(listOf(\"sql\", \"query\", \"dml\"))\n    }\n    \n    override suspend fun processData(inputData: DataInput, options: ProcessingOptions): ProcessingResult {\n        throw UnsupportedOperationException(\n            \"DatabaseProcessor cannot use async processing due to transaction requirements. \" +\n            \"Use processDatabaseSync() method instead for proper transaction handling.\"\n        )\n    }\n    \n    fun processDatabaseSync(inputData: DataInput, options: ProcessingOptions): ProcessingResult {\n        val startTime = System.currentTimeMillis()\n        \n        runBlocking {\n            processingMutex.withLock {\n                if (isProcessing) {\n                    throw IllegalStateException(\"Database processor $processorId is already processing\")\n                }\n                setProcessing(true)\n            }\n        }\n        \n        return try {\n            validateInput(inputData)\n            establishConnection()\n            \n            val sqlContent = File(inputData.filePath).readText()\n            val statements = sqlContent.split(';').map { it.trim() }.filter { it.isNotEmpty() }\n            var executedStatements = 0\n            \n            connection?.autoCommit = false\n            connection?.let { conn ->\n                try {\n                    statements.forEach { statement ->\n                        currentStatement = conn.createStatement()\n                        currentStatement?.execute(statement)\n                        executedStatements++\n                    }\n                    conn.commit()\n                    \n                    val processingTime = System.currentTimeMillis() - startTime\n                    ProcessingResult(\n                        recordsProcessed = executedStatements,\n                        outputLocation = null,\n                        statusMessage = \"DATABASE_SUCCESS\",\n                        processingTimeMs = processingTime\n                    )\n                } catch (e: Exception) {\n                    conn.rollback()\n                    throw RuntimeException(\"Database transaction failed: ${e.message}\")\n                }\n            } ?: throw RuntimeException(\"Failed to establish database connection\")\n            \n        } catch (e: Exception) {\n            val processingTime = System.currentTimeMillis() - startTime\n            ProcessingResult(\n                recordsProcessed = 0,\n                outputLocation = null,\n                statusMessage = \"DATABASE_ERROR: ${e.message}\",\n                processingTimeMs = processingTime,\n                errors = listOf(e.message ?: \"Unknown error\")\n            )\n        } finally {\n            setProcessing(false)\n            cleanup()\n        }\n    }\n    \n    private fun establishConnection() {\n        val dbPath = configuration[\"dbPath\"] as? String ?: \":memory:\"\n        connection = DriverManager.getConnection(\"jdbc:sqlite:$dbPath\")\n        connection?.autoCommit = true\n    }\n    \n    override fun validateInput(inputData: DataInput) {\n        if (inputData.filePath.isBlank()) {\n            throw ValidationException(\"Database processor requires valid SQL file path\")\n        }\n        \n        if (!canProcess(inputData.formatType)) {\n            throw ValidationException(\"Database processor cannot handle format: ${inputData.formatType}\")\n        }\n        \n        if (!configuration.containsKey(\"dbPath\")) {\n            throw ValidationException(\"Database processor requires database configuration\")\n        }\n        \n        val sqlPath = Paths.get(inputData.filePath)\n        if (!Files.exists(sqlPath)) {\n            throw ValidationException(\"SQL file not found: ${inputData.filePath}\")\n        }\n    }\n    \n    override fun canProcess(formatType: String): Boolean {\n        return supportedFormats.contains(formatType.lowercase())\n    }\n    \n    override fun cleanup() {\n        try {\n            currentStatement?.close()\n            connection?.close()\n        } catch (e: Exception) {\n            println(\"Database cleanup error: ${e.message}\")\n        } finally {\n            currentStatement = null\n            connection = null\n        }\n    }\n}\n\nclass ProcessingOrchestrator {\n    private val processors = mutableListOf<DataProcessor>()\n    private val processingSemaphore = Semaphore(4)\n    \n    fun addProcessor(processor: DataProcessor) {\n        processors.add(processor)\n    }\n    \n    suspend fun processAllData(inputs: List<DataInput>, options: ProcessingOptions): List<ProcessingResult> {\n        val results = mutableListOf<ProcessingResult>()\n        \n        inputs.forEach { inputData ->\n            val processor = findProcessorForFormat(inputData.formatType)\n            if (processor == null) {\n                results.add(ProcessingResult(\n                    recordsProcessed = 0,\n                    outputLocation = null,\n                    statusMessage = \"No processor found for format: ${inputData.formatType}\",\n                    processingTimeMs = 0L,\n                    errors = listOf(\"Unsupported format: ${inputData.formatType}\")\n                ))\n                return@forEach\n            }\n            \n            try {\n                processingSemaphore.acquire()\n                val result = withTimeout(options.timeoutSeconds.seconds) {\n                    processor.processData(inputData, options)\n                }\n                results.add(result)\n            } catch (e: Exception) {\n                results.add(ProcessingResult(\n                    recordsProcessed = 0,\n                    outputLocation = null,\n                    statusMessage = \"ORCHESTRATOR_ERROR: ${e.message}\",\n                    processingTimeMs = 0L,\n                    errors = listOf(e.message ?: \"Unknown error\")\n                ))\n            } finally {\n                processingSemaphore.release()\n            }\n        }\n        \n        return results\n    }\n    \n    private fun findProcessorForFormat(formatType: String): DataProcessor? {\n        return processors.find { it.canProcess(formatType) }\n    }\n    \n    fun shutdown() {\n        processors.forEach { it.cleanup() }\n    }\n}", "raw_response": "The provided code defines a system for processing data using different types of processors, such as `StreamProcessor` and `DatabaseProcessor`, managed by an orchestrator. Here's a detailed breakdown of the components and their functionalities:\n\n### Components\n\n1. **DataProcessor (Abstract Class)**\n   - This is an abstract class that defines the common interface for all processors.\n   - It includes methods like `processData`, `validateInput`, `canProcess`, and `cleanup`.\n   - The `processData` method is abstract and must be implemented by subclasses.\n\n2. **StreamProcessor (Concrete Class)**\n   - Inherits from `DataProcessor`.\n   - Processes data asynchronously using Kotlin coroutines.\n   - Handles file reading, line processing, and writing to an output file.\n   - Uses a mutex (`processingMutex`) to ensure thread safety during processing.\n   - Implements the `processData` method to read lines from a file, process them, and write the results to another file.\n\n3. **DatabaseProcessor (Concrete Class)**\n   - Inherits from `DataProcessor`.\n   - Processes SQL statements synchronously due to transaction requirements.\n   - Establishes a database connection, executes SQL statements, and commits or rolls back transactions based on success or failure.\n   - Implements the `processDatabaseSync` method for synchronous processing.\n\n4. **ProcessingOrchestrator (Class)**\n   - Manages multiple processors and orchestrates their execution.\n   - Maintains a list of processors and uses a semaphore (`processingSemaphore`) to limit concurrent processing tasks.\n   - Provides methods to add processors, process all data inputs, and shut down the system.\n\n5. **DataInput (Data Class)**\n   - Represents input data for processing, including file path and format type.\n\n6. **ProcessingOptions (Data Class)**\n   - Contains options for processing, such as timeout duration.\n\n7. **ProcessingResult (Data Class)**\n   - Holds the result of a processing task, including processed records count, output location, status message, processing time, and any errors encountered.\n\n8. **ValidationException (Custom Exception)**\n   - Thrown when input validation fails.\n\n### Key Features\n\n- **Concurrency Control**: The `ProcessingOrchestrator` uses a semaphore to limit the number of concurrent processing tasks.\n- **Thread Safety**: Mutexes are used in processors to ensure that only one task is processed at a time per processor instance.\n- **Error Handling**: Custom exceptions and error messages are used to handle validation failures and other issues during processing.\n- **Extensibility**: New processors can be added by implementing the `DataProcessor` interface.\n\n### Example Usage\n\nHere's an example of how you might use this system:\n\n```kotlin\nfun main() = runBlocking {\n    val orchestrator = ProcessingOrchestrator()\n    \n    // Add processors\n    orchestrator.addProcessor(StreamProcessor())\n    orchestrator.addProcessor(DatabaseProcessor())\n    \n    // Define input data and options\n    val inputs = listOf(\n        DataInput(filePath = \"input.txt\", formatType = \"stream\"),\n        DataInput(filePath = \"script.sql\", formatType = \"database\")\n    )\n    val options = ProcessingOptions(timeoutSeconds = 60)\n    \n    // Process all data\n    val results = orchestrator.processAllData(inputs, options)\n    \n    // Print results\n    results.forEach { result ->\n        println(\"Status: ${result.statusMessage}, Records Processed: ${result.recordsProcessed}\")\n    }\n    \n    // Shutdown the orchestrator\n    orchestrator.shutdown()\n}\n```\n\n### Considerations\n\n- **Error Handling**: Ensure that all exceptions are properly handled and logged.\n- **Resource Management**: Properly close resources like file handles and database connections to avoid leaks.\n- **Performance**: Monitor performance and adjust concurrency limits as needed.\n\nThis system provides a robust framework for processing data using different types of processors, with built-in support for concurrency control and error handling.", "violation": "Unknown", "violation_list": [], "explanation": "The provided code defines a system for processing data using different types of processors, such as `StreamProcessor` and `DatabaseProcessor`, managed by an orchestrator. Here's a detailed breakdown of the components and their functionalities:\n\n### Components\n\n1. **DataProcessor (Abstract Class)**\n   - This is an abstract class that defines the common interface for all processors.\n   - It includes methods like `processData`, `validateInput`, `canProcess`, and `cleanup`.\n   - The `processData` method is abstract and must be implemented by subclasses.\n\n2. **StreamProcessor (Concrete Class)**\n   - Inherits from `DataProcessor`.\n   - Processes data asynchronously using Kotlin coroutines.\n   - Handles file reading, line processing, and writing to an output file.\n   - Uses a mutex (`processingMutex`) to ensure thread safety during processing.\n   - Implements the `processData` method to read lines from a file, process them, and write the results to another file.\n\n3. **DatabaseProcessor (Concrete Class)**\n   - Inherits from `DataProcessor`.\n   - Processes SQL statements synchronously due to transaction requirements.\n   - Establishes a database connection, executes SQL statements, and commits or rolls back transactions based on success or failure.\n   - Implements the `processDatabaseSync` method for synchronous processing.\n\n4. **ProcessingOrchestrator (Class)**\n   - Manages multiple processors and orchestrates their execution.\n   - Maintains a list of processors and uses a semaphore (`processingSemaphore`) to limit concurrent processing tasks.\n   - Provides methods to add processors, process all data inputs, and shut down the system.\n\n5. **DataInput (Data Class)**\n   - Represents input data for processing, including file path and format type.\n\n6. **ProcessingOptions (Data Class)**\n   - Contains options for processing, such as timeout duration.\n\n7. **ProcessingResult (Data Class)**\n   - Holds the result of a processing task, including processed records count, output location, status message, processing time, and any errors encountered.\n\n8. **ValidationException (Custom Exception)**\n   - Thrown when input validation fails.\n\n### Key Features\n\n- **Concurrency Control**: The `ProcessingOrchestrator` uses a semaphore to limit the number of concurrent processing tasks.\n- **Thread Safety**: Mutexes are used in processors to ensure that only one task is processed at a time per processor instance.\n- **Error Handling**: Custom exceptions and error messages are used to handle validation failures and other issues during processing.\n- **Extensibility**: New processors can be added by implementing the `DataProcessor` interface.\n\n### Example Usage\n\nHere's an example of how you might use this system:", "solution_code": "NO FIX VERSION", "duration_seconds": 28.616674661636353}
{"id": 35, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.IO;\nusing System.Data;\nusing System.Data.SQLite;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing System.Text;\n\npublic class DataInput\n{\n    public string FilePath { get; set; }\n    public string FormatType { get; set; }\n    public Dictionary<string, object> Metadata { get; set; } = new Dictionary<string, object>();\n}\n\npublic class ProcessingOptions\n{\n    public string OutputPath { get; set; }\n    public bool TransformData { get; set; } = false;\n    public int BatchSize { get; set; } = 1000;\n    public int TimeoutSeconds { get; set; } = 30;\n    public Dictionary<string, object> AdditionalParams { get; set; } = new Dictionary<string, object>();\n}\n\npublic class ProcessingResult\n{\n    public int RecordsProcessed { get; set; }\n    public string OutputLocation { get; set; }\n    public string StatusMessage { get; set; }\n    public long ProcessingTimeMs { get; set; }\n    public List<string> Errors { get; set; } = new List<string>();\n}\n\npublic class ValidationException : Exception\n{\n    public ValidationException(string message) : base(message) { }\n}\n\npublic abstract class DataProcessor\n{\n    protected readonly string processorId;\n    protected readonly Dictionary<string, object> configuration;\n    protected readonly List<string> supportedFormats;\n    private volatile bool _isProcessing = false;\n    protected readonly SemaphoreSlim processingLock = new SemaphoreSlim(1, 1);\n    \n    protected DataProcessor(string processorId, Dictionary<string, object> configuration)\n    {\n        this.processorId = processorId;\n        this.configuration = new Dictionary<string, object>(configuration);\n        this.supportedFormats = new List<string>();\n    }\n    \n    public abstract Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options);\n    public abstract void ValidateInput(DataInput inputData);\n    public abstract bool CanProcess(string formatType);\n    public abstract void Cleanup();\n    \n    public bool IsProcessing => _isProcessing;\n    \n    public Dictionary<string, object> ProcessorInfo => new Dictionary<string, object>\n    {\n        [\"id\"] = processorId,\n        [\"supportedFormats\"] = supportedFormats.ToList(),\n        [\"isBusy\"] = _isProcessing\n    };\n    \n    protected void SetProcessing(bool processing)\n    {\n        _isProcessing = processing;\n    }\n}\n\npublic class StreamProcessor : DataProcessor\n{\n    private readonly List<IDisposable> activeResources = new List<IDisposable>();\n    \n    public StreamProcessor(string processorId, Dictionary<string, object> configuration) \n        : base(processorId, configuration)\n    {\n        supportedFormats.AddRange(new[] { \"csv\", \"txt\", \"json\", \"xml\", \"log\" });\n    }\n    \n    public override async Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options)\n    {\n        var startTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();\n        \n        await processingLock.WaitAsync();\n        try\n        {\n            if (IsProcessing)\n            {\n                throw new InvalidOperationException($\"Processor {processorId} is already processing data\");\n            }\n            SetProcessing(true);\n        }\n        finally\n        {\n            processingLock.Release();\n        }\n        \n        try\n        {\n            ValidateInput(inputData);\n            \n            using var inputReader = new StreamReader(inputData.FilePath);\n            using var outputWriter = new StreamWriter(options.OutputPath);\n            \n            activeResources.Add(inputReader);\n            activeResources.Add(outputWriter);\n            \n            var lineCount = 0;\n            var batchBuffer = new List<string>();\n            \n            string line;\n            while ((line = await inputReader.ReadLineAsync()) != null)\n            {\n                var processedLine = ProcessLine(line, options);\n                batchBuffer.Add(processedLine);\n                lineCount++;\n                \n                if (batchBuffer.Count >= options.BatchSize)\n                {\n                    foreach (var bufferedLine in batchBuffer)\n                    {\n                        await outputWriter.WriteAsync(bufferedLine);\n                    }\n                    batchBuffer.Clear();\n                }\n                \n                if (lineCount % 5000 == 0)\n                {\n                    Console.WriteLine($\"Stream processor: {lineCount} lines processed\");\n                }\n            }\n            \n            if (batchBuffer.Any())\n            {\n                foreach (var bufferedLine in batchBuffer)\n                {\n                    await outputWriter.WriteAsync(bufferedLine);\n                }\n            }\n            \n            await outputWriter.FlushAsync();\n            \n            var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n            return new ProcessingResult\n            {\n                RecordsProcessed = lineCount,\n                OutputLocation = options.OutputPath,\n                StatusMessage = \"STREAM_SUCCESS\",\n                ProcessingTimeMs = processingTime\n            };\n        }\n        catch (Exception ex)\n        {\n            var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n            return new ProcessingResult\n            {\n                RecordsProcessed = 0,\n                OutputLocation = null,\n                StatusMessage = $\"STREAM_ERROR: {ex.Message}\",\n                ProcessingTimeMs = processingTime,\n                Errors = new List<string> { ex.Message }\n            };\n        }\n        finally\n        {\n            SetProcessing(false);\n            Cleanup();\n        }\n    }\n    \n    private string ProcessLine(string line, ProcessingOptions options)\n    {\n        return options.TransformData \n            ? line.ToUpper().Trim() + Environment.NewLine\n            : line.Trim() + Environment.NewLine;\n    }\n    \n    public override void ValidateInput(DataInput inputData)\n    {\n        if (string.IsNullOrWhiteSpace(inputData?.FilePath))\n        {\n            throw new ValidationException(\"Input file path cannot be empty\");\n        }\n        \n        if (!File.Exists(inputData.FilePath))\n        {\n            throw new ValidationException($\"Input file does not exist: {inputData.FilePath}\");\n        }\n        \n        if (!CanProcess(inputData.FormatType))\n        {\n            throw new ValidationException($\"Unsupported format for stream processing: {inputData.FormatType}\");\n        }\n        \n        var maxFileSize = configuration.ContainsKey(\"maxFileSize\") \n            ? Convert.ToInt64(configuration[\"maxFileSize\"]) \n            : 100 * 1024 * 1024;\n            \n        if (new FileInfo(inputData.FilePath).Length > maxFileSize)\n        {\n            throw new ValidationException(\"File too large for stream processing\");\n        }\n    }\n    \n    public override bool CanProcess(string formatType)\n    {\n        return supportedFormats.Contains(formatType?.ToLowerInvariant());\n    }\n    \n    public override void Cleanup()\n    {\n        foreach (var resource in activeResources)\n        {\n            try\n            {\n                resource?.Dispose();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Cleanup error: {ex.Message}\");\n            }\n        }\n        activeResources.Clear();\n    }\n}\n\npublic class DatabaseProcessor : DataProcessor\n{\n    private SQLiteConnection connection;\n    private SQLiteCommand currentCommand;\n    \n    public DatabaseProcessor(string processorId, Dictionary<string, object> configuration) \n        : base(processorId, configuration)\n    {\n        supportedFormats.AddRange(new[] { \"sql\", \"query\", \"dml\" });\n    }\n    \n    public override Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options)\n    {\n        throw new NotSupportedException(\n            \"DatabaseProcessor cannot use async processing due to transaction requirements. \" +\n            \"Use ProcessDatabaseSync() method instead for proper transaction handling.\"\n        );\n    }\n    \n    public ProcessingResult ProcessDatabaseSync(DataInput inputData, ProcessingOptions options)\n    {\n        var startTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();\n        \n        processingLock.Wait();\n        try\n        {\n            if (IsProcessing)\n            {\n                throw new InvalidOperationException($\"Database processor {processorId} is already processing\");\n            }\n            SetProcessing(true);\n        }\n        finally\n        {\n            processingLock.Release();\n        }\n        \n        try\n        {\n            ValidateInput(inputData);\n            EstablishConnection();\n            \n            var sqlContent = File.ReadAllText(inputData.FilePath);\n            var statements = sqlContent.Split(';')\n                .Select(s => s.Trim())\n                .Where(s => !string.IsNullOrEmpty(s))\n                .ToList();\n                \n            var executedStatements = 0;\n            \n            using var transaction = connection.BeginTransaction();\n            \n            try\n            {\n                foreach (var statement in statements)\n                {\n                    currentCommand = new SQLiteCommand(statement, connection, transaction);\n                    currentCommand.ExecuteNonQuery();\n                    executedStatements++;\n                }\n                \n                transaction.Commit();\n                \n                var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n                return new ProcessingResult\n                {\n                    RecordsProcessed = executedStatements,\n                    OutputLocation = null,\n                    StatusMessage = \"DATABASE_SUCCESS\",\n                    ProcessingTimeMs = processingTime\n                };\n            }\n            catch (Exception ex)\n            {\n                transaction.Rollback();\n                throw new InvalidOperationException($\"Database transaction failed: {ex.Message}\");\n            }\n        }\n        catch (Exception ex)\n        {\n            var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n            return new ProcessingResult\n            {\n                RecordsProcessed = 0,\n                OutputLocation = null,\n                StatusMessage = $\"DATABASE_ERROR: {ex.Message}\",\n                ProcessingTimeMs = processingTime,\n                Errors = new List<string> { ex.Message }\n            };\n        }\n        finally\n        {\n            SetProcessing(false);\n            Cleanup();\n        }\n    }\n    \n    private void EstablishConnection()\n    {\n        var dbPath = configuration.ContainsKey(\"dbPath\") \n            ? configuration[\"dbPath\"].ToString() \n            : \":memory:\";\n        connection = new SQLiteConnection($\"Data Source={dbPath}\");\n        connection.Open();\n    }\n    \n    public override void ValidateInput(DataInput inputData)\n    {\n        if (string.IsNullOrWhiteSpace(inputData?.FilePath))\n        {\n            throw new ValidationException(\"Database processor requires valid SQL file path\");\n        }\n        \n        if (!CanProcess(inputData.FormatType))\n        {\n            throw new ValidationException($\"Database processor cannot handle format: {inputData.FormatType}\");\n        }\n        \n        if (!configuration.ContainsKey(\"dbPath\"))\n        {\n            throw new ValidationException(\"Database processor requires database configuration\");\n        }\n        \n        if (!File.Exists(inputData.FilePath))\n        {\n            throw new ValidationException($\"SQL file not found: {inputData.FilePath}\");\n        }\n    }\n    \n    public override bool CanProcess(string formatType)\n    {\n        return supportedFormats.Contains(formatType?.ToLowerInvariant());\n    }\n    \n    public override void Cleanup()\n    {\n        try\n        {\n            currentCommand?.Dispose();\n            connection?.Close();\n            connection?.Dispose();\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Database cleanup error: {ex.Message}\");\n        }\n        finally\n        {\n            currentCommand = null;\n            connection = null;\n        }\n    }\n}\n\npublic class ProcessingOrchestrator\n{\n    private readonly List<DataProcessor> processors = new List<DataProcessor>();\n    private readonly SemaphoreSlim processingSemaphore = new SemaphoreSlim(4, 4);\n    \n    public void AddProcessor(DataProcessor processor)\n    {\n        processors.Add(processor);\n    }\n    \n    public async Task<List<ProcessingResult>> ProcessAllDataAsync(List<DataInput> inputs, ProcessingOptions options)\n    {\n        var results = new List<ProcessingResult>();\n        \n        foreach (var inputData in inputs)\n        {\n            var processor = FindProcessorForFormat(inputData.FormatType);\n            if (processor == null)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = $\"No processor found for format: {inputData.FormatType}\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { $\"Unsupported format: {inputData.FormatType}\" }\n                });\n                continue;\n            }\n            \n            try\n            {\n                await processingSemaphore.WaitAsync();\n                \n                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(options.TimeoutSeconds));\n                var result = await processor.ProcessDataAsync(inputData, options);\n                results.Add(result);\n            }\n            catch (Exception ex)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = $\"ORCHESTRATOR_ERROR: {ex.Message}\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { ex.Message }\n                });\n            }\n            finally\n            {\n                processingSemaphore.Release();\n            }\n        }\n        \n        return results;\n    }\n    \n    private DataProcessor FindProcessorForFormat(string formatType)\n    {\n        return processors.FirstOrDefault(p => p.CanProcess(formatType));\n    }\n    \n    public void Shutdown()\n    {\n        foreach (var processor in processors)\n        {\n            processor.Cleanup();\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Concurrent;\nusing System.IO;\nusing System.Data;\nusing System.Data.SQLite;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Linq;\nusing System.Text;\n\npublic class DataInput\n{\n    public string FilePath { get; set; }\n    public string FormatType { get; set; }\n    public Dictionary<string, object> Metadata { get; set; } = new Dictionary<string, object>();\n}\n\npublic class ProcessingOptions\n{\n    public string OutputPath { get; set; }\n    public bool TransformData { get; set; } = false;\n    public int BatchSize { get; set; } = 1000;\n    public int TimeoutSeconds { get; set; } = 30;\n    public Dictionary<string, object> AdditionalParams { get; set; } = new Dictionary<string, object>();\n}\n\npublic class ProcessingResult\n{\n    public int RecordsProcessed { get; set; }\n    public string OutputLocation { get; set; }\n    public string StatusMessage { get; set; }\n    public long ProcessingTimeMs { get; set; }\n    public List<string> Errors { get; set; } = new List<string>();\n}\n\npublic class ValidationException : Exception\n{\n    public ValidationException(string message) : base(message) { }\n}\n\npublic abstract class DataProcessor\n{\n    protected readonly string processorId;\n    protected readonly Dictionary<string, object> configuration;\n    protected readonly List<string> supportedFormats;\n    private volatile bool _isProcessing = false;\n    protected readonly SemaphoreSlim processingLock = new SemaphoreSlim(1, 1);\n    \n    protected DataProcessor(string processorId, Dictionary<string, object> configuration)\n    {\n        this.processorId = processorId;\n        this.configuration = new Dictionary<string, object>(configuration);\n        this.supportedFormats = new List<string>();\n    }\n    \n    public abstract Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options);\n    public abstract void ValidateInput(DataInput inputData);\n    public abstract bool CanProcess(string formatType);\n    public abstract void Cleanup();\n    \n    public bool IsProcessing => _isProcessing;\n    \n    public Dictionary<string, object> ProcessorInfo => new Dictionary<string, object>\n    {\n        [\"id\"] = processorId,\n        [\"supportedFormats\"] = supportedFormats.ToList(),\n        [\"isBusy\"] = _isProcessing\n    };\n    \n    protected void SetProcessing(bool processing)\n    {\n        _isProcessing = processing;\n    }\n}\n\npublic class StreamProcessor : DataProcessor\n{\n    private readonly List<IDisposable> activeResources = new List<IDisposable>();\n    \n    public StreamProcessor(string processorId, Dictionary<string, object> configuration) \n        : base(processorId, configuration)\n    {\n        supportedFormats.AddRange(new[] { \"csv\", \"txt\", \"json\", \"xml\", \"log\" });\n    }\n    \n    public override async Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options)\n    {\n        var startTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();\n        \n        await processingLock.WaitAsync();\n        try\n        {\n            if (IsProcessing)\n            {\n                throw new InvalidOperationException($\"Processor {processorId} is already processing data\");\n            }\n            SetProcessing(true);\n        }\n        finally\n        {\n            processingLock.Release();\n        }\n        \n        try\n        {\n            ValidateInput(inputData);\n            \n            using var inputReader = new StreamReader(inputData.FilePath);\n            using var outputWriter = new StreamWriter(options.OutputPath);\n            \n            activeResources.Add(inputReader);\n            activeResources.Add(outputWriter);\n            \n            var lineCount = 0;\n            var batchBuffer = new List<string>();\n            \n            string line;\n            while ((line = await inputReader.ReadLineAsync()) != null)\n            {\n                var processedLine = ProcessLine(line, options);\n                batchBuffer.Add(processedLine);\n                lineCount++;\n                \n                if (batchBuffer.Count >= options.BatchSize)\n                {\n                    foreach (var bufferedLine in batchBuffer)\n                    {\n                        await outputWriter.WriteAsync(bufferedLine);\n                    }\n                    batchBuffer.Clear();\n                }\n                \n                if (lineCount % 5000 == 0)\n                {\n                    Console.WriteLine($\"Stream processor: {lineCount} lines processed\");\n                }\n            }\n            \n            if (batchBuffer.Any())\n            {\n                foreach (var bufferedLine in batchBuffer)\n                {\n                    await outputWriter.WriteAsync(bufferedLine);\n                }\n            }\n            \n            await outputWriter.FlushAsync();\n            \n            var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n            return new ProcessingResult\n            {\n                RecordsProcessed = lineCount,\n                OutputLocation = options.OutputPath,\n                StatusMessage = \"STREAM_SUCCESS\",\n                ProcessingTimeMs = processingTime\n            };\n        }\n        catch (Exception ex)\n        {\n            var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n            return new ProcessingResult\n            {\n                RecordsProcessed = 0,\n                OutputLocation = null,\n                StatusMessage = $\"STREAM_ERROR: {ex.Message}\",\n                ProcessingTimeMs = processingTime,\n                Errors = new List<string> { ex.Message }\n            };\n        }\n        finally\n        {\n            SetProcessing(false);\n            Cleanup();\n        }\n    }\n    \n    private string ProcessLine(string line, ProcessingOptions options)\n    {\n        return options.TransformData \n            ? line.ToUpper().Trim() + Environment.NewLine\n            : line.Trim() + Environment.NewLine;\n    }\n    \n    public override void ValidateInput(DataInput inputData)\n    {\n        if (string.IsNullOrWhiteSpace(inputData?.FilePath))\n        {\n            throw new ValidationException(\"Input file path cannot be empty\");\n        }\n        \n        if (!File.Exists(inputData.FilePath))\n        {\n            throw new ValidationException($\"Input file does not exist: {inputData.FilePath}\");\n        }\n        \n        if (!CanProcess(inputData.FormatType))\n        {\n            throw new ValidationException($\"Unsupported format for stream processing: {inputData.FormatType}\");\n        }\n        \n        var maxFileSize = configuration.ContainsKey(\"maxFileSize\") \n            ? Convert.ToInt64(configuration[\"maxFileSize\"]) \n            : 100 * 1024 * 1024;\n            \n        if (new FileInfo(inputData.FilePath).Length > maxFileSize)\n        {\n            throw new ValidationException(\"File too large for stream processing\");\n        }\n    }\n    \n    public override bool CanProcess(string formatType)\n    {\n        return supportedFormats.Contains(formatType?.ToLowerInvariant());\n    }\n    \n    public override void Cleanup()\n    {\n        foreach (var resource in activeResources)\n        {\n            try\n            {\n                resource?.Dispose();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Cleanup error: {ex.Message}\");\n            }\n        }\n        activeResources.Clear();\n    }\n}\n\npublic class DatabaseProcessor : DataProcessor\n{\n    private SQLiteConnection connection;\n    private SQLiteCommand currentCommand;\n    \n    public DatabaseProcessor(string processorId, Dictionary<string, object> configuration) \n        : base(processorId, configuration)\n    {\n        supportedFormats.AddRange(new[] { \"sql\", \"query\", \"dml\" });\n    }\n    \n    public override Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options)\n    {\n        throw new NotSupportedException(\n            \"DatabaseProcessor cannot use async processing due to transaction requirements. \" +\n            \"Use ProcessDatabaseSync() method instead for proper transaction handling.\"\n        );\n    }\n    \n    public ProcessingResult ProcessDatabaseSync(DataInput inputData, ProcessingOptions options)\n    {\n        var startTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();\n        \n        processingLock.Wait();\n        try\n        {\n            if (IsProcessing)\n            {\n                throw new InvalidOperationException($\"Database processor {processorId} is already processing\");\n            }\n            SetProcessing(true);\n        }\n        finally\n        {\n            processingLock.Release();\n        }\n        \n        try\n        {\n            ValidateInput(inputData);\n            EstablishConnection();\n            \n            var sqlContent = File.ReadAllText(inputData.FilePath);\n            var statements = sqlContent.Split(';')\n                .Select(s => s.Trim())\n                .Where(s => !string.IsNullOrEmpty(s))\n                .ToList();\n                \n            var executedStatements = 0;\n            \n            using var transaction = connection.BeginTransaction();\n            \n            try\n            {\n                foreach (var statement in statements)\n                {\n                    currentCommand = new SQLiteCommand(statement, connection, transaction);\n                    currentCommand.ExecuteNonQuery();\n                    executedStatements++;\n                }\n                \n                transaction.Commit();\n                \n                var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n                return new ProcessingResult\n                {\n                    RecordsProcessed = executedStatements,\n                    OutputLocation = null,\n                    StatusMessage = \"DATABASE_SUCCESS\",\n                    ProcessingTimeMs = processingTime\n                };\n            }\n            catch (Exception ex)\n            {\n                transaction.Rollback();\n                throw new InvalidOperationException($\"Database transaction failed: {ex.Message}\");\n            }\n        }\n        catch (Exception ex)\n        {\n            var processingTime = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - startTime;\n            return new ProcessingResult\n            {\n                RecordsProcessed = 0,\n                OutputLocation = null,\n                StatusMessage = $\"DATABASE_ERROR: {ex.Message}\",\n                ProcessingTimeMs = processingTime,\n                Errors = new List<string> { ex.Message }\n            };\n        }\n        finally\n        {\n            SetProcessing(false);\n            Cleanup();\n        }\n    }\n    \n    private void EstablishConnection()\n    {\n        var dbPath = configuration.ContainsKey(\"dbPath\") \n            ? configuration[\"dbPath\"].ToString() \n            : \":memory:\";\n        connection = new SQLiteConnection($\"Data Source={dbPath}\");\n        connection.Open();\n    }\n    \n    public override void ValidateInput(DataInput inputData)\n    {\n        if (string.IsNullOrWhiteSpace(inputData?.FilePath))\n        {\n            throw new ValidationException(\"Database processor requires valid SQL file path\");\n        }\n        \n        if (!CanProcess(inputData.FormatType))\n        {\n            throw new ValidationException($\"Database processor cannot handle format: {inputData.FormatType}\");\n        }\n        \n        if (!configuration.ContainsKey(\"dbPath\"))\n        {\n            throw new ValidationException(\"Database processor requires database configuration\");\n        }\n        \n        if (!File.Exists(inputData.FilePath))\n        {\n            throw new ValidationException($\"SQL file not found: {inputData.FilePath}\");\n        }\n    }\n    \n    public override bool CanProcess(string formatType)\n    {\n        return supportedFormats.Contains(formatType?.ToLowerInvariant());\n    }\n    \n    public override void Cleanup()\n    {\n        try\n        {\n            currentCommand?.Dispose();\n            connection?.Close();\n            connection?.Dispose();\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Database cleanup error: {ex.Message}\");\n        }\n        finally\n        {\n            currentCommand = null;\n            connection = null;\n        }\n    }\n}\n\npublic class ProcessingOrchestrator\n{\n    private readonly List<DataProcessor> processors = new List<DataProcessor>();\n    private readonly SemaphoreSlim processingSemaphore = new SemaphoreSlim(4, 4);\n    \n    public void AddProcessor(DataProcessor processor)\n    {\n        processors.Add(processor);\n    }\n    \n    public async Task<List<ProcessingResult>> ProcessAllDataAsync(List<DataInput> inputs, ProcessingOptions options)\n    {\n        var results = new List<ProcessingResult>();\n        \n        foreach (var inputData in inputs)\n        {\n            var processor = FindProcessorForFormat(inputData.FormatType);\n            if (processor == null)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = $\"No processor found for format: {inputData.FormatType}\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { $\"Unsupported format: {inputData.FormatType}\" }\n                });\n                continue;\n            }\n            \n            try\n            {\n                await processingSemaphore.WaitAsync();\n                \n                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(options.TimeoutSeconds));\n                var result = await processor.ProcessDataAsync(inputData, options);\n                results.Add(result);\n            }\n            catch (Exception ex)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = $\"ORCHESTRATOR_ERROR: {ex.Message}\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { ex.Message }\n                });\n            }\n            finally\n            {\n                processingSemaphore.Release();\n            }\n        }\n        \n        return results;\n    }\n    \n    private DataProcessor FindProcessorForFormat(string formatType)\n    {\n        return processors.FirstOrDefault(p => p.CanProcess(formatType));\n    }\n    \n    public void Shutdown()\n    {\n        foreach (var processor in processors)\n        {\n            processor.Cleanup();\n        }\n    }\n}", "raw_response": "Your code is well-structured and demonstrates a good understanding of object-oriented design principles, concurrency, and error handling. Here are some suggestions for improvement:\n\n### General Improvements\n\n1. **Logging**: Instead of using `Console.WriteLine` for errors, consider using a logging framework like NLog or Serilog to handle logging more robustly.\n2. **Configuration Management**: Use configuration files (e.g., JSON) to manage configurations such as database paths and timeouts instead of hardcoding them in the code.\n3. **Dependency Injection**: Consider using dependency injection to manage dependencies, which can make your code more testable and maintainable.\n\n### Specific Improvements\n\n#### StreamProcessor Class\n- **Error Handling**: Improve error handling by catching specific exceptions where possible.\n- **Resource Management**: Ensure all resources are properly disposed of in the `Cleanup` method.\n\n```csharp\npublic class StreamProcessor : DataProcessor\n{\n    private readonly List<Stream> streams = new List<Stream>();\n\n    public override bool CanProcess(string formatType)\n    {\n        return formatType == \"stream\";\n    }\n\n    protected override void ProcessData(DataInput inputData, ProcessingOptions options)\n    {\n        // Implement stream processing logic here\n    }\n\n    public override void Cleanup()\n    {\n        foreach (var stream in streams)\n        {\n            try\n            {\n                stream.Close();\n                stream.Dispose();\n            }\n            catch (Exception ex)\n            {\n                // Log the exception using a logging framework\n                Console.WriteLine($\"Error disposing stream: {ex.Message}\");\n            }\n        }\n        streams.Clear();\n    }\n}\n```\n\n#### StreamOrchestrator Class\n- **Concurrency Control**: Ensure that the semaphore is properly released even if an exception occurs.\n- **Timeout Handling**: Handle timeouts more gracefully.\n\n```csharp\npublic class StreamOrchestrator\n{\n    private readonly List<StreamProcessor> processors = new List<StreamProcessor>();\n    private readonly SemaphoreSlim processingSemaphore = new SemaphoreSlim(4, 4);\n\n    public void AddProcessor(StreamProcessor processor)\n    {\n        processors.Add(processor);\n    }\n\n    public async Task<List<ProcessingResult>> ProcessAllStreamsAsync(List<DataInput> inputs, ProcessingOptions options)\n    {\n        var results = new List<ProcessingResult>();\n\n        foreach (var inputData in inputs)\n        {\n            var processor = FindProcessorForFormat(inputData.FormatType);\n            if (processor == null)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = $\"No processor found for format: {inputData.FormatType}\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { $\"Unsupported format: {inputData.FormatType}\" }\n                });\n                continue;\n            }\n\n            try\n            {\n                await processingSemaphore.WaitAsync();\n\n                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(options.TimeoutSeconds));\n                var result = await processor.ProcessDataAsync(inputData, options);\n                results.Add(result);\n            }\n            catch (OperationCanceledException)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = \"Processing timed out\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { \"Timeout occurred\" }\n                });\n            }\n            catch (Exception ex)\n            {\n                results.Add(new ProcessingResult\n                {\n                    RecordsProcessed = 0,\n                    OutputLocation = null,\n                    StatusMessage = $\"ORCHESTRATOR_ERROR: {ex.Message}\",\n                    ProcessingTimeMs = 0,\n                    Errors = new List<string> { ex.Message }\n                });\n            }\n            finally\n            {\n                processingSemaphore.Release();\n            }\n        }\n\n        return results;\n    }\n\n    private StreamProcessor FindProcessorForFormat(string formatType)\n    {\n        return processors.FirstOrDefault(p => p.CanProcess(formatType));\n    }\n\n    public void Shutdown()\n    {\n        foreach (var processor in processors)\n        {\n            processor.Cleanup();\n        }\n    }\n}\n```\n\n#### DataProcessor Class\n- **Abstract Method**: Make `ProcessData` an abstract method to enforce implementation in derived classes.\n\n```csharp\npublic abstract class DataProcessor : IDisposable\n{\n    private readonly List<string> supportedFormats = new List<string>();\n    protected bool isProcessing;\n\n    public void AddSupportedFormat(string format)\n    {\n        supportedFormats.Add(format);\n    }\n\n    public virtual bool CanProcess(string formatType)\n    {\n        return supportedFormats.Contains(formatType);\n    }\n\n    public async Task<ProcessingResult> ProcessDataAsync(DataInput inputData, ProcessingOptions options)\n    {\n        if (isProcessing)\n            throw new InvalidOperationException(\"Processor is already busy.\");\n\n        try\n        {\n            isProcessing = true;\n            var stopwatch = Stopwatch.StartNew();\n\n            await Task.Run(() => ProcessData(inputData, options));\n\n            stopwatch.Stop();\n            return new ProcessingResult\n            {\n                RecordsProcessed = 100, // Placeholder value\n                OutputLocation = \"output.txt\", // Placeholder value\n                StatusMessage = \"Processing completed successfully\",\n                ProcessingTimeMs = stopwatch.ElapsedMilliseconds,\n                Errors = new List<string>()\n            };\n        }\n        catch (Exception ex)\n        {\n            return new ProcessingResult\n            {\n                RecordsProcessed = 0,\n                OutputLocation = null,\n                StatusMessage = $\"Error processing data: {ex.Message}\",\n                ProcessingTimeMs = 0,\n                Errors = new List<string> { ex.Message }\n            };\n        }\n        finally\n        {\n            isProcessing = false;\n        }\n    }\n\n    protected abstract void ProcessData(DataInput inputData, ProcessingOptions options);\n\n    public virtual void Cleanup()\n    {\n        // Implement cleanup logic here if necessary\n    }\n\n    public void Dispose()\n    {\n        Cleanup();\n    }\n}\n```\n\n### Conclusion\n\nThese improvements should help make your code more robust, maintainable, and testable. Consider implementing these suggestions to enhance the quality of your application.", "violation": "Unknown", "violation_list": [], "explanation": "Your code is well-structured and demonstrates a good understanding of object-oriented design principles, concurrency, and error handling. Here are some suggestions for improvement:\n\n### General Improvements\n\n1. **Logging**: Instead of using `Console.WriteLine` for errors, consider using a logging framework like NLog or Serilog to handle logging more robustly.\n2. **Configuration Management**: Use configuration files (e.g., JSON) to manage configurations such as database paths and timeouts instead of hardcoding them in the code.\n3. **Dependency Injection**: Consider using dependency injection to manage dependencies, which can make your code more testable and maintainable.\n\n### Specific Improvements\n\n#### StreamProcessor Class\n- **Error Handling**: Improve error handling by catching specific exceptions where possible.\n- **Resource Management**: Ensure all resources are properly disposed of in the `Cleanup` method.", "solution_code": "NO FIX VERSION", "duration_seconds": 42.44546627998352}
{"id": 36, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public abstract class Document {\n    protected String content;\n    \n    public Document(String content) {\n        this.content = content;\n    }\n    \n    public abstract void save();\n    public abstract void print();\n}\n\npublic class PDFDocument extends Document {\n    public PDFDocument(String content) {\n        super(content);\n    }\n    \n    public void save() {\n        System.out.println(\"Saving PDF document\");\n    }\n    \n    public void print() {\n        System.out.println(\"Printing PDF document\");\n    }\n}\n\npublic class ReadOnlyDocument extends Document {\n    public ReadOnlyDocument(String content) {\n        super(content);\n    }\n    \n    public void save() {\n        throw new UnsupportedOperationException(\"Cannot save read-only document\");\n    }\n    \n    public void print() {\n        System.out.println(\"Printing read-only document\");\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic abstract class Document {\n    protected String content;\n    \n    public Document(String content) {\n        this.content = content;\n    }\n    \n    public abstract void save();\n    public abstract void print();\n}\n\npublic class PDFDocument extends Document {\n    public PDFDocument(String content) {\n        super(content);\n    }\n    \n    public void save() {\n        System.out.println(\"Saving PDF document\");\n    }\n    \n    public void print() {\n        System.out.println(\"Printing PDF document\");\n    }\n}\n\npublic class ReadOnlyDocument extends Document {\n    public ReadOnlyDocument(String content) {\n        super(content);\n    }\n    \n    public void save() {\n        throw new UnsupportedOperationException(\"Cannot save read-only document\");\n    }\n    \n    public void print() {\n        System.out.println(\"Printing read-only document\");\n    }\n}", "raw_response": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor {\n    private List<Order> orders;\n\n    public OrderProcessor(List<Order> orders) {\n        this.orders = orders;\n    }\n\n    public void processOrders() {\n        for (Order order : orders) {\n            validateOrder(order);\n            calculateTotal(order);\n            applyDiscounts(order);\n            saveOrder(order);\n            notifyCustomer(order);\n        }\n    }\n\n    private void validateOrder(Order order) {\n        // Validation logic\n    }\n\n    private void calculateTotal(Order order) {\n        // Calculation logic\n    }\n\n    private void applyDiscounts(Order order) {\n        // Discount logic\n    }\n\n    private void saveOrder(Order order) {\n        // Save to database logic\n    }\n\n    private void notifyCustomer(Order order) {\n        // Notification logic\n    }\n}\n\n**SRP**\n0\n**OCP**\n2\n**LSP**\n5\n**ISP**\n5\n**DIP**\n3", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**God Object**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor {\n    private List<Order> orders;\n\n    public OrderProcessor(List<Order> orders) {\n        this.orders = orders;\n    }\n\n    public void processOrders() {\n        for (Order order : orders) {\n            validateOrder(order);\n            calculateTotal(order);\n            applyDiscounts(order);\n            saveOrder(order);\n            notifyCustomer(order);\n        }\n    }\n\n    private void validateOrder(Order order) {\n        // Validation logic\n    }\n\n    private void calculateTotal(Order order) {\n        // Calculation logic\n    }\n\n    private void applyDiscounts(Order order) {\n        // Discount logic\n    }\n\n    private void saveOrder(Order order) {\n        // Save to database logic\n    }\n\n    private void notifyCustomer(Order order) {\n        // Notification logic\n    }\n}\n\n**SRP**\n0\n**OCP**\n2\n**LSP**\n5\n**ISP**\n5\n**DIP**\n3", "solution_code": "NO FIX VERSION", "duration_seconds": 7.203738451004028}
{"id": 37, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\n\nclass Document(ABC):\n    def __init__(self, content):\n        self.content = content\n    \n    @abstractmethod\n    def save(self):\n        pass\n    \n    @abstractmethod\n    def print_doc(self):\n        pass\n\nclass PDFDocument(Document):\n    def __init__(self, content):\n        super().__init__(content)\n    \n    def save(self):\n        print(\"Saving PDF document\")\n    \n    def print_doc(self):\n        print(\"Printing PDF document\")\n\nclass ReadOnlyDocument(Document):\n    def __init__(self, content):\n        super().__init__(content)\n    \n    def save(self):\n        raise NotImplementedError(\"Cannot save read-only document\")\n    \n    def print_doc(self):\n        print(\"Printing read-only document\")", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\n\nclass Document(ABC):\n    def __init__(self, content):\n        self.content = content\n    \n    @abstractmethod\n    def save(self):\n        pass\n    \n    @abstractmethod\n    def print_doc(self):\n        pass\n\nclass PDFDocument(Document):\n    def __init__(self, content):\n        super().__init__(content)\n    \n    def save(self):\n        print(\"Saving PDF document\")\n    \n    def print_doc(self):\n        print(\"Printing PDF document\")\n\nclass ReadOnlyDocument(Document):\n    def __init__(self, content):\n        super().__init__(content)\n    \n    def save(self):\n        raise NotImplementedError(\"Cannot save read-only document\")\n    \n    def print_doc(self):\n        print(\"Printing read-only document\")", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n```python\nclass FileManager:\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_file(self):\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def delete_file(self):\n        import os\n        os.remove(self.file_path)\n\n    def compress_file(self):\n        import zipfile\n        with zipfile.ZipFile(f\"{self.file_path}.zip\", 'w') as zipf:\n            zipf.write(self.file_path, arcname=self.file_path.split('/')[-1])\n\n    def decompress_file(self):\n        import zipfile\n        with zipfile.ZipFile(f\"{self.file_path}.zip\", 'r') as zipf:\n            zipf.extractall(path='.')\n\n    def encrypt_file(self):\n        from cryptography.fernet import Fernet\n        key = Fernet.generate_key()\n        cipher_suite = Fernet(key)\n        with open(self.file_path, 'rb') as file:\n            file_data = file.read()\n        encrypted_data = cipher_suite.encrypt(file_data)\n        with open(f\"{self.file_path}.enc\", 'wb') as file:\n            file.write(encrypted_data)\n\n    def decrypt_file(self):\n        from cryptography.fernet import Fernet\n        key = Fernet.generate_key()  # In practice, you should use the same key used for encryption\n        cipher_suite = Fernet(key)\n        with open(f\"{self.file_path}.enc\", 'rb') as file:\n            encrypted_data = file.read()\n        decrypted_data = cipher_suite.decrypt(encrypted_data)\n        with open(self.file_path, 'wb') as file:\n            file.write(decrypted_data)\n\n    def backup_file(self):\n        import shutil\n        shutil.copy2(self.file_path, f\"{self.file_path}.bak\")\n\n    def restore_file(self):\n        import shutil\n        shutil.move(f\"{self.file_path}.bak\", self.file_path)\n```\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\n0\n0\n0\n0\n0", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.", "solution_code": "NO FIX VERSION", "duration_seconds": 15.70424747467041}
{"id": 38, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "abstract class Document(protected val content: String) {\n    abstract fun save()\n    abstract fun print()\n}\n\nclass PDFDocument(content: String) : Document(content) {\n    override fun save() {\n        println(\"Saving PDF document\")\n    }\n    \n    override fun print() {\n        println(\"Printing PDF document\")\n    }\n}\n\nclass ReadOnlyDocument(content: String) : Document(content) {\n    override fun save() {\n        throw UnsupportedOperationException(\"Cannot save read-only document\")\n    }\n    \n    override fun print() {\n        println(\"Printing read-only document\")\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nabstract class Document(protected val content: String) {\n    abstract fun save()\n    abstract fun print()\n}\n\nclass PDFDocument(content: String) : Document(content) {\n    override fun save() {\n        println(\"Saving PDF document\")\n    }\n    \n    override fun print() {\n        println(\"Printing PDF document\")\n    }\n}\n\nclass ReadOnlyDocument(content: String) : Document(content) {\n    override fun save() {\n        throw UnsupportedOperationException(\"Cannot save read-only document\")\n    }\n    \n    override fun print() {\n        println(\"Printing read-only document\")\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including handling both saving and printing documents.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including handling both saving and printing documents.", "solution_code": "NO FIX VERSION", "duration_seconds": 1.169726848602295}
{"id": 39, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "public abstract class Document\n{\n    protected string content;\n    \n    public Document(string content)\n    {\n        this.content = content;\n    }\n    \n    public abstract void Save();\n    public abstract void Print();\n}\n\npublic class PDFDocument : Document\n{\n    public PDFDocument(string content) : base(content) { }\n    \n    public override void Save()\n    {\n        Console.WriteLine(\"Saving PDF document\");\n    }\n    \n    public override void Print()\n    {\n        Console.WriteLine(\"Printing PDF document\");\n    }\n}\n\npublic class ReadOnlyDocument : Document\n{\n    public ReadOnlyDocument(string content) : base(content) { }\n    \n    public override void Save()\n    {\n        throw new NotSupportedException(\"Cannot save read-only document\");\n    }\n    \n    public override void Print()\n    {\n        Console.WriteLine(\"Printing read-only document\");\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic abstract class Document\n{\n    protected string content;\n    \n    public Document(string content)\n    {\n        this.content = content;\n    }\n    \n    public abstract void Save();\n    public abstract void Print();\n}\n\npublic class PDFDocument : Document\n{\n    public PDFDocument(string content) : base(content) { }\n    \n    public override void Save()\n    {\n        Console.WriteLine(\"Saving PDF document\");\n    }\n    \n    public override void Print()\n    {\n        Console.WriteLine(\"Printing PDF document\");\n    }\n}\n\npublic class ReadOnlyDocument : Document\n{\n    public ReadOnlyDocument(string content) : base(content) { }\n    \n    public override void Save()\n    {\n        throw new NotSupportedException(\"Cannot save read-only document\");\n    }\n    \n    public override void Print()\n    {\n        Console.WriteLine(\"Printing read-only document\");\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor\n{\n    private List<Order> orders;\n\n    public OrderProcessor(List<Order> orders)\n    {\n        this.orders = orders;\n    }\n\n    public void ProcessOrders()\n    {\n        foreach (var order in orders)\n        {\n            ValidateOrder(order);\n            CalculateTax(order);\n            ApplyDiscounts(order);\n            SaveOrder(order);\n            NotifyCustomer(order);\n        }\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic\n    }\n\n    private void CalculateTax(Order order)\n    {\n        // Tax calculation logic\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount application logic\n    }\n\n    private void SaveOrder(Order order)\n    {\n        // Database save logic\n    }\n\n    private void NotifyCustomer(Order order)\n    {\n        // Notification logic\n    }\n}\n\n**SRP**\n0\nOCP\n2\nLSP\n3\nISP\n4\nDIP\n3", "violation": "SRP, OCP, LSP, ISP, DIP", "violation_list": ["SRP", "OCP", "LSP", "ISP", "DIP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic class OrderProcessor\n{\n    private List<Order> orders;\n\n    public OrderProcessor(List<Order> orders)\n    {\n        this.orders = orders;\n    }\n\n    public void ProcessOrders()\n    {\n        foreach (var order in orders)\n        {\n            ValidateOrder(order);\n            CalculateTax(order);\n            ApplyDiscounts(order);\n            SaveOrder(order);\n            NotifyCustomer(order);\n        }\n    }\n\n    private void ValidateOrder(Order order)\n    {\n        // Validation logic\n    }\n\n    private void CalculateTax(Order order)\n    {\n        // Tax calculation logic\n    }\n\n    private void ApplyDiscounts(Order order)\n    {\n        // Discount application logic\n    }\n\n    private void SaveOrder(Order order)\n    {\n        // Database save logic\n    }\n\n    private void NotifyCustomer(Order order)\n    {\n        // Notification logic\n    }\n}\n\n**SRP**\n0\nOCP\n2\nLSP\n3\nISP\n4\nDIP\n3", "solution_code": "NO FIX VERSION", "duration_seconds": 7.362306594848633}
{"id": 40, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "public abstract class Document {\n    protected String content;\n    protected String format;\n    protected boolean encrypted;\n    \n    public Document(String content, String format) {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n    }\n    \n    public abstract void save();\n    public abstract void print();\n    public abstract void export(String targetFormat);\n    public abstract void compress();\n    \n    public String getContent() { return content; }\n    public String getFormat() { return format; }\n    public boolean isEncrypted() { return encrypted; }\n}\n\npublic class WordDocument extends Document {\n    private String author;\n    private int wordCount;\n    \n    public WordDocument(String content, String author) {\n        super(content, \"DOCX\");\n        this.author = author;\n        this.wordCount = content.split(\" \").length;\n    }\n    \n    public void save() {\n        System.out.println(\"Saving Word document with \" + wordCount + \" words\");\n    }\n    \n    public void print() {\n        System.out.println(\"Printing Word document by \" + author);\n    }\n    \n    public void export(String targetFormat) {\n        System.out.println(\"Exporting Word document to \" + targetFormat);\n    }\n    \n    public void compress() {\n        System.out.println(\"Compressing Word document\");\n        this.content = this.content.replaceAll(\"\\\\s+\", \" \");\n    }\n}\n\npublic class SecureDocument extends Document {\n    private String password;\n    private boolean isLocked;\n    \n    public SecureDocument(String content, String password) {\n        super(content, \"SECURE\");\n        this.password = password;\n        this.encrypted = true;\n        this.isLocked = true;\n    }\n    \n    public void save() {\n        if (isLocked) {\n            throw new SecurityException(\"Document is locked and cannot be saved\");\n        }\n        System.out.println(\"Saving secure document\");\n    }\n    \n    public void print() {\n        if (isLocked) {\n            throw new SecurityException(\"Document is locked and cannot be printed\");\n        }\n        System.out.println(\"Printing secure document\");\n    }\n    \n    public void export(String targetFormat) {\n        throw new UnsupportedOperationException(\"Secure documents cannot be exported for security reasons\");\n    }\n    \n    public void compress() {\n        System.out.println(\"Secure documents use built-in compression\");\n    }\n    \n    public void unlock(String inputPassword) {\n        if (password.equals(inputPassword)) {\n            isLocked = false;\n            System.out.println(\"Document unlocked\");\n        } else {\n            throw new SecurityException(\"Invalid password\");\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\npublic abstract class Document {\n    protected String content;\n    protected String format;\n    protected boolean encrypted;\n    \n    public Document(String content, String format) {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n    }\n    \n    public abstract void save();\n    public abstract void print();\n    public abstract void export(String targetFormat);\n    public abstract void compress();\n    \n    public String getContent() { return content; }\n    public String getFormat() { return format; }\n    public boolean isEncrypted() { return encrypted; }\n}\n\npublic class WordDocument extends Document {\n    private String author;\n    private int wordCount;\n    \n    public WordDocument(String content, String author) {\n        super(content, \"DOCX\");\n        this.author = author;\n        this.wordCount = content.split(\" \").length;\n    }\n    \n    public void save() {\n        System.out.println(\"Saving Word document with \" + wordCount + \" words\");\n    }\n    \n    public void print() {\n        System.out.println(\"Printing Word document by \" + author);\n    }\n    \n    public void export(String targetFormat) {\n        System.out.println(\"Exporting Word document to \" + targetFormat);\n    }\n    \n    public void compress() {\n        System.out.println(\"Compressing Word document\");\n        this.content = this.content.replaceAll(\"\\\\s+\", \" \");\n    }\n}\n\npublic class SecureDocument extends Document {\n    private String password;\n    private boolean isLocked;\n    \n    public SecureDocument(String content, String password) {\n        super(content, \"SECURE\");\n        this.password = password;\n        this.encrypted = true;\n        this.isLocked = true;\n    }\n    \n    public void save() {\n        if (isLocked) {\n            throw new SecurityException(\"Document is locked and cannot be saved\");\n        }\n        System.out.println(\"Saving secure document\");\n    }\n    \n    public void print() {\n        if (isLocked) {\n            throw new SecurityException(\"Document is locked and cannot be printed\");\n        }\n        System.out.println(\"Printing secure document\");\n    }\n    \n    public void export(String targetFormat) {\n        throw new UnsupportedOperationException(\"Secure documents cannot be exported for security reasons\");\n    }\n    \n    public void compress() {\n        System.out.println(\"Secure documents use built-in compression\");\n    }\n    \n    public void unlock(String inputPassword) {\n        if (password.equals(inputPassword)) {\n            isLocked = false;\n            System.out.println(\"Document unlocked\");\n        } else {\n            throw new SecurityException(\"Invalid password\");\n        }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, and compressing documents.\n\n0\n0\n0\n0\n0\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, and compressing documents.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, and compressing documents.\n\n0\n0\n0\n0\n0\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, and compressing documents.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.905646324157715}
{"id": 41, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\nimport re\n\nclass Document(ABC):\n    def __init__(self, content, format_type):\n        self.content = content\n        self.format = format_type\n        self.encrypted = False\n    \n    @abstractmethod\n    def save(self):\n        pass\n    \n    @abstractmethod\n    def print_doc(self):\n        pass\n    \n    @abstractmethod\n    def export(self, target_format):\n        pass\n    \n    @abstractmethod\n    def compress(self):\n        pass\n    \n    def get_content(self):\n        return self.content\n    \n    def get_format(self):\n        return self.format\n    \n    def is_encrypted(self):\n        return self.encrypted\n\nclass WordDocument(Document):\n    def __init__(self, content, author):\n        super().__init__(content, \"DOCX\")\n        self.author = author\n        self.word_count = len(content.split())\n    \n    def save(self):\n        print(f\"Saving Word document with {self.word_count} words\")\n    \n    def print_doc(self):\n        print(f\"Printing Word document by {self.author}\")\n    \n    def export(self, target_format):\n        print(f\"Exporting Word document to {target_format}\")\n    \n    def compress(self):\n        print(\"Compressing Word document\")\n        self.content = re.sub(r'\\s+', ' ', self.content)\n\nclass SecureDocument(Document):\n    def __init__(self, content, password):\n        super().__init__(content, \"SECURE\")\n        self.password = password\n        self.encrypted = True\n        self.is_locked = True\n    \n    def save(self):\n        if self.is_locked:\n            raise PermissionError(\"Document is locked and cannot be saved\")\n        print(\"Saving secure document\")\n    \n    def print_doc(self):\n        if self.is_locked:\n            raise PermissionError(\"Document is locked and cannot be printed\")\n        print(\"Printing secure document\")\n    \n    def export(self, target_format):\n        raise NotImplementedError(\"Secure documents cannot be exported for security reasons\")\n    \n    def compress(self):\n        print(\"Secure documents use built-in compression\")\n    \n    def unlock(self, input_password):\n        if self.password == input_password:\n            self.is_locked = False\n            print(\"Document unlocked\")\n        else:\n            raise PermissionError(\"Invalid password\")", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\nimport re\n\nclass Document(ABC):\n    def __init__(self, content, format_type):\n        self.content = content\n        self.format = format_type\n        self.encrypted = False\n    \n    @abstractmethod\n    def save(self):\n        pass\n    \n    @abstractmethod\n    def print_doc(self):\n        pass\n    \n    @abstractmethod\n    def export(self, target_format):\n        pass\n    \n    @abstractmethod\n    def compress(self):\n        pass\n    \n    def get_content(self):\n        return self.content\n    \n    def get_format(self):\n        return self.format\n    \n    def is_encrypted(self):\n        return self.encrypted\n\nclass WordDocument(Document):\n    def __init__(self, content, author):\n        super().__init__(content, \"DOCX\")\n        self.author = author\n        self.word_count = len(content.split())\n    \n    def save(self):\n        print(f\"Saving Word document with {self.word_count} words\")\n    \n    def print_doc(self):\n        print(f\"Printing Word document by {self.author}\")\n    \n    def export(self, target_format):\n        print(f\"Exporting Word document to {target_format}\")\n    \n    def compress(self):\n        print(\"Compressing Word document\")\n        self.content = re.sub(r'\\s+', ' ', self.content)\n\nclass SecureDocument(Document):\n    def __init__(self, content, password):\n        super().__init__(content, \"SECURE\")\n        self.password = password\n        self.encrypted = True\n        self.is_locked = True\n    \n    def save(self):\n        if self.is_locked:\n            raise PermissionError(\"Document is locked and cannot be saved\")\n        print(\"Saving secure document\")\n    \n    def print_doc(self):\n        if self.is_locked:\n            raise PermissionError(\"Document is locked and cannot be printed\")\n        print(\"Printing secure document\")\n    \n    def export(self, target_format):\n        raise NotImplementedError(\"Secure documents cannot be exported for security reasons\")\n    \n    def compress(self):\n        print(\"Secure documents use built-in compression\")\n    \n    def unlock(self, input_password):\n        if self.password == input_password:\n            self.is_locked = False\n            print(\"Document unlocked\")\n        else:\n            raise PermissionError(\"Invalid password\")", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities such as saving, printing, exporting, and compressing documents. Each of these should be handled by separate classes or modules.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities such as saving, printing, exporting, and compressing documents. Each of these should be handled by separate classes or modules.", "solution_code": "NO FIX VERSION", "duration_seconds": 1.9522571563720703}
{"id": 42, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "abstract class Document(protected val content: String, protected val format: String) {\n    protected var encrypted: Boolean = false\n    \n    abstract fun save()\n    abstract fun print()\n    abstract fun export(targetFormat: String)\n    abstract fun compress()\n    \n    fun getContent(): String = content\n    fun getFormat(): String = format\n    fun isEncrypted(): Boolean = encrypted\n}\n\nclass WordDocument(content: String, private val author: String) : Document(content, \"DOCX\") {\n    private val wordCount = content.split(\" \").size\n    \n    override fun save() {\n        println(\"Saving Word document with $wordCount words\")\n    }\n    \n    override fun print() {\n        println(\"Printing Word document by $author\")\n    }\n    \n    override fun export(targetFormat: String) {\n        println(\"Exporting Word document to $targetFormat\")\n    }\n    \n    override fun compress() {\n        println(\"Compressing Word document\")\n    }\n}\n\nclass SecureDocument(content: String, private val password: String) : Document(content, \"SECURE\") {\n    private var isLocked: Boolean = true\n    \n    init {\n        encrypted = true\n    }\n    \n    override fun save() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be saved\")\n        }\n        println(\"Saving secure document\")\n    }\n    \n    override fun print() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be printed\")\n        }\n        println(\"Printing secure document\")\n    }\n    \n    override fun export(targetFormat: String) {\n        throw UnsupportedOperationException(\"Secure documents cannot be exported for security reasons\")\n    }\n    \n    override fun compress() {\n        println(\"Secure documents use built-in compression\")\n    }\n    \n    fun unlock(inputPassword: String) {\n        if (password == inputPassword) {\n            isLocked = false\n            println(\"Document unlocked\")\n        } else {\n            throw SecurityException(\"Invalid password\")\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nabstract class Document(protected val content: String, protected val format: String) {\n    protected var encrypted: Boolean = false\n    \n    abstract fun save()\n    abstract fun print()\n    abstract fun export(targetFormat: String)\n    abstract fun compress()\n    \n    fun getContent(): String = content\n    fun getFormat(): String = format\n    fun isEncrypted(): Boolean = encrypted\n}\n\nclass WordDocument(content: String, private val author: String) : Document(content, \"DOCX\") {\n    private val wordCount = content.split(\" \").size\n    \n    override fun save() {\n        println(\"Saving Word document with $wordCount words\")\n    }\n    \n    override fun print() {\n        println(\"Printing Word document by $author\")\n    }\n    \n    override fun export(targetFormat: String) {\n        println(\"Exporting Word document to $targetFormat\")\n    }\n    \n    override fun compress() {\n        println(\"Compressing Word document\")\n    }\n}\n\nclass SecureDocument(content: String, private val password: String) : Document(content, \"SECURE\") {\n    private var isLocked: Boolean = true\n    \n    init {\n        encrypted = true\n    }\n    \n    override fun save() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be saved\")\n        }\n        println(\"Saving secure document\")\n    }\n    \n    override fun print() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be printed\")\n        }\n        println(\"Printing secure document\")\n    }\n    \n    override fun export(targetFormat: String) {\n        throw UnsupportedOperationException(\"Secure documents cannot be exported for security reasons\")\n    }\n    \n    override fun compress() {\n        println(\"Secure documents use built-in compression\")\n    }\n    \n    fun unlock(inputPassword: String) {\n        if (password == inputPassword) {\n            isLocked = false\n            println(\"Document unlocked\")\n        } else {\n            throw SecurityException(\"Invalid password\")\n        }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, and compressing documents. Each of these operations could be handled by separate classes or modules.\n\nabstract class Document(protected val content: String, protected val format: String) {\n    protected var encrypted: Boolean = false\n    \n    abstract fun save()\n    abstract fun print()\n    abstract fun export(targetFormat: String)\n    abstract fun compress()\n    \n    fun getContent(): String = content\n    fun getFormat(): String = format\n    fun isEncrypted(): Boolean = encrypted\n}\n\nclass WordDocument(content: String, private val author: String) : Document(content, \"DOCX\") {\n    private val wordCount = content.split(\" \").size\n    \n    override fun save() {\n        println(\"Saving Word document with $wordCount words\")\n    }\n    \n    override fun print() {\n        println(\"Printing Word document by $author\")\n    }\n    \n    override fun export(targetFormat: String) {\n        println(\"Exporting Word document to $targetFormat\")\n    }\n    \n    override fun compress() {\n        println(\"Compressing Word document\")\n    }\n}\n\nclass SecureDocument(content: String, private val password: String) : Document(content, \"SECURE\") {\n    private var isLocked: Boolean = true\n    \n    init {\n        encrypted = true\n    }\n    \n    override fun save() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be saved\")\n        }\n        println(\"Saving secure document\")\n    }\n    \n    override fun print() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be printed\")\n        }\n        println(\"Printing secure document\")\n    }\n    \n    override fun export(targetFormat: String) {\n        throw UnsupportedOperationException(\"Secure documents cannot be exported for security reasons\")\n    }\n    \n    override fun compress() {\n        println(\"Secure documents use built-in compression\")\n    }\n    \n    fun unlock(inputPassword: String) {\n        if (password == inputPassword) {\n            isLocked = false\n            println(\"Document unlocked\")\n        } else {\n            throw SecurityException(\"Invalid password\")\n        }\n    }\n}\n\n0 1 3 4 2", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, and compressing documents. Each of these operations could be handled by separate classes or modules.\n\nabstract class Document(protected val content: String, protected val format: String) {\n    protected var encrypted: Boolean = false\n    \n    abstract fun save()\n    abstract fun print()\n    abstract fun export(targetFormat: String)\n    abstract fun compress()\n    \n    fun getContent(): String = content\n    fun getFormat(): String = format\n    fun isEncrypted(): Boolean = encrypted\n}\n\nclass WordDocument(content: String, private val author: String) : Document(content, \"DOCX\") {\n    private val wordCount = content.split(\" \").size\n    \n    override fun save() {\n        println(\"Saving Word document with $wordCount words\")\n    }\n    \n    override fun print() {\n        println(\"Printing Word document by $author\")\n    }\n    \n    override fun export(targetFormat: String) {\n        println(\"Exporting Word document to $targetFormat\")\n    }\n    \n    override fun compress() {\n        println(\"Compressing Word document\")\n    }\n}\n\nclass SecureDocument(content: String, private val password: String) : Document(content, \"SECURE\") {\n    private var isLocked: Boolean = true\n    \n    init {\n        encrypted = true\n    }\n    \n    override fun save() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be saved\")\n        }\n        println(\"Saving secure document\")\n    }\n    \n    override fun print() {\n        if (isLocked) {\n            throw SecurityException(\"Document is locked and cannot be printed\")\n        }\n        println(\"Printing secure document\")\n    }\n    \n    override fun export(targetFormat: String) {\n        throw UnsupportedOperationException(\"Secure documents cannot be exported for security reasons\")\n    }\n    \n    override fun compress() {\n        println(\"Secure documents use built-in compression\")\n    }\n    \n    fun unlock(inputPassword: String) {\n        if (password == inputPassword) {\n            isLocked = false\n            println(\"Document unlocked\")\n        } else {\n            throw SecurityException(\"Invalid password\")\n        }\n    }\n}\n\n0 1 3 4 2", "solution_code": "NO FIX VERSION", "duration_seconds": 15.794058322906494}
{"id": 43, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Text.RegularExpressions;\n\npublic abstract class Document\n{\n    protected string content;\n    protected string format;\n    protected bool encrypted;\n    \n    public Document(string content, string format)\n    {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n    }\n    \n    public abstract void Save();\n    public abstract void Print();\n    public abstract void Export(string targetFormat);\n    public abstract void Compress();\n    \n    public string GetContent() => content;\n    public string GetFormat() => format;\n    public bool IsEncrypted() => encrypted;\n}\n\npublic class WordDocument : Document\n{\n    private string author;\n    private int wordCount;\n    \n    public WordDocument(string content, string author) : base(content, \"DOCX\")\n    {\n        this.author = author;\n        this.wordCount = content.Split(' ').Length;\n    }\n    \n    public override void Save()\n    {\n        Console.WriteLine($\"Saving Word document with {wordCount} words\");\n    }\n    \n    public override void Print()\n    {\n        Console.WriteLine($\"Printing Word document by {author}\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        Console.WriteLine($\"Exporting Word document to {targetFormat}\");\n    }\n    \n    public override void Compress()\n    {\n        Console.WriteLine(\"Compressing Word document\");\n        this.content = Regex.Replace(this.content, @\"\\s+\", \" \");\n    }\n}\n\npublic class SecureDocument : Document\n{\n    private string password;\n    private bool isLocked;\n    \n    public SecureDocument(string content, string password) : base(content, \"SECURE\")\n    {\n        this.password = password;\n        this.encrypted = true;\n        this.isLocked = true;\n    }\n    \n    public override void Save()\n    {\n        if (isLocked)\n        {\n            throw new UnauthorizedAccessException(\"Document is locked and cannot be saved\");\n        }\n        Console.WriteLine(\"Saving secure document\");\n    }\n    \n    public override void Print()\n    {\n        if (isLocked)\n        {\n            throw new UnauthorizedAccessException(\"Document is locked and cannot be printed\");\n        }\n        Console.WriteLine(\"Printing secure document\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        throw new NotSupportedException(\"Secure documents cannot be exported for security reasons\");\n    }\n    \n    public override void Compress()\n    {\n        Console.WriteLine(\"Secure documents use built-in compression\");\n    }\n    \n    public void Unlock(string inputPassword)\n    {\n        if (password.Equals(inputPassword))\n        {\n            isLocked = false;\n            Console.WriteLine(\"Document unlocked\");\n        }\n        else\n        {\n            throw new UnauthorizedAccessException(\"Invalid password\");\n        }\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Text.RegularExpressions;\n\npublic abstract class Document\n{\n    protected string content;\n    protected string format;\n    protected bool encrypted;\n    \n    public Document(string content, string format)\n    {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n    }\n    \n    public abstract void Save();\n    public abstract void Print();\n    public abstract void Export(string targetFormat);\n    public abstract void Compress();\n    \n    public string GetContent() => content;\n    public string GetFormat() => format;\n    public bool IsEncrypted() => encrypted;\n}\n\npublic class WordDocument : Document\n{\n    private string author;\n    private int wordCount;\n    \n    public WordDocument(string content, string author) : base(content, \"DOCX\")\n    {\n        this.author = author;\n        this.wordCount = content.Split(' ').Length;\n    }\n    \n    public override void Save()\n    {\n        Console.WriteLine($\"Saving Word document with {wordCount} words\");\n    }\n    \n    public override void Print()\n    {\n        Console.WriteLine($\"Printing Word document by {author}\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        Console.WriteLine($\"Exporting Word document to {targetFormat}\");\n    }\n    \n    public override void Compress()\n    {\n        Console.WriteLine(\"Compressing Word document\");\n        this.content = Regex.Replace(this.content, @\"\\s+\", \" \");\n    }\n}\n\npublic class SecureDocument : Document\n{\n    private string password;\n    private bool isLocked;\n    \n    public SecureDocument(string content, string password) : base(content, \"SECURE\")\n    {\n        this.password = password;\n        this.encrypted = true;\n        this.isLocked = true;\n    }\n    \n    public override void Save()\n    {\n        if (isLocked)\n        {\n            throw new UnauthorizedAccessException(\"Document is locked and cannot be saved\");\n        }\n        Console.WriteLine(\"Saving secure document\");\n    }\n    \n    public override void Print()\n    {\n        if (isLocked)\n        {\n            throw new UnauthorizedAccessException(\"Document is locked and cannot be printed\");\n        }\n        Console.WriteLine(\"Printing secure document\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        throw new NotSupportedException(\"Secure documents cannot be exported for security reasons\");\n    }\n    \n    public override void Compress()\n    {\n        Console.WriteLine(\"Secure documents use built-in compression\");\n    }\n    \n    public void Unlock(string inputPassword)\n    {\n        if (password.Equals(inputPassword))\n        {\n            isLocked = false;\n            Console.WriteLine(\"Document unlocked\");\n        }\n        else\n        {\n            throw new UnauthorizedAccessException(\"Invalid password\");\n        }\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities such as saving, printing, exporting, and compressing documents. Each of these operations could be handled by different classes or services.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities such as saving, printing, exporting, and compressing documents. Each of these operations could be handled by different classes or services.", "solution_code": "NO FIX VERSION", "duration_seconds": 2.062844753265381}
{"id": 44, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "JAVA", "input": "import java.util.*;\nimport java.time.LocalDateTime;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.io.*;\n\npublic abstract class Document {\n    protected String content;\n    protected String format;\n    protected boolean encrypted;\n    protected LocalDateTime createdAt;\n    protected LocalDateTime lastModified;\n    protected Map<String, String> metadata;\n    protected List<String> revisionHistory;\n    protected DocumentPermissions permissions;\n    \n    public Document(String content, String format, DocumentPermissions permissions) {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n        this.createdAt = LocalDateTime.now();\n        this.lastModified = LocalDateTime.now();\n        this.metadata = new HashMap<>();\n        this.revisionHistory = new ArrayList<>();\n        this.permissions = permissions;\n        this.revisionHistory.add(\"Document created at \" + createdAt);\n    }\n    \n    public abstract void save() throws DocumentException;\n    public abstract void print() throws DocumentException;\n    public abstract void export(String targetFormat) throws DocumentException;\n    public abstract void compress() throws DocumentException;\n    public abstract void backup(String location) throws DocumentException;\n    public abstract DocumentStatistics getStatistics();\n    public abstract void addWatermark(String watermarkText) throws DocumentException;\n    public abstract void digitallySSign(String certificate) throws DocumentException;\n    \n    protected void updateLastModified() {\n        this.lastModified = LocalDateTime.now();\n        this.revisionHistory.add(\"Document modified at \" + lastModified);\n    }\n    \n    public String getContent() { return content; }\n    public String getFormat() { return format; }\n    public boolean isEncrypted() { return encrypted; }\n    public DocumentPermissions getPermissions() { return permissions; }\n}\n\nclass DocumentPermissions {\n    private boolean canRead, canWrite, canPrint, canExport, canBackup;\n    \n    public DocumentPermissions(boolean canRead, boolean canWrite, boolean canPrint, boolean canExport, boolean canBackup) {\n        this.canRead = canRead; this.canWrite = canWrite; this.canPrint = canPrint;\n        this.canExport = canExport; this.canBackup = canBackup;\n    }\n    \n    public boolean canRead() { return canRead; }\n    public boolean canWrite() { return canWrite; }\n    public boolean canPrint() { return canPrint; }\n    public boolean canExport() { return canExport; }\n    public boolean canBackup() { return canBackup; }\n}\n\nclass DocumentStatistics {\n    private int wordCount, characterCount, pageCount;\n    private double fileSizeKB;\n    \n    public DocumentStatistics(int wordCount, int characterCount, int pageCount, double fileSizeKB) {\n        this.wordCount = wordCount; this.characterCount = characterCount;\n        this.pageCount = pageCount; this.fileSizeKB = fileSizeKB;\n    }\n    \n    public int getWordCount() { return wordCount; }\n    public int getCharacterCount() { return characterCount; }\n    public int getPageCount() { return pageCount; }\n    public double getFileSizeKB() { return fileSizeKB; }\n}\n\nclass DocumentException extends Exception {\n    public DocumentException(String message) { super(message); }\n}\n\npublic class EnterpriseWordDocument extends Document {\n    private String author;\n    private String department;\n    private List<String> collaborators;\n    private ReentrantLock documentLock;\n    private boolean isBeingEdited;\n    \n    public EnterpriseWordDocument(String content, String author, String department) {\n        super(content, \"DOCX\", new DocumentPermissions(true, true, true, true, true));\n        this.author = author;\n        this.department = department;\n        this.collaborators = new ArrayList<>();\n        this.documentLock = new ReentrantLock();\n        this.isBeingEdited = false;\n        this.metadata.put(\"author\", author);\n        this.metadata.put(\"department\", department);\n    }\n    \n    public void save() throws DocumentException {\n        documentLock.lock();\n        try {\n            if (!permissions.canWrite()) {\n                throw new DocumentException(\"No write permission for this document\");\n            }\n            System.out.println(\"Saving enterprise Word document by \" + author + \" in \" + department);\n            updateLastModified();\n            isBeingEdited = false;\n        } finally {\n            documentLock.unlock();\n        }\n    }\n    \n    public void print() throws DocumentException {\n        if (!permissions.canPrint()) {\n            throw new DocumentException(\"No print permission for this document\");\n        }\n        System.out.println(\"Printing enterprise Word document with watermark\");\n    }\n    \n    public void export(String targetFormat) throws DocumentException {\n        if (!permissions.canExport()) {\n            throw new DocumentException(\"No export permission for this document\");\n        }\n        System.out.println(\"Exporting enterprise Word document to \" + targetFormat + \" with audit trail\");\n    }\n    \n    public void compress() throws DocumentException {\n        System.out.println(\"Compressing enterprise Word document using advanced algorithms\");\n        this.content = this.content.replaceAll(\"\\\\s+\", \" \").trim();\n        updateLastModified();\n    }\n    \n    public void backup(String location) throws DocumentException {\n        if (!permissions.canBackup()) {\n            throw new DocumentException(\"No backup permission for this document\");\n        }\n        System.out.println(\"Creating encrypted backup of enterprise document at \" + location);\n    }\n    \n    public DocumentStatistics getStatistics() {\n        int wordCount = content.split(\"\\\\s+\").length;\n        int charCount = content.length();\n        int pageCount = Math.max(1, wordCount / 250);\n        double fileSize = content.length() * 0.001;\n        return new DocumentStatistics(wordCount, charCount, pageCount, fileSize);\n    }\n    \n    public void addWatermark(String watermarkText) throws DocumentException {\n        System.out.println(\"Adding enterprise watermark: \" + watermarkText);\n        updateLastModified();\n    }\n    \n    public void digitallySSign(String certificate) throws DocumentException {\n        System.out.println(\"Digitally signing document with certificate: \" + certificate);\n        this.encrypted = true;\n        updateLastModified();\n    }\n}\n\npublic class LegacyDocument extends Document {\n    private String originalSystem;\n    private boolean conversionRequired;\n    private List<String> conversionErrors;\n    \n    public LegacyDocument(String content, String originalSystem) {\n        super(content, \"LEGACY\", new DocumentPermissions(true, false, false, false, false));\n        this.originalSystem = originalSystem;\n        this.conversionRequired = true;\n        this.conversionErrors = new ArrayList<>();\n        this.metadata.put(\"originalSystem\", originalSystem);\n        this.metadata.put(\"migrationStatus\", \"pending\");\n    }\n    \n    public void save() throws DocumentException {\n        throw new DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\");\n    }\n    \n    public void print() throws DocumentException {\n        throw new DocumentException(\"Legacy documents cannot be printed without conversion\");\n    }\n    \n    public void export(String targetFormat) throws DocumentException {\n        throw new DocumentException(\"Legacy documents cannot be exported without manual conversion\");\n    }\n    \n    public void compress() throws DocumentException {\n        throw new DocumentException(\"Legacy documents use proprietary compression that cannot be modified\");\n    }\n    \n    public void backup(String location) throws DocumentException {\n        throw new DocumentException(\"Legacy documents require specialized backup procedures\");\n    }\n    \n    public DocumentStatistics getStatistics() {\n        return new DocumentStatistics(0, content.length(), 1, content.length() * 0.002);\n    }\n    \n    public void addWatermark(String watermarkText) throws DocumentException {\n        throw new DocumentException(\"Cannot add watermark to legacy document format\");\n    }\n    \n    public void digitallySSign(String certificate) throws DocumentException {\n        throw new DocumentException(\"Digital signatures not supported for legacy document format\");\n    }\n    \n    public void attemptConversion() {\n        System.out.println(\"Attempting to convert legacy document from \" + originalSystem);\n        conversionErrors.add(\"Formatting may be lost during conversion\");\n        conversionErrors.add(\"Some features not supported in modern format\");\n    }\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following JAVA code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport java.util.*;\nimport java.time.LocalDateTime;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.io.*;\n\npublic abstract class Document {\n    protected String content;\n    protected String format;\n    protected boolean encrypted;\n    protected LocalDateTime createdAt;\n    protected LocalDateTime lastModified;\n    protected Map<String, String> metadata;\n    protected List<String> revisionHistory;\n    protected DocumentPermissions permissions;\n    \n    public Document(String content, String format, DocumentPermissions permissions) {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n        this.createdAt = LocalDateTime.now();\n        this.lastModified = LocalDateTime.now();\n        this.metadata = new HashMap<>();\n        this.revisionHistory = new ArrayList<>();\n        this.permissions = permissions;\n        this.revisionHistory.add(\"Document created at \" + createdAt);\n    }\n    \n    public abstract void save() throws DocumentException;\n    public abstract void print() throws DocumentException;\n    public abstract void export(String targetFormat) throws DocumentException;\n    public abstract void compress() throws DocumentException;\n    public abstract void backup(String location) throws DocumentException;\n    public abstract DocumentStatistics getStatistics();\n    public abstract void addWatermark(String watermarkText) throws DocumentException;\n    public abstract void digitallySSign(String certificate) throws DocumentException;\n    \n    protected void updateLastModified() {\n        this.lastModified = LocalDateTime.now();\n        this.revisionHistory.add(\"Document modified at \" + lastModified);\n    }\n    \n    public String getContent() { return content; }\n    public String getFormat() { return format; }\n    public boolean isEncrypted() { return encrypted; }\n    public DocumentPermissions getPermissions() { return permissions; }\n}\n\nclass DocumentPermissions {\n    private boolean canRead, canWrite, canPrint, canExport, canBackup;\n    \n    public DocumentPermissions(boolean canRead, boolean canWrite, boolean canPrint, boolean canExport, boolean canBackup) {\n        this.canRead = canRead; this.canWrite = canWrite; this.canPrint = canPrint;\n        this.canExport = canExport; this.canBackup = canBackup;\n    }\n    \n    public boolean canRead() { return canRead; }\n    public boolean canWrite() { return canWrite; }\n    public boolean canPrint() { return canPrint; }\n    public boolean canExport() { return canExport; }\n    public boolean canBackup() { return canBackup; }\n}\n\nclass DocumentStatistics {\n    private int wordCount, characterCount, pageCount;\n    private double fileSizeKB;\n    \n    public DocumentStatistics(int wordCount, int characterCount, int pageCount, double fileSizeKB) {\n        this.wordCount = wordCount; this.characterCount = characterCount;\n        this.pageCount = pageCount; this.fileSizeKB = fileSizeKB;\n    }\n    \n    public int getWordCount() { return wordCount; }\n    public int getCharacterCount() { return characterCount; }\n    public int getPageCount() { return pageCount; }\n    public double getFileSizeKB() { return fileSizeKB; }\n}\n\nclass DocumentException extends Exception {\n    public DocumentException(String message) { super(message); }\n}\n\npublic class EnterpriseWordDocument extends Document {\n    private String author;\n    private String department;\n    private List<String> collaborators;\n    private ReentrantLock documentLock;\n    private boolean isBeingEdited;\n    \n    public EnterpriseWordDocument(String content, String author, String department) {\n        super(content, \"DOCX\", new DocumentPermissions(true, true, true, true, true));\n        this.author = author;\n        this.department = department;\n        this.collaborators = new ArrayList<>();\n        this.documentLock = new ReentrantLock();\n        this.isBeingEdited = false;\n        this.metadata.put(\"author\", author);\n        this.metadata.put(\"department\", department);\n    }\n    \n    public void save() throws DocumentException {\n        documentLock.lock();\n        try {\n            if (!permissions.canWrite()) {\n                throw new DocumentException(\"No write permission for this document\");\n            }\n            System.out.println(\"Saving enterprise Word document by \" + author + \" in \" + department);\n            updateLastModified();\n            isBeingEdited = false;\n        } finally {\n            documentLock.unlock();\n        }\n    }\n    \n    public void print() throws DocumentException {\n        if (!permissions.canPrint()) {\n            throw new DocumentException(\"No print permission for this document\");\n        }\n        System.out.println(\"Printing enterprise Word document with watermark\");\n    }\n    \n    public void export(String targetFormat) throws DocumentException {\n        if (!permissions.canExport()) {\n            throw new DocumentException(\"No export permission for this document\");\n        }\n        System.out.println(\"Exporting enterprise Word document to \" + targetFormat + \" with audit trail\");\n    }\n    \n    public void compress() throws DocumentException {\n        System.out.println(\"Compressing enterprise Word document using advanced algorithms\");\n        this.content = this.content.replaceAll(\"\\\\s+\", \" \").trim();\n        updateLastModified();\n    }\n    \n    public void backup(String location) throws DocumentException {\n        if (!permissions.canBackup()) {\n            throw new DocumentException(\"No backup permission for this document\");\n        }\n        System.out.println(\"Creating encrypted backup of enterprise document at \" + location);\n    }\n    \n    public DocumentStatistics getStatistics() {\n        int wordCount = content.split(\"\\\\s+\").length;\n        int charCount = content.length();\n        int pageCount = Math.max(1, wordCount / 250);\n        double fileSize = content.length() * 0.001;\n        return new DocumentStatistics(wordCount, charCount, pageCount, fileSize);\n    }\n    \n    public void addWatermark(String watermarkText) throws DocumentException {\n        System.out.println(\"Adding enterprise watermark: \" + watermarkText);\n        updateLastModified();\n    }\n    \n    public void digitallySSign(String certificate) throws DocumentException {\n        System.out.println(\"Digitally signing document with certificate: \" + certificate);\n        this.encrypted = true;\n        updateLastModified();\n    }\n}\n\npublic class LegacyDocument extends Document {\n    private String originalSystem;\n    private boolean conversionRequired;\n    private List<String> conversionErrors;\n    \n    public LegacyDocument(String content, String originalSystem) {\n        super(content, \"LEGACY\", new DocumentPermissions(true, false, false, false, false));\n        this.originalSystem = originalSystem;\n        this.conversionRequired = true;\n        this.conversionErrors = new ArrayList<>();\n        this.metadata.put(\"originalSystem\", originalSystem);\n        this.metadata.put(\"migrationStatus\", \"pending\");\n    }\n    \n    public void save() throws DocumentException {\n        throw new DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\");\n    }\n    \n    public void print() throws DocumentException {\n        throw new DocumentException(\"Legacy documents cannot be printed without conversion\");\n    }\n    \n    public void export(String targetFormat) throws DocumentException {\n        throw new DocumentException(\"Legacy documents cannot be exported without manual conversion\");\n    }\n    \n    public void compress() throws DocumentException {\n        throw new DocumentException(\"Legacy documents use proprietary compression that cannot be modified\");\n    }\n    \n    public void backup(String location) throws DocumentException {\n        throw new DocumentException(\"Legacy documents require specialized backup procedures\");\n    }\n    \n    public DocumentStatistics getStatistics() {\n        return new DocumentStatistics(0, content.length(), 1, content.length() * 0.002);\n    }\n    \n    public void addWatermark(String watermarkText) throws DocumentException {\n        throw new DocumentException(\"Cannot add watermark to legacy document format\");\n    }\n    \n    public void digitallySSign(String certificate) throws DocumentException {\n        throw new DocumentException(\"Digital signatures not supported for legacy document format\");\n    }\n    \n    public void attemptConversion() {\n        System.out.println(\"Attempting to convert legacy document from \" + originalSystem);\n        conversionErrors.add(\"Formatting may be lost during conversion\");\n        conversionErrors.add(\"Some features not supported in modern format\");\n    }\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, compressing, backing up, adding watermarks, and digitally signing documents. Each of these operations could be handled by a separate class or service.\n\n0\n1\n2\n3\n4", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, including saving, printing, exporting, compressing, backing up, adding watermarks, and digitally signing documents. Each of these operations could be handled by a separate class or service.\n\n0\n1\n2\n3\n4", "solution_code": "NO FIX VERSION", "duration_seconds": 3.647399663925171}
{"id": 45, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "PYTHON", "input": "from abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom threading import Lock\nfrom typing import List, Dict, Optional\nimport re\n\nclass DocumentPermissions:\n    def __init__(self, can_read: bool, can_write: bool, can_print: bool, can_export: bool, can_backup: bool):\n        self.can_read = can_read\n        self.can_write = can_write\n        self.can_print = can_print\n        self.can_export = can_export\n        self.can_backup = can_backup\n\nclass DocumentStatistics:\n    def __init__(self, word_count: int, character_count: int, page_count: int, file_size_kb: float):\n        self.word_count = word_count\n        self.character_count = character_count\n        self.page_count = page_count\n        self.file_size_kb = file_size_kb\n\nclass DocumentException(Exception):\n    pass\n\nclass Document(ABC):\n    def __init__(self, content: str, format_type: str, permissions: DocumentPermissions):\n        self.content = content\n        self.format = format_type\n        self.encrypted = False\n        self.created_at = datetime.now()\n        self.last_modified = datetime.now()\n        self.metadata: Dict[str, str] = {}\n        self.revision_history: List[str] = []\n        self.permissions = permissions\n        self.revision_history.append(f\"Document created at {self.created_at}\")\n    \n    @abstractmethod\n    def save(self) -> None:\n        pass\n    \n    @abstractmethod\n    def print_doc(self) -> None:\n        pass\n    \n    @abstractmethod\n    def export(self, target_format: str) -> None:\n        pass\n    \n    @abstractmethod\n    def compress(self) -> None:\n        pass\n    \n    @abstractmethod\n    def backup(self, location: str) -> None:\n        pass\n    \n    @abstractmethod\n    def get_statistics(self) -> DocumentStatistics:\n        pass\n    \n    @abstractmethod\n    def add_watermark(self, watermark_text: str) -> None:\n        pass\n    \n    @abstractmethod\n    def digitally_sign(self, certificate: str) -> None:\n        pass\n    \n    def _update_last_modified(self):\n        self.last_modified = datetime.now()\n        self.revision_history.append(f\"Document modified at {self.last_modified}\")\n\nclass EnterpriseWordDocument(Document):\n    def __init__(self, content: str, author: str, department: str):\n        super().__init__(content, \"DOCX\", DocumentPermissions(True, True, True, True, True))\n        self.author = author\n        self.department = department\n        self.collaborators: List[str] = []\n        self.document_lock = Lock()\n        self.is_being_edited = False\n        self.metadata[\"author\"] = author\n        self.metadata[\"department\"] = department\n    \n    def save(self) -> None:\n        with self.document_lock:\n            if not self.permissions.can_write:\n                raise DocumentException(\"No write permission for this document\")\n            print(f\"Saving enterprise Word document by {self.author} in {self.department}\")\n            self._update_last_modified()\n            self.is_being_edited = False\n    \n    def print_doc(self) -> None:\n        if not self.permissions.can_print:\n            raise DocumentException(\"No print permission for this document\")\n        print(\"Printing enterprise Word document with watermark\")\n    \n    def export(self, target_format: str) -> None:\n        if not self.permissions.can_export:\n            raise DocumentException(\"No export permission for this document\")\n        print(f\"Exporting enterprise Word document to {target_format} with audit trail\")\n    \n    def compress(self) -> None:\n        print(\"Compressing enterprise Word document using advanced algorithms\")\n        self.content = re.sub(r'\\s+', ' ', self.content).strip()\n        self._update_last_modified()\n    \n    def backup(self, location: str) -> None:\n        if not self.permissions.can_backup:\n            raise DocumentException(\"No backup permission for this document\")\n        print(f\"Creating encrypted backup of enterprise document at {location}\")\n    \n    def get_statistics(self) -> DocumentStatistics:\n        word_count = len(self.content.split())\n        char_count = len(self.content)\n        page_count = max(1, word_count // 250)\n        file_size = len(self.content) * 0.001\n        return DocumentStatistics(word_count, char_count, page_count, file_size)\n    \n    def add_watermark(self, watermark_text: str) -> None:\n        print(f\"Adding enterprise watermark: {watermark_text}\")\n        self._update_last_modified()\n    \n    def digitally_sign(self, certificate: str) -> None:\n        print(f\"Digitally signing document with certificate: {certificate}\")\n        self.encrypted = True\n        self._update_last_modified()\n\nclass LegacyDocument(Document):\n    def __init__(self, content: str, original_system: str):\n        super().__init__(content, \"LEGACY\", DocumentPermissions(True, False, False, False, False))\n        self.original_system = original_system\n        self.conversion_required = True\n        self.conversion_errors: List[str] = []\n        self.metadata[\"original_system\"] = original_system\n        self.metadata[\"migration_status\"] = \"pending\"\n    \n    def save(self) -> None:\n        raise DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\")\n    \n    def print_doc(self) -> None:\n        raise DocumentException(\"Legacy documents cannot be printed without conversion\")\n    \n    def export(self, target_format: str) -> None:\n        raise DocumentException(\"Legacy documents cannot be exported without manual conversion\")\n    \n    def compress(self) -> None:\n        raise DocumentException(\"Legacy documents use proprietary compression that cannot be modified\")\n    \n    def backup(self, location: str) -> None:\n        raise DocumentException(\"Legacy documents require specialized backup procedures\")\n    \n    def get_statistics(self) -> DocumentStatistics:\n        return DocumentStatistics(0, len(self.content), 1, len(self.content) * 0.002)\n    \n    def add_watermark(self, watermark_text: str) -> None:\n        raise DocumentException(\"Cannot add watermark to legacy document format\")\n    \n    def digitally_sign(self, certificate: str) -> None:\n        raise DocumentException(\"Digital signatures not supported for legacy document format\")\n    \n    def attempt_conversion(self):\n        print(f\"Attempting to convert legacy document from {self.original_system}\")\n        self.conversion_errors.append(\"Formatting may be lost during conversion\")\n        self.conversion_errors.append(\"Some features not supported in modern format\")", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following PYTHON code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nfrom abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom threading import Lock\nfrom typing import List, Dict, Optional\nimport re\n\nclass DocumentPermissions:\n    def __init__(self, can_read: bool, can_write: bool, can_print: bool, can_export: bool, can_backup: bool):\n        self.can_read = can_read\n        self.can_write = can_write\n        self.can_print = can_print\n        self.can_export = can_export\n        self.can_backup = can_backup\n\nclass DocumentStatistics:\n    def __init__(self, word_count: int, character_count: int, page_count: int, file_size_kb: float):\n        self.word_count = word_count\n        self.character_count = character_count\n        self.page_count = page_count\n        self.file_size_kb = file_size_kb\n\nclass DocumentException(Exception):\n    pass\n\nclass Document(ABC):\n    def __init__(self, content: str, format_type: str, permissions: DocumentPermissions):\n        self.content = content\n        self.format = format_type\n        self.encrypted = False\n        self.created_at = datetime.now()\n        self.last_modified = datetime.now()\n        self.metadata: Dict[str, str] = {}\n        self.revision_history: List[str] = []\n        self.permissions = permissions\n        self.revision_history.append(f\"Document created at {self.created_at}\")\n    \n    @abstractmethod\n    def save(self) -> None:\n        pass\n    \n    @abstractmethod\n    def print_doc(self) -> None:\n        pass\n    \n    @abstractmethod\n    def export(self, target_format: str) -> None:\n        pass\n    \n    @abstractmethod\n    def compress(self) -> None:\n        pass\n    \n    @abstractmethod\n    def backup(self, location: str) -> None:\n        pass\n    \n    @abstractmethod\n    def get_statistics(self) -> DocumentStatistics:\n        pass\n    \n    @abstractmethod\n    def add_watermark(self, watermark_text: str) -> None:\n        pass\n    \n    @abstractmethod\n    def digitally_sign(self, certificate: str) -> None:\n        pass\n    \n    def _update_last_modified(self):\n        self.last_modified = datetime.now()\n        self.revision_history.append(f\"Document modified at {self.last_modified}\")\n\nclass EnterpriseWordDocument(Document):\n    def __init__(self, content: str, author: str, department: str):\n        super().__init__(content, \"DOCX\", DocumentPermissions(True, True, True, True, True))\n        self.author = author\n        self.department = department\n        self.collaborators: List[str] = []\n        self.document_lock = Lock()\n        self.is_being_edited = False\n        self.metadata[\"author\"] = author\n        self.metadata[\"department\"] = department\n    \n    def save(self) -> None:\n        with self.document_lock:\n            if not self.permissions.can_write:\n                raise DocumentException(\"No write permission for this document\")\n            print(f\"Saving enterprise Word document by {self.author} in {self.department}\")\n            self._update_last_modified()\n            self.is_being_edited = False\n    \n    def print_doc(self) -> None:\n        if not self.permissions.can_print:\n            raise DocumentException(\"No print permission for this document\")\n        print(\"Printing enterprise Word document with watermark\")\n    \n    def export(self, target_format: str) -> None:\n        if not self.permissions.can_export:\n            raise DocumentException(\"No export permission for this document\")\n        print(f\"Exporting enterprise Word document to {target_format} with audit trail\")\n    \n    def compress(self) -> None:\n        print(\"Compressing enterprise Word document using advanced algorithms\")\n        self.content = re.sub(r'\\s+', ' ', self.content).strip()\n        self._update_last_modified()\n    \n    def backup(self, location: str) -> None:\n        if not self.permissions.can_backup:\n            raise DocumentException(\"No backup permission for this document\")\n        print(f\"Creating encrypted backup of enterprise document at {location}\")\n    \n    def get_statistics(self) -> DocumentStatistics:\n        word_count = len(self.content.split())\n        char_count = len(self.content)\n        page_count = max(1, word_count // 250)\n        file_size = len(self.content) * 0.001\n        return DocumentStatistics(word_count, char_count, page_count, file_size)\n    \n    def add_watermark(self, watermark_text: str) -> None:\n        print(f\"Adding enterprise watermark: {watermark_text}\")\n        self._update_last_modified()\n    \n    def digitally_sign(self, certificate: str) -> None:\n        print(f\"Digitally signing document with certificate: {certificate}\")\n        self.encrypted = True\n        self._update_last_modified()\n\nclass LegacyDocument(Document):\n    def __init__(self, content: str, original_system: str):\n        super().__init__(content, \"LEGACY\", DocumentPermissions(True, False, False, False, False))\n        self.original_system = original_system\n        self.conversion_required = True\n        self.conversion_errors: List[str] = []\n        self.metadata[\"original_system\"] = original_system\n        self.metadata[\"migration_status\"] = \"pending\"\n    \n    def save(self) -> None:\n        raise DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\")\n    \n    def print_doc(self) -> None:\n        raise DocumentException(\"Legacy documents cannot be printed without conversion\")\n    \n    def export(self, target_format: str) -> None:\n        raise DocumentException(\"Legacy documents cannot be exported without manual conversion\")\n    \n    def compress(self) -> None:\n        raise DocumentException(\"Legacy documents use proprietary compression that cannot be modified\")\n    \n    def backup(self, location: str) -> None:\n        raise DocumentException(\"Legacy documents require specialized backup procedures\")\n    \n    def get_statistics(self) -> DocumentStatistics:\n        return DocumentStatistics(0, len(self.content), 1, len(self.content) * 0.002)\n    \n    def add_watermark(self, watermark_text: str) -> None:\n        raise DocumentException(\"Cannot add watermark to legacy document format\")\n    \n    def digitally_sign(self, certificate: str) -> None:\n        raise DocumentException(\"Digital signatures not supported for legacy document format\")\n    \n    def attempt_conversion(self):\n        print(f\"Attempting to convert legacy document from {self.original_system}\")\n        self.conversion_errors.append(\"Formatting may be lost during conversion\")\n        self.conversion_errors.append(\"Some features not supported in modern format\")", "raw_response": "**Interface Bloat**\nThe `Document` abstract class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they might not need.\n\nSRP: 3  \nOCP: 2  \nLSP: 4  \nISP: 1  \nDIP: 5  \n\n**ISP**\nThe `Document` abstract class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they might not need.", "violation": "ISP, SRP, OCP, LSP, DIP", "violation_list": ["ISP", "SRP", "OCP", "LSP", "DIP"], "explanation": "**Interface Bloat**\nThe `Document` abstract class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they might not need.\n\nSRP: 3  \nOCP: 2  \nLSP: 4  \nISP: 1  \nDIP: 5  \n\n**ISP**\nThe `Document` abstract class has too many methods, which violates the Interface Segregation Principle by forcing subclasses to implement methods they might not need.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.527210235595703}
{"id": 46, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "KOTLIN", "input": "import java.time.LocalDateTime\nimport java.util.concurrent.locks.ReentrantLock\nimport kotlin.collections.mutableListOf\nimport kotlin.collections.mutableMapOf\n\ndata class DocumentPermissions(\n    val canRead: Boolean,\n    val canWrite: Boolean,\n    val canPrint: Boolean,\n    val canExport: Boolean,\n    val canBackup: Boolean\n)\n\ndata class DocumentStatistics(\n    val wordCount: Int,\n    val characterCount: Int,\n    val pageCount: Int,\n    val fileSizeKB: Double\n)\n\nclass DocumentException(message: String) : Exception(message)\n\nabstract class Document(\n    protected var content: String,\n    protected val format: String,\n    protected val permissions: DocumentPermissions\n) {\n    protected var encrypted: Boolean = false\n    protected val createdAt: LocalDateTime = LocalDateTime.now()\n    protected var lastModified: LocalDateTime = LocalDateTime.now()\n    protected val metadata: MutableMap<String, String> = mutableMapOf()\n    protected val revisionHistory: MutableList<String> = mutableListOf()\n    \n    init {\n        revisionHistory.add(\"Document created at $createdAt\")\n    }\n    \n    abstract fun save()\n    abstract fun print()\n    abstract fun export(targetFormat: String)\n    abstract fun compress()\n    abstract fun backup(location: String)\n    abstract fun getStatistics(): DocumentStatistics\n    abstract fun addWatermark(watermarkText: String)\n    abstract fun digitallySign(certificate: String)\n    \n    protected fun updateLastModified() {\n        lastModified = LocalDateTime.now()\n        revisionHistory.add(\"Document modified at $lastModified\")\n    }\n    \n    fun getContent(): String = content\n    fun getFormat(): String = format\n    fun isEncrypted(): Boolean = encrypted\n    fun getPermissions(): DocumentPermissions = permissions\n}\n\nclass EnterpriseWordDocument(\n    content: String,\n    private val author: String,\n    private val department: String\n) : Document(content, \"DOCX\", DocumentPermissions(true, true, true, true, true)) {\n    \n    private val collaborators: MutableList<String> = mutableListOf()\n    private val documentLock = ReentrantLock()\n    private var isBeingEdited: Boolean = false\n    \n    init {\n        metadata[\"author\"] = author\n        metadata[\"department\"] = department\n    }\n    \n    override fun save() {\n        documentLock.lock()\n        try {\n            if (!permissions.canWrite) {\n                throw DocumentException(\"No write permission for this document\")\n            }\n            println(\"Saving enterprise Word document by $author in $department\")\n            updateLastModified()\n            isBeingEdited = false\n        } finally {\n            documentLock.unlock()\n        }\n    }\n    \n    override fun print() {\n        if (!permissions.canPrint) {\n            throw DocumentException(\"No print permission for this document\")\n        }\n        println(\"Printing enterprise Word document with watermark\")\n    }\n    \n    override fun export(targetFormat: String) {\n        if (!permissions.canExport) {\n            throw DocumentException(\"No export permission for this document\")\n        }\n        println(\"Exporting enterprise Word document to $targetFormat with audit trail\")\n    }\n    \n    override fun compress() {\n        println(\"Compressing enterprise Word document using advanced algorithms\")\n        content = content.replace(Regex(\"\\\\s+\"), \" \").trim()\n        updateLastModified()\n    }\n    \n    override fun backup(location: String) {\n        if (!permissions.canBackup) {\n            throw DocumentException(\"No backup permission for this document\")\n        }\n        println(\"Creating encrypted backup of enterprise document at $location\")\n    }\n    \n    override fun getStatistics(): DocumentStatistics {\n        val wordCount = content.split(Regex(\"\\\\s+\")).size\n        val charCount = content.length\n        val pageCount = maxOf(1, wordCount / 250)\n        val fileSize = content.length * 0.001\n        return DocumentStatistics(wordCount, charCount, pageCount, fileSize)\n    }\n    \n    override fun addWatermark(watermarkText: String) {\n        println(\"Adding enterprise watermark: $watermarkText\")\n        updateLastModified()\n    }\n    \n    override fun digitallySign(certificate: String) {\n        println(\"Digitally signing document with certificate: $certificate\")\n        encrypted = true\n        updateLastModified()\n    }\n    \n    fun addCollaborator(collaborator: String) {\n        collaborators.add(collaborator)\n        updateLastModified()\n    }\n    \n    fun startEditing() {\n        documentLock.lock()\n        try {\n            isBeingEdited = true\n            println(\"Document is now being edited by $author\")\n        } finally {\n            documentLock.unlock()\n        }\n    }\n}\n\nclass LegacyDocument(\n    content: String,\n    private val originalSystem: String\n) : Document(content, \"LEGACY\", DocumentPermissions(true, false, false, false, false)) {\n    \n    private val conversionRequired: Boolean = true\n    private val conversionErrors: MutableList<String> = mutableListOf()\n    \n    init {\n        metadata[\"originalSystem\"] = originalSystem\n        metadata[\"migrationStatus\"] = \"pending\"\n    }\n    \n    override fun save() {\n        throw DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\")\n    }\n    \n    override fun print() {\n        throw DocumentException(\"Legacy documents cannot be printed without conversion\")\n    }\n    \n    override fun export(targetFormat: String) {\n        throw DocumentException(\"Legacy documents cannot be exported without manual conversion\")\n    }\n    \n    override fun compress() {\n        throw DocumentException(\"Legacy documents use proprietary compression that cannot be modified\")\n    }\n    \n    override fun backup(location: String) {\n        throw DocumentException(\"Legacy documents require specialized backup procedures\")\n    }\n    \n    override fun getStatistics(): DocumentStatistics {\n        return DocumentStatistics(0, content.length, 1, content.length * 0.002)\n    }\n    \n    override fun addWatermark(watermarkText: String) {\n        throw DocumentException(\"Cannot add watermark to legacy document format\")\n    }\n    \n    override fun digitallySign(certificate: String) {\n        throw DocumentException(\"Digital signatures not supported for legacy document format\")\n    }\n    \n    fun attemptConversion() {\n        println(\"Attempting to convert legacy document from $originalSystem\")\n        conversionErrors.add(\"Formatting may be lost during conversion\")\n        conversionErrors.add(\"Some features not supported in modern format\")\n    }\n    \n    fun getConversionErrors(): List<String> = conversionErrors.toList()\n    fun isConversionRequired(): Boolean = conversionRequired\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following KOTLIN code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nimport java.time.LocalDateTime\nimport java.util.concurrent.locks.ReentrantLock\nimport kotlin.collections.mutableListOf\nimport kotlin.collections.mutableMapOf\n\ndata class DocumentPermissions(\n    val canRead: Boolean,\n    val canWrite: Boolean,\n    val canPrint: Boolean,\n    val canExport: Boolean,\n    val canBackup: Boolean\n)\n\ndata class DocumentStatistics(\n    val wordCount: Int,\n    val characterCount: Int,\n    val pageCount: Int,\n    val fileSizeKB: Double\n)\n\nclass DocumentException(message: String) : Exception(message)\n\nabstract class Document(\n    protected var content: String,\n    protected val format: String,\n    protected val permissions: DocumentPermissions\n) {\n    protected var encrypted: Boolean = false\n    protected val createdAt: LocalDateTime = LocalDateTime.now()\n    protected var lastModified: LocalDateTime = LocalDateTime.now()\n    protected val metadata: MutableMap<String, String> = mutableMapOf()\n    protected val revisionHistory: MutableList<String> = mutableListOf()\n    \n    init {\n        revisionHistory.add(\"Document created at $createdAt\")\n    }\n    \n    abstract fun save()\n    abstract fun print()\n    abstract fun export(targetFormat: String)\n    abstract fun compress()\n    abstract fun backup(location: String)\n    abstract fun getStatistics(): DocumentStatistics\n    abstract fun addWatermark(watermarkText: String)\n    abstract fun digitallySign(certificate: String)\n    \n    protected fun updateLastModified() {\n        lastModified = LocalDateTime.now()\n        revisionHistory.add(\"Document modified at $lastModified\")\n    }\n    \n    fun getContent(): String = content\n    fun getFormat(): String = format\n    fun isEncrypted(): Boolean = encrypted\n    fun getPermissions(): DocumentPermissions = permissions\n}\n\nclass EnterpriseWordDocument(\n    content: String,\n    private val author: String,\n    private val department: String\n) : Document(content, \"DOCX\", DocumentPermissions(true, true, true, true, true)) {\n    \n    private val collaborators: MutableList<String> = mutableListOf()\n    private val documentLock = ReentrantLock()\n    private var isBeingEdited: Boolean = false\n    \n    init {\n        metadata[\"author\"] = author\n        metadata[\"department\"] = department\n    }\n    \n    override fun save() {\n        documentLock.lock()\n        try {\n            if (!permissions.canWrite) {\n                throw DocumentException(\"No write permission for this document\")\n            }\n            println(\"Saving enterprise Word document by $author in $department\")\n            updateLastModified()\n            isBeingEdited = false\n        } finally {\n            documentLock.unlock()\n        }\n    }\n    \n    override fun print() {\n        if (!permissions.canPrint) {\n            throw DocumentException(\"No print permission for this document\")\n        }\n        println(\"Printing enterprise Word document with watermark\")\n    }\n    \n    override fun export(targetFormat: String) {\n        if (!permissions.canExport) {\n            throw DocumentException(\"No export permission for this document\")\n        }\n        println(\"Exporting enterprise Word document to $targetFormat with audit trail\")\n    }\n    \n    override fun compress() {\n        println(\"Compressing enterprise Word document using advanced algorithms\")\n        content = content.replace(Regex(\"\\\\s+\"), \" \").trim()\n        updateLastModified()\n    }\n    \n    override fun backup(location: String) {\n        if (!permissions.canBackup) {\n            throw DocumentException(\"No backup permission for this document\")\n        }\n        println(\"Creating encrypted backup of enterprise document at $location\")\n    }\n    \n    override fun getStatistics(): DocumentStatistics {\n        val wordCount = content.split(Regex(\"\\\\s+\")).size\n        val charCount = content.length\n        val pageCount = maxOf(1, wordCount / 250)\n        val fileSize = content.length * 0.001\n        return DocumentStatistics(wordCount, charCount, pageCount, fileSize)\n    }\n    \n    override fun addWatermark(watermarkText: String) {\n        println(\"Adding enterprise watermark: $watermarkText\")\n        updateLastModified()\n    }\n    \n    override fun digitallySign(certificate: String) {\n        println(\"Digitally signing document with certificate: $certificate\")\n        encrypted = true\n        updateLastModified()\n    }\n    \n    fun addCollaborator(collaborator: String) {\n        collaborators.add(collaborator)\n        updateLastModified()\n    }\n    \n    fun startEditing() {\n        documentLock.lock()\n        try {\n            isBeingEdited = true\n            println(\"Document is now being edited by $author\")\n        } finally {\n            documentLock.unlock()\n        }\n    }\n}\n\nclass LegacyDocument(\n    content: String,\n    private val originalSystem: String\n) : Document(content, \"LEGACY\", DocumentPermissions(true, false, false, false, false)) {\n    \n    private val conversionRequired: Boolean = true\n    private val conversionErrors: MutableList<String> = mutableListOf()\n    \n    init {\n        metadata[\"originalSystem\"] = originalSystem\n        metadata[\"migrationStatus\"] = \"pending\"\n    }\n    \n    override fun save() {\n        throw DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\")\n    }\n    \n    override fun print() {\n        throw DocumentException(\"Legacy documents cannot be printed without conversion\")\n    }\n    \n    override fun export(targetFormat: String) {\n        throw DocumentException(\"Legacy documents cannot be exported without manual conversion\")\n    }\n    \n    override fun compress() {\n        throw DocumentException(\"Legacy documents use proprietary compression that cannot be modified\")\n    }\n    \n    override fun backup(location: String) {\n        throw DocumentException(\"Legacy documents require specialized backup procedures\")\n    }\n    \n    override fun getStatistics(): DocumentStatistics {\n        return DocumentStatistics(0, content.length, 1, content.length * 0.002)\n    }\n    \n    override fun addWatermark(watermarkText: String) {\n        throw DocumentException(\"Cannot add watermark to legacy document format\")\n    }\n    \n    override fun digitallySign(certificate: String) {\n        throw DocumentException(\"Digital signatures not supported for legacy document format\")\n    }\n    \n    fun attemptConversion() {\n        println(\"Attempting to convert legacy document from $originalSystem\")\n        conversionErrors.add(\"Formatting may be lost during conversion\")\n        conversionErrors.add(\"Some features not supported in modern format\")\n    }\n    \n    fun getConversionErrors(): List<String> = conversionErrors.toList()\n    fun isConversionRequired(): Boolean = conversionRequired\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, maintaining metadata, and performing various operations like saving, printing, exporting, compressing, backing up, and more.\n\n0\n1\n2\n3\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, maintaining metadata, and performing various operations like saving, printing, exporting, compressing, backing up, and more.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, maintaining metadata, and performing various operations like saving, printing, exporting, compressing, backing up, and more.\n\n0\n1\n2\n3\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, maintaining metadata, and performing various operations like saving, printing, exporting, compressing, backing up, and more.", "solution_code": "NO FIX VERSION", "duration_seconds": 4.854523658752441}
{"id": 47, "strategy": "smell", "violation_type": "lsp", "model": "qwen2.5-coder32b-temp0:latest", "language": "C#", "input": "using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Text.RegularExpressions;\nusing System.Linq;\n\npublic class DocumentPermissions\n{\n    public bool CanRead { get; }\n    public bool CanWrite { get; }\n    public bool CanPrint { get; }\n    public bool CanExport { get; }\n    public bool CanBackup { get; }\n    \n    public DocumentPermissions(bool canRead, bool canWrite, bool canPrint, bool canExport, bool canBackup)\n    {\n        CanRead = canRead;\n        CanWrite = canWrite;\n        CanPrint = canPrint;\n        CanExport = canExport;\n        CanBackup = canBackup;\n    }\n}\n\npublic class DocumentStatistics\n{\n    public int WordCount { get; }\n    public int CharacterCount { get; }\n    public int PageCount { get; }\n    public double FileSizeKB { get; }\n    \n    public DocumentStatistics(int wordCount, int characterCount, int pageCount, double fileSizeKB)\n    {\n        WordCount = wordCount;\n        CharacterCount = characterCount;\n        PageCount = pageCount;\n        FileSizeKB = fileSizeKB;\n    }\n}\n\npublic class DocumentException : Exception\n{\n    public DocumentException(string message) : base(message) { }\n}\n\npublic abstract class Document\n{\n    protected string content;\n    protected string format;\n    protected bool encrypted;\n    protected DateTime createdAt;\n    protected DateTime lastModified;\n    protected Dictionary<string, string> metadata;\n    protected List<string> revisionHistory;\n    protected DocumentPermissions permissions;\n    \n    public Document(string content, string format, DocumentPermissions permissions)\n    {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n        this.createdAt = DateTime.Now;\n        this.lastModified = DateTime.Now;\n        this.metadata = new Dictionary<string, string>();\n        this.revisionHistory = new List<string>();\n        this.permissions = permissions;\n        this.revisionHistory.Add($\"Document created at {createdAt}\");\n    }\n    \n    public abstract void Save();\n    public abstract void Print();\n    public abstract void Export(string targetFormat);\n    public abstract void Compress();\n    public abstract void Backup(string location);\n    public abstract DocumentStatistics GetStatistics();\n    public abstract void AddWatermark(string watermarkText);\n    public abstract void DigitallySign(string certificate);\n    \n    protected void UpdateLastModified()\n    {\n        lastModified = DateTime.Now;\n        revisionHistory.Add($\"Document modified at {lastModified}\");\n    }\n    \n    public string GetContent() => content;\n    public string GetFormat() => format;\n    public bool IsEncrypted() => encrypted;\n    public DocumentPermissions GetPermissions() => permissions;\n}\n\npublic class EnterpriseWordDocument : Document\n{\n    private string author;\n    private string department;\n    private List<string> collaborators;\n    private ReaderWriterLockSlim documentLock;\n    private bool isBeingEdited;\n    \n    public EnterpriseWordDocument(string content, string author, string department) \n        : base(content, \"DOCX\", new DocumentPermissions(true, true, true, true, true))\n    {\n        this.author = author;\n        this.department = department;\n        this.collaborators = new List<string>();\n        this.documentLock = new ReaderWriterLockSlim();\n        this.isBeingEdited = false;\n        this.metadata[\"author\"] = author;\n        this.metadata[\"department\"] = department;\n    }\n    \n    public override void Save()\n    {\n        documentLock.EnterWriteLock();\n        try\n        {\n            if (!permissions.CanWrite)\n            {\n                throw new DocumentException(\"No write permission for this document\");\n            }\n            Console.WriteLine($\"Saving enterprise Word document by {author} in {department}\");\n            UpdateLastModified();\n            isBeingEdited = false;\n        }\n        finally\n        {\n            documentLock.ExitWriteLock();\n        }\n    }\n    \n    public override void Print()\n    {\n        if (!permissions.CanPrint)\n        {\n            throw new DocumentException(\"No print permission for this document\");\n        }\n        Console.WriteLine(\"Printing enterprise Word document with watermark\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        if (!permissions.CanExport)\n        {\n            throw new DocumentException(\"No export permission for this document\");\n        }\n        Console.WriteLine($\"Exporting enterprise Word document to {targetFormat} with audit trail\");\n    }\n    \n    public override void Compress()\n    {\n        Console.WriteLine(\"Compressing enterprise Word document using advanced algorithms\");\n        content = Regex.Replace(content, @\"\\s+\", \" \").Trim();\n        UpdateLastModified();\n    }\n    \n    public override void Backup(string location)\n    {\n        if (!permissions.CanBackup)\n        {\n            throw new DocumentException(\"No backup permission for this document\");\n        }\n        Console.WriteLine($\"Creating encrypted backup of enterprise document at {location}\");\n    }\n    \n    public override DocumentStatistics GetStatistics()\n    {\n        var wordCount = content.Split(new char[] { ' ', '\\t', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries).Length;\n        var charCount = content.Length;\n        var pageCount = Math.Max(1, wordCount / 250);\n        var fileSize = content.Length * 0.001;\n        return new DocumentStatistics(wordCount, charCount, pageCount, fileSize);\n    }\n    \n    public override void AddWatermark(string watermarkText)\n    {\n        Console.WriteLine($\"Adding enterprise watermark: {watermarkText}\");\n        UpdateLastModified();\n    }\n    \n    public override void DigitallySign(string certificate)\n    {\n        Console.WriteLine($\"Digitally signing document with certificate: {certificate}\");\n        encrypted = true;\n        UpdateLastModified();\n    }\n    \n    public void AddCollaborator(string collaborator)\n    {\n        collaborators.Add(collaborator);\n        UpdateLastModified();\n    }\n    \n    public void StartEditing()\n    {\n        documentLock.EnterWriteLock();\n        try\n        {\n            isBeingEdited = true;\n            Console.WriteLine($\"Document is now being edited by {author}\");\n        }\n        finally\n        {\n            documentLock.ExitWriteLock();\n        }\n    }\n}\n\npublic class LegacyDocument : Document\n{\n    private string originalSystem;\n    private bool conversionRequired;\n    private List<string> conversionErrors;\n    \n    public LegacyDocument(string content, string originalSystem) \n        : base(content, \"LEGACY\", new DocumentPermissions(true, false, false, false, false))\n    {\n        this.originalSystem = originalSystem;\n        this.conversionRequired = true;\n        this.conversionErrors = new List<string>();\n        this.metadata[\"originalSystem\"] = originalSystem;\n        this.metadata[\"migrationStatus\"] = \"pending\";\n    }\n    \n    public override void Save()\n    {\n        throw new DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\");\n    }\n    \n    public override void Print()\n    {\n        throw new DocumentException(\"Legacy documents cannot be printed without conversion\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        throw new DocumentException(\"Legacy documents cannot be exported without manual conversion\");\n    }\n    \n    public override void Compress()\n    {\n        throw new DocumentException(\"Legacy documents use proprietary compression that cannot be modified\");\n    }\n    \n    public override void Backup(string location)\n    {\n        throw new DocumentException(\"Legacy documents require specialized backup procedures\");\n    }\n    \n    public override DocumentStatistics GetStatistics()\n    {\n        return new DocumentStatistics(0, content.Length, 1, content.Length * 0.002);\n    }\n    \n    public override void AddWatermark(string watermarkText)\n    {\n        throw new DocumentException(\"Cannot add watermark to legacy document format\");\n    }\n    \n    public override void DigitallySign(string certificate)\n    {\n        throw new DocumentException(\"Digital signatures not supported for legacy document format\");\n    }\n    \n    public void AttemptConversion()\n    {\n        Console.WriteLine($\"Attempting to convert legacy document from {originalSystem}\");\n        conversionErrors.Add(\"Formatting may be lost during conversion\");\n        conversionErrors.Add(\"Some features not supported in modern format\");\n    }\n    \n    public List<string> GetConversionErrors() => new List<string>(conversionErrors);\n    public bool IsConversionRequired() => conversionRequired;\n}", "prompt": "First, identify any code smells (e.g., God Object, Interface Bloat, Inappropriate Intimacy) in the following C# code.\nThen, map each smell to a relevant SOLID principle.\nAfter that, rate the code from 0 (bad) to 5 (good) on:\nSRP, OCP, LSP, ISP, DIP.\n\nThen, pick the **single most violated** principle and explain the violation.\n\nIf there is no violation, you can return NONE.\n**Important:** Your output must follow *exactly* this format, with no additional commentary before or after.\n\n**<VIOLATION TYPE>**\n<Explanation of the violation>\n\nOnly output the text above. Do not include extra analysis or preamble.\n\nExample:\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Text.RegularExpressions;\nusing System.Linq;\n\npublic class DocumentPermissions\n{\n    public bool CanRead { get; }\n    public bool CanWrite { get; }\n    public bool CanPrint { get; }\n    public bool CanExport { get; }\n    public bool CanBackup { get; }\n    \n    public DocumentPermissions(bool canRead, bool canWrite, bool canPrint, bool canExport, bool canBackup)\n    {\n        CanRead = canRead;\n        CanWrite = canWrite;\n        CanPrint = canPrint;\n        CanExport = canExport;\n        CanBackup = canBackup;\n    }\n}\n\npublic class DocumentStatistics\n{\n    public int WordCount { get; }\n    public int CharacterCount { get; }\n    public int PageCount { get; }\n    public double FileSizeKB { get; }\n    \n    public DocumentStatistics(int wordCount, int characterCount, int pageCount, double fileSizeKB)\n    {\n        WordCount = wordCount;\n        CharacterCount = characterCount;\n        PageCount = pageCount;\n        FileSizeKB = fileSizeKB;\n    }\n}\n\npublic class DocumentException : Exception\n{\n    public DocumentException(string message) : base(message) { }\n}\n\npublic abstract class Document\n{\n    protected string content;\n    protected string format;\n    protected bool encrypted;\n    protected DateTime createdAt;\n    protected DateTime lastModified;\n    protected Dictionary<string, string> metadata;\n    protected List<string> revisionHistory;\n    protected DocumentPermissions permissions;\n    \n    public Document(string content, string format, DocumentPermissions permissions)\n    {\n        this.content = content;\n        this.format = format;\n        this.encrypted = false;\n        this.createdAt = DateTime.Now;\n        this.lastModified = DateTime.Now;\n        this.metadata = new Dictionary<string, string>();\n        this.revisionHistory = new List<string>();\n        this.permissions = permissions;\n        this.revisionHistory.Add($\"Document created at {createdAt}\");\n    }\n    \n    public abstract void Save();\n    public abstract void Print();\n    public abstract void Export(string targetFormat);\n    public abstract void Compress();\n    public abstract void Backup(string location);\n    public abstract DocumentStatistics GetStatistics();\n    public abstract void AddWatermark(string watermarkText);\n    public abstract void DigitallySign(string certificate);\n    \n    protected void UpdateLastModified()\n    {\n        lastModified = DateTime.Now;\n        revisionHistory.Add($\"Document modified at {lastModified}\");\n    }\n    \n    public string GetContent() => content;\n    public string GetFormat() => format;\n    public bool IsEncrypted() => encrypted;\n    public DocumentPermissions GetPermissions() => permissions;\n}\n\npublic class EnterpriseWordDocument : Document\n{\n    private string author;\n    private string department;\n    private List<string> collaborators;\n    private ReaderWriterLockSlim documentLock;\n    private bool isBeingEdited;\n    \n    public EnterpriseWordDocument(string content, string author, string department) \n        : base(content, \"DOCX\", new DocumentPermissions(true, true, true, true, true))\n    {\n        this.author = author;\n        this.department = department;\n        this.collaborators = new List<string>();\n        this.documentLock = new ReaderWriterLockSlim();\n        this.isBeingEdited = false;\n        this.metadata[\"author\"] = author;\n        this.metadata[\"department\"] = department;\n    }\n    \n    public override void Save()\n    {\n        documentLock.EnterWriteLock();\n        try\n        {\n            if (!permissions.CanWrite)\n            {\n                throw new DocumentException(\"No write permission for this document\");\n            }\n            Console.WriteLine($\"Saving enterprise Word document by {author} in {department}\");\n            UpdateLastModified();\n            isBeingEdited = false;\n        }\n        finally\n        {\n            documentLock.ExitWriteLock();\n        }\n    }\n    \n    public override void Print()\n    {\n        if (!permissions.CanPrint)\n        {\n            throw new DocumentException(\"No print permission for this document\");\n        }\n        Console.WriteLine(\"Printing enterprise Word document with watermark\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        if (!permissions.CanExport)\n        {\n            throw new DocumentException(\"No export permission for this document\");\n        }\n        Console.WriteLine($\"Exporting enterprise Word document to {targetFormat} with audit trail\");\n    }\n    \n    public override void Compress()\n    {\n        Console.WriteLine(\"Compressing enterprise Word document using advanced algorithms\");\n        content = Regex.Replace(content, @\"\\s+\", \" \").Trim();\n        UpdateLastModified();\n    }\n    \n    public override void Backup(string location)\n    {\n        if (!permissions.CanBackup)\n        {\n            throw new DocumentException(\"No backup permission for this document\");\n        }\n        Console.WriteLine($\"Creating encrypted backup of enterprise document at {location}\");\n    }\n    \n    public override DocumentStatistics GetStatistics()\n    {\n        var wordCount = content.Split(new char[] { ' ', '\\t', '\\n', '\\r' }, StringSplitOptions.RemoveEmptyEntries).Length;\n        var charCount = content.Length;\n        var pageCount = Math.Max(1, wordCount / 250);\n        var fileSize = content.Length * 0.001;\n        return new DocumentStatistics(wordCount, charCount, pageCount, fileSize);\n    }\n    \n    public override void AddWatermark(string watermarkText)\n    {\n        Console.WriteLine($\"Adding enterprise watermark: {watermarkText}\");\n        UpdateLastModified();\n    }\n    \n    public override void DigitallySign(string certificate)\n    {\n        Console.WriteLine($\"Digitally signing document with certificate: {certificate}\");\n        encrypted = true;\n        UpdateLastModified();\n    }\n    \n    public void AddCollaborator(string collaborator)\n    {\n        collaborators.Add(collaborator);\n        UpdateLastModified();\n    }\n    \n    public void StartEditing()\n    {\n        documentLock.EnterWriteLock();\n        try\n        {\n            isBeingEdited = true;\n            Console.WriteLine($\"Document is now being edited by {author}\");\n        }\n        finally\n        {\n            documentLock.ExitWriteLock();\n        }\n    }\n}\n\npublic class LegacyDocument : Document\n{\n    private string originalSystem;\n    private bool conversionRequired;\n    private List<string> conversionErrors;\n    \n    public LegacyDocument(string content, string originalSystem) \n        : base(content, \"LEGACY\", new DocumentPermissions(true, false, false, false, false))\n    {\n        this.originalSystem = originalSystem;\n        this.conversionRequired = true;\n        this.conversionErrors = new List<string>();\n        this.metadata[\"originalSystem\"] = originalSystem;\n        this.metadata[\"migrationStatus\"] = \"pending\";\n    }\n    \n    public override void Save()\n    {\n        throw new DocumentException(\"Legacy documents are read-only and cannot be saved in modern format\");\n    }\n    \n    public override void Print()\n    {\n        throw new DocumentException(\"Legacy documents cannot be printed without conversion\");\n    }\n    \n    public override void Export(string targetFormat)\n    {\n        throw new DocumentException(\"Legacy documents cannot be exported without manual conversion\");\n    }\n    \n    public override void Compress()\n    {\n        throw new DocumentException(\"Legacy documents use proprietary compression that cannot be modified\");\n    }\n    \n    public override void Backup(string location)\n    {\n        throw new DocumentException(\"Legacy documents require specialized backup procedures\");\n    }\n    \n    public override DocumentStatistics GetStatistics()\n    {\n        return new DocumentStatistics(0, content.Length, 1, content.Length * 0.002);\n    }\n    \n    public override void AddWatermark(string watermarkText)\n    {\n        throw new DocumentException(\"Cannot add watermark to legacy document format\");\n    }\n    \n    public override void DigitallySign(string certificate)\n    {\n        throw new DocumentException(\"Digital signatures not supported for legacy document format\");\n    }\n    \n    public void AttemptConversion()\n    {\n        Console.WriteLine($\"Attempting to convert legacy document from {originalSystem}\");\n        conversionErrors.Add(\"Formatting may be lost during conversion\");\n        conversionErrors.Add(\"Some features not supported in modern format\");\n    }\n    \n    public List<string> GetConversionErrors() => new List<string>(conversionErrors);\n    public bool IsConversionRequired() => conversionRequired;\n}", "raw_response": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, and performing various operations like saving, printing, exporting, etc. Each of these should be handled by separate classes or modules.\n\n0\n1\n2\n3\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, and performing various operations like saving, printing, exporting, etc. Each of these should be handled by separate classes or modules.", "violation": "SRP", "violation_list": ["SRP"], "explanation": "**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, and performing various operations like saving, printing, exporting, etc. Each of these should be handled by separate classes or modules.\n\n0\n1\n2\n3\n2\n\n**SRP**\nThis class violates the Single Responsibility Principle because it has multiple responsibilities, such as managing content, handling permissions, and performing various operations like saving, printing, exporting, etc. Each of these should be handled by separate classes or modules.", "solution_code": "NO FIX VERSION", "duration_seconds": 5.328824520111084}
