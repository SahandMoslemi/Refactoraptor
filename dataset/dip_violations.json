{
    "code_examples": [
        {
            "input": "public class EmailService {\n    public void sendEmail(String message) {\n        System.out.println(\"Sending email: \" + message);\n    }\n}\n\npublic class NotificationManager {\n    private EmailService emailService;\n    \n    public NotificationManager() {\n        this.emailService = new EmailService();\n    }\n    \n    public void sendNotification(String message) {\n        emailService.sendEmail(message);\n    }\n}",
            "output": "public interface INotificationService {\n    void sendNotification(String message);\n}\n\npublic class EmailService implements INotificationService {\n    public void sendNotification(String message) {\n        System.out.println(\"Sending email: \" + message);\n    }\n}\n\npublic class NotificationManager {\n    private INotificationService notificationService;\n    \n    public NotificationManager(INotificationService notificationService) {\n        this.notificationService = notificationService;\n    }\n    \n    public void sendNotification(String message) {\n        notificationService.sendNotification(message);\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class MySQLDatabase {\n    public void save(String data) {\n        System.out.println(\"Saving to MySQL: \" + data);\n    }\n}\n\npublic class UserService {\n    private MySQLDatabase database;\n    \n    public UserService() {\n        this.database = new MySQLDatabase();\n    }\n    \n    public void saveUser(String userData) {\n        database.save(userData);\n    }\n}",
            "output": "public interface IDatabase {\n    void save(String data);\n}\n\npublic class MySQLDatabase implements IDatabase {\n    public void save(String data) {\n        System.out.println(\"Saving to MySQL: \" + data);\n    }\n}\n\npublic class UserService {\n    private IDatabase database;\n    \n    public UserService(IDatabase database) {\n        this.database = database;\n    }\n    \n    public void saveUser(String userData) {\n        database.save(userData);\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class FileLogger {\n    public void log(String message) {\n        System.out.println(\"Writing to file: \" + message);\n    }\n}\n\npublic class OrderProcessor {\n    private FileLogger logger;\n    \n    public OrderProcessor() {\n        this.logger = new FileLogger();\n    }\n    \n    public void processOrder(String order) {\n        System.out.println(\"Processing order: \" + order);\n        logger.log(\"Order processed: \" + order);\n    }\n}",
            "output": "public interface ILogger {\n    void log(String message);\n}\n\npublic class FileLogger implements ILogger {\n    public void log(String message) {\n        System.out.println(\"Writing to file: \" + message);\n    }\n}\n\npublic class OrderProcessor {\n    private ILogger logger;\n    \n    public OrderProcessor(ILogger logger) {\n        this.logger = logger;\n    }\n    \n    public void processOrder(String order) {\n        System.out.println(\"Processing order: \" + order);\n        logger.log(\"Order processed: \" + order);\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class SMSGateway {\n    public void sendSMS(String phoneNumber, String message) {\n        System.out.println(\"SMS sent to \" + phoneNumber + \": \" + message);\n    }\n}\n\npublic class AlertSystem {\n    private SMSGateway smsGateway;\n    \n    public AlertSystem() {\n        this.smsGateway = new SMSGateway();\n    }\n    \n    public void sendAlert(String phoneNumber, String alert) {\n        smsGateway.sendSMS(phoneNumber, alert);\n    }\n}",
            "output": "public interface IMessagingService {\n    void sendMessage(String recipient, String message);\n}\n\npublic class SMSGateway implements IMessagingService {\n    public void sendMessage(String phoneNumber, String message) {\n        System.out.println(\"SMS sent to \" + phoneNumber + \": \" + message);\n    }\n}\n\npublic class AlertSystem {\n    private IMessagingService messagingService;\n    \n    public AlertSystem(IMessagingService messagingService) {\n        this.messagingService = messagingService;\n    }\n    \n    public void sendAlert(String recipient, String alert) {\n        messagingService.sendMessage(recipient, alert);\n    }\n}",
            "level": "EASY",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "class EmailSender:\n    def send_email(self, message):\n        print(f\"Sending email: {message}\")\n\nclass NotificationService:\n    def __init__(self):\n        self.email_sender = EmailSender()\n    \n    def notify(self, message):\n        self.email_sender.send_email(message)",
            "output": "from abc import ABC, abstractmethod\n\nclass INotificationSender(ABC):\n    @abstractmethod\n    def send_notification(self, message):\n        pass\n\nclass EmailSender(INotificationSender):\n    def send_notification(self, message):\n        print(f\"Sending email: {message}\")\n\nclass NotificationService:\n    def __init__(self, notification_sender: INotificationSender):\n        self.notification_sender = notification_sender\n    \n    def notify(self, message):\n        self.notification_sender.send_notification(message)",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class FileStorage:\n    def save(self, data):\n        print(f\"Saving to file: {data}\")\n\nclass DocumentManager:\n    def __init__(self):\n        self.storage = FileStorage()\n    \n    def save_document(self, document):\n        self.storage.save(document)",
            "output": "from abc import ABC, abstractmethod\n\nclass IStorage(ABC):\n    @abstractmethod\n    def save(self, data):\n        pass\n\nclass FileStorage(IStorage):\n    def save(self, data):\n        print(f\"Saving to file: {data}\")\n\nclass DocumentManager:\n    def __init__(self, storage: IStorage):\n        self.storage = storage\n    \n    def save_document(self, document):\n        self.storage.save(document)",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class ConsoleLogger:\n    def log(self, message):\n        print(f\"Console: {message}\")\n\nclass PaymentProcessor:\n    def __init__(self):\n        self.logger = ConsoleLogger()\n    \n    def process_payment(self, amount):\n        print(f\"Processing payment: ${amount}\")\n        self.logger.log(f\"Payment processed: ${amount}\")",
            "output": "from abc import ABC, abstractmethod\n\nclass ILogger(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass ConsoleLogger(ILogger):\n    def log(self, message):\n        print(f\"Console: {message}\")\n\nclass PaymentProcessor:\n    def __init__(self, logger: ILogger):\n        self.logger = logger\n    \n    def process_payment(self, amount):\n        print(f\"Processing payment: ${amount}\")\n        self.logger.log(f\"Payment processed: ${amount}\")",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class DatabaseConnection:\n    def execute_query(self, query):\n        print(f\"Executing: {query}\")\n\nclass UserRepository:\n    def __init__(self):\n        self.db = DatabaseConnection()\n    \n    def find_user(self, user_id):\n        query = f\"SELECT * FROM users WHERE id = {user_id}\"\n        return self.db.execute_query(query)",
            "output": "from abc import ABC, abstractmethod\n\nclass IDataConnection(ABC):\n    @abstractmethod\n    def execute_query(self, query):\n        pass\n\nclass DatabaseConnection(IDataConnection):\n    def execute_query(self, query):\n        print(f\"Executing: {query}\")\n\nclass UserRepository:\n    def __init__(self, data_connection: IDataConnection):\n        self.db = data_connection\n    \n    def find_user(self, user_id):\n        query = f\"SELECT * FROM users WHERE id = {user_id}\"\n        return self.db.execute_query(query)",
            "level": "EASY",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class EmailService {\n    fun sendEmail(message: String) {\n        println(\"Sending email: $message\")\n    }\n}\n\nclass OrderService {\n    private val emailService = EmailService()\n    \n    fun completeOrder(orderDetails: String) {\n        println(\"Order completed: $orderDetails\")\n        emailService.sendEmail(\"Order confirmation: $orderDetails\")\n    }\n}",
            "output": "interface INotificationService {\n    fun sendNotification(message: String)\n}\n\nclass EmailService : INotificationService {\n    override fun sendNotification(message: String) {\n        println(\"Sending email: $message\")\n    }\n}\n\nclass OrderService(private val notificationService: INotificationService) {\n    fun completeOrder(orderDetails: String) {\n        println(\"Order completed: $orderDetails\")\n        notificationService.sendNotification(\"Order confirmation: $orderDetails\")\n    }\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class JsonSerializer {\n    fun serialize(data: Any): String {\n        return \"JSON: $data\"\n    }\n}\n\nclass DataExporter {\n    private val serializer = JsonSerializer()\n    \n    fun exportData(data: Any): String {\n        return serializer.serialize(data)\n    }\n}",
            "output": "interface ISerializer {\n    fun serialize(data: Any): String\n}\n\nclass JsonSerializer : ISerializer {\n    override fun serialize(data: Any): String {\n        return \"JSON: $data\"\n    }\n}\n\nclass DataExporter(private val serializer: ISerializer) {\n    fun exportData(data: Any): String {\n        return serializer.serialize(data)\n    }\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class FileReader {\n    fun readFile(filename: String): String {\n        return \"Content of $filename\"\n    }\n}\n\nclass ConfigurationManager {\n    private val fileReader = FileReader()\n    \n    fun loadConfiguration(configFile: String): String {\n        return fileReader.readFile(configFile)\n    }\n}",
            "output": "interface IFileReader {\n    fun readFile(filename: String): String\n}\n\nclass FileReader : IFileReader {\n    override fun readFile(filename: String): String {\n        return \"Content of $filename\"\n    }\n}\n\nclass ConfigurationManager(private val fileReader: IFileReader) {\n    fun loadConfiguration(configFile: String): String {\n        return fileReader.readFile(configFile)\n    }\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class HttpClient {\n    fun get(url: String): String {\n        return \"Response from $url\"\n    }\n}\n\nclass WeatherService {\n    private val httpClient = HttpClient()\n    \n    fun getWeather(city: String): String {\n        val url = \"https://api.weather.com/$city\"\n        return httpClient.get(url)\n    }\n}",
            "output": "interface IHttpClient {\n    fun get(url: String): String\n}\n\nclass HttpClient : IHttpClient {\n    override fun get(url: String): String {\n        return \"Response from $url\"\n    }\n}\n\nclass WeatherService(private val httpClient: IHttpClient) {\n    fun getWeather(city: String): String {\n        val url = \"https://api.weather.com/$city\"\n        return httpClient.get(url)\n    }\n}",
            "level": "EASY",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "public class EmailClient\n{\n    public void SendEmail(string message)\n    {\n        Console.WriteLine($\"Sending email: {message}\");\n    }\n}\n\npublic class CustomerService\n{\n    private EmailClient _emailClient;\n    \n    public CustomerService()\n    {\n        _emailClient = new EmailClient();\n    }\n    \n    public void NotifyCustomer(string message)\n    {\n        _emailClient.SendEmail(message);\n    }\n}",
            "output": "public interface INotificationSender\n{\n    void SendNotification(string message);\n}\n\npublic class EmailClient : INotificationSender\n{\n    public void SendNotification(string message)\n    {\n        Console.WriteLine($\"Sending email: {message}\");\n    }\n}\n\npublic class CustomerService\n{\n    private readonly INotificationSender _notificationSender;\n    \n    public CustomerService(INotificationSender notificationSender)\n    {\n        _notificationSender = notificationSender;\n    }\n    \n    public void NotifyCustomer(string message)\n    {\n        _notificationSender.SendNotification(message);\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class SqlDatabase\n{\n    public void Save(string data)\n    {\n        Console.WriteLine($\"Saving to SQL database: {data}\");\n    }\n}\n\npublic class ProductService\n{\n    private SqlDatabase _database;\n    \n    public ProductService()\n    {\n        _database = new SqlDatabase();\n    }\n    \n    public void SaveProduct(string productData)\n    {\n        _database.Save(productData);\n    }\n}",
            "output": "public interface IDatabase\n{\n    void Save(string data);\n}\n\npublic class SqlDatabase : IDatabase\n{\n    public void Save(string data)\n    {\n        Console.WriteLine($\"Saving to SQL database: {data}\");\n    }\n}\n\npublic class ProductService\n{\n    private readonly IDatabase _database;\n    \n    public ProductService(IDatabase database)\n    {\n        _database = database;\n    }\n    \n    public void SaveProduct(string productData)\n    {\n        _database.Save(productData);\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class TextFileLogger\n{\n    public void WriteLog(string message)\n    {\n        Console.WriteLine($\"Writing to log file: {message}\");\n    }\n}\n\npublic class InventoryManager\n{\n    private TextFileLogger _logger;\n    \n    public InventoryManager()\n    {\n        _logger = new TextFileLogger();\n    }\n    \n    public void UpdateInventory(string item, int quantity)\n    {\n        Console.WriteLine($\"Updating inventory: {item} - {quantity}\");\n        _logger.WriteLog($\"Inventory updated: {item} - {quantity}\");\n    }\n}",
            "output": "public interface ILogger\n{\n    void WriteLog(string message);\n}\n\npublic class TextFileLogger : ILogger\n{\n    public void WriteLog(string message)\n    {\n        Console.WriteLine($\"Writing to log file: {message}\");\n    }\n}\n\npublic class InventoryManager\n{\n    private readonly ILogger _logger;\n    \n    public InventoryManager(ILogger logger)\n    {\n        _logger = logger;\n    }\n    \n    public void UpdateInventory(string item, int quantity)\n    {\n        Console.WriteLine($\"Updating inventory: {item} - {quantity}\");\n        _logger.WriteLog($\"Inventory updated: {item} - {quantity}\");\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class PayPalGateway\n{\n    public void ProcessPayment(decimal amount)\n    {\n        Console.WriteLine($\"Processing PayPal payment: ${amount}\");\n    }\n}\n\npublic class ShoppingCart\n{\n    private PayPalGateway _paymentGateway;\n    \n    public ShoppingCart()\n    {\n        _paymentGateway = new PayPalGateway();\n    }\n    \n    public void Checkout(decimal totalAmount)\n    {\n        Console.WriteLine($\"Checkout initiated for ${totalAmount}\");\n        _paymentGateway.ProcessPayment(totalAmount);\n    }\n}",
            "output": "public interface IPaymentGateway\n{\n    void ProcessPayment(decimal amount);\n}\n\npublic class PayPalGateway : IPaymentGateway\n{\n    public void ProcessPayment(decimal amount)\n    {\n        Console.WriteLine($\"Processing PayPal payment: ${amount}\");\n    }\n}\n\npublic class ShoppingCart\n{\n    private readonly IPaymentGateway _paymentGateway;\n    \n    public ShoppingCart(IPaymentGateway paymentGateway)\n    {\n        _paymentGateway = paymentGateway;\n    }\n    \n    public void Checkout(decimal totalAmount)\n    {\n        Console.WriteLine($\"Checkout initiated for ${totalAmount}\");\n        _paymentGateway.ProcessPayment(totalAmount);\n    }\n}",
            "level": "EASY",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class OrderService {\n    private MySQLDatabase database;\n    private EmailService emailService;\n    \n    public OrderService() {\n        this.database = new MySQLDatabase();\n        this.emailService = new EmailService();\n    }\n    \n    public void processOrder(Order order) {\n        database.save(order);\n        emailService.sendConfirmation(order.getCustomerEmail());\n    }\n}",
            "output": "public interface Database {\n    void save(Order order);\n}\n\npublic interface NotificationService {\n    void sendConfirmation(String email);\n}\n\npublic class OrderService {\n    private final Database database;\n    private final NotificationService notificationService;\n    \n    public OrderService(Database database, NotificationService notificationService) {\n        this.database = database;\n        this.notificationService = notificationService;\n    }\n    \n    public void processOrder(Order order) {\n        database.save(order);\n        notificationService.sendConfirmation(order.getCustomerEmail());\n    }\n}\n\npublic class MySQLDatabase implements Database {\n    @Override\n    public void save(Order order) {\n        // MySQL implementation\n    }\n}\n\npublic class EmailService implements NotificationService {\n    @Override\n    public void sendConfirmation(String email) {\n        // Email implementation\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class PaymentProcessor {\n    private StripePaymentGateway stripeGateway;\n    private FileLogger logger;\n    \n    public PaymentProcessor() {\n        this.stripeGateway = new StripePaymentGateway();\n        this.logger = new FileLogger(\"/var/log/payments.log\");\n    }\n    \n    public boolean processPayment(decimal amount, string cardToken) {\n        try {\n            bool result = stripeGateway.ChargeCard(amount, cardToken);\n            logger.Log($\"Payment processed: {amount}, Success: {result}\");\n            return result;\n        }\n        catch (Exception ex) {\n            logger.Log($\"Payment failed: {ex.Message}\");\n            return false;\n        }\n    }\n}",
            "output": "public interface IPaymentGateway {\n    bool ChargeCard(decimal amount, string cardToken);\n}\n\npublic interface ILogger {\n    void Log(string message);\n}\n\npublic class PaymentProcessor {\n    private readonly IPaymentGateway paymentGateway;\n    private readonly ILogger logger;\n    \n    public PaymentProcessor(IPaymentGateway paymentGateway, ILogger logger) {\n        this.paymentGateway = paymentGateway;\n        this.logger = logger;\n    }\n    \n    public bool ProcessPayment(decimal amount, string cardToken) {\n        try {\n            bool result = paymentGateway.ChargeCard(amount, cardToken);\n            logger.Log($\"Payment processed: {amount}, Success: {result}\");\n            return result;\n        }\n        catch (Exception ex) {\n            logger.Log($\"Payment failed: {ex.Message}\");\n            return false;\n        }\n    }\n}\n\npublic class StripePaymentGateway : IPaymentGateway {\n    public bool ChargeCard(decimal amount, string cardToken) {\n        // Stripe implementation\n        return true;\n    }\n}\n\npublic class FileLogger : ILogger {\n    private readonly string logPath;\n    \n    public FileLogger(string logPath) {\n        this.logPath = logPath;\n    }\n    \n    public void Log(string message) {\n        // File logging implementation\n    }\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "class UserService {\n    private val mongoRepository = MongoUserRepository()\n    private val redisCache = RedisCache()\n    private val twilioSms = TwilioSmsService()\n    \n    fun createUser(userData: UserData): User {\n        val user = User(userData)\n        mongoRepository.save(user)\n        redisCache.store(user.id, user)\n        twilioSms.sendWelcomeSms(user.phoneNumber)\n        return user\n    }\n    \n    fun getUserById(id: String): User? {\n        return redisCache.get(id) ?: mongoRepository.findById(id)\n    }\n    \n    fun updateUserProfile(id: String, updates: Map<String, Any>) {\n        val user = mongoRepository.findById(id)\n        user?.let {\n            val updatedUser = it.copy(updates)\n            mongoRepository.update(updatedUser)\n            redisCache.invalidate(id)\n        }\n    }\n}",
            "output": "interface UserRepository {\n    fun save(user: User)\n    fun findById(id: String): User?\n    fun update(user: User)\n}\n\ninterface CacheService {\n    fun store(key: String, value: User)\n    fun get(key: String): User?\n    fun invalidate(key: String)\n}\n\ninterface SmsService {\n    fun sendWelcomeSms(phoneNumber: String)\n}\n\nclass UserService(\n    private val userRepository: UserRepository,\n    private val cacheService: CacheService,\n    private val smsService: SmsService\n) {\n    fun createUser(userData: UserData): User {\n        val user = User(userData)\n        userRepository.save(user)\n        cacheService.store(user.id, user)\n        smsService.sendWelcomeSms(user.phoneNumber)\n        return user\n    }\n    \n    fun getUserById(id: String): User? {\n        return cacheService.get(id) ?: userRepository.findById(id)\n    }\n    \n    fun updateUserProfile(id: String, updates: Map<String, Any>) {\n        val user = userRepository.findById(id)\n        user?.let {\n            val updatedUser = it.copy(updates)\n            userRepository.update(updatedUser)\n            cacheService.invalidate(id)\n        }\n    }\n}\n\nclass MongoUserRepository : UserRepository {\n    override fun save(user: User) { /* MongoDB implementation */ }\n    override fun findById(id: String): User? { /* MongoDB implementation */ return null }\n    override fun update(user: User) { /* MongoDB implementation */ }\n}\n\nclass RedisCache : CacheService {\n    override fun store(key: String, value: User) { /* Redis implementation */ }\n    override fun get(key: String): User? { /* Redis implementation */ return null }\n    override fun invalidate(key: String) { /* Redis implementation */ }\n}\n\nclass TwilioSmsService : SmsService {\n    override fun sendWelcomeSms(phoneNumber: String) { /* Twilio implementation */ }\n}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class ReportGenerator:\n    def __init__(self):\n        self.pdf_generator = PDFGenerator()\n        self.excel_exporter = ExcelExporter()\n        self.ftp_uploader = FTPUploader('reports.company.com', 'username', 'password')\n        \n    def generate_sales_report(self, sales_data):\n        # Generate PDF report\n        pdf_content = self.pdf_generator.create_pdf(sales_data)\n        \n        # Generate Excel report\n        excel_content = self.excel_exporter.create_excel(sales_data)\n        \n        # Upload both files\n        self.ftp_uploader.upload_file('sales_report.pdf', pdf_content)\n        self.ftp_uploader.upload_file('sales_report.xlsx', excel_content)\n        \n        return {'pdf': pdf_content, 'excel': excel_content}\n    \n    def generate_inventory_report(self, inventory_data):\n        pdf_content = self.pdf_generator.create_pdf(inventory_data)\n        self.ftp_uploader.upload_file('inventory_report.pdf', pdf_content)\n        return pdf_content",
            "output": "from abc import ABC, abstractmethod\n\nclass DocumentGenerator(ABC):\n    @abstractmethod\n    def generate(self, data):\n        pass\n\nclass FileUploader(ABC):\n    @abstractmethod\n    def upload(self, filename, content):\n        pass\n\nclass ReportGenerator:\n    def __init__(self, pdf_generator: DocumentGenerator, excel_generator: DocumentGenerator, uploader: FileUploader):\n        self.pdf_generator = pdf_generator\n        self.excel_generator = excel_generator\n        self.uploader = uploader\n        \n    def generate_sales_report(self, sales_data):\n        # Generate PDF report\n        pdf_content = self.pdf_generator.generate(sales_data)\n        \n        # Generate Excel report\n        excel_content = self.excel_generator.generate(sales_data)\n        \n        # Upload both files\n        self.uploader.upload('sales_report.pdf', pdf_content)\n        self.uploader.upload('sales_report.xlsx', excel_content)\n        \n        return {'pdf': pdf_content, 'excel': excel_content}\n    \n    def generate_inventory_report(self, inventory_data):\n        pdf_content = self.pdf_generator.generate(inventory_data)\n        self.uploader.upload('inventory_report.pdf', pdf_content)\n        return pdf_content\n\nclass PDFGenerator(DocumentGenerator):\n    def generate(self, data):\n        # PDF generation implementation\n        return f\"PDF content for {data}\"\n\nclass ExcelGenerator(DocumentGenerator):\n    def generate(self, data):\n        # Excel generation implementation\n        return f\"Excel content for {data}\"\n\nclass FTPUploader(FileUploader):\n    def __init__(self, host, username, password):\n        self.host = host\n        self.username = username\n        self.password = password\n    \n    def upload(self, filename, content):\n        # FTP upload implementation\n        print(f\"Uploading {filename} to {self.host}\")",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "public class InventoryService {\n    private OracleDatabase database;\n    private SlackNotifier notifier;\n    private AmazonS3Storage storage;\n    \n    public InventoryService() {\n        this.database = new OracleDatabase(\"jdbc:oracle:thin:@localhost:1521:xe\");\n        this.notifier = new SlackNotifier(\"#inventory-alerts\");\n        this.storage = new AmazonS3Storage(\"inventory-bucket\", \"us-west-2\");\n    }\n    \n    public void updateStock(String productId, int quantity) {\n        Product product = database.getProduct(productId);\n        product.setQuantity(quantity);\n        database.updateProduct(product);\n        \n        if (quantity < 10) {\n            notifier.sendLowStockAlert(product.getName(), quantity);\n        }\n        \n        String inventoryReport = generateReport(product);\n        storage.uploadFile(\"reports/\" + productId + \".json\", inventoryReport);\n    }\n    \n    private String generateReport(Product product) {\n        return \"{\\\"productId\\\":\\\"\" + product.getId() + \"\\\",\\\"quantity\\\":\" + product.getQuantity() + \"}\";\n    }\n}",
            "output": "public interface ProductRepository {\n    Product getProduct(String productId);\n    void updateProduct(Product product);\n}\n\npublic interface AlertService {\n    void sendLowStockAlert(String productName, int quantity);\n}\n\npublic interface CloudStorage {\n    void uploadFile(String path, String content);\n}\n\npublic class InventoryService {\n    private final ProductRepository repository;\n    private final AlertService alertService;\n    private final CloudStorage storage;\n    \n    public InventoryService(ProductRepository repository, AlertService alertService, CloudStorage storage) {\n        this.repository = repository;\n        this.alertService = alertService;\n        this.storage = storage;\n    }\n    \n    public void updateStock(String productId, int quantity) {\n        Product product = repository.getProduct(productId);\n        product.setQuantity(quantity);\n        repository.updateProduct(product);\n        \n        if (quantity < 10) {\n            alertService.sendLowStockAlert(product.getName(), quantity);\n        }\n        \n        String inventoryReport = generateReport(product);\n        storage.uploadFile(\"reports/\" + productId + \".json\", inventoryReport);\n    }\n    \n    private String generateReport(Product product) {\n        return \"{\\\"productId\\\":\\\"\" + product.getId() + \"\\\",\\\"quantity\\\":\" + product.getQuantity() + \"}\";\n    }\n}\n\npublic class OracleProductRepository implements ProductRepository {\n    private final String connectionString;\n    \n    public OracleProductRepository(String connectionString) {\n        this.connectionString = connectionString;\n    }\n    \n    @Override\n    public Product getProduct(String productId) {\n        // Oracle implementation\n        return new Product();\n    }\n    \n    @Override\n    public void updateProduct(Product product) {\n        // Oracle implementation\n    }\n}\n\npublic class SlackAlertService implements AlertService {\n    private final String channel;\n    \n    public SlackAlertService(String channel) {\n        this.channel = channel;\n    }\n    \n    @Override\n    public void sendLowStockAlert(String productName, int quantity) {\n        // Slack implementation\n    }\n}\n\npublic class AmazonS3Storage implements CloudStorage {\n    private final String bucket;\n    private final String region;\n    \n    public AmazonS3Storage(String bucket, String region) {\n        this.bucket = bucket;\n        this.region = region;\n    }\n    \n    @Override\n    public void uploadFile(String path, String content) {\n        // S3 implementation\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class CustomerService {\n    private SqlServerCustomerRepository customerRepository;\n    private SendGridEmailService emailService;\n    private TwilioSmsService smsService;\n    private RedisCacheService cacheService;\n    \n    public CustomerService() {\n        this.customerRepository = new SqlServerCustomerRepository();\n        this.emailService = new SendGridEmailService();\n        this.smsService = new TwilioSmsService();\n        this.cacheService = new RedisCacheService();\n    }\n    \n    public async Task<Customer> GetCustomerAsync(int customerId) {\n        var cachedCustomer = cacheService.Get<Customer>($\"customer_{customerId}\");\n        if (cachedCustomer != null) {\n            return cachedCustomer;\n        }\n        \n        var customer = await customerRepository.GetByIdAsync(customerId);\n        cacheService.Set($\"customer_{customerId}\", customer, TimeSpan.FromMinutes(30));\n        return customer;\n    }\n    \n    public async Task SendPromotionAsync(int customerId, string promotionMessage) {\n        var customer = await GetCustomerAsync(customerId);\n        \n        if (customer.PreferredContact == \"Email\") {\n            await emailService.SendEmailAsync(customer.Email, \"Special Promotion\", promotionMessage);\n        }\n        else if (customer.PreferredContact == \"SMS\") {\n            await smsService.SendSmsAsync(customer.PhoneNumber, promotionMessage);\n        }\n    }\n}",
            "output": "public interface ICustomerRepository {\n    Task<Customer> GetByIdAsync(int customerId);\n}\n\npublic interface IEmailService {\n    Task SendEmailAsync(string email, string subject, string message);\n}\n\npublic interface ISmsService {\n    Task SendSmsAsync(string phoneNumber, string message);\n}\n\npublic interface ICacheService {\n    T Get<T>(string key);\n    void Set<T>(string key, T value, TimeSpan expiration);\n}\n\npublic class CustomerService {\n    private readonly ICustomerRepository customerRepository;\n    private readonly IEmailService emailService;\n    private readonly ISmsService smsService;\n    private readonly ICacheService cacheService;\n    \n    public CustomerService(\n        ICustomerRepository customerRepository,\n        IEmailService emailService,\n        ISmsService smsService,\n        ICacheService cacheService) {\n        this.customerRepository = customerRepository;\n        this.emailService = emailService;\n        this.smsService = smsService;\n        this.cacheService = cacheService;\n    }\n    \n    public async Task<Customer> GetCustomerAsync(int customerId) {\n        var cachedCustomer = cacheService.Get<Customer>($\"customer_{customerId}\");\n        if (cachedCustomer != null) {\n            return cachedCustomer;\n        }\n        \n        var customer = await customerRepository.GetByIdAsync(customerId);\n        cacheService.Set($\"customer_{customerId}\", customer, TimeSpan.FromMinutes(30));\n        return customer;\n    }\n    \n    public async Task SendPromotionAsync(int customerId, string promotionMessage) {\n        var customer = await GetCustomerAsync(customerId);\n        \n        if (customer.PreferredContact == \"Email\") {\n            await emailService.SendEmailAsync(customer.Email, \"Special Promotion\", promotionMessage);\n        }\n        else if (customer.PreferredContact == \"SMS\") {\n            await smsService.SendSmsAsync(customer.PhoneNumber, promotionMessage);\n        }\n    }\n}\n\npublic class SqlServerCustomerRepository : ICustomerRepository {\n    public async Task<Customer> GetByIdAsync(int customerId) {\n        // SQL Server implementation\n        return new Customer();\n    }\n}\n\npublic class SendGridEmailService : IEmailService {\n    public async Task SendEmailAsync(string email, string subject, string message) {\n        // SendGrid implementation\n    }\n}\n\npublic class TwilioSmsService : ISmsService {\n    public async Task SendSmsAsync(string phoneNumber, string message) {\n        // Twilio implementation\n    }\n}\n\npublic class RedisCacheService : ICacheService {\n    public T Get<T>(string key) {\n        // Redis implementation\n        return default(T);\n    }\n    \n    public void Set<T>(string key, T value, TimeSpan expiration) {\n        // Redis implementation\n    }\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "class OrderProcessor {\n    private val postgresOrderRepo = PostgresOrderRepository()\n    private val stripePaymentService = StripePaymentService()\n    private val elasticsearchLogger = ElasticsearchLogger()\n    private val rabbitMqPublisher = RabbitMQEventPublisher()\n    \n    fun processOrder(orderRequest: OrderRequest): OrderResult {\n        try {\n            // Create order\n            val order = Order(\n                id = generateOrderId(),\n                customerId = orderRequest.customerId,\n                items = orderRequest.items,\n                totalAmount = calculateTotal(orderRequest.items)\n            )\n            \n            // Save to database\n            postgresOrderRepo.save(order)\n            \n            // Process payment\n            val paymentResult = stripePaymentService.processPayment(\n                order.totalAmount,\n                orderRequest.paymentToken\n            )\n            \n            if (paymentResult.isSuccessful) {\n                // Update order status\n                order.status = OrderStatus.PAID\n                postgresOrderRepo.update(order)\n                \n                // Log success\n                elasticsearchLogger.logOrderProcessed(order)\n                \n                // Publish event\n                rabbitMqPublisher.publishOrderCompleted(order)\n                \n                return OrderResult.success(order)\n            } else {\n                elasticsearchLogger.logPaymentFailed(order, paymentResult.errorMessage)\n                return OrderResult.failure(\"Payment failed: ${paymentResult.errorMessage}\")\n            }\n        } catch (e: Exception) {\n            elasticsearchLogger.logError(\"Order processing failed\", e)\n            return OrderResult.failure(\"Order processing failed: ${e.message}\")\n        }\n    }\n    \n    private fun calculateTotal(items: List<OrderItem>): BigDecimal {\n        return items.sumOf { it.price * it.quantity.toBigDecimal() }\n    }\n    \n    private fun generateOrderId(): String {\n        return \"ORD-${System.currentTimeMillis()}\"\n    }\n}",
            "output": "interface OrderRepository {\n    fun save(order: Order)\n    fun update(order: Order)\n}\n\ninterface PaymentService {\n    fun processPayment(amount: BigDecimal, paymentToken: String): PaymentResult\n}\n\ninterface Logger {\n    fun logOrderProcessed(order: Order)\n    fun logPaymentFailed(order: Order, errorMessage: String)\n    fun logError(message: String, exception: Exception)\n}\n\ninterface EventPublisher {\n    fun publishOrderCompleted(order: Order)\n}\n\nclass OrderProcessor(\n    private val orderRepository: OrderRepository,\n    private val paymentService: PaymentService,\n    private val logger: Logger,\n    private val eventPublisher: EventPublisher\n) {\n    fun processOrder(orderRequest: OrderRequest): OrderResult {\n        try {\n            // Create order\n            val order = Order(\n                id = generateOrderId(),\n                customerId = orderRequest.customerId,\n                items = orderRequest.items,\n                totalAmount = calculateTotal(orderRequest.items)\n            )\n            \n            // Save to database\n            orderRepository.save(order)\n            \n            // Process payment\n            val paymentResult = paymentService.processPayment(\n                order.totalAmount,\n                orderRequest.paymentToken\n            )\n            \n            if (paymentResult.isSuccessful) {\n                // Update order status\n                order.status = OrderStatus.PAID\n                orderRepository.update(order)\n                \n                // Log success\n                logger.logOrderProcessed(order)\n                \n                // Publish event\n                eventPublisher.publishOrderCompleted(order)\n                \n                return OrderResult.success(order)\n            } else {\n                logger.logPaymentFailed(order, paymentResult.errorMessage)\n                return OrderResult.failure(\"Payment failed: ${paymentResult.errorMessage}\")\n            }\n        } catch (e: Exception) {\n            logger.logError(\"Order processing failed\", e)\n            return OrderResult.failure(\"Order processing failed: ${e.message}\")\n        }\n    }\n    \n    private fun calculateTotal(items: List<OrderItem>): BigDecimal {\n        return items.sumOf { it.price * it.quantity.toBigDecimal() }\n    }\n    \n    private fun generateOrderId(): String {\n        return \"ORD-${System.currentTimeMillis()}\"\n    }\n}\n\nclass PostgresOrderRepository : OrderRepository {\n    override fun save(order: Order) {\n        // PostgreSQL implementation\n    }\n    \n    override fun update(order: Order) {\n        // PostgreSQL implementation\n    }\n}\n\nclass StripePaymentService : PaymentService {\n    override fun processPayment(amount: BigDecimal, paymentToken: String): PaymentResult {\n        // Stripe implementation\n        return PaymentResult(true, null)\n    }\n}\n\nclass ElasticsearchLogger : Logger {\n    override fun logOrderProcessed(order: Order) {\n        // Elasticsearch implementation\n    }\n    \n    override fun logPaymentFailed(order: Order, errorMessage: String) {\n        // Elasticsearch implementation\n    }\n    \n    override fun logError(message: String, exception: Exception) {\n        // Elasticsearch implementation\n    }\n}\n\nclass RabbitMQEventPublisher : EventPublisher {\n    override fun publishOrderCompleted(order: Order) {\n        // RabbitMQ implementation\n    }\n}",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class AuthenticationService:\n    def __init__(self):\n        self.jwt_handler = JWTTokenHandler()\n        self.bcrypt_hasher = BCryptPasswordHasher()\n        self.mysql_user_repo = MySQLUserRepository()\n        self.redis_session_store = RedisSessionStore()\n        self.sendgrid_mailer = SendGridMailer()\n        \n    def authenticate_user(self, email, password):\n        # Get user from database\n        user = self.mysql_user_repo.find_by_email(email)\n        if not user:\n            return {'success': False, 'message': 'User not found'}\n            \n        # Verify password\n        if not self.bcrypt_hasher.verify_password(password, user.password_hash):\n            return {'success': False, 'message': 'Invalid password'}\n            \n        # Generate JWT token\n        token = self.jwt_handler.generate_token({\n            'user_id': user.id,\n            'email': user.email,\n            'roles': user.roles\n        })\n        \n        # Store session\n        session_id = self.redis_session_store.create_session(user.id, token)\n        \n        # Send login notification email\n        self.sendgrid_mailer.send_email(\n            to=user.email,\n            subject='Login Notification',\n            body=f'You have successfully logged in at {datetime.now()}'\n        )\n        \n        return {\n            'success': True,\n            'token': token,\n            'session_id': session_id,\n            'user': {\n                'id': user.id,\n                'email': user.email,\n                'roles': user.roles\n            }\n        }\n    \n    def validate_token(self, token):\n        try:\n            payload = self.jwt_handler.decode_token(token)\n            session_exists = self.redis_session_store.validate_session(\n                payload['user_id'], \n                token\n            )\n            return session_exists and payload\n        except Exception:\n            return False\n    \n    def logout_user(self, user_id, token):\n        self.redis_session_store.delete_session(user_id, token)\n        return {'success': True, 'message': 'Logged out successfully'}",
            "output": "from abc import ABC, abstractmethod\nfrom datetime import datetime\n\nclass TokenHandler(ABC):\n    @abstractmethod\n    def generate_token(self, payload):\n        pass\n    \n    @abstractmethod\n    def decode_token(self, token):\n        pass\n\nclass PasswordHasher(ABC):\n    @abstractmethod\n    def verify_password(self, password, hash):\n        pass\n\nclass UserRepository(ABC):\n    @abstractmethod\n    def find_by_email(self, email):\n        pass\n\nclass SessionStore(ABC):\n    @abstractmethod\n    def create_session(self, user_id, token):\n        pass\n    \n    @abstractmethod\n    def validate_session(self, user_id, token):\n        pass\n    \n    @abstractmethod\n    def delete_session(self, user_id, token):\n        pass\n\nclass EmailService(ABC):\n    @abstractmethod\n    def send_email(self, to, subject, body):\n        pass\n\nclass AuthenticationService:\n    def __init__(self, token_handler: TokenHandler, password_hasher: PasswordHasher,\n                 user_repository: UserRepository, session_store: SessionStore,\n                 email_service: EmailService):\n        self.token_handler = token_handler\n        self.password_hasher = password_hasher\n        self.user_repository = user_repository\n        self.session_store = session_store\n        self.email_service = email_service\n        \n    def authenticate_user(self, email, password):\n        # Get user from database\n        user = self.user_repository.find_by_email(email)\n        if not user:\n            return {'success': False, 'message': 'User not found'}\n            \n        # Verify password\n        if not self.password_hasher.verify_password(password, user.password_hash):\n            return {'success': False, 'message': 'Invalid password'}\n            \n        # Generate JWT token\n        token = self.token_handler.generate_token({\n            'user_id': user.id,\n            'email': user.email,\n            'roles': user.roles\n        })\n        \n        # Store session\n        session_id = self.session_store.create_session(user.id, token)\n        \n        # Send login notification email\n        self.email_service.send_email(\n            to=user.email,\n            subject='Login Notification',\n            body=f'You have successfully logged in at {datetime.now()}'\n        )\n        \n        return {\n            'success': True,\n            'token': token,\n            'session_id': session_id,\n            'user': {\n                'id': user.id,\n                'email': user.email,\n                'roles': user.roles\n            }\n        }\n    \n    def validate_token(self, token):\n        try:\n            payload = self.token_handler.decode_token(token)\n            session_exists = self.session_store.validate_session(\n                payload['user_id'], \n                token\n            )\n            return session_exists and payload\n        except Exception:\n            return False\n    \n    def logout_user(self, user_id, token):\n        self.session_store.delete_session(user_id, token)\n        return {'success': True, 'message': 'Logged out successfully'}\n\n# Concrete implementations\nclass JWTTokenHandler(TokenHandler):\n    def generate_token(self, payload):\n        # JWT implementation\n        return \"jwt_token_here\"\n    \n    def decode_token(self, token):\n        # JWT decode implementation\n        return {'user_id': 1, 'email': 'user@example.com'}\n\nclass BCryptPasswordHasher(PasswordHasher):\n    def verify_password(self, password, hash):\n        # BCrypt implementation\n        return True\n\nclass MySQLUserRepository(UserRepository):\n    def find_by_email(self, email):\n        # MySQL implementation\n        return None\n\nclass RedisSessionStore(SessionStore):\n    def create_session(self, user_id, token):\n        # Redis implementation\n        return \"session_id\"\n    \n    def validate_session(self, user_id, token):\n        # Redis implementation\n        return True\n    \n    def delete_session(self, user_id, token):\n        # Redis implementation\n        pass\n\nclass SendGridEmailService(EmailService):\n    def send_email(self, to, subject, body):\n        # SendGrid implementation\n        print(f\"Sending email to {to}: {subject}\")",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "public class OrderService {\n    private MySQLDatabase database;\n    private EmailService emailService;\n    \n    public OrderService() {\n        this.database = new MySQLDatabase();\n        this.emailService = new EmailService();\n    }\n    \n    public void processOrder(Order order) {\n        database.save(order);\n        emailService.sendConfirmation(order.getCustomerEmail());\n    }\n}\n\npublic class MySQLDatabase {\n    public void save(Order order) {\n        // MySQL specific implementation\n    }\n}\n\npublic class EmailService {\n    public void sendConfirmation(String email) {\n        // SMTP email implementation\n    }\n}",
            "output": "public interface DatabaseRepository {\n    void save(Order order);\n}\n\npublic interface NotificationService {\n    void sendConfirmation(String email);\n}\n\npublic class OrderService {\n    private DatabaseRepository database;\n    private NotificationService notificationService;\n    \n    public OrderService(DatabaseRepository database, NotificationService notificationService) {\n        this.database = database;\n        this.notificationService = notificationService;\n    }\n    \n    public void processOrder(Order order) {\n        database.save(order);\n        notificationService.sendConfirmation(order.getCustomerEmail());\n    }\n}\n\npublic class MySQLDatabase implements DatabaseRepository {\n    public void save(Order order) {\n        // MySQL specific implementation\n    }\n}\n\npublic class EmailService implements NotificationService {\n    public void sendConfirmation(String email) {\n        // SMTP email implementation\n    }\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "class PaymentProcessor:\n    def __init__(self):\n        self.stripe_gateway = StripePaymentGateway()\n        self.logger = FileLogger()\n    \n    def process_payment(self, amount, card_details):\n        try:\n            result = self.stripe_gateway.charge(amount, card_details)\n            self.logger.log(f\"Payment processed: {result}\")\n            return result\n        except Exception as e:\n            self.logger.log(f\"Payment failed: {e}\")\n            raise\n\nclass StripePaymentGateway:\n    def charge(self, amount, card_details):\n        # Stripe-specific implementation\n        return {\"transaction_id\": \"stripe_123\", \"status\": \"success\"}\n\nclass FileLogger:\n    def log(self, message):\n        with open(\"payment.log\", \"a\") as f:\n            f.write(f\"{message}\\n\")",
            "output": "from abc import ABC, abstractmethod\n\nclass PaymentGateway(ABC):\n    @abstractmethod\n    def charge(self, amount, card_details):\n        pass\n\nclass Logger(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass PaymentProcessor:\n    def __init__(self, payment_gateway: PaymentGateway, logger: Logger):\n        self.payment_gateway = payment_gateway\n        self.logger = logger\n    \n    def process_payment(self, amount, card_details):\n        try:\n            result = self.payment_gateway.charge(amount, card_details)\n            self.logger.log(f\"Payment processed: {result}\")\n            return result\n        except Exception as e:\n            self.logger.log(f\"Payment failed: {e}\")\n            raise\n\nclass StripePaymentGateway(PaymentGateway):\n    def charge(self, amount, card_details):\n        # Stripe-specific implementation\n        return {\"transaction_id\": \"stripe_123\", \"status\": \"success\"}\n\nclass FileLogger(Logger):\n    def log(self, message):\n        with open(\"payment.log\", \"a\") as f:\n            f.write(f\"{message}\\n\")",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class UserService {\n    private val apiClient = HttpApiClient()\n    private val cache = RedisCache()\n    \n    fun getUserProfile(userId: String): UserProfile? {\n        val cachedProfile = cache.get(\"user_$userId\")\n        if (cachedProfile != null) {\n            return cachedProfile as UserProfile\n        }\n        \n        val profile = apiClient.fetchUserProfile(userId)\n        if (profile != null) {\n            cache.set(\"user_$userId\", profile, 3600)\n        }\n        return profile\n    }\n}\n\nclass HttpApiClient {\n    fun fetchUserProfile(userId: String): UserProfile? {\n        // REST API call implementation\n        return UserProfile(userId, \"John Doe\", \"john@example.com\")\n    }\n}\n\nclass RedisCache {\n    fun get(key: String): Any? {\n        // Redis get implementation\n        return null\n    }\n    \n    fun set(key: String, value: Any, ttl: Int) {\n        // Redis set implementation\n    }\n}\n\ndata class UserProfile(val id: String, val name: String, val email: String)",
            "output": "interface ApiClient {\n    fun fetchUserProfile(userId: String): UserProfile?\n}\n\ninterface CacheService {\n    fun get(key: String): Any?\n    fun set(key: String, value: Any, ttl: Int)\n}\n\nclass UserService(private val apiClient: ApiClient, private val cache: CacheService) {\n    fun getUserProfile(userId: String): UserProfile? {\n        val cachedProfile = cache.get(\"user_$userId\")\n        if (cachedProfile != null) {\n            return cachedProfile as UserProfile\n        }\n        \n        val profile = apiClient.fetchUserProfile(userId)\n        if (profile != null) {\n            cache.set(\"user_$userId\", profile, 3600)\n        }\n        return profile\n    }\n}\n\nclass HttpApiClient : ApiClient {\n    override fun fetchUserProfile(userId: String): UserProfile? {\n        // REST API call implementation\n        return UserProfile(userId, \"John Doe\", \"john@example.com\")\n    }\n}\n\nclass RedisCache : CacheService {\n    override fun get(key: String): Any? {\n        // Redis get implementation\n        return null\n    }\n    \n    override fun set(key: String, value: Any, ttl: Int) {\n        // Redis set implementation\n    }\n}\n\ndata class UserProfile(val id: String, val name: String, val email: String)",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "public class InventoryManager\n{\n    private SqlServerDatabase database;\n    private SmsNotificationService smsService;\n    \n    public InventoryManager()\n    {\n        database = new SqlServerDatabase();\n        smsService = new SmsNotificationService();\n    }\n    \n    public void UpdateStock(string productId, int quantity)\n    {\n        var product = database.GetProduct(productId);\n        product.Stock += quantity;\n        database.UpdateProduct(product);\n        \n        if (product.Stock < 10)\n        {\n            smsService.SendLowStockAlert(product.Name, product.Stock);\n        }\n    }\n}\n\npublic class SqlServerDatabase\n{\n    public Product GetProduct(string productId)\n    {\n        // SQL Server specific query\n        return new Product { Id = productId, Name = \"Sample\", Stock = 5 };\n    }\n    \n    public void UpdateProduct(Product product)\n    {\n        // SQL Server specific update\n    }\n}\n\npublic class SmsNotificationService\n{\n    public void SendLowStockAlert(string productName, int stock)\n    {\n        // SMS service implementation\n    }\n}\n\npublic class Product\n{\n    public string Id { get; set; }\n    public string Name { get; set; }\n    public int Stock { get; set; }\n}",
            "output": "public interface IProductRepository\n{\n    Product GetProduct(string productId);\n    void UpdateProduct(Product product);\n}\n\npublic interface INotificationService\n{\n    void SendLowStockAlert(string productName, int stock);\n}\n\npublic class InventoryManager\n{\n    private readonly IProductRepository repository;\n    private readonly INotificationService notificationService;\n    \n    public InventoryManager(IProductRepository repository, INotificationService notificationService)\n    {\n        this.repository = repository;\n        this.notificationService = notificationService;\n    }\n    \n    public void UpdateStock(string productId, int quantity)\n    {\n        var product = repository.GetProduct(productId);\n        product.Stock += quantity;\n        repository.UpdateProduct(product);\n        \n        if (product.Stock < 10)\n        {\n            notificationService.SendLowStockAlert(product.Name, product.Stock);\n        }\n    }\n}\n\npublic class SqlServerDatabase : IProductRepository\n{\n    public Product GetProduct(string productId)\n    {\n        // SQL Server specific query\n        return new Product { Id = productId, Name = \"Sample\", Stock = 5 };\n    }\n    \n    public void UpdateProduct(Product product)\n    {\n        // SQL Server specific update\n    }\n}\n\npublic class SmsNotificationService : INotificationService\n{\n    public void SendLowStockAlert(string productName, int stock)\n    {\n        // SMS service implementation\n    }\n}\n\npublic class Product\n{\n    public string Id { get; set; }\n    public string Name { get; set; }\n    public int Stock { get; set; }\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class ReportGenerator {\n    private PdfWriter pdfWriter;\n    private DatabaseConnection dbConnection;\n    \n    public ReportGenerator() {\n        this.pdfWriter = new PdfWriter();\n        this.dbConnection = new OracleConnection();\n    }\n    \n    public void generateSalesReport(String period) {\n        List<SalesData> data = dbConnection.getSalesData(period);\n        String content = formatSalesData(data);\n        pdfWriter.writeToPdf(content, \"sales_report.pdf\");\n    }\n    \n    private String formatSalesData(List<SalesData> data) {\n        return \"Sales Report Content\";\n    }\n}\n\npublic class PdfWriter {\n    public void writeToPdf(String content, String filename) {\n        // PDF generation logic\n    }\n}\n\npublic class OracleConnection {\n    public List<SalesData> getSalesData(String period) {\n        // Oracle specific query\n        return new ArrayList<>();\n    }\n}\n\npublic class SalesData {\n    private String product;\n    private double amount;\n    // getters and setters\n}",
            "output": "public interface DocumentWriter {\n    void writeDocument(String content, String filename);\n}\n\npublic interface DataRepository {\n    List<SalesData> getSalesData(String period);\n}\n\npublic class ReportGenerator {\n    private final DocumentWriter documentWriter;\n    private final DataRepository dataRepository;\n    \n    public ReportGenerator(DocumentWriter documentWriter, DataRepository dataRepository) {\n        this.documentWriter = documentWriter;\n        this.dataRepository = dataRepository;\n    }\n    \n    public void generateSalesReport(String period) {\n        List<SalesData> data = dataRepository.getSalesData(period);\n        String content = formatSalesData(data);\n        documentWriter.writeDocument(content, \"sales_report.pdf\");\n    }\n    \n    private String formatSalesData(List<SalesData> data) {\n        return \"Sales Report Content\";\n    }\n}\n\npublic class PdfWriter implements DocumentWriter {\n    public void writeDocument(String content, String filename) {\n        // PDF generation logic\n    }\n}\n\npublic class OracleConnection implements DataRepository {\n    public List<SalesData> getSalesData(String period) {\n        // Oracle specific query\n        return new ArrayList<>();\n    }\n}\n\npublic class SalesData {\n    private String product;\n    private double amount;\n    // getters and setters\n}",
            "level": "MODERATE",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "class WeatherService:\n    def __init__(self):\n        self.weather_api = OpenWeatherMapAPI()\n        self.geocoder = GoogleGeocoder()\n        self.cache = MemoryCache()\n    \n    def get_weather_forecast(self, city_name):\n        cache_key = f\"weather_{city_name}\"\n        cached_result = self.cache.get(cache_key)\n        \n        if cached_result:\n            return cached_result\n        \n        coordinates = self.geocoder.get_coordinates(city_name)\n        weather_data = self.weather_api.get_forecast(coordinates['lat'], coordinates['lon'])\n        \n        self.cache.set(cache_key, weather_data, 1800)  # 30 minutes\n        return weather_data\n\nclass OpenWeatherMapAPI:\n    def get_forecast(self, lat, lon):\n        # OpenWeatherMap API call\n        return {\"temperature\": 25, \"description\": \"sunny\"}\n\nclass GoogleGeocoder:\n    def get_coordinates(self, city_name):\n        # Google Geocoding API call\n        return {\"lat\": 40.7128, \"lon\": -74.0060}\n\nclass MemoryCache:\n    def __init__(self):\n        self.cache = {}\n    \n    def get(self, key):\n        return self.cache.get(key)\n    \n    def set(self, key, value, ttl):\n        self.cache[key] = value",
            "output": "from abc import ABC, abstractmethod\n\nclass WeatherAPI(ABC):\n    @abstractmethod\n    def get_forecast(self, lat, lon):\n        pass\n\nclass GeocodingService(ABC):\n    @abstractmethod\n    def get_coordinates(self, city_name):\n        pass\n\nclass CacheProvider(ABC):\n    @abstractmethod\n    def get(self, key):\n        pass\n    \n    @abstractmethod\n    def set(self, key, value, ttl):\n        pass\n\nclass WeatherService:\n    def __init__(self, weather_api: WeatherAPI, geocoder: GeocodingService, cache: CacheProvider):\n        self.weather_api = weather_api\n        self.geocoder = geocoder\n        self.cache = cache\n    \n    def get_weather_forecast(self, city_name):\n        cache_key = f\"weather_{city_name}\"\n        cached_result = self.cache.get(cache_key)\n        \n        if cached_result:\n            return cached_result\n        \n        coordinates = self.geocoder.get_coordinates(city_name)\n        weather_data = self.weather_api.get_forecast(coordinates['lat'], coordinates['lon'])\n        \n        self.cache.set(cache_key, weather_data, 1800)  # 30 minutes\n        return weather_data\n\nclass OpenWeatherMapAPI(WeatherAPI):\n    def get_forecast(self, lat, lon):\n        # OpenWeatherMap API call\n        return {\"temperature\": 25, \"description\": \"sunny\"}\n\nclass GoogleGeocoder(GeocodingService):\n    def get_coordinates(self, city_name):\n        # Google Geocoding API call\n        return {\"lat\": 40.7128, \"lon\": -74.0060}\n\nclass MemoryCache(CacheProvider):\n    def __init__(self):\n        self.cache = {}\n    \n    def get(self, key):\n        return self.cache.get(key)\n    \n    def set(self, key, value, ttl):\n        self.cache[key] = value",
            "level": "MODERATE",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class TaskScheduler {\n    private val taskQueue = RabbitMQQueue()\n    private val taskExecutor = ThreadPoolExecutor()\n    private val monitor = SystemMonitor()\n    \n    fun scheduleTask(task: Task) {\n        val systemLoad = monitor.getCpuUsage()\n        \n        if (systemLoad < 0.8) {\n            taskExecutor.executeImmediately(task)\n        } else {\n            taskQueue.enqueue(task)\n        }\n    }\n    \n    fun processQueuedTasks() {\n        while (taskQueue.hasItems() && monitor.getCpuUsage() < 0.7) {\n            val task = taskQueue.dequeue()\n            taskExecutor.executeImmediately(task)\n        }\n    }\n}\n\nclass RabbitMQQueue {\n    private val items = mutableListOf<Task>()\n    \n    fun enqueue(task: Task) {\n        items.add(task)\n    }\n    \n    fun dequeue(): Task {\n        return items.removeAt(0)\n    }\n    \n    fun hasItems(): Boolean {\n        return items.isNotEmpty()\n    }\n}\n\nclass ThreadPoolExecutor {\n    fun executeImmediately(task: Task) {\n        // Thread pool execution\n    }\n}\n\nclass SystemMonitor {\n    fun getCpuUsage(): Double {\n        // System monitoring logic\n        return 0.5\n    }\n}\n\ndata class Task(val id: String, val payload: String)",
            "output": "interface TaskQueue {\n    fun enqueue(task: Task)\n    fun dequeue(): Task\n    fun hasItems(): Boolean\n}\n\ninterface TaskExecutor {\n    fun executeImmediately(task: Task)\n}\n\ninterface SystemMonitor {\n    fun getCpuUsage(): Double\n}\n\nclass TaskScheduler(\n    private val taskQueue: TaskQueue,\n    private val taskExecutor: TaskExecutor,\n    private val monitor: SystemMonitor\n) {\n    fun scheduleTask(task: Task) {\n        val systemLoad = monitor.getCpuUsage()\n        \n        if (systemLoad < 0.8) {\n            taskExecutor.executeImmediately(task)\n        } else {\n            taskQueue.enqueue(task)\n        }\n    }\n    \n    fun processQueuedTasks() {\n        while (taskQueue.hasItems() && monitor.getCpuUsage() < 0.7) {\n            val task = taskQueue.dequeue()\n            taskExecutor.executeImmediately(task)\n        }\n    }\n}\n\nclass RabbitMQQueue : TaskQueue {\n    private val items = mutableListOf<Task>()\n    \n    override fun enqueue(task: Task) {\n        items.add(task)\n    }\n    \n    override fun dequeue(): Task {\n        return items.removeAt(0)\n    }\n    \n    override fun hasItems(): Boolean {\n        return items.isNotEmpty()\n    }\n}\n\nclass ThreadPoolTaskExecutor : TaskExecutor {\n    override fun executeImmediately(task: Task) {\n        // Thread pool execution\n    }\n}\n\nclass CpuSystemMonitor : SystemMonitor {\n    override fun getCpuUsage(): Double {\n        // System monitoring logic\n        return 0.5\n    }\n}\n\ndata class Task(val id: String, val payload: String)",
            "level": "MODERATE",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "public class OrderFulfillmentService\n{\n    private InventorySystem inventorySystem;\n    private ShippingProvider shippingProvider;\n    private AuditLogger auditLogger;\n    \n    public OrderFulfillmentService()\n    {\n        inventorySystem = new WarehouseInventorySystem();\n        shippingProvider = new FedExShippingProvider();\n        auditLogger = new DatabaseAuditLogger();\n    }\n    \n    public bool FulfillOrder(Order order)\n    {\n        auditLogger.LogEvent($\"Starting fulfillment for order {order.Id}\");\n        \n        if (!inventorySystem.IsItemAvailable(order.ProductId, order.Quantity))\n        {\n            auditLogger.LogEvent($\"Insufficient inventory for order {order.Id}\");\n            return false;\n        }\n        \n        inventorySystem.ReserveItem(order.ProductId, order.Quantity);\n        var trackingNumber = shippingProvider.CreateShipment(order);\n        \n        auditLogger.LogEvent($\"Order {order.Id} fulfilled with tracking {trackingNumber}\");\n        return true;\n    }\n}\n\npublic class WarehouseInventorySystem\n{\n    public bool IsItemAvailable(string productId, int quantity)\n    {\n        // Warehouse specific inventory check\n        return true;\n    }\n    \n    public void ReserveItem(string productId, int quantity)\n    {\n        // Reserve inventory\n    }\n}\n\npublic class FedExShippingProvider\n{\n    public string CreateShipment(Order order)\n    {\n        // FedEx API integration\n        return \"FEDEX123456\";\n    }\n}\n\npublic class DatabaseAuditLogger\n{\n    public void LogEvent(string message)\n    {\n        // Database logging\n    }\n}\n\npublic class Order\n{\n    public string Id { get; set; }\n    public string ProductId { get; set; }\n    public int Quantity { get; set; }\n    public string CustomerAddress { get; set; }\n}",
            "output": "public interface IInventorySystem\n{\n    bool IsItemAvailable(string productId, int quantity);\n    void ReserveItem(string productId, int quantity);\n}\n\npublic interface IShippingProvider\n{\n    string CreateShipment(Order order);\n}\n\npublic interface IAuditLogger\n{\n    void LogEvent(string message);\n}\n\npublic class OrderFulfillmentService\n{\n    private readonly IInventorySystem inventorySystem;\n    private readonly IShippingProvider shippingProvider;\n    private readonly IAuditLogger auditLogger;\n    \n    public OrderFulfillmentService(\n        IInventorySystem inventorySystem,\n        IShippingProvider shippingProvider,\n        IAuditLogger auditLogger)\n    {\n        this.inventorySystem = inventorySystem;\n        this.shippingProvider = shippingProvider;\n        this.auditLogger = auditLogger;\n    }\n    \n    public bool FulfillOrder(Order order)\n    {\n        auditLogger.LogEvent($\"Starting fulfillment for order {order.Id}\");\n        \n        if (!inventorySystem.IsItemAvailable(order.ProductId, order.Quantity))\n        {\n            auditLogger.LogEvent($\"Insufficient inventory for order {order.Id}\");\n            return false;\n        }\n        \n        inventorySystem.ReserveItem(order.ProductId, order.Quantity);\n        var trackingNumber = shippingProvider.CreateShipment(order);\n        \n        auditLogger.LogEvent($\"Order {order.Id} fulfilled with tracking {trackingNumber}\");\n        return true;\n    }\n}\n\npublic class WarehouseInventorySystem : IInventorySystem\n{\n    public bool IsItemAvailable(string productId, int quantity)\n    {\n        // Warehouse specific inventory check\n        return true;\n    }\n    \n    public void ReserveItem(string productId, int quantity)\n    {\n        // Reserve inventory\n    }\n}\n\npublic class FedExShippingProvider : IShippingProvider\n{\n    public string CreateShipment(Order order)\n    {\n        // FedEx API integration\n        return \"FEDEX123456\";\n    }\n}\n\npublic class DatabaseAuditLogger : IAuditLogger\n{\n    public void LogEvent(string message)\n    {\n        // Database logging\n    }\n}\n\npublic class Order\n{\n    public string Id { get; set; }\n    public string ProductId { get; set; }\n    public int Quantity { get; set; }\n    public string CustomerAddress { get; set; }\n}",
            "level": "MODERATE",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "import sqlite3\nimport smtplib\nimport logging\nfrom datetime import datetime\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\n\nclass OrderProcessor:\n    def __init__(self):\n        self.db_connection = sqlite3.connect('orders.db')\n        self.smtp_server = smtplib.SMTP('smtp.gmail.com', 587)\n        self.logger = logging.getLogger(__name__)\n        \n    def process_order(self, order_data):\n        # Validate order\n        if not self._validate_order(order_data):\n            self.logger.error(f\"Invalid order: {order_data['id']}\")\n            return False\n            \n        # Save to database\n        cursor = self.db_connection.cursor()\n        cursor.execute(\n            \"INSERT INTO orders (id, customer_id, amount, status, created_at) VALUES (?, ?, ?, ?, ?)\",\n            (order_data['id'], order_data['customer_id'], order_data['amount'], 'pending', datetime.now())\n        )\n        self.db_connection.commit()\n        \n        # Process payment\n        payment_gateway = PayPalGateway()\n        payment_result = payment_gateway.charge_card(\n            order_data['card_number'], \n            order_data['amount']\n        )\n        \n        if payment_result['success']:\n            # Update order status\n            cursor.execute(\n                \"UPDATE orders SET status = ? WHERE id = ?\",\n                ('paid', order_data['id'])\n            )\n            self.db_connection.commit()\n            \n            # Send confirmation email\n            self.smtp_server.starttls()\n            self.smtp_server.login('orders@company.com', 'password123')\n            \n            msg = MIMEMultipart()\n            msg['From'] = 'orders@company.com'\n            msg['To'] = order_data['customer_email']\n            msg['Subject'] = f\"Order Confirmation - {order_data['id']}\"\n            \n            body = f\"Your order {order_data['id']} has been confirmed and payment processed.\"\n            msg.attach(MIMEText(body, 'plain'))\n            \n            self.smtp_server.send_message(msg)\n            \n            # Update inventory\n            inventory_system = WarehouseInventorySystem()\n            for item in order_data['items']:\n                inventory_system.reduce_stock(\n                    item['product_id'], \n                    item['quantity']\n                )\n            \n            # Schedule shipping\n            shipping_service = FedExShippingService()\n            tracking_number = shipping_service.create_shipment({\n                'address': order_data['shipping_address'],\n                'items': order_data['items'],\n                'priority': order_data.get('shipping_priority', 'standard')\n            })\n            \n            # Update order with tracking\n            cursor.execute(\n                \"UPDATE orders SET tracking_number = ?, status = ? WHERE id = ?\",\n                (tracking_number, 'shipped', order_data['id'])\n            )\n            self.db_connection.commit()\n            \n            self.logger.info(f\"Order {order_data['id']} processed successfully\")\n            return True\n        else:\n            self.logger.error(f\"Payment failed for order {order_data['id']}\")\n            return False\n    \n    def _validate_order(self, order_data):\n        required_fields = ['id', 'customer_id', 'amount', 'customer_email', 'items']\n        return all(field in order_data for field in required_fields)\n\nclass PayPalGateway:\n    def charge_card(self, card_number, amount):\n        # PayPal-specific payment processing\n        return {'success': True, 'transaction_id': 'pp_123456'}\n\nclass WarehouseInventorySystem:\n    def reduce_stock(self, product_id, quantity):\n        # Warehouse-specific inventory management\n        pass\n\nclass FedExShippingService:\n    def create_shipment(self, shipment_data):\n        # FedEx-specific shipping logic\n        return 'FEDEX123456789'",
            "output": "from abc import ABC, abstractmethod\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional\n\n# Abstractions\nclass DatabaseRepository(ABC):\n    @abstractmethod\n    def save_order(self, order_data: Dict[str, Any]) -> bool:\n        pass\n    \n    @abstractmethod\n    def update_order_status(self, order_id: str, status: str) -> bool:\n        pass\n    \n    @abstractmethod\n    def update_order_tracking(self, order_id: str, tracking_number: str, status: str) -> bool:\n        pass\n\nclass PaymentGateway(ABC):\n    @abstractmethod\n    def process_payment(self, card_number: str, amount: float) -> Dict[str, Any]:\n        pass\n\nclass EmailService(ABC):\n    @abstractmethod\n    def send_confirmation_email(self, recipient: str, order_id: str) -> bool:\n        pass\n\nclass InventoryService(ABC):\n    @abstractmethod\n    def reduce_stock(self, product_id: str, quantity: int) -> bool:\n        pass\n\nclass ShippingService(ABC):\n    @abstractmethod\n    def create_shipment(self, shipment_data: Dict[str, Any]) -> str:\n        pass\n\nclass Logger(ABC):\n    @abstractmethod\n    def info(self, message: str) -> None:\n        pass\n    \n    @abstractmethod\n    def error(self, message: str) -> None:\n        pass\n\n# High-level module\nclass OrderProcessor:\n    def __init__(self, \n                 db_repository: DatabaseRepository,\n                 payment_gateway: PaymentGateway,\n                 email_service: EmailService,\n                 inventory_service: InventoryService,\n                 shipping_service: ShippingService,\n                 logger: Logger):\n        self.db_repository = db_repository\n        self.payment_gateway = payment_gateway\n        self.email_service = email_service\n        self.inventory_service = inventory_service\n        self.shipping_service = shipping_service\n        self.logger = logger\n        \n    def process_order(self, order_data: Dict[str, Any]) -> bool:\n        # Validate order\n        if not self._validate_order(order_data):\n            self.logger.error(f\"Invalid order: {order_data['id']}\")\n            return False\n            \n        # Save to database\n        if not self.db_repository.save_order(order_data):\n            self.logger.error(f\"Failed to save order: {order_data['id']}\")\n            return False\n        \n        # Process payment\n        payment_result = self.payment_gateway.process_payment(\n            order_data['card_number'], \n            order_data['amount']\n        )\n        \n        if payment_result['success']:\n            # Update order status\n            self.db_repository.update_order_status(order_data['id'], 'paid')\n            \n            # Send confirmation email\n            self.email_service.send_confirmation_email(\n                order_data['customer_email'], \n                order_data['id']\n            )\n            \n            # Update inventory\n            for item in order_data['items']:\n                self.inventory_service.reduce_stock(\n                    item['product_id'], \n                    item['quantity']\n                )\n            \n            # Schedule shipping\n            tracking_number = self.shipping_service.create_shipment({\n                'address': order_data['shipping_address'],\n                'items': order_data['items'],\n                'priority': order_data.get('shipping_priority', 'standard')\n            })\n            \n            # Update order with tracking\n            self.db_repository.update_order_tracking(\n                order_data['id'], tracking_number, 'shipped'\n            )\n            \n            self.logger.info(f\"Order {order_data['id']} processed successfully\")\n            return True\n        else:\n            self.logger.error(f\"Payment failed for order {order_data['id']}\")\n            return False\n    \n    def _validate_order(self, order_data: Dict[str, Any]) -> bool:\n        required_fields = ['id', 'customer_id', 'amount', 'customer_email', 'items']\n        return all(field in order_data for field in required_fields)\n\n# Concrete implementations (low-level modules)\nclass SQLiteOrderRepository(DatabaseRepository):\n    def __init__(self, db_path: str):\n        import sqlite3\n        self.connection = sqlite3.connect(db_path)\n    \n    def save_order(self, order_data: Dict[str, Any]) -> bool:\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(\n                \"INSERT INTO orders (id, customer_id, amount, status, created_at) VALUES (?, ?, ?, ?, ?)\",\n                (order_data['id'], order_data['customer_id'], order_data['amount'], 'pending', datetime.now())\n            )\n            self.connection.commit()\n            return True\n        except Exception:\n            return False\n    \n    def update_order_status(self, order_id: str, status: str) -> bool:\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(\"UPDATE orders SET status = ? WHERE id = ?\", (status, order_id))\n            self.connection.commit()\n            return True\n        except Exception:\n            return False\n    \n    def update_order_tracking(self, order_id: str, tracking_number: str, status: str) -> bool:\n        try:\n            cursor = self.connection.cursor()\n            cursor.execute(\n                \"UPDATE orders SET tracking_number = ?, status = ? WHERE id = ?\",\n                (tracking_number, status, order_id)\n            )\n            self.connection.commit()\n            return True\n        except Exception:\n            return False\n\nclass PayPalPaymentGateway(PaymentGateway):\n    def process_payment(self, card_number: str, amount: float) -> Dict[str, Any]:\n        # PayPal-specific payment processing\n        return {'success': True, 'transaction_id': 'pp_123456'}\n\nclass SMTPEmailService(EmailService):\n    def __init__(self, smtp_server: str, port: int, username: str, password: str):\n        self.smtp_server = smtp_server\n        self.port = port\n        self.username = username\n        self.password = password\n    \n    def send_confirmation_email(self, recipient: str, order_id: str) -> bool:\n        try:\n            import smtplib\n            from email.mime.text import MIMEText\n            \n            server = smtplib.SMTP(self.smtp_server, self.port)\n            server.starttls()\n            server.login(self.username, self.password)\n            \n            msg = MIMEText(f\"Your order {order_id} has been confirmed and payment processed.\")\n            msg['Subject'] = f\"Order Confirmation - {order_id}\"\n            msg['From'] = self.username\n            msg['To'] = recipient\n            \n            server.send_message(msg)\n            server.quit()\n            return True\n        except Exception:\n            return False\n\nclass WarehouseInventoryService(InventoryService):\n    def reduce_stock(self, product_id: str, quantity: int) -> bool:\n        # Warehouse-specific inventory management\n        return True\n\nclass FedExShippingService(ShippingService):\n    def create_shipment(self, shipment_data: Dict[str, Any]) -> str:\n        # FedEx-specific shipping logic\n        return 'FEDEX123456789'\n\nclass ConsoleLogger(Logger):\n    def info(self, message: str) -> None:\n        print(f\"INFO: {message}\")\n    \n    def error(self, message: str) -> None:\n        print(f\"ERROR: {message}\")",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "class DataAnalyticsPipeline:\n    def __init__(self):\n        self.kafka_consumer = KafkaConsumer()\n        self.redis_cache = RedisCache()\n        self.postgresql_store = PostgreSQLStore()\n        self.ml_processor = TensorFlowProcessor()\n        self.elasticsearch_indexer = ElasticsearchIndexer()\n        self.slack_notifier = SlackNotifier()\n        self.prometheus_metrics = PrometheusMetrics()\n        \n    def process_streaming_data(self, topic_name):\n        self.prometheus_metrics.increment_counter('pipeline_started')\n        \n        try:\n            # Consume data from Kafka\n            raw_data = self.kafka_consumer.consume_messages(topic_name)\n            \n            for message in raw_data:\n                # Check cache for processed data\n                cache_key = f\"processed_{message['id']}\"\n                cached_result = self.redis_cache.get(cache_key)\n                \n                if cached_result:\n                    continue\n                    \n                # Process with ML model\n                processed_data = self.ml_processor.predict(message['features'])\n                \n                # Store in database\n                enriched_data = {\n                    'original': message,\n                    'predictions': processed_data,\n                    'timestamp': datetime.now()\n                }\n                \n                self.postgresql_store.insert_record('analytics_results', enriched_data)\n                \n                # Cache the result\n                self.redis_cache.set(cache_key, processed_data, ttl=3600)\n                \n                # Index for search\n                self.elasticsearch_indexer.index_document('analytics', enriched_data)\n                \n                # Update metrics\n                self.prometheus_metrics.increment_counter('records_processed')\n                \n                # Notify on anomalies\n                if processed_data.get('anomaly_score', 0) > 0.8:\n                    self.slack_notifier.send_alert(\n                        f\"High anomaly detected: {processed_data['anomaly_score']}\"\n                    )\n                    \n        except Exception as e:\n            self.slack_notifier.send_error(f\"Pipeline failed: {str(e)}\")\n            self.prometheus_metrics.increment_counter('pipeline_errors')\n            raise\n            \nclass KafkaConsumer:\n    def consume_messages(self, topic):\n        # Kafka-specific consumption logic\n        return [{'id': '1', 'features': [1, 2, 3]}]\n        \nclass RedisCache:\n    def get(self, key):\n        return None\n        \n    def set(self, key, value, ttl):\n        pass\n        \nclass PostgreSQLStore:\n    def insert_record(self, table, data):\n        # PostgreSQL-specific insertion\n        pass\n        \nclass TensorFlowProcessor:\n    def predict(self, features):\n        # TensorFlow model prediction\n        return {'prediction': 0.7, 'anomaly_score': 0.9}\n        \nclass ElasticsearchIndexer:\n    def index_document(self, index, document):\n        # Elasticsearch indexing\n        pass\n        \nclass SlackNotifier:\n    def send_alert(self, message):\n        # Slack API call\n        pass\n        \n    def send_error(self, message):\n        # Slack error notification\n        pass\n        \nclass PrometheusMetrics:\n    def increment_counter(self, metric_name):\n        # Prometheus metric update\n        pass",
            "output": "from abc import ABC, abstractmethod\nfrom typing import List, Dict, Any, Optional\nfrom datetime import datetime\n\nclass MessageConsumer(ABC):\n    @abstractmethod\n    def consume_messages(self, source: str) -> List[Dict[str, Any]]:\n        pass\n\nclass CacheService(ABC):\n    @abstractmethod\n    def get(self, key: str) -> Optional[Any]:\n        pass\n    \n    @abstractmethod\n    def set(self, key: str, value: Any, ttl: int) -> None:\n        pass\n\nclass DataStore(ABC):\n    @abstractmethod\n    def insert_record(self, table: str, data: Dict[str, Any]) -> None:\n        pass\n\nclass MLProcessor(ABC):\n    @abstractmethod\n    def predict(self, features: List[float]) -> Dict[str, Any]:\n        pass\n\nclass SearchIndexer(ABC):\n    @abstractmethod\n    def index_document(self, index: str, document: Dict[str, Any]) -> None:\n        pass\n\nclass NotificationService(ABC):\n    @abstractmethod\n    def send_alert(self, message: str) -> None:\n        pass\n    \n    @abstractmethod\n    def send_error(self, message: str) -> None:\n        pass\n\nclass MetricsCollector(ABC):\n    @abstractmethod\n    def increment_counter(self, metric_name: str) -> None:\n        pass\n\nclass DataAnalyticsPipeline:\n    def __init__(self, consumer: MessageConsumer, cache: CacheService, \n                 store: DataStore, ml_processor: MLProcessor, \n                 indexer: SearchIndexer, notifier: NotificationService,\n                 metrics: MetricsCollector):\n        self.consumer = consumer\n        self.cache = cache\n        self.store = store\n        self.ml_processor = ml_processor\n        self.indexer = indexer\n        self.notifier = notifier\n        self.metrics = metrics\n        \n    def process_streaming_data(self, topic_name: str):\n        self.metrics.increment_counter('pipeline_started')\n        \n        try:\n            # Consume data from message source\n            raw_data = self.consumer.consume_messages(topic_name)\n            \n            for message in raw_data:\n                # Check cache for processed data\n                cache_key = f\"processed_{message['id']}\"\n                cached_result = self.cache.get(cache_key)\n                \n                if cached_result:\n                    continue\n                    \n                # Process with ML model\n                processed_data = self.ml_processor.predict(message['features'])\n                \n                # Store in database\n                enriched_data = {\n                    'original': message,\n                    'predictions': processed_data,\n                    'timestamp': datetime.now()\n                }\n                \n                self.store.insert_record('analytics_results', enriched_data)\n                \n                # Cache the result\n                self.cache.set(cache_key, processed_data, 3600)\n                \n                # Index for search\n                self.indexer.index_document('analytics', enriched_data)\n                \n                # Update metrics\n                self.metrics.increment_counter('records_processed')\n                \n                # Notify on anomalies\n                if processed_data.get('anomaly_score', 0) > 0.8:\n                    self.notifier.send_alert(\n                        f\"High anomaly detected: {processed_data['anomaly_score']}\"\n                    )\n                    \n        except Exception as e:\n            self.notifier.send_error(f\"Pipeline failed: {str(e)}\")\n            self.metrics.increment_counter('pipeline_errors')\n            raise\n\n# Concrete implementations\nclass KafkaMessageConsumer(MessageConsumer):\n    def consume_messages(self, source: str) -> List[Dict[str, Any]]:\n        # Kafka-specific consumption logic\n        return [{'id': '1', 'features': [1, 2, 3]}]\n        \nclass RedisCacheService(CacheService):\n    def get(self, key: str) -> Optional[Any]:\n        return None\n        \n    def set(self, key: str, value: Any, ttl: int) -> None:\n        pass\n        \nclass PostgreSQLDataStore(DataStore):\n    def insert_record(self, table: str, data: Dict[str, Any]) -> None:\n        # PostgreSQL-specific insertion\n        pass\n        \nclass TensorFlowMLProcessor(MLProcessor):\n    def predict(self, features: List[float]) -> Dict[str, Any]:\n        # TensorFlow model prediction\n        return {'prediction': 0.7, 'anomaly_score': 0.9}\n        \nclass ElasticsearchIndexer(SearchIndexer):\n    def index_document(self, index: str, document: Dict[str, Any]) -> None:\n        # Elasticsearch indexing\n        pass\n        \nclass SlackNotificationService(NotificationService):\n    def send_alert(self, message: str) -> None:\n        # Slack API call\n        pass\n        \n    def send_error(self, message: str) -> None:\n        # Slack error notification\n        pass\n        \nclass PrometheusMetricsCollector(MetricsCollector):\n    def increment_counter(self, metric_name: str) -> None:\n        # Prometheus metric update\n        pass",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "import boto3\nimport psycopg2\nimport redis\nimport json\nfrom datetime import datetime\n\nclass OrderProcessingSystem:\n    def __init__(self):\n        self.db_connection = psycopg2.connect(\n            host=\"localhost\", database=\"orders\", user=\"admin\", password=\"secret\"\n        )\n        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)\n        self.s3_client = boto3.client('s3', region_name='us-east-1')\n        self.sns_client = boto3.client('sns', region_name='us-east-1')\n    \n    def process_order(self, order_data):\n        # Validate order\n        if not self._validate_order(order_data):\n            raise ValueError(\"Invalid order data\")\n        \n        # Save to PostgreSQL\n        cursor = self.db_connection.cursor()\n        cursor.execute(\n            \"INSERT INTO orders (customer_id, items, total) VALUES (%s, %s, %s)\",\n            (order_data['customer_id'], json.dumps(order_data['items']), order_data['total'])\n        )\n        self.db_connection.commit()\n        order_id = cursor.lastrowid\n        \n        # Cache order in Redis\n        self.redis_client.setex(\n            f\"order:{order_id}\", 3600, json.dumps(order_data)\n        )\n        \n        # Store order documents in S3\n        self.s3_client.put_object(\n            Bucket='order-documents',\n            Key=f'orders/{order_id}/receipt.json',\n            Body=json.dumps(order_data)\n        )\n        \n        # Send notification via SNS\n        self.sns_client.publish(\n            TopicArn='arn:aws:sns:us-east-1:123456789012:order-notifications',\n            Message=f'Order {order_id} processed successfully',\n            Subject='Order Processed'\n        )\n        \n        # Update inventory\n        for item in order_data['items']:\n            cursor.execute(\n                \"UPDATE inventory SET quantity = quantity - %s WHERE product_id = %s\",\n                (item['quantity'], item['product_id'])\n            )\n        self.db_connection.commit()\n        \n        return order_id\n    \n    def _validate_order(self, order_data):\n        return all(key in order_data for key in ['customer_id', 'items', 'total'])",
            "output": "from abc import ABC, abstractmethod\nimport json\nfrom datetime import datetime\nfrom typing import List, Dict, Any\n\n# Abstractions\nclass DatabaseRepository(ABC):\n    @abstractmethod\n    def save_order(self, order_data: Dict[str, Any]) -> int:\n        pass\n    \n    @abstractmethod\n    def update_inventory(self, items: List[Dict[str, Any]]) -> None:\n        pass\n\nclass CacheService(ABC):\n    @abstractmethod\n    def cache_order(self, order_id: int, order_data: Dict[str, Any], ttl: int) -> None:\n        pass\n\nclass FileStorage(ABC):\n    @abstractmethod\n    def store_document(self, path: str, content: str) -> None:\n        pass\n\nclass NotificationService(ABC):\n    @abstractmethod\n    def send_notification(self, message: str, subject: str) -> None:\n        pass\n\nclass OrderValidator(ABC):\n    @abstractmethod\n    def validate(self, order_data: Dict[str, Any]) -> bool:\n        pass\n\n# High-level module\nclass OrderProcessingSystem:\n    def __init__(self, \n                 database: DatabaseRepository,\n                 cache: CacheService,\n                 storage: FileStorage,\n                 notifier: NotificationService,\n                 validator: OrderValidator):\n        self.database = database\n        self.cache = cache\n        self.storage = storage\n        self.notifier = notifier\n        self.validator = validator\n    \n    def process_order(self, order_data: Dict[str, Any]) -> int:\n        if not self.validator.validate(order_data):\n            raise ValueError(\"Invalid order data\")\n        \n        order_id = self.database.save_order(order_data)\n        self.cache.cache_order(order_id, order_data, 3600)\n        \n        self.storage.store_document(\n            f'orders/{order_id}/receipt.json',\n            json.dumps(order_data)\n        )\n        \n        self.notifier.send_notification(\n            f'Order {order_id} processed successfully',\n            'Order Processed'\n        )\n        \n        self.database.update_inventory(order_data['items'])\n        return order_id\n\n# Low-level implementations\nclass PostgreSQLRepository(DatabaseRepository):\n    def __init__(self, connection):\n        self.connection = connection\n    \n    def save_order(self, order_data: Dict[str, Any]) -> int:\n        cursor = self.connection.cursor()\n        cursor.execute(\n            \"INSERT INTO orders (customer_id, items, total) VALUES (%s, %s, %s)\",\n            (order_data['customer_id'], json.dumps(order_data['items']), order_data['total'])\n        )\n        self.connection.commit()\n        return cursor.lastrowid\n    \n    def update_inventory(self, items: List[Dict[str, Any]]) -> None:\n        cursor = self.connection.cursor()\n        for item in items:\n            cursor.execute(\n                \"UPDATE inventory SET quantity = quantity - %s WHERE product_id = %s\",\n                (item['quantity'], item['product_id'])\n            )\n        self.connection.commit()\n\nclass RedisCache(CacheService):\n    def __init__(self, redis_client):\n        self.redis_client = redis_client\n    \n    def cache_order(self, order_id: int, order_data: Dict[str, Any], ttl: int) -> None:\n        self.redis_client.setex(\n            f\"order:{order_id}\", ttl, json.dumps(order_data)\n        )\n\nclass S3Storage(FileStorage):\n    def __init__(self, s3_client, bucket_name: str):\n        self.s3_client = s3_client\n        self.bucket_name = bucket_name\n    \n    def store_document(self, path: str, content: str) -> None:\n        self.s3_client.put_object(\n            Bucket=self.bucket_name,\n            Key=path,\n            Body=content\n        )\n\nclass SNSNotificationService(NotificationService):\n    def __init__(self, sns_client, topic_arn: str):\n        self.sns_client = sns_client\n        self.topic_arn = topic_arn\n    \n    def send_notification(self, message: str, subject: str) -> None:\n        self.sns_client.publish(\n            TopicArn=self.topic_arn,\n            Message=message,\n            Subject=subject\n        )\n\nclass BasicOrderValidator(OrderValidator):\n    def validate(self, order_data: Dict[str, Any]) -> bool:\n        return all(key in order_data for key in ['customer_id', 'items', 'total'])",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "import requests\nimport xml.etree.ElementTree as ET\nimport sqlite3\nimport hashlib\nimport hmac\nimport base64\nfrom datetime import datetime\n\nclass PaymentGatewayIntegration:\n    def __init__(self):\n        self.db_connection = sqlite3.connect('payments.db')\n        self.setup_database()\n    \n    def setup_database(self):\n        cursor = self.db_connection.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS payment_logs (\n                id INTEGER PRIMARY KEY,\n                transaction_id TEXT,\n                amount REAL,\n                status TEXT,\n                timestamp TEXT\n            )\n        ''')\n        self.db_connection.commit()\n    \n    def process_payment(self, payment_data):\n        # Validate payment\n        if not self._validate_payment(payment_data):\n            return {'status': 'failed', 'message': 'Invalid payment data'}\n        \n        # Process with Stripe\n        stripe_result = self._process_with_stripe(payment_data)\n        if stripe_result['status'] == 'success':\n            self._log_payment(stripe_result['transaction_id'], payment_data['amount'], 'success')\n            return stripe_result\n        \n        # Fallback to PayPal\n        paypal_result = self._process_with_paypal(payment_data)\n        if paypal_result['status'] == 'success':\n            self._log_payment(paypal_result['transaction_id'], payment_data['amount'], 'success')\n            return paypal_result\n        \n        # Fallback to Square\n        square_result = self._process_with_square(payment_data)\n        self._log_payment(\n            square_result.get('transaction_id', 'unknown'), \n            payment_data['amount'], \n            square_result['status']\n        )\n        return square_result\n    \n    def _process_with_stripe(self, payment_data):\n        headers = {\n            'Authorization': f'Bearer sk_test_stripe_key',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        \n        data = {\n            'amount': int(payment_data['amount'] * 100),\n            'currency': 'usd',\n            'source': payment_data['card_token']\n        }\n        \n        response = requests.post('https://api.stripe.com/v1/charges', headers=headers, data=data)\n        \n        if response.status_code == 200:\n            result = response.json()\n            return {\n                'status': 'success',\n                'transaction_id': result['id'],\n                'gateway': 'stripe'\n            }\n        return {'status': 'failed', 'message': 'Stripe processing failed'}\n    \n    def _process_with_paypal(self, payment_data):\n        auth_header = base64.b64encode(b'client_id:client_secret').decode('ascii')\n        \n        # Get access token\n        token_response = requests.post(\n            'https://api.sandbox.paypal.com/v1/oauth2/token',\n            headers={'Authorization': f'Basic {auth_header}'},\n            data={'grant_type': 'client_credentials'}\n        )\n        \n        if token_response.status_code != 200:\n            return {'status': 'failed', 'message': 'PayPal auth failed'}\n        \n        access_token = token_response.json()['access_token']\n        \n        # Process payment\n        payment_payload = {\n            'intent': 'sale',\n            'payer': {'payment_method': 'credit_card'},\n            'transactions': [{\n                'amount': {\n                    'total': str(payment_data['amount']),\n                    'currency': 'USD'\n                }\n            }]\n        }\n        \n        payment_response = requests.post(\n            'https://api.sandbox.paypal.com/v1/payments/payment',\n            headers={'Authorization': f'Bearer {access_token}'},\n            json=payment_payload\n        )\n        \n        if payment_response.status_code == 201:\n            result = payment_response.json()\n            return {\n                'status': 'success',\n                'transaction_id': result['id'],\n                'gateway': 'paypal'\n            }\n        return {'status': 'failed', 'message': 'PayPal processing failed'}\n    \n    def _process_with_square(self, payment_data):\n        headers = {\n            'Authorization': f'Bearer sandbox_square_token',\n            'Content-Type': 'application/json',\n            'Square-Version': '2021-06-16'\n        }\n        \n        payment_request = {\n            'source_id': payment_data['card_token'],\n            'amount_money': {\n                'amount': int(payment_data['amount'] * 100),\n                'currency': 'USD'\n            },\n            'idempotency_key': hashlib.md5(str(datetime.now()).encode()).hexdigest()\n        }\n        \n        response = requests.post(\n            'https://connect.squareupsandbox.com/v2/payments',\n            headers=headers,\n            json=payment_request\n        )\n        \n        if response.status_code == 200:\n            result = response.json()\n            return {\n                'status': 'success',\n                'transaction_id': result['payment']['id'],\n                'gateway': 'square'\n            }\n        return {'status': 'failed', 'message': 'Square processing failed'}\n    \n    def _validate_payment(self, payment_data):\n        required_fields = ['amount', 'card_token']\n        return all(field in payment_data for field in required_fields)\n    \n    def _log_payment(self, transaction_id, amount, status):\n        cursor = self.db_connection.cursor()\n        cursor.execute(\n            'INSERT INTO payment_logs (transaction_id, amount, status, timestamp) VALUES (?, ?, ?, ?)',\n            (transaction_id, amount, status, datetime.now().isoformat())\n        )\n        self.db_connection.commit()",
            "output": "from abc import ABC, abstractmethod\nfrom typing import Dict, Any, List\nfrom datetime import datetime\n\n# Abstractions\nclass PaymentGateway(ABC):\n    @abstractmethod\n    def process_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        pass\n    \n    @abstractmethod\n    def get_gateway_name(self) -> str:\n        pass\n\nclass PaymentLogger(ABC):\n    @abstractmethod\n    def log_payment(self, transaction_id: str, amount: float, status: str, gateway: str) -> None:\n        pass\n\nclass PaymentValidator(ABC):\n    @abstractmethod\n    def validate(self, payment_data: Dict[str, Any]) -> bool:\n        pass\n\nclass PaymentStrategy(ABC):\n    @abstractmethod\n    def execute_payment_chain(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        pass\n\n# High-level module\nclass PaymentGatewayIntegration:\n    def __init__(self, \n                 payment_strategy: PaymentStrategy,\n                 logger: PaymentLogger,\n                 validator: PaymentValidator):\n        self.payment_strategy = payment_strategy\n        self.logger = logger\n        self.validator = validator\n    \n    def process_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        if not self.validator.validate(payment_data):\n            return {'status': 'failed', 'message': 'Invalid payment data'}\n        \n        result = self.payment_strategy.execute_payment_chain(payment_data)\n        \n        self.logger.log_payment(\n            result.get('transaction_id', 'unknown'),\n            payment_data['amount'],\n            result['status'],\n            result.get('gateway', 'unknown')\n        )\n        \n        return result\n\n# Low-level implementations\nclass StripeGateway(PaymentGateway):\n    def __init__(self, api_key: str, http_client):\n        self.api_key = api_key\n        self.http_client = http_client\n    \n    def process_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        headers = {\n            'Authorization': f'Bearer {self.api_key}',\n            'Content-Type': 'application/x-www-form-urlencoded'\n        }\n        \n        data = {\n            'amount': int(payment_data['amount'] * 100),\n            'currency': 'usd',\n            'source': payment_data['card_token']\n        }\n        \n        response = self.http_client.post('https://api.stripe.com/v1/charges', headers=headers, data=data)\n        \n        if response.status_code == 200:\n            result = response.json()\n            return {\n                'status': 'success',\n                'transaction_id': result['id'],\n                'gateway': self.get_gateway_name()\n            }\n        return {'status': 'failed', 'message': 'Stripe processing failed'}\n    \n    def get_gateway_name(self) -> str:\n        return 'stripe'\n\nclass PayPalGateway(PaymentGateway):\n    def __init__(self, client_id: str, client_secret: str, http_client):\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.http_client = http_client\n    \n    def process_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        # Implementation details for PayPal\n        # (Similar to original but using injected http_client)\n        return {'status': 'success', 'transaction_id': 'pp_123', 'gateway': self.get_gateway_name()}\n    \n    def get_gateway_name(self) -> str:\n        return 'paypal'\n\nclass SquareGateway(PaymentGateway):\n    def __init__(self, access_token: str, http_client):\n        self.access_token = access_token\n        self.http_client = http_client\n    \n    def process_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        # Implementation details for Square\n        # (Similar to original but using injected http_client)\n        return {'status': 'success', 'transaction_id': 'sq_123', 'gateway': self.get_gateway_name()}\n    \n    def get_gateway_name(self) -> str:\n        return 'square'\n\nclass FallbackPaymentStrategy(PaymentStrategy):\n    def __init__(self, gateways: List[PaymentGateway]):\n        self.gateways = gateways\n    \n    def execute_payment_chain(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:\n        for gateway in self.gateways:\n            result = gateway.process_payment(payment_data)\n            if result['status'] == 'success':\n                return result\n        \n        return {'status': 'failed', 'message': 'All payment gateways failed'}\n\nclass DatabasePaymentLogger(PaymentLogger):\n    def __init__(self, database_connection):\n        self.db_connection = database_connection\n        self._setup_database()\n    \n    def _setup_database(self):\n        cursor = self.db_connection.cursor()\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS payment_logs (\n                id INTEGER PRIMARY KEY,\n                transaction_id TEXT,\n                amount REAL,\n                status TEXT,\n                gateway TEXT,\n                timestamp TEXT\n            )\n        ''')\n        self.db_connection.commit()\n    \n    def log_payment(self, transaction_id: str, amount: float, status: str, gateway: str) -> None:\n        cursor = self.db_connection.cursor()\n        cursor.execute(\n            'INSERT INTO payment_logs (transaction_id, amount, status, gateway, timestamp) VALUES (?, ?, ?, ?, ?)',\n            (transaction_id, amount, status, gateway, datetime.now().isoformat())\n        )\n        self.db_connection.commit()\n\nclass StandardPaymentValidator(PaymentValidator):\n    def validate(self, payment_data: Dict[str, Any]) -> bool:\n        required_fields = ['amount', 'card_token']\n        return all(field in payment_data for field in required_fields)",
            "level": "HARD",
            "language": "PYTHON",
            "violation": "DIP"
        },
        {
            "input": "public class OrderProcessor {\n    private EmailService emailService = new EmailService();\n    private DatabaseLogger logger = new DatabaseLogger();\n    private PayPalPaymentGateway paymentGateway = new PayPalPaymentGateway();\n    private InventoryService inventoryService = new InventoryService();\n    private TaxCalculator taxCalculator = new TaxCalculator();\n    \n    public void processOrder(Order order) {\n        logger.log(\"Processing order: \" + order.getId());\n        \n        if (!inventoryService.checkAvailability(order.getItems())) {\n            emailService.sendEmail(order.getCustomerEmail(), \"Order Failed\", \"Items not available\");\n            return;\n        }\n        \n        double tax = taxCalculator.calculateTax(order.getTotal(), order.getCustomerAddress());\n        double totalWithTax = order.getTotal() + tax;\n        \n        PaymentResult result = paymentGateway.processPayment(order.getPaymentInfo(), totalWithTax);\n        \n        if (result.isSuccess()) {\n            inventoryService.reserveItems(order.getItems());\n            emailService.sendEmail(order.getCustomerEmail(), \"Order Confirmed\", \"Your order has been processed\");\n            logger.log(\"Order processed successfully: \" + order.getId());\n        } else {\n            emailService.sendEmail(order.getCustomerEmail(), \"Payment Failed\", result.getErrorMessage());\n            logger.log(\"Payment failed for order: \" + order.getId());\n        }\n    }\n}\n\nclass EmailService {\n    public void sendEmail(String to, String subject, String body) {\n        // SMTP email implementation\n    }\n}\n\nclass DatabaseLogger {\n    public void log(String message) {\n        // Database logging implementation\n    }\n}\n\nclass PayPalPaymentGateway {\n    public PaymentResult processPayment(PaymentInfo info, double amount) {\n        // PayPal API integration\n        return new PaymentResult(true, null);\n    }\n}\n\nclass InventoryService {\n    public boolean checkAvailability(List<OrderItem> items) {\n        // Database inventory check\n        return true;\n    }\n    \n    public void reserveItems(List<OrderItem> items) {\n        // Database inventory update\n    }\n}\n\nclass TaxCalculator {\n    public double calculateTax(double amount, Address address) {\n        // Complex tax calculation based on location\n        return amount * 0.08;\n    }\n}",
            "output": "public interface NotificationService {\n    void sendNotification(String recipient, String subject, String message);\n}\n\npublic interface Logger {\n    void log(String message);\n}\n\npublic interface PaymentGateway {\n    PaymentResult processPayment(PaymentInfo info, double amount);\n}\n\npublic interface InventoryManager {\n    boolean checkAvailability(List<OrderItem> items);\n    void reserveItems(List<OrderItem> items);\n}\n\npublic interface TaxService {\n    double calculateTax(double amount, Address address);\n}\n\npublic class OrderProcessor {\n    private final NotificationService notificationService;\n    private final Logger logger;\n    private final PaymentGateway paymentGateway;\n    private final InventoryManager inventoryManager;\n    private final TaxService taxService;\n    \n    public OrderProcessor(NotificationService notificationService, Logger logger, \n                         PaymentGateway paymentGateway, InventoryManager inventoryManager,\n                         TaxService taxService) {\n        this.notificationService = notificationService;\n        this.logger = logger;\n        this.paymentGateway = paymentGateway;\n        this.inventoryManager = inventoryManager;\n        this.taxService = taxService;\n    }\n    \n    public void processOrder(Order order) {\n        logger.log(\"Processing order: \" + order.getId());\n        \n        if (!inventoryManager.checkAvailability(order.getItems())) {\n            notificationService.sendNotification(order.getCustomerEmail(), \"Order Failed\", \"Items not available\");\n            return;\n        }\n        \n        double tax = taxService.calculateTax(order.getTotal(), order.getCustomerAddress());\n        double totalWithTax = order.getTotal() + tax;\n        \n        PaymentResult result = paymentGateway.processPayment(order.getPaymentInfo(), totalWithTax);\n        \n        if (result.isSuccess()) {\n            inventoryManager.reserveItems(order.getItems());\n            notificationService.sendNotification(order.getCustomerEmail(), \"Order Confirmed\", \"Your order has been processed\");\n            logger.log(\"Order processed successfully: \" + order.getId());\n        } else {\n            notificationService.sendNotification(order.getCustomerEmail(), \"Payment Failed\", result.getErrorMessage());\n            logger.log(\"Payment failed for order: \" + order.getId());\n        }\n    }\n}\n\n// Concrete implementations\nclass EmailNotificationService implements NotificationService {\n    @Override\n    public void sendNotification(String recipient, String subject, String message) {\n        // SMTP email implementation\n    }\n}\n\nclass DatabaseLogger implements Logger {\n    @Override\n    public void log(String message) {\n        // Database logging implementation\n    }\n}\n\nclass PayPalPaymentGateway implements PaymentGateway {\n    @Override\n    public PaymentResult processPayment(PaymentInfo info, double amount) {\n        // PayPal API integration\n        return new PaymentResult(true, null);\n    }\n}\n\nclass DatabaseInventoryManager implements InventoryManager {\n    @Override\n    public boolean checkAvailability(List<OrderItem> items) {\n        // Database inventory check\n        return true;\n    }\n    \n    @Override\n    public void reserveItems(List<OrderItem> items) {\n        // Database inventory update\n    }\n}\n\nclass RegionalTaxService implements TaxService {\n    @Override\n    public double calculateTax(double amount, Address address) {\n        // Complex tax calculation based on location\n        return amount * 0.08;\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class ReportGenerator {\n    private SqlServerConnection dbConnection = new SqlServerConnection();\n    private ExcelReportFormatter formatter = new ExcelReportFormatter();\n    private EmailReportSender sender = new EmailReportSender();\n    private FileSystemStorage storage = new FileSystemStorage();\n    private AuditLogger auditLogger = new AuditLogger();\n    \n    public void generateMonthlyReport(String reportType, List<String> recipients) {\n        auditLogger.logAction(\"Starting report generation: \" + reportType);\n        \n        // Query data based on report type\n        ResultSet data;\n        if (\"sales\".equals(reportType)) {\n            data = dbConnection.executeQuery(\"SELECT * FROM sales WHERE month = MONTH(GETDATE())\");\n        } else if (\"inventory\".equals(reportType)) {\n            data = dbConnection.executeQuery(\"SELECT * FROM inventory WHERE status = 'active'\");\n        } else {\n            data = dbConnection.executeQuery(\"SELECT * FROM customers WHERE created_date >= DATEADD(month, -1, GETDATE())\");\n        }\n        \n        // Format the report\n        byte[] reportContent = formatter.formatToExcel(data, reportType);\n        \n        // Store the report\n        String fileName = reportType + \"_\" + LocalDate.now() + \".xlsx\";\n        String filePath = storage.saveFile(fileName, reportContent);\n        \n        // Send to recipients\n        for (String recipient : recipients) {\n            sender.sendReportEmail(recipient, \"Monthly \" + reportType + \" Report\", \n                                 \"Please find attached the monthly report.\", filePath);\n        }\n        \n        auditLogger.logAction(\"Report generation completed: \" + reportType);\n    }\n}\n\nclass SqlServerConnection {\n    public ResultSet executeQuery(String sql) {\n        // SQL Server specific connection and query\n        return new ResultSet();\n    }\n}\n\nclass ExcelReportFormatter {\n    public byte[] formatToExcel(ResultSet data, String reportType) {\n        // Excel-specific formatting using Apache POI\n        return new byte[0];\n    }\n}\n\nclass EmailReportSender {\n    public void sendReportEmail(String recipient, String subject, String body, String attachmentPath) {\n        // SMTP email sending with attachment\n    }\n}\n\nclass FileSystemStorage {\n    public String saveFile(String fileName, byte[] content) {\n        // Local file system storage\n        return \"/reports/\" + fileName;\n    }\n}\n\nclass AuditLogger {\n    public void logAction(String action) {\n        // Database audit logging\n    }\n}",
            "output": "public interface DataRepository {\n    ReportData fetchReportData(String reportType, Map<String, Object> parameters);\n}\n\npublic interface ReportFormatter {\n    byte[] formatReport(ReportData data, String reportType, String format);\n}\n\npublic interface ReportDelivery {\n    void deliverReport(String recipient, String subject, String message, byte[] reportContent, String fileName);\n}\n\npublic interface ReportStorage {\n    String storeReport(String fileName, byte[] content);\n}\n\npublic interface AuditService {\n    void logAction(String action);\n}\n\npublic class ReportGenerator {\n    private final DataRepository dataRepository;\n    private final ReportFormatter formatter;\n    private final ReportDelivery delivery;\n    private final ReportStorage storage;\n    private final AuditService auditService;\n    \n    public ReportGenerator(DataRepository dataRepository, ReportFormatter formatter,\n                          ReportDelivery delivery, ReportStorage storage, AuditService auditService) {\n        this.dataRepository = dataRepository;\n        this.formatter = formatter;\n        this.delivery = delivery;\n        this.storage = storage;\n        this.auditService = auditService;\n    }\n    \n    public void generateMonthlyReport(String reportType, List<String> recipients) {\n        auditService.logAction(\"Starting report generation: \" + reportType);\n        \n        // Fetch data using abstraction\n        Map<String, Object> params = Map.of(\"period\", \"monthly\", \"type\", reportType);\n        ReportData data = dataRepository.fetchReportData(reportType, params);\n        \n        // Format the report\n        byte[] reportContent = formatter.formatReport(data, reportType, \"excel\");\n        \n        // Store the report\n        String fileName = reportType + \"_\" + LocalDate.now() + \".xlsx\";\n        String filePath = storage.storeReport(fileName, reportContent);\n        \n        // Send to recipients\n        for (String recipient : recipients) {\n            delivery.deliverReport(recipient, \"Monthly \" + reportType + \" Report\", \n                                 \"Please find attached the monthly report.\", reportContent, fileName);\n        }\n        \n        auditService.logAction(\"Report generation completed: \" + reportType);\n    }\n}\n\n// Concrete implementations\nclass SqlServerDataRepository implements DataRepository {\n    @Override\n    public ReportData fetchReportData(String reportType, Map<String, Object> parameters) {\n        // SQL Server specific implementation\n        return new ReportData();\n    }\n}\n\nclass ExcelReportFormatter implements ReportFormatter {\n    @Override\n    public byte[] formatReport(ReportData data, String reportType, String format) {\n        // Excel-specific formatting\n        return new byte[0];\n    }\n}\n\nclass EmailReportDelivery implements ReportDelivery {\n    @Override\n    public void deliverReport(String recipient, String subject, String message, byte[] reportContent, String fileName) {\n        // SMTP email delivery\n    }\n}\n\nclass FileSystemReportStorage implements ReportStorage {\n    @Override\n    public String storeReport(String fileName, byte[] content) {\n        // File system storage\n        return \"/reports/\" + fileName;\n    }\n}\n\nclass DatabaseAuditService implements AuditService {\n    @Override\n    public void logAction(String action) {\n        // Database audit logging\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class PaymentProcessor {\n    private DatabaseLogger logger;\n    private EmailService emailService;\n    private MySQLDatabase database;\n    private EncryptionService encryption;\n    \n    public PaymentProcessor() {\n        this.logger = new DatabaseLogger();\n        this.emailService = new SMTPEmailService();\n        this.database = new MySQLDatabase();\n        this.encryption = new AESEncryption();\n    }\n    \n    public void processPayment(Payment payment) {\n        logger.log(\"Processing payment: \" + payment.getId());\n        \n        String encryptedData = encryption.encrypt(payment.getCardData());\n        \n        database.save(payment);\n        \n        emailService.sendConfirmation(payment.getCustomerEmail(), \n                                    \"Payment processed successfully\");\n        \n        logger.log(\"Payment processed: \" + payment.getId());\n    }\n    \n    public void refundPayment(String paymentId) {\n        Payment payment = database.findById(paymentId);\n        payment.setStatus(\"REFUNDED\");\n        database.update(payment);\n        \n        emailService.sendRefundNotification(payment.getCustomerEmail());\n        logger.log(\"Refund processed: \" + paymentId);\n    }\n}",
            "output": "public interface Logger {\n    void log(String message);\n}\n\npublic interface EmailService {\n    void sendConfirmation(String email, String message);\n    void sendRefundNotification(String email);\n}\n\npublic interface PaymentRepository {\n    void save(Payment payment);\n    Payment findById(String id);\n    void update(Payment payment);\n}\n\npublic interface EncryptionService {\n    String encrypt(String data);\n    String decrypt(String encryptedData);\n}\n\npublic class PaymentProcessor {\n    private final Logger logger;\n    private final EmailService emailService;\n    private final PaymentRepository repository;\n    private final EncryptionService encryption;\n    \n    public PaymentProcessor(Logger logger, EmailService emailService, \n                          PaymentRepository repository, EncryptionService encryption) {\n        this.logger = logger;\n        this.emailService = emailService;\n        this.repository = repository;\n        this.encryption = encryption;\n    }\n    \n    public void processPayment(Payment payment) {\n        logger.log(\"Processing payment: \" + payment.getId());\n        \n        String encryptedData = encryption.encrypt(payment.getCardData());\n        payment.setEncryptedCardData(encryptedData);\n        \n        repository.save(payment);\n        \n        emailService.sendConfirmation(payment.getCustomerEmail(), \n                                    \"Payment processed successfully\");\n        \n        logger.log(\"Payment processed: \" + payment.getId());\n    }\n    \n    public void refundPayment(String paymentId) {\n        Payment payment = repository.findById(paymentId);\n        payment.setStatus(\"REFUNDED\");\n        repository.update(payment);\n        \n        emailService.sendRefundNotification(payment.getCustomerEmail());\n        logger.log(\"Refund processed: \" + paymentId);\n    }\n}\n\n// Concrete implementations\npublic class DatabaseLogger implements Logger {\n    public void log(String message) {\n        // log to database\n    }\n}\n\npublic class SMTPEmailService implements EmailService {\n    public void sendConfirmation(String email, String message) {\n        // send via SMTP\n    }\n    \n    public void sendRefundNotification(String email) {\n        // send refund notification\n    }\n}\n\npublic class MySQLPaymentRepository implements PaymentRepository {\n    public void save(Payment payment) {\n        // save to MySQL\n    }\n    \n    public Payment findById(String id) {\n        // find in MySQL\n        return null;\n    }\n    \n    public void update(Payment payment) {\n        // update in MySQL\n    }\n}\n\npublic class AESEncryption implements EncryptionService {\n    public String encrypt(String data) {\n        // AES encryption\n        return \"encrypted_\" + data;\n    }\n    \n    public String decrypt(String encryptedData) {\n        // AES decryption\n        return encryptedData.replace(\"encrypted_\", \"\");\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class OrderManagementSystem {\n    private PostgreSQLConnection dbConnection;\n    private RedisCache cache;\n    private KafkaMessageProducer messageProducer;\n    private StripePaymentGateway paymentGateway;\n    private AmazonS3FileStorage fileStorage;\n    \n    public OrderManagementSystem() {\n        this.dbConnection = new PostgreSQLConnection(\"localhost:5432/orders\");\n        this.cache = new RedisCache(\"localhost:6379\");\n        this.messageProducer = new KafkaMessageProducer(\"localhost:9092\");\n        this.paymentGateway = new StripePaymentGateway(\"sk_test_...\");\n        this.fileStorage = new AmazonS3FileStorage(\"order-receipts-bucket\");\n    }\n    \n    public Order createOrder(OrderRequest request) {\n        Order order = new Order(request);\n        \n        // Validate payment\n        PaymentResult result = paymentGateway.processPayment(\n            request.getPaymentToken(), request.getAmount());\n        \n        if (!result.isSuccessful()) {\n            throw new PaymentFailedException(\"Payment failed\");\n        }\n        \n        // Save to database\n        String sql = \"INSERT INTO orders (id, customer_id, amount, status) VALUES (?, ?, ?, ?)\";\n        dbConnection.executeUpdate(sql, order.getId(), order.getCustomerId(), \n                                 order.getAmount(), \"PENDING\");\n        \n        // Cache order\n        cache.set(\"order:\" + order.getId(), order.toJson(), 3600);\n        \n        // Send notification\n        OrderCreatedEvent event = new OrderCreatedEvent(order);\n        messageProducer.sendMessage(\"order-events\", event.toJson());\n        \n        // Generate receipt\n        String receiptPdf = generateReceipt(order);\n        String receiptUrl = fileStorage.uploadFile(\"receipt_\" + order.getId() + \".pdf\", \n                                                 receiptPdf.getBytes());\n        order.setReceiptUrl(receiptUrl);\n        \n        return order;\n    }\n    \n    public void cancelOrder(String orderId) {\n        // Complex cancellation logic with multiple dependencies\n        Order order = getOrderFromCacheOrDb(orderId);\n        \n        paymentGateway.refundPayment(order.getPaymentId());\n        \n        dbConnection.executeUpdate(\"UPDATE orders SET status = 'CANCELLED' WHERE id = ?\", orderId);\n        \n        cache.delete(\"order:\" + orderId);\n        \n        OrderCancelledEvent event = new OrderCancelledEvent(order);\n        messageProducer.sendMessage(\"order-events\", event.toJson());\n    }\n    \n    private Order getOrderFromCacheOrDb(String orderId) {\n        String cachedOrder = cache.get(\"order:\" + orderId);\n        if (cachedOrder != null) {\n            return Order.fromJson(cachedOrder);\n        }\n        \n        ResultSet rs = dbConnection.executeQuery(\"SELECT * FROM orders WHERE id = ?\", orderId);\n        return Order.fromResultSet(rs);\n    }\n}",
            "output": "public interface DatabaseConnection {\n    void executeUpdate(String sql, Object... params);\n    ResultSet executeQuery(String sql, Object... params);\n}\n\npublic interface CacheService {\n    void set(String key, String value, int ttl);\n    String get(String key);\n    void delete(String key);\n}\n\npublic interface MessageProducer {\n    void sendMessage(String topic, String message);\n}\n\npublic interface PaymentGateway {\n    PaymentResult processPayment(String token, BigDecimal amount);\n    RefundResult refundPayment(String paymentId);\n}\n\npublic interface FileStorage {\n    String uploadFile(String filename, byte[] content);\n    byte[] downloadFile(String filename);\n}\n\npublic interface OrderRepository {\n    void save(Order order);\n    Order findById(String id);\n    void update(Order order);\n}\n\npublic class OrderManagementSystem {\n    private final DatabaseConnection dbConnection;\n    private final CacheService cache;\n    private final MessageProducer messageProducer;\n    private final PaymentGateway paymentGateway;\n    private final FileStorage fileStorage;\n    private final OrderRepository orderRepository;\n    \n    public OrderManagementSystem(DatabaseConnection dbConnection,\n                               CacheService cache,\n                               MessageProducer messageProducer,\n                               PaymentGateway paymentGateway,\n                               FileStorage fileStorage,\n                               OrderRepository orderRepository) {\n        this.dbConnection = dbConnection;\n        this.cache = cache;\n        this.messageProducer = messageProducer;\n        this.paymentGateway = paymentGateway;\n        this.fileStorage = fileStorage;\n        this.orderRepository = orderRepository;\n    }\n    \n    public Order createOrder(OrderRequest request) {\n        Order order = new Order(request);\n        \n        PaymentResult result = paymentGateway.processPayment(\n            request.getPaymentToken(), request.getAmount());\n        \n        if (!result.isSuccessful()) {\n            throw new PaymentFailedException(\"Payment failed\");\n        }\n        \n        orderRepository.save(order);\n        \n        cache.set(\"order:\" + order.getId(), order.toJson(), 3600);\n        \n        OrderCreatedEvent event = new OrderCreatedEvent(order);\n        messageProducer.sendMessage(\"order-events\", event.toJson());\n        \n        String receiptPdf = generateReceipt(order);\n        String receiptUrl = fileStorage.uploadFile(\"receipt_\" + order.getId() + \".pdf\", \n                                                 receiptPdf.getBytes());\n        order.setReceiptUrl(receiptUrl);\n        \n        return order;\n    }\n    \n    public void cancelOrder(String orderId) {\n        Order order = getOrderFromCacheOrRepository(orderId);\n        \n        paymentGateway.refundPayment(order.getPaymentId());\n        \n        order.setStatus(\"CANCELLED\");\n        orderRepository.update(order);\n        \n        cache.delete(\"order:\" + orderId);\n        \n        OrderCancelledEvent event = new OrderCancelledEvent(order);\n        messageProducer.sendMessage(\"order-events\", event.toJson());\n    }\n    \n    private Order getOrderFromCacheOrRepository(String orderId) {\n        String cachedOrder = cache.get(\"order:\" + orderId);\n        if (cachedOrder != null) {\n            return Order.fromJson(cachedOrder);\n        }\n        return orderRepository.findById(orderId);\n    }\n}",
            "level": "HARD",
            "language": "JAVA",
            "violation": "DIP"
        },
        {
            "input": "public class OrderProcessingSystem\n{\n    private readonly MySqlConnection _dbConnection;\n    private readonly RabbitMQPublisher _eventPublisher;\n    private readonly RedisCache _cache;\n    private readonly EmailService _emailService;\n    private readonly AuditLogger _auditLogger;\n    \n    public OrderProcessingSystem()\n    {\n        _dbConnection = new MySqlConnection(\"server=localhost;database=orders\");\n        _eventPublisher = new RabbitMQPublisher(\"amqp://localhost:5672\");\n        _cache = new RedisCache(\"localhost:6379\");\n        _emailService = new EmailService(\"smtp.gmail.com\", 587);\n        _auditLogger = new AuditLogger(\"C:\\\\logs\\\\audit.log\");\n    }\n    \n    public async Task<bool> ProcessOrder(Order order)\n    {\n        try\n        {\n            // Validate order against cache\n            var cachedCustomer = await _cache.GetAsync($\"customer:{order.CustomerId}\");\n            if (cachedCustomer == null)\n            {\n                var customer = await _dbConnection.QueryFirstOrDefaultAsync<Customer>(\n                    \"SELECT * FROM Customers WHERE Id = @Id\", new { Id = order.CustomerId });\n                if (customer == null) return false;\n                await _cache.SetAsync($\"customer:{order.CustomerId}\", customer, TimeSpan.FromMinutes(30));\n            }\n            \n            // Process payment\n            var transaction = new Transaction\n            {\n                OrderId = order.Id,\n                Amount = order.TotalAmount,\n                Status = \"Processing\"\n            };\n            \n            await _dbConnection.ExecuteAsync(\n                \"INSERT INTO Transactions (OrderId, Amount, Status, CreatedAt) VALUES (@OrderId, @Amount, @Status, @CreatedAt)\",\n                new { transaction.OrderId, transaction.Amount, transaction.Status, CreatedAt = DateTime.UtcNow });\n            \n            // Update inventory\n            foreach (var item in order.Items)\n            {\n                await _dbConnection.ExecuteAsync(\n                    \"UPDATE Inventory SET Quantity = Quantity - @Quantity WHERE ProductId = @ProductId\",\n                    new { Quantity = item.Quantity, ProductId = item.ProductId });\n            }\n            \n            // Publish events\n            await _eventPublisher.PublishAsync(\"order.created\", new OrderCreatedEvent\n            {\n                OrderId = order.Id,\n                CustomerId = order.CustomerId,\n                TotalAmount = order.TotalAmount,\n                Timestamp = DateTime.UtcNow\n            });\n            \n            await _eventPublisher.PublishAsync(\"inventory.updated\", new InventoryUpdatedEvent\n            {\n                Items = order.Items.Select(i => new { i.ProductId, i.Quantity }).ToList(),\n                Timestamp = DateTime.UtcNow\n            });\n            \n            // Send confirmation email\n            await _emailService.SendAsync(order.CustomerEmail, \"Order Confirmation\",\n                $\"Your order #{order.Id} has been processed successfully.\");\n            \n            // Log audit trail\n            await _auditLogger.LogAsync(new AuditEntry\n            {\n                Action = \"ORDER_PROCESSED\",\n                EntityId = order.Id.ToString(),\n                UserId = order.CustomerId.ToString(),\n                Timestamp = DateTime.UtcNow,\n                Details = $\"Order processed with {order.Items.Count} items, total: {order.TotalAmount}\"\n            });\n            \n            return true;\n        }\n        catch (Exception ex)\n        {\n            await _auditLogger.LogAsync(new AuditEntry\n            {\n                Action = \"ORDER_PROCESSING_FAILED\",\n                EntityId = order.Id.ToString(),\n                Error = ex.Message,\n                Timestamp = DateTime.UtcNow\n            });\n            throw;\n        }\n    }\n}",
            "output": "public interface IRepository<T>\n{\n    Task<T> GetByIdAsync(int id);\n    Task<bool> InsertAsync(T entity);\n    Task<bool> UpdateAsync(T entity);\n}\n\npublic interface IEventPublisher\n{\n    Task PublishAsync<T>(string topic, T eventData);\n}\n\npublic interface ICacheService\n{\n    Task<T> GetAsync<T>(string key);\n    Task SetAsync<T>(string key, T value, TimeSpan expiration);\n}\n\npublic interface INotificationService\n{\n    Task SendAsync(string recipient, string subject, string message);\n}\n\npublic interface IAuditService\n{\n    Task LogAsync(AuditEntry entry);\n}\n\npublic interface IInventoryService\n{\n    Task<bool> ReserveItemsAsync(List<OrderItem> items);\n    Task<bool> UpdateInventoryAsync(List<OrderItem> items);\n}\n\npublic class OrderProcessingSystem\n{\n    private readonly IRepository<Customer> _customerRepository;\n    private readonly IRepository<Transaction> _transactionRepository;\n    private readonly IEventPublisher _eventPublisher;\n    private readonly ICacheService _cacheService;\n    private readonly INotificationService _notificationService;\n    private readonly IAuditService _auditService;\n    private readonly IInventoryService _inventoryService;\n    \n    public OrderProcessingSystem(\n        IRepository<Customer> customerRepository,\n        IRepository<Transaction> transactionRepository,\n        IEventPublisher eventPublisher,\n        ICacheService cacheService,\n        INotificationService notificationService,\n        IAuditService auditService,\n        IInventoryService inventoryService)\n    {\n        _customerRepository = customerRepository;\n        _transactionRepository = transactionRepository;\n        _eventPublisher = eventPublisher;\n        _cacheService = cacheService;\n        _notificationService = notificationService;\n        _auditService = auditService;\n        _inventoryService = inventoryService;\n    }\n    \n    public async Task<bool> ProcessOrder(Order order)\n    {\n        try\n        {\n            // Validate customer\n            var cachedCustomer = await _cacheService.GetAsync<Customer>($\"customer:{order.CustomerId}\");\n            if (cachedCustomer == null)\n            {\n                var customer = await _customerRepository.GetByIdAsync(order.CustomerId);\n                if (customer == null) return false;\n                await _cacheService.SetAsync($\"customer:{order.CustomerId}\", customer, TimeSpan.FromMinutes(30));\n            }\n            \n            // Process payment\n            var transaction = new Transaction\n            {\n                OrderId = order.Id,\n                Amount = order.TotalAmount,\n                Status = \"Processing\"\n            };\n            \n            await _transactionRepository.InsertAsync(transaction);\n            \n            // Update inventory\n            await _inventoryService.UpdateInventoryAsync(order.Items);\n            \n            // Publish events\n            await _eventPublisher.PublishAsync(\"order.created\", new OrderCreatedEvent\n            {\n                OrderId = order.Id,\n                CustomerId = order.CustomerId,\n                TotalAmount = order.TotalAmount,\n                Timestamp = DateTime.UtcNow\n            });\n            \n            await _eventPublisher.PublishAsync(\"inventory.updated\", new InventoryUpdatedEvent\n            {\n                Items = order.Items.Select(i => new { i.ProductId, i.Quantity }).ToList(),\n                Timestamp = DateTime.UtcNow\n            });\n            \n            // Send confirmation\n            await _notificationService.SendAsync(order.CustomerEmail, \"Order Confirmation\",\n                $\"Your order #{order.Id} has been processed successfully.\");\n            \n            // Log audit trail\n            await _auditService.LogAsync(new AuditEntry\n            {\n                Action = \"ORDER_PROCESSED\",\n                EntityId = order.Id.ToString(),\n                UserId = order.CustomerId.ToString(),\n                Timestamp = DateTime.UtcNow,\n                Details = $\"Order processed with {order.Items.Count} items, total: {order.TotalAmount}\"\n            });\n            \n            return true;\n        }\n        catch (Exception ex)\n        {\n            await _auditService.LogAsync(new AuditEntry\n            {\n                Action = \"ORDER_PROCESSING_FAILED\",\n                EntityId = order.Id.ToString(),\n                Error = ex.Message,\n                Timestamp = DateTime.UtcNow\n            });\n            throw;\n        }\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class ReportGenerationService\n{\n    private readonly SqlConnection _sqlConnection;\n    private readonly AzureBlobStorage _blobStorage;\n    private readonly SendGridEmailService _emailService;\n    private readonly ElasticsearchClient _searchClient;\n    \n    public ReportGenerationService()\n    {\n        _sqlConnection = new SqlConnection(\"Server=localhost;Database=Analytics;Trusted_Connection=true;\");\n        _blobStorage = new AzureBlobStorage(\"DefaultEndpointsProtocol=https;AccountName=reports;AccountKey=...\");\n        _emailService = new SendGridEmailService(\"SG.api_key_here\");\n        _searchClient = new ElasticsearchClient(\"http://localhost:9200\");\n    }\n    \n    public async Task<string> GenerateComprehensiveReport(ReportRequest request)\n    {\n        var reportData = new StringBuilder();\n        \n        // Fetch data from multiple sources\n        var salesData = await _sqlConnection.QueryAsync<SalesRecord>(\n            @\"SELECT s.*, p.Name as ProductName, c.Name as CustomerName \n              FROM Sales s \n              JOIN Products p ON s.ProductId = p.Id \n              JOIN Customers c ON s.CustomerId = c.Id \n              WHERE s.Date BETWEEN @StartDate AND @EndDate\",\n            new { request.StartDate, request.EndDate });\n        \n        var userBehaviorData = await _searchClient.SearchAsync<UserBehavior>(s => s\n            .Index(\"user-behavior\")\n            .Query(q => q\n                .DateRange(dr => dr\n                    .Field(f => f.Timestamp)\n                    .GreaterThanOrEquals(request.StartDate)\n                    .LessThanOrEquals(request.EndDate))));\n        \n        var performanceMetrics = await _sqlConnection.QueryAsync<PerformanceMetric>(\n            \"SELECT * FROM PerformanceMetrics WHERE Date BETWEEN @StartDate AND @EndDate\",\n            new { request.StartDate, request.EndDate });\n        \n        // Generate different report sections\n        reportData.AppendLine(\"=== SALES ANALYSIS ===\");\n        var totalSales = salesData.Sum(s => s.Amount);\n        var topProducts = salesData.GroupBy(s => s.ProductName)\n            .Select(g => new { Product = g.Key, Revenue = g.Sum(s => s.Amount) })\n            .OrderByDescending(x => x.Revenue)\n            .Take(10);\n        \n        reportData.AppendLine($\"Total Sales: ${totalSales:N2}\");\n        reportData.AppendLine($\"Total Transactions: {salesData.Count()}\");\n        reportData.AppendLine(\"Top 10 Products:\");\n        foreach (var product in topProducts)\n        {\n            reportData.AppendLine($\"  {product.Product}: ${product.Revenue:N2}\");\n        }\n        \n        reportData.AppendLine(\"\\n=== USER BEHAVIOR ANALYSIS ===\");\n        var behaviorStats = userBehaviorData.Documents.GroupBy(u => u.Action)\n            .Select(g => new { Action = g.Key, Count = g.Count() })\n            .OrderByDescending(x => x.Count);\n        \n        foreach (var stat in behaviorStats)\n        {\n            reportData.AppendLine($\"  {stat.Action}: {stat.Count} times\");\n        }\n        \n        reportData.AppendLine(\"\\n=== PERFORMANCE METRICS ===\");\n        var avgResponseTime = performanceMetrics.Average(p => p.ResponseTime);\n        var errorRate = performanceMetrics.Where(p => p.ErrorCount > 0).Count() / (double)performanceMetrics.Count();\n        \n        reportData.AppendLine($\"Average Response Time: {avgResponseTime:F2}ms\");\n        reportData.AppendLine($\"Error Rate: {errorRate:P2}\");\n        \n        // Generate charts and visualizations\n        var chartData = GenerateChartData(salesData, userBehaviorData.Documents, performanceMetrics);\n        var reportHtml = GenerateHtmlReport(reportData.ToString(), chartData);\n        \n        // Store report in blob storage\n        var reportFileName = $\"report_{request.StartDate:yyyyMMdd}_{request.EndDate:yyyyMMdd}_{Guid.NewGuid()}.html\";\n        var reportUrl = await _blobStorage.UploadTextAsync(\"reports\", reportFileName, reportHtml);\n        \n        // Send email notification\n        await _emailService.SendEmailAsync(new EmailMessage\n        {\n            To = request.RecipientEmail,\n            Subject = $\"Comprehensive Report: {request.StartDate:yyyy-MM-dd} to {request.EndDate:yyyy-MM-dd}\",\n            HtmlContent = $@\"\n                <h2>Your report is ready!</h2>\n                <p>The comprehensive report covering {request.StartDate:yyyy-MM-dd} to {request.EndDate:yyyy-MM-dd} has been generated.</p>\n                <p><a href='{reportUrl}'>Download Report</a></p>\n                <h3>Quick Summary:</h3>\n                <ul>\n                    <li>Total Sales: ${totalSales:N2}</li>\n                    <li>Total Transactions: {salesData.Count()}</li>\n                    <li>Average Response Time: {avgResponseTime:F2}ms</li>\n                    <li>Error Rate: {errorRate:P2}</li>\n                </ul>\"\n        });\n        \n        return reportUrl;\n    }\n    \n    private ChartData GenerateChartData(IEnumerable<SalesRecord> sales, IEnumerable<UserBehavior> behavior, IEnumerable<PerformanceMetric> metrics)\n    {\n        // Complex chart generation logic\n        return new ChartData();\n    }\n    \n    private string GenerateHtmlReport(string textContent, ChartData chartData)\n    {\n        // HTML report generation logic\n        return $\"<html><body>{textContent}</body></html>\";\n    }\n}",
            "output": "public interface IDataRepository\n{\n    Task<IEnumerable<T>> QueryAsync<T>(string query, object parameters = null);\n    Task<T> QueryFirstOrDefaultAsync<T>(string query, object parameters = null);\n}\n\npublic interface ISearchService\n{\n    Task<SearchResult<T>> SearchAsync<T>(SearchQuery query);\n}\n\npublic interface IFileStorage\n{\n    Task<string> UploadTextAsync(string container, string fileName, string content);\n    Task<string> UploadBinaryAsync(string container, string fileName, byte[] content);\n}\n\npublic interface IEmailService\n{\n    Task SendEmailAsync(EmailMessage message);\n}\n\npublic interface IReportBuilder\n{\n    Task<ReportData> BuildSalesAnalysisAsync(DateTime startDate, DateTime endDate);\n    Task<ReportData> BuildUserBehaviorAnalysisAsync(DateTime startDate, DateTime endDate);\n    Task<ReportData> BuildPerformanceAnalysisAsync(DateTime startDate, DateTime endDate);\n}\n\npublic interface IReportFormatter\n{\n    string FormatAsHtml(IEnumerable<ReportData> reportSections);\n    string FormatAsText(IEnumerable<ReportData> reportSections);\n    ChartData GenerateCharts(IEnumerable<ReportData> reportSections);\n}\n\npublic interface INotificationService\n{\n    Task SendReportNotificationAsync(string recipient, string reportUrl, ReportSummary summary);\n}\n\npublic class ReportGenerationService\n{\n    private readonly IDataRepository _dataRepository;\n    private readonly ISearchService _searchService;\n    private readonly IFileStorage _fileStorage;\n    private readonly IEmailService _emailService;\n    private readonly IReportBuilder _reportBuilder;\n    private readonly IReportFormatter _reportFormatter;\n    private readonly INotificationService _notificationService;\n    \n    public ReportGenerationService(\n        IDataRepository dataRepository,\n        ISearchService searchService,\n        IFileStorage fileStorage,\n        IEmailService emailService,\n        IReportBuilder reportBuilder,\n        IReportFormatter reportFormatter,\n        INotificationService notificationService)\n    {\n        _dataRepository = dataRepository;\n        _searchService = searchService;\n        _fileStorage = fileStorage;\n        _emailService = emailService;\n        _reportBuilder = reportBuilder;\n        _reportFormatter = reportFormatter;\n        _notificationService = notificationService;\n    }\n    \n    public async Task<string> GenerateComprehensiveReport(ReportRequest request)\n    {\n        // Build report sections using abstracted services\n        var reportSections = new List<ReportData>\n        {\n            await _reportBuilder.BuildSalesAnalysisAsync(request.StartDate, request.EndDate),\n            await _reportBuilder.BuildUserBehaviorAnalysisAsync(request.StartDate, request.EndDate),\n            await _reportBuilder.BuildPerformanceAnalysisAsync(request.StartDate, request.EndDate)\n        };\n        \n        // Format report using abstracted formatter\n        var reportHtml = _reportFormatter.FormatAsHtml(reportSections);\n        \n        // Store report using abstracted storage\n        var reportFileName = $\"report_{request.StartDate:yyyyMMdd}_{request.EndDate:yyyyMMdd}_{Guid.NewGuid()}.html\";\n        var reportUrl = await _fileStorage.UploadTextAsync(\"reports\", reportFileName, reportHtml);\n        \n        // Send notification using abstracted service\n        var summary = new ReportSummary\n        {\n            StartDate = request.StartDate,\n            EndDate = request.EndDate,\n            TotalSales = reportSections.FirstOrDefault(r => r.Type == \"Sales\")?.GetMetric(\"TotalSales\") ?? 0,\n            TransactionCount = reportSections.FirstOrDefault(r => r.Type == \"Sales\")?.GetMetric(\"TransactionCount\") ?? 0,\n            AvgResponseTime = reportSections.FirstOrDefault(r => r.Type == \"Performance\")?.GetMetric(\"AvgResponseTime\") ?? 0,\n            ErrorRate = reportSections.FirstOrDefault(r => r.Type == \"Performance\")?.GetMetric(\"ErrorRate\") ?? 0\n        };\n        \n        await _notificationService.SendReportNotificationAsync(request.RecipientEmail, reportUrl, summary);\n        \n        return reportUrl;\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class PaymentProcessingOrchestrator\n{\n    private readonly SqlServerPaymentRepository _paymentRepo;\n    private readonly StripePaymentGateway _stripeGateway;\n    private readonly PayPalPaymentGateway _paypalGateway;\n    private readonly SmtpEmailService _emailService;\n    private readonly TwilioSmsService _smsService;\n    private readonly RedisCache _cache;\n    private readonly ElasticsearchLogger _logger;\n    \n    public PaymentProcessingOrchestrator()\n    {\n        _paymentRepo = new SqlServerPaymentRepository(\"connectionString\");\n        _stripeGateway = new StripePaymentGateway(\"stripe_key\");\n        _paypalGateway = new PayPalPaymentGateway(\"paypal_credentials\");\n        _emailService = new SmtpEmailService(\"smtp.gmail.com\", 587);\n        _smsService = new TwilioSmsService(\"twilio_sid\", \"twilio_token\");\n        _cache = new RedisCache(\"redis://localhost:6379\");\n        _logger = new ElasticsearchLogger(\"http://elasticsearch:9200\");\n    }\n    \n    public async Task<PaymentResult> ProcessPayment(PaymentRequest request)\n    {\n        try\n        {\n            _logger.LogInfo($\"Processing payment {request.Id}\");\n            \n            var cachedResult = _cache.Get<PaymentResult>($\"payment_{request.Id}\");\n            if (cachedResult != null)\n            {\n                return cachedResult;\n            }\n            \n            PaymentResult result;\n            if (request.PaymentMethod == \"stripe\")\n            {\n                result = await _stripeGateway.ProcessPayment(request.Amount, request.Currency, request.Token);\n            }\n            else if (request.PaymentMethod == \"paypal\")\n            {\n                result = await _paypalGateway.ProcessPayment(request.Amount, request.Currency, request.PayPalToken);\n            }\n            else\n            {\n                throw new InvalidOperationException(\"Unsupported payment method\");\n            }\n            \n            await _paymentRepo.SavePayment(new Payment\n            {\n                Id = request.Id,\n                Amount = request.Amount,\n                Status = result.Status,\n                TransactionId = result.TransactionId,\n                ProcessedAt = DateTime.UtcNow\n            });\n            \n            _cache.Set($\"payment_{request.Id}\", result, TimeSpan.FromMinutes(30));\n            \n            if (result.IsSuccess)\n            {\n                await _emailService.SendEmail(request.CustomerEmail, \"Payment Confirmation\", \n                    $\"Your payment of {request.Amount} {request.Currency} was successful.\");\n                    \n                if (!string.IsNullOrEmpty(request.CustomerPhone))\n                {\n                    await _smsService.SendSms(request.CustomerPhone, \n                        $\"Payment confirmed: {request.Amount} {request.Currency}\");\n                }\n            }\n            \n            _logger.LogInfo($\"Payment {request.Id} processed successfully\");\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError($\"Payment processing failed: {ex.Message}\");\n            throw;\n        }\n    }\n}",
            "output": "public interface IPaymentRepository\n{\n    Task SavePayment(Payment payment);\n    Task<Payment> GetPayment(string id);\n}\n\npublic interface IPaymentGateway\n{\n    Task<PaymentResult> ProcessPayment(decimal amount, string currency, string token);\n    string SupportedMethod { get; }\n}\n\npublic interface INotificationService\n{\n    Task SendNotification(string recipient, string subject, string message);\n}\n\npublic interface ICacheService\n{\n    T Get<T>(string key) where T : class;\n    void Set<T>(string key, T value, TimeSpan expiration);\n}\n\npublic interface ILogger\n{\n    void LogInfo(string message);\n    void LogError(string message);\n}\n\npublic class PaymentProcessingOrchestrator\n{\n    private readonly IPaymentRepository _paymentRepo;\n    private readonly IEnumerable<IPaymentGateway> _paymentGateways;\n    private readonly IEnumerable<INotificationService> _notificationServices;\n    private readonly ICacheService _cache;\n    private readonly ILogger _logger;\n    \n    public PaymentProcessingOrchestrator(\n        IPaymentRepository paymentRepo,\n        IEnumerable<IPaymentGateway> paymentGateways,\n        IEnumerable<INotificationService> notificationServices,\n        ICacheService cache,\n        ILogger logger)\n    {\n        _paymentRepo = paymentRepo;\n        _paymentGateways = paymentGateways;\n        _notificationServices = notificationServices;\n        _cache = cache;\n        _logger = logger;\n    }\n    \n    public async Task<PaymentResult> ProcessPayment(PaymentRequest request)\n    {\n        try\n        {\n            _logger.LogInfo($\"Processing payment {request.Id}\");\n            \n            var cachedResult = _cache.Get<PaymentResult>($\"payment_{request.Id}\");\n            if (cachedResult != null)\n            {\n                return cachedResult;\n            }\n            \n            var gateway = _paymentGateways.FirstOrDefault(g => g.SupportedMethod == request.PaymentMethod);\n            if (gateway == null)\n            {\n                throw new InvalidOperationException($\"Unsupported payment method: {request.PaymentMethod}\");\n            }\n            \n            var result = await gateway.ProcessPayment(request.Amount, request.Currency, request.Token);\n            \n            await _paymentRepo.SavePayment(new Payment\n            {\n                Id = request.Id,\n                Amount = request.Amount,\n                Status = result.Status,\n                TransactionId = result.TransactionId,\n                ProcessedAt = DateTime.UtcNow\n            });\n            \n            _cache.Set($\"payment_{request.Id}\", result, TimeSpan.FromMinutes(30));\n            \n            if (result.IsSuccess)\n            {\n                var notifications = new[]\n                {\n                    (request.CustomerEmail, $\"Your payment of {request.Amount} {request.Currency} was successful.\"),\n                    (request.CustomerPhone, $\"Payment confirmed: {request.Amount} {request.Currency}\")\n                }.Where(n => !string.IsNullOrEmpty(n.Item1));\n                \n                foreach (var (recipient, message) in notifications)\n                {\n                    foreach (var service in _notificationServices)\n                    {\n                        await service.SendNotification(recipient, \"Payment Confirmation\", message);\n                    }\n                }\n            }\n            \n            _logger.LogInfo($\"Payment {request.Id} processed successfully\");\n            return result;\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError($\"Payment processing failed: {ex.Message}\");\n            throw;\n        }\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "public class DataMigrationEngine\n{\n    private readonly SqlServerConnection _sourceDb;\n    private readonly PostgreSqlConnection _targetDb;\n    private readonly AmazonS3Client _s3Client;\n    private readonly ElasticsearchClient _searchClient;\n    private readonly RabbitMqProducer _messageQueue;\n    private readonly FileSystemLogger _logger;\n    private readonly JsonConfigManager _configManager;\n    \n    public DataMigrationEngine()\n    {\n        _sourceDb = new SqlServerConnection(\"Server=source;Database=Legacy;\");\n        _targetDb = new PostgreSqlConnection(\"Host=target;Database=Modern;\");\n        _s3Client = new AmazonS3Client(\"aws_key\", \"aws_secret\", RegionEndpoint.USEast1);\n        _searchClient = new ElasticsearchClient(new Uri(\"http://elasticsearch:9200\"));\n        _messageQueue = new RabbitMqProducer(\"amqp://rabbitmq:5672\");\n        _logger = new FileSystemLogger(\"C:\\\\logs\\\\migration.log\");\n        _configManager = new JsonConfigManager(\"migration-config.json\");\n    }\n    \n    public async Task<MigrationResult> ExecuteMigration(string migrationName)\n    {\n        var config = _configManager.GetMigrationConfig(migrationName);\n        var startTime = DateTime.UtcNow;\n        \n        try\n        {\n            _logger.Log($\"Starting migration: {migrationName}\");\n            \n            var sourceQuery = config.SourceQuery;\n            var sourceData = await _sourceDb.ExecuteQuery(sourceQuery);\n            \n            var transformedData = new List<Dictionary<string, object>>();\n            var batchSize = config.BatchSize;\n            var totalRecords = sourceData.Count();\n            var processedRecords = 0;\n            \n            foreach (var batch in sourceData.Chunk(batchSize))\n            {\n                var transformedBatch = new List<Dictionary<string, object>>();\n                \n                foreach (var record in batch)\n                {\n                    var transformed = TransformRecord(record, config.TransformationRules);\n                    transformedBatch.Add(transformed);\n                    \n                    if (config.EnableSearch)\n                    {\n                        await _searchClient.IndexAsync(\"migrated_data\", transformed);\n                    }\n                    \n                    if (config.BackupToS3)\n                    {\n                        var json = JsonConvert.SerializeObject(transformed);\n                        await _s3Client.PutObjectAsync(new PutObjectRequest\n                        {\n                            BucketName = \"migration-backup\",\n                            Key = $\"{migrationName}/{record[\"id\"]}.json\",\n                            ContentBody = json\n                        });\n                    }\n                }\n                \n                await _targetDb.BulkInsert(config.TargetTable, transformedBatch);\n                transformedData.AddRange(transformedBatch);\n                \n                processedRecords += batch.Count();\n                var progress = (double)processedRecords / totalRecords * 100;\n                \n                await _messageQueue.PublishMessage(\"migration.progress\", new\n                {\n                    MigrationName = migrationName,\n                    Progress = progress,\n                    ProcessedRecords = processedRecords,\n                    TotalRecords = totalRecords,\n                    Timestamp = DateTime.UtcNow\n                });\n                \n                _logger.Log($\"Processed batch: {processedRecords}/{totalRecords} ({progress:F2}%)\");\n            }\n            \n            var duration = DateTime.UtcNow - startTime;\n            _logger.Log($\"Migration {migrationName} completed in {duration.TotalMinutes:F2} minutes\");\n            \n            return new MigrationResult\n            {\n                Success = true,\n                RecordsProcessed = processedRecords,\n                Duration = duration,\n                MigrationName = migrationName\n            };\n        }\n        catch (Exception ex)\n        {\n            _logger.Log($\"Migration failed: {ex.Message}\");\n            \n            await _messageQueue.PublishMessage(\"migration.failed\", new\n            {\n                MigrationName = migrationName,\n                Error = ex.Message,\n                Timestamp = DateTime.UtcNow\n            });\n            \n            throw;\n        }\n    }\n}",
            "output": "public interface ISourceDatabase\n{\n    Task<IEnumerable<Dictionary<string, object>>> ExecuteQuery(string query);\n}\n\npublic interface ITargetDatabase\n{\n    Task BulkInsert(string table, IEnumerable<Dictionary<string, object>> data);\n}\n\npublic interface ICloudStorage\n{\n    Task StoreData(string path, string content);\n}\n\npublic interface ISearchIndexer\n{\n    Task IndexData(string index, Dictionary<string, object> document);\n}\n\npublic interface IMessagePublisher\n{\n    Task PublishMessage(string topic, object message);\n}\n\npublic interface IMigrationLogger\n{\n    void Log(string message);\n}\n\npublic interface IConfigurationManager\n{\n    MigrationConfig GetMigrationConfig(string name);\n}\n\npublic interface IDataTransformer\n{\n    Dictionary<string, object> TransformRecord(Dictionary<string, object> record, TransformationRules rules);\n}\n\npublic class DataMigrationEngine\n{\n    private readonly ISourceDatabase _sourceDb;\n    private readonly ITargetDatabase _targetDb;\n    private readonly ICloudStorage _storage;\n    private readonly ISearchIndexer _searchIndexer;\n    private readonly IMessagePublisher _messagePublisher;\n    private readonly IMigrationLogger _logger;\n    private readonly IConfigurationManager _configManager;\n    private readonly IDataTransformer _transformer;\n    \n    public DataMigrationEngine(\n        ISourceDatabase sourceDb,\n        ITargetDatabase targetDb,\n        ICloudStorage storage,\n        ISearchIndexer searchIndexer,\n        IMessagePublisher messagePublisher,\n        IMigrationLogger logger,\n        IConfigurationManager configManager,\n        IDataTransformer transformer)\n    {\n        _sourceDb = sourceDb;\n        _targetDb = targetDb;\n        _storage = storage;\n        _searchIndexer = searchIndexer;\n        _messagePublisher = messagePublisher;\n        _logger = logger;\n        _configManager = configManager;\n        _transformer = transformer;\n    }\n    \n    public async Task<MigrationResult> ExecuteMigration(string migrationName)\n    {\n        var config = _configManager.GetMigrationConfig(migrationName);\n        var startTime = DateTime.UtcNow;\n        \n        try\n        {\n            _logger.Log($\"Starting migration: {migrationName}\");\n            \n            var sourceData = await _sourceDb.ExecuteQuery(config.SourceQuery);\n            var totalRecords = sourceData.Count();\n            var processedRecords = 0;\n            \n            foreach (var batch in sourceData.Chunk(config.BatchSize))\n            {\n                var transformedBatch = new List<Dictionary<string, object>>();\n                \n                foreach (var record in batch)\n                {\n                    var transformed = _transformer.TransformRecord(record, config.TransformationRules);\n                    transformedBatch.Add(transformed);\n                    \n                    if (config.EnableSearch)\n                    {\n                        await _searchIndexer.IndexData(\"migrated_data\", transformed);\n                    }\n                    \n                    if (config.BackupToStorage)\n                    {\n                        var json = JsonConvert.SerializeObject(transformed);\n                        await _storage.StoreData($\"{migrationName}/{record[\"id\"]}.json\", json);\n                    }\n                }\n                \n                await _targetDb.BulkInsert(config.TargetTable, transformedBatch);\n                processedRecords += batch.Count();\n                \n                await PublishProgress(migrationName, processedRecords, totalRecords);\n                _logger.Log($\"Processed batch: {processedRecords}/{totalRecords}\");\n            }\n            \n            var duration = DateTime.UtcNow - startTime;\n            _logger.Log($\"Migration {migrationName} completed in {duration.TotalMinutes:F2} minutes\");\n            \n            return new MigrationResult\n            {\n                Success = true,\n                RecordsProcessed = processedRecords,\n                Duration = duration,\n                MigrationName = migrationName\n            };\n        }\n        catch (Exception ex)\n        {\n            _logger.Log($\"Migration failed: {ex.Message}\");\n            await _messagePublisher.PublishMessage(\"migration.failed\", new { MigrationName = migrationName, Error = ex.Message });\n            throw;\n        }\n    }\n    \n    private async Task PublishProgress(string migrationName, int processed, int total)\n    {\n        var progress = (double)processed / total * 100;\n        await _messagePublisher.PublishMessage(\"migration.progress\", new\n        {\n            MigrationName = migrationName,\n            Progress = progress,\n            ProcessedRecords = processed,\n            TotalRecords = total,\n            Timestamp = DateTime.UtcNow\n        });\n    }\n}",
            "level": "HARD",
            "language": "C#",
            "violation": "DIP"
        },
        {
            "input": "class EventSourcingSystem {\n    private val postgresEventStore = PostgresEventStore()\n    private val redisSnapshotStore = RedisSnapshotStore()\n    private val kafkaPublisher = KafkaEventPublisher()\n    private val elasticsearchProjector = ElasticsearchProjector()\n    private val metricsCollector = PrometheusMetricsCollector()\n    \n    fun processCommand(command: DomainCommand): CommandResult {\n        val currentState = loadCurrentState(command.aggregateId)\n        val events = currentState.handle(command)\n        \n        // Store events\n        events.forEach { event ->\n            postgresEventStore.append(event)\n            metricsCollector.recordEvent(\"event_stored\", event.type)\n        }\n        \n        // Update snapshot if needed\n        if (events.size > 10) {\n            val snapshot = currentState.createSnapshot()\n            redisSnapshotStore.save(snapshot)\n            metricsCollector.recordEvent(\"snapshot_created\", command.aggregateId)\n        }\n        \n        // Publish events\n        events.forEach { event ->\n            kafkaPublisher.publish(event)\n            elasticsearchProjector.project(event)\n        }\n        \n        return CommandResult.Success(events)\n    }\n    \n    private fun loadCurrentState(aggregateId: String): AggregateRoot {\n        val snapshot = redisSnapshotStore.load(aggregateId)\n        val events = postgresEventStore.getEventsAfter(aggregateId, snapshot?.version ?: 0)\n        return AggregateRoot.fromSnapshot(snapshot).apply(events)\n    }\n}\n\nclass PostgresEventStore {\n    fun append(event: DomainEvent) { /* Postgres-specific logic */ }\n    fun getEventsAfter(aggregateId: String, version: Long): List<DomainEvent> = emptyList()\n}\n\nclass RedisSnapshotStore {\n    fun save(snapshot: AggregateSnapshot) { /* Redis-specific logic */ }\n    fun load(aggregateId: String): AggregateSnapshot? = null\n}\n\nclass KafkaEventPublisher {\n    fun publish(event: DomainEvent) { /* Kafka-specific logic */ }\n}\n\nclass ElasticsearchProjector {\n    fun project(event: DomainEvent) { /* Elasticsearch-specific logic */ }\n}\n\nclass PrometheusMetricsCollector {\n    fun recordEvent(metric: String, tag: String) { /* Prometheus-specific logic */ }\n}",
            "output": "interface EventStore {\n    fun append(event: DomainEvent)\n    fun getEventsAfter(aggregateId: String, version: Long): List<DomainEvent>\n}\n\ninterface SnapshotStore {\n    fun save(snapshot: AggregateSnapshot)\n    fun load(aggregateId: String): AggregateSnapshot?\n}\n\ninterface EventPublisher {\n    fun publish(event: DomainEvent)\n}\n\ninterface EventProjector {\n    fun project(event: DomainEvent)\n}\n\ninterface MetricsCollector {\n    fun recordEvent(metric: String, tag: String)\n}\n\nclass EventSourcingSystem(\n    private val eventStore: EventStore,\n    private val snapshotStore: SnapshotStore,\n    private val eventPublisher: EventPublisher,\n    private val eventProjector: EventProjector,\n    private val metricsCollector: MetricsCollector\n) {\n    fun processCommand(command: DomainCommand): CommandResult {\n        val currentState = loadCurrentState(command.aggregateId)\n        val events = currentState.handle(command)\n        \n        // Store events\n        events.forEach { event ->\n            eventStore.append(event)\n            metricsCollector.recordEvent(\"event_stored\", event.type)\n        }\n        \n        // Update snapshot if needed\n        if (events.size > 10) {\n            val snapshot = currentState.createSnapshot()\n            snapshotStore.save(snapshot)\n            metricsCollector.recordEvent(\"snapshot_created\", command.aggregateId)\n        }\n        \n        // Publish events\n        events.forEach { event ->\n            eventPublisher.publish(event)\n            eventProjector.project(event)\n        }\n        \n        return CommandResult.Success(events)\n    }\n    \n    private fun loadCurrentState(aggregateId: String): AggregateRoot {\n        val snapshot = snapshotStore.load(aggregateId)\n        val events = eventStore.getEventsAfter(aggregateId, snapshot?.version ?: 0)\n        return AggregateRoot.fromSnapshot(snapshot).apply(events)\n    }\n}\n\n// Concrete implementations\nclass PostgresEventStore : EventStore {\n    override fun append(event: DomainEvent) { /* Postgres-specific logic */ }\n    override fun getEventsAfter(aggregateId: String, version: Long): List<DomainEvent> = emptyList()\n}\n\nclass RedisSnapshotStore : SnapshotStore {\n    override fun save(snapshot: AggregateSnapshot) { /* Redis-specific logic */ }\n    override fun load(aggregateId: String): AggregateSnapshot? = null\n}\n\nclass KafkaEventPublisher : EventPublisher {\n    override fun publish(event: DomainEvent) { /* Kafka-specific logic */ }\n}\n\nclass ElasticsearchProjector : EventProjector {\n    override fun project(event: DomainEvent) { /* Elasticsearch-specific logic */ }\n}\n\nclass PrometheusMetricsCollector : MetricsCollector {\n    override fun recordEvent(metric: String, tag: String) { /* Prometheus-specific logic */ }\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class DistributedCacheManager {\n    private val redisCluster = RedisClusterClient()\n    private val memcachedClient = MemcachedClient()\n    private val consulServiceDiscovery = ConsulServiceDiscovery()\n    private val datadogMetrics = DatadogMetricsReporter()\n    private val circuitBreaker = HystrixCircuitBreaker()\n    \n    fun get(key: String): Any? {\n        val services = consulServiceDiscovery.getHealthyServices(\"cache\")\n        \n        return try {\n            circuitBreaker.execute {\n                when {\n                    services.any { it.name == \"redis\" } -> {\n                        val result = redisCluster.get(key)\n                        datadogMetrics.increment(\"cache.hit.redis\")\n                        result\n                    }\n                    services.any { it.name == \"memcached\" } -> {\n                        val result = memcachedClient.get(key)\n                        datadogMetrics.increment(\"cache.hit.memcached\")\n                        result\n                    }\n                    else -> {\n                        datadogMetrics.increment(\"cache.miss.no_service\")\n                        null\n                    }\n                }\n            }\n        } catch (e: Exception) {\n            datadogMetrics.increment(\"cache.error\")\n            null\n        }\n    }\n    \n    fun put(key: String, value: Any, ttl: Duration) {\n        val services = consulServiceDiscovery.getHealthyServices(\"cache\")\n        \n        services.forEach { service ->\n            try {\n                when (service.name) {\n                    \"redis\" -> {\n                        redisCluster.setex(key, ttl.seconds.toInt(), value)\n                        datadogMetrics.increment(\"cache.write.redis\")\n                    }\n                    \"memcached\" -> {\n                        memcachedClient.set(key, value, ttl.seconds.toInt())\n                        datadogMetrics.increment(\"cache.write.memcached\")\n                    }\n                }\n            } catch (e: Exception) {\n                datadogMetrics.increment(\"cache.write.error\", \"service:${service.name}\")\n            }\n        }\n    }\n}\n\nclass RedisClusterClient {\n    fun get(key: String): Any? = null\n    fun setex(key: String, seconds: Int, value: Any) {}\n}\n\nclass MemcachedClient {\n    fun get(key: String): Any? = null\n    fun set(key: String, value: Any, ttl: Int) {}\n}\n\nclass ConsulServiceDiscovery {\n    fun getHealthyServices(serviceName: String): List<ServiceInstance> = emptyList()\n}\n\nclass DatadogMetricsReporter {\n    fun increment(metric: String, tags: String = \"\") {}\n}\n\nclass HystrixCircuitBreaker {\n    fun <T> execute(action: () -> T): T = action()\n}",
            "output": "interface CacheClient {\n    fun get(key: String): Any?\n    fun put(key: String, value: Any, ttl: Duration)\n}\n\ninterface ServiceDiscovery {\n    fun getHealthyServices(serviceName: String): List<ServiceInstance>\n}\n\ninterface MetricsReporter {\n    fun increment(metric: String, tags: String = \"\")\n}\n\ninterface CircuitBreaker {\n    fun <T> execute(action: () -> T): T\n}\n\nclass DistributedCacheManager(\n    private val cacheClients: Map<String, CacheClient>,\n    private val serviceDiscovery: ServiceDiscovery,\n    private val metricsReporter: MetricsReporter,\n    private val circuitBreaker: CircuitBreaker\n) {\n    fun get(key: String): Any? {\n        val services = serviceDiscovery.getHealthyServices(\"cache\")\n        val prioritizedService = services.firstOrNull()\n        \n        return try {\n            circuitBreaker.execute {\n                prioritizedService?.let { service ->\n                    cacheClients[service.name]?.get(key)?.also {\n                        metricsReporter.increment(\"cache.hit.${service.name}\")\n                    }\n                } ?: run {\n                    metricsReporter.increment(\"cache.miss.no_service\")\n                    null\n                }\n            }\n        } catch (e: Exception) {\n            metricsReporter.increment(\"cache.error\")\n            null\n        }\n    }\n    \n    fun put(key: String, value: Any, ttl: Duration) {\n        val services = serviceDiscovery.getHealthyServices(\"cache\")\n        \n        services.forEach { service ->\n            try {\n                cacheClients[service.name]?.put(key, value, ttl)\n                metricsReporter.increment(\"cache.write.${service.name}\")\n            } catch (e: Exception) {\n                metricsReporter.increment(\"cache.write.error\", \"service:${service.name}\")\n            }\n        }\n    }\n}\n\n// Concrete implementations\nclass RedisCacheClient(private val redisCluster: RedisClusterClient) : CacheClient {\n    override fun get(key: String): Any? = redisCluster.get(key)\n    override fun put(key: String, value: Any, ttl: Duration) {\n        redisCluster.setex(key, ttl.seconds.toInt(), value)\n    }\n}\n\nclass MemcachedCacheClient(private val memcachedClient: MemcachedClient) : CacheClient {\n    override fun get(key: String): Any? = memcachedClient.get(key)\n    override fun put(key: String, value: Any, ttl: Duration) {\n        memcachedClient.set(key, value, ttl.seconds.toInt())\n    }\n}\n\nclass ConsulServiceDiscovery : ServiceDiscovery {\n    override fun getHealthyServices(serviceName: String): List<ServiceInstance> = emptyList()\n}\n\nclass DatadogMetricsReporter : MetricsReporter {\n    override fun increment(metric: String, tags: String) {}\n}\n\nclass HystrixCircuitBreaker : CircuitBreaker {\n    override fun <T> execute(action: () -> T): T = action()\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class MLModelTrainingPipeline {\n    private val s3DataSource = S3DataSource()\n    private val tensorflowTrainer = TensorflowModelTrainer()\n    private val wandbExperimentTracker = WandbExperimentTracker()\n    private val mlflowModelRegistry = MLFlowModelRegistry()\n    private val kubernetesJobScheduler = KubernetesJobScheduler()\n    private val slackNotifier = SlackNotificationService()\n    \n    fun trainModel(config: TrainingConfig): TrainingResult {\n        val experimentId = wandbExperimentTracker.startExperiment(config.modelName)\n        \n        try {\n            // Load and preprocess data\n            val rawData = s3DataSource.loadDataset(config.datasetPath)\n            val preprocessedData = preprocessData(rawData, config.preprocessingSteps)\n            \n            // Schedule training job\n            val jobId = kubernetesJobScheduler.scheduleTrainingJob(\n                image = \"tensorflow/tensorflow:latest-gpu\",\n                resources = config.computeResources,\n                data = preprocessedData\n            )\n            \n            // Monitor training\n            val trainingMetrics = monitorTraining(jobId, experimentId)\n            \n            // Train model\n            val trainedModel = tensorflowTrainer.train(\n                data = preprocessedData,\n                config = config,\n                metricsCallback = { metrics ->\n                    wandbExperimentTracker.logMetrics(experimentId, metrics)\n                }\n            )\n            \n            // Evaluate and register model\n            val evaluation = evaluateModel(trainedModel, preprocessedData.testSet)\n            \n            if (evaluation.accuracy > config.minimumAccuracy) {\n                val modelVersion = mlflowModelRegistry.registerModel(\n                    model = trainedModel,\n                    metrics = evaluation,\n                    experimentId = experimentId\n                )\n                \n                slackNotifier.sendMessage(\n                    channel = \"#ml-team\",\n                    message = \"Model ${config.modelName} v${modelVersion} trained successfully! Accuracy: ${evaluation.accuracy}\"\n                )\n                \n                return TrainingResult.Success(modelVersion, evaluation)\n            } else {\n                slackNotifier.sendMessage(\n                    channel = \"#ml-team\",\n                    message = \"Model ${config.modelName} training failed. Accuracy ${evaluation.accuracy} below threshold ${config.minimumAccuracy}\"\n                )\n                \n                return TrainingResult.Failed(\"Accuracy below threshold\")\n            }\n        } catch (e: Exception) {\n            wandbExperimentTracker.logError(experimentId, e.message ?: \"Unknown error\")\n            slackNotifier.sendMessage(\n                channel = \"#ml-team\",\n                message = \"Model ${config.modelName} training failed with error: ${e.message}\"\n            )\n            throw e\n        }\n    }\n}\n\nclass S3DataSource {\n    fun loadDataset(path: String): RawDataset = RawDataset()\n}\n\nclass TensorflowModelTrainer {\n    fun train(data: PreprocessedDataset, config: TrainingConfig, metricsCallback: (Map<String, Double>) -> Unit): TrainedModel = TrainedModel()\n}\n\nclass WandbExperimentTracker {\n    fun startExperiment(modelName: String): String = \"exp_123\"\n    fun logMetrics(experimentId: String, metrics: Map<String, Double>) {}\n    fun logError(experimentId: String, error: String) {}\n}\n\nclass MLFlowModelRegistry {\n    fun registerModel(model: TrainedModel, metrics: ModelEvaluation, experimentId: String): String = \"v1.0\"\n}\n\nclass KubernetesJobScheduler {\n    fun scheduleTrainingJob(image: String, resources: ComputeResources, data: PreprocessedDataset): String = \"job_123\"\n}\n\nclass SlackNotificationService {\n    fun sendMessage(channel: String, message: String) {}\n}",
            "output": "interface DataSource {\n    fun loadDataset(path: String): RawDataset\n}\n\ninterface ModelTrainer {\n    fun train(data: PreprocessedDataset, config: TrainingConfig, metricsCallback: (Map<String, Double>) -> Unit): TrainedModel\n}\n\ninterface ExperimentTracker {\n    fun startExperiment(modelName: String): String\n    fun logMetrics(experimentId: String, metrics: Map<String, Double>)\n    fun logError(experimentId: String, error: String)\n}\n\ninterface ModelRegistry {\n    fun registerModel(model: TrainedModel, metrics: ModelEvaluation, experimentId: String): String\n}\n\ninterface JobScheduler {\n    fun scheduleTrainingJob(image: String, resources: ComputeResources, data: PreprocessedDataset): String\n}\n\ninterface NotificationService {\n    fun sendMessage(channel: String, message: String)\n}\n\nclass MLModelTrainingPipeline(\n    private val dataSource: DataSource,\n    private val modelTrainer: ModelTrainer,\n    private val experimentTracker: ExperimentTracker,\n    private val modelRegistry: ModelRegistry,\n    private val jobScheduler: JobScheduler,\n    private val notificationService: NotificationService\n) {\n    fun trainModel(config: TrainingConfig): TrainingResult {\n        val experimentId = experimentTracker.startExperiment(config.modelName)\n        \n        try {\n            // Load and preprocess data\n            val rawData = dataSource.loadDataset(config.datasetPath)\n            val preprocessedData = preprocessData(rawData, config.preprocessingSteps)\n            \n            // Schedule training job\n            val jobId = jobScheduler.scheduleTrainingJob(\n                image = \"tensorflow/tensorflow:latest-gpu\",\n                resources = config.computeResources,\n                data = preprocessedData\n            )\n            \n            // Monitor training\n            val trainingMetrics = monitorTraining(jobId, experimentId)\n            \n            // Train model\n            val trainedModel = modelTrainer.train(\n                data = preprocessedData,\n                config = config,\n                metricsCallback = { metrics ->\n                    experimentTracker.logMetrics(experimentId, metrics)\n                }\n            )\n            \n            // Evaluate and register model\n            val evaluation = evaluateModel(trainedModel, preprocessedData.testSet)\n            \n            if (evaluation.accuracy > config.minimumAccuracy) {\n                val modelVersion = modelRegistry.registerModel(\n                    model = trainedModel,\n                    metrics = evaluation,\n                    experimentId = experimentId\n                )\n                \n                notificationService.sendMessage(\n                    channel = \"#ml-team\",\n                    message = \"Model ${config.modelName} v${modelVersion} trained successfully! Accuracy: ${evaluation.accuracy}\"\n                )\n                \n                return TrainingResult.Success(modelVersion, evaluation)\n            } else {\n                notificationService.sendMessage(\n                    channel = \"#ml-team\",\n                    message = \"Model ${config.modelName} training failed. Accuracy ${evaluation.accuracy} below threshold ${config.minimumAccuracy}\"\n                )\n                \n                return TrainingResult.Failed(\"Accuracy below threshold\")\n            }\n        } catch (e: Exception) {\n            experimentTracker.logError(experimentId, e.message ?: \"Unknown error\")\n            notificationService.sendMessage(\n                channel = \"#ml-team\",\n                message = \"Model ${config.modelName} training failed with error: ${e.message}\"\n            )\n            throw e\n        }\n    }\n}\n\n// Concrete implementations\nclass S3DataSource : DataSource {\n    override fun loadDataset(path: String): RawDataset = RawDataset()\n}\n\nclass TensorflowModelTrainer : ModelTrainer {\n    override fun train(data: PreprocessedDataset, config: TrainingConfig, metricsCallback: (Map<String, Double>) -> Unit): TrainedModel = TrainedModel()\n}\n\nclass WandbExperimentTracker : ExperimentTracker {\n    override fun startExperiment(modelName: String): String = \"exp_123\"\n    override fun logMetrics(experimentId: String, metrics: Map<String, Double>) {}\n    override fun logError(experimentId: String, error: String) {}\n}\n\nclass MLFlowModelRegistry : ModelRegistry {\n    override fun registerModel(model: TrainedModel, metrics: ModelEvaluation, experimentId: String): String = \"v1.0\"\n}\n\nclass KubernetesJobScheduler : JobScheduler {\n    override fun scheduleTrainingJob(image: String, resources: ComputeResources, data: PreprocessedDataset): String = \"job_123\"\n}\n\nclass SlackNotificationService : NotificationService {\n    override fun sendMessage(channel: String, message: String) {}\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "DIP"
        },
        {
            "input": "class OrderProcessingWorkflow {\n    private val paymentGateway = StripePaymentGateway()\n    private val inventoryManager = MySQLInventoryManager()\n    private val shippingService = FedExShippingService()\n    private val notificationService = SendGridEmailService()\n    private val auditLogger = ElasticsearchAuditLogger()\n    private val fraudDetector = DataDogFraudDetector()\n    \n    suspend fun processOrder(order: Order): OrderResult {\n        try {\n            // Fraud detection\n            val fraudScore = fraudDetector.analyzeFraudRisk(\n                order.customerId, \n                order.totalAmount, \n                order.paymentMethod\n            )\n            \n            if (fraudScore > 0.7) {\n                auditLogger.logFraudAttempt(order.id, fraudScore)\n                return OrderResult.FRAUD_DETECTED\n            }\n            \n            // Check inventory\n            val availabilityCheck = inventoryManager.checkAvailability(order.items)\n            if (!availabilityCheck.allAvailable) {\n                auditLogger.logInventoryFailure(order.id, availabilityCheck.unavailableItems)\n                return OrderResult.INSUFFICIENT_INVENTORY\n            }\n            \n            // Reserve inventory\n            inventoryManager.reserveItems(order.items, order.id)\n            \n            // Process payment\n            val paymentResult = paymentGateway.processPayment(\n                order.totalAmount,\n                order.paymentMethod,\n                order.customerId\n            )\n            \n            if (!paymentResult.success) {\n                inventoryManager.releaseReservation(order.id)\n                auditLogger.logPaymentFailure(order.id, paymentResult.errorCode)\n                return OrderResult.PAYMENT_FAILED\n            }\n            \n            // Create shipment\n            val shipmentResult = shippingService.createShipment(\n                order.shippingAddress,\n                order.items,\n                order.id\n            )\n            \n            if (!shipmentResult.success) {\n                paymentGateway.refundPayment(paymentResult.transactionId)\n                inventoryManager.releaseReservation(order.id)\n                auditLogger.logShippingFailure(order.id, shipmentResult.errorMessage)\n                return OrderResult.SHIPPING_FAILED\n            }\n            \n            // Send notifications\n            notificationService.sendOrderConfirmation(\n                order.customerEmail,\n                order.id,\n                shipmentResult.trackingNumber\n            )\n            \n            auditLogger.logSuccessfulOrder(order.id, paymentResult.transactionId, shipmentResult.trackingNumber)\n            return OrderResult.SUCCESS\n            \n        } catch (exception: Exception) {\n            auditLogger.logSystemError(order.id, exception.message ?: \"Unknown error\")\n            return OrderResult.SYSTEM_ERROR\n        }\n    }\n}\n\nclass StripePaymentGateway {\n    fun processPayment(amount: Double, paymentMethod: PaymentMethod, customerId: String): PaymentResult {\n        // Stripe-specific payment processing\n        return PaymentResult(true, \"txn_123456\")\n    }\n    \n    fun refundPayment(transactionId: String): Boolean {\n        // Stripe refund logic\n        return true\n    }\n}\n\nclass MySQLInventoryManager {\n    fun checkAvailability(items: List<OrderItem>): AvailabilityResult {\n        // MySQL database queries\n        return AvailabilityResult(true, emptyList())\n    }\n    \n    fun reserveItems(items: List<OrderItem>, orderId: String) {\n        // MySQL inventory reservation\n    }\n    \n    fun releaseReservation(orderId: String) {\n        // MySQL reservation release\n    }\n}\n\nclass FedExShippingService {\n    fun createShipment(address: ShippingAddress, items: List<OrderItem>, orderId: String): ShipmentResult {\n        // FedEx API integration\n        return ShipmentResult(true, \"FDX123456789\")\n    }\n}\n\nclass SendGridEmailService {\n    fun sendOrderConfirmation(email: String, orderId: String, trackingNumber: String) {\n        // SendGrid email sending\n    }\n}\n\nclass ElasticsearchAuditLogger {\n    fun logFraudAttempt(orderId: String, fraudScore: Double) {\n        // Elasticsearch logging\n    }\n    \n    fun logInventoryFailure(orderId: String, unavailableItems: List<String>) {\n        // Elasticsearch logging\n    }\n    \n    fun logPaymentFailure(orderId: String, errorCode: String) {\n        // Elasticsearch logging\n    }\n    \n    fun logShippingFailure(orderId: String, errorMessage: String) {\n        // Elasticsearch logging\n    }\n    \n    fun logSuccessfulOrder(orderId: String, transactionId: String, trackingNumber: String) {\n        // Elasticsearch logging\n    }\n    \n    fun logSystemError(orderId: String, errorMessage: String) {\n        // Elasticsearch logging\n    }\n}\n\nclass DataDogFraudDetector {\n    fun analyzeFraudRisk(customerId: String, amount: Double, paymentMethod: PaymentMethod): Double {\n        // DataDog fraud detection logic\n        return 0.3\n    }\n}\n\ndata class Order(\n    val id: String,\n    val customerId: String,\n    val customerEmail: String,\n    val items: List<OrderItem>,\n    val totalAmount: Double,\n    val paymentMethod: PaymentMethod,\n    val shippingAddress: ShippingAddress\n)\n\ndata class OrderItem(val productId: String, val quantity: Int)\ndata class PaymentMethod(val type: String, val token: String)\ndata class ShippingAddress(val street: String, val city: String, val zipCode: String)\ndata class PaymentResult(val success: Boolean, val transactionId: String, val errorCode: String = \"\")\ndata class AvailabilityResult(val allAvailable: Boolean, val unavailableItems: List<String>)\ndata class ShipmentResult(val success: Boolean, val trackingNumber: String, val errorMessage: String = \"\")\n\nenum class OrderResult {\n    SUCCESS, FRAUD_DETECTED, INSUFFICIENT_INVENTORY, PAYMENT_FAILED, SHIPPING_FAILED, SYSTEM_ERROR\n}",
            "output": "interface PaymentGateway {\n    suspend fun processPayment(amount: Double, paymentMethod: PaymentMethod, customerId: String): PaymentResult\n    suspend fun refundPayment(transactionId: String): Boolean\n}\n\ninterface InventoryManager {\n    suspend fun checkAvailability(items: List<OrderItem>): AvailabilityResult\n    suspend fun reserveItems(items: List<OrderItem>, orderId: String)\n    suspend fun releaseReservation(orderId: String)\n}\n\ninterface ShippingService {\n    suspend fun createShipment(address: ShippingAddress, items: List<OrderItem>, orderId: String): ShipmentResult\n}\n\ninterface NotificationService {\n    suspend fun sendOrderConfirmation(email: String, orderId: String, trackingNumber: String)\n}\n\ninterface AuditLogger {\n    suspend fun logFraudAttempt(orderId: String, fraudScore: Double)\n    suspend fun logInventoryFailure(orderId: String, unavailableItems: List<String>)\n    suspend fun logPaymentFailure(orderId: String, errorCode: String)\n    suspend fun logShippingFailure(orderId: String, errorMessage: String)\n    suspend fun logSuccessfulOrder(orderId: String, transactionId: String, trackingNumber: String)\n    suspend fun logSystemError(orderId: String, errorMessage: String)\n}\n\ninterface FraudDetector {\n    suspend fun analyzeFraudRisk(customerId: String, amount: Double, paymentMethod: PaymentMethod): Double\n}\n\nclass OrderProcessingWorkflow(\n    private val paymentGateway: PaymentGateway,\n    private val inventoryManager: InventoryManager,\n    private val shippingService: ShippingService,\n    private val notificationService: NotificationService,\n    private val auditLogger: AuditLogger,\n    private val fraudDetector: FraudDetector\n) {\n    suspend fun processOrder(order: Order): OrderResult {\n        try {\n            // Fraud detection\n            val fraudScore = fraudDetector.analyzeFraudRisk(\n                order.customerId, \n                order.totalAmount, \n                order.paymentMethod\n            )\n            \n            if (fraudScore > 0.7) {\n                auditLogger.logFraudAttempt(order.id, fraudScore)\n                return OrderResult.FRAUD_DETECTED\n            }\n            \n            // Check inventory\n            val availabilityCheck = inventoryManager.checkAvailability(order.items)\n            if (!availabilityCheck.allAvailable) {\n                auditLogger.logInventoryFailure(order.id, availabilityCheck.unavailableItems)\n                return OrderResult.INSUFFICIENT_INVENTORY\n            }\n            \n            // Reserve inventory\n            inventoryManager.reserveItems(order.items, order.id)\n            \n            // Process payment\n            val paymentResult = paymentGateway.processPayment(\n                order.totalAmount,\n                order.paymentMethod,\n                order.customerId\n            )\n            \n            if (!paymentResult.success) {\n                inventoryManager.releaseReservation(order.id)\n                auditLogger.logPaymentFailure(order.id, paymentResult.errorCode)\n                return OrderResult.PAYMENT_FAILED\n            }\n            \n            // Create shipment\n            val shipmentResult = shippingService.createShipment(\n                order.shippingAddress,\n                order.items,\n                order.id\n            )\n            \n            if (!shipmentResult.success) {\n                paymentGateway.refundPayment(paymentResult.transactionId)\n                inventoryManager.releaseReservation(order.id)\n                auditLogger.logShippingFailure(order.id, shipmentResult.errorMessage)\n                return OrderResult.SHIPPING_FAILED\n            }\n            \n            // Send notifications\n            notificationService.sendOrderConfirmation(\n                order.customerEmail,\n                order.id,\n                shipmentResult.trackingNumber\n            )\n            \n            auditLogger.logSuccessfulOrder(order.id, paymentResult.transactionId, shipmentResult.trackingNumber)\n            return OrderResult.SUCCESS\n            \n        } catch (exception: Exception) {\n            auditLogger.logSystemError(order.id, exception.message ?: \"Unknown error\")\n            return OrderResult.SYSTEM_ERROR\n        }\n    }\n}\n\n// Concrete implementations\nclass StripePaymentGateway : PaymentGateway {\n    override suspend fun processPayment(amount: Double, paymentMethod: PaymentMethod, customerId: String): PaymentResult {\n        // Stripe-specific payment processing\n        return PaymentResult(true, \"txn_123456\")\n    }\n    \n    override suspend fun refundPayment(transactionId: String): Boolean {\n        // Stripe refund logic\n        return true\n    }\n}\n\nclass MySQLInventoryManager : InventoryManager {\n    override suspend fun checkAvailability(items: List<OrderItem>): AvailabilityResult {\n        // MySQL database queries\n        return AvailabilityResult(true, emptyList())\n    }\n    \n    override suspend fun reserveItems(items: List<OrderItem>, orderId: String) {\n        // MySQL inventory reservation\n    }\n    \n    override suspend fun releaseReservation(orderId: String) {\n        // MySQL reservation release\n    }\n}\n\nclass FedExShippingService : ShippingService {\n    override suspend fun createShipment(address: ShippingAddress, items: List<OrderItem>, orderId: String): ShipmentResult {\n        // FedEx API integration\n        return ShipmentResult(true, \"FDX123456789\")\n    }\n}\n\nclass SendGridEmailService : NotificationService {\n    override suspend fun sendOrderConfirmation(email: String, orderId: String, trackingNumber: String) {\n        // SendGrid email sending\n    }\n}\n\nclass ElasticsearchAuditLogger : AuditLogger {\n    override suspend fun logFraudAttempt(orderId: String, fraudScore: Double) {\n        // Elasticsearch logging\n    }\n    \n    override suspend fun logInventoryFailure(orderId: String, unavailableItems: List<String>) {\n        // Elasticsearch logging\n    }\n    \n    override suspend fun logPaymentFailure(orderId: String, errorCode: String) {\n        // Elasticsearch logging\n    }\n    \n    override suspend fun logShippingFailure(orderId: String, errorMessage: String) {\n        // Elasticsearch logging\n    }\n    \n    override suspend fun logSuccessfulOrder(orderId: String, transactionId: String, trackingNumber: String) {\n        // Elasticsearch logging\n    }\n    \n    override suspend fun logSystemError(orderId: String, errorMessage: String) {\n        // Elasticsearch logging\n    }\n}\n\nclass DataDogFraudDetector : FraudDetector {\n    override suspend fun analyzeFraudRisk(customerId: String, amount: Double, paymentMethod: PaymentMethod): Double {\n        // DataDog fraud detection logic\n        return 0.3\n    }\n}\n\ndata class Order(\n    val id: String,\n    val customerId: String,\n    val customerEmail: String,\n    val items: List<OrderItem>,\n    val totalAmount: Double,\n    val paymentMethod: PaymentMethod,\n    val shippingAddress: ShippingAddress\n)\n\ndata class OrderItem(val productId: String, val quantity: Int)\ndata class PaymentMethod(val type: String, val token: String)\ndata class ShippingAddress(val street: String, val city: String, val zipCode: String)\ndata class PaymentResult(val success: Boolean, val transactionId: String, val errorCode: String = \"\")\ndata class AvailabilityResult(val allAvailable: Boolean, val unavailableItems: List<String>)\ndata class ShipmentResult(val success: Boolean, val trackingNumber: String, val errorMessage: String = \"\")\n\nenum class OrderResult {\n    SUCCESS, FRAUD_DETECTED, INSUFFICIENT_INVENTORY, PAYMENT_FAILED, SHIPPING_FAILED, SYSTEM_ERROR\n}",
            "level": "HARD",
            "language": "KOTLIN",
            "violation": "DIP"
        }
    ]
}